/* packet-ieee80211.c
 * Routines for Wireless LAN (IEEE 802.11) dissection
 * Copyright 2000, Axis Communications AB
 *
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 *
 * SPDX-License-Identifier: GPL-2.0-or-later
 *
 * Credits:
 *
 * The following people helped me by pointing out bugs etc. Thank you!
 *
 * Marco Molteni
 * Lena-Marie Nilsson
 * Magnus Hultman-Persson
 */

/*
 * 10/24/2005 - Add dissection for 802.11e
 * Zhu Yi <yi.zhu@intel.com>
 *
 * 04/21/2008 - Added dissection for 802.11p
 * Arada Systems <http://www.aradasystems.com>
 *
 * 04/20/2013 - Added dissection of 802.11ad according to the 9th draft of the standard.
 * Extended as a project in the Laboratory of Computer Communication & Networking (LCCN), Computer Science Department, Technion, Israel.
 * Majd Omari    <majd.omari@outlook.com>
 * Jalil Moraney <moraney.jalil@outlook.com>
 */

/*
 * Reference :
 * The 802.11 standard is "free", 6 month after the publication.
 *
 * IEEE Std 802.11-2020: Revision of IEEE Std 802.11-2016
 * include 5 amendments (802.11ai,ah,aj,ak,aq) 802.11-2016
 * include 5 amendments (802.11ae,aa,ad,ac,af) 802.11-2012
 * include 10 amendments (802.11k,r,y,w,n,p,z,v,u,s) 802.11-2007
 * include 8 amendments (802.11a,b,d,e,g,h,i,j) 802.11-1999
 * https://ieeexplore.ieee.org/document/9502043
 *
 * WAPI (IE 68)
 * http://isotc.iso.org/livelink/livelink/fetch/-8913189/8913214/8913250/8913253/JTC001-N-9880.pdf?nodeid=8500308&vernum=-2
 */

#include "config.h"

#include <math.h>

#include <epan/packet.h>
#include <epan/capture_dissectors.h>
#include <epan/exceptions.h>
#include <wsutil/pint.h>
#include <wsutil/ws_roundup.h>
#include <epan/addr_resolv.h>
#include <epan/address_types.h>
#include <epan/strutil.h>
#include <epan/prefs.h>
#include <epan/reassemble.h>
#include "packet-eapol.h"
#include "packet-ieee80211.h"
#include <epan/etypes.h>
#include <epan/oui.h>
#include <epan/crc32-tvb.h>
#include <epan/crypt/wep-wpadefs.h>
#include <epan/expert.h>
#include <epan/conversation_table.h>
#include <epan/uat.h>
#include <epan/eapol_keydes_types.h>
#include <epan/proto_data.h>
#include <epan/tfs.h>
#include <epan/unit_strings.h>
#include <wsutil/array.h>

#include "packet-wps.h"
#include "packet-e212.h"
#include "packet-sflow.h"
#include "packet-gre.h"

#include <epan/crypt/dot11decrypt_ws.h>

void proto_register_ieee80211(void);
void proto_reg_handoff_ieee80211(void);
void proto_register_wlan_rsna_eapol(void);

static dissector_handle_t centrino_handle;

typedef struct {
  DOT11DECRYPT_KEY_ITEM used_key;
  unsigned keydata_len;
  uint8_t *keydata;
} proto_keydata_t;

extern value_string_ext eap_type_vals_ext; /* from packet-eap.c */

/* TUs are used a lot in 802.11 ... */
static const unit_name_string units_tu_tus = { "TU", "TUs" };

/* DIs are also used */
static const unit_name_string units_di_dis = { "DI", "DIs" };

static const unit_name_string units_ppm = { " ppm", NULL };

static const unit_name_string units_ms = { "ms", NULL };

/* az min/max time units */
static const unit_name_string units_100_us = { " times 100 microseconds", NULL };
static const unit_name_string units_10_ms = { " times 10 milliseconds", NULL };

#define IS_2_4_GHZ(freq) (freq >= 2400 && freq <= 2500)
#define IS_5PLUS GHZ(freq) (freq >= 5000)
#define IS_6_GHZ(freq) (freq >= 5955)

/*
 * We keep STA properties here, like whether they are S1G STAs or DMG STAs.
 * This is based on looking at BEACONs, or perhaps from the radiotap header
 * if we get one.
 */
static wmem_map_t *sta_prop_hash;

/*
 * Not sure that they can be both, so are bit values wanted?
 */
#define STA_IS_S1G 0x00000001
#define STA_IS_DMG 0x00000002

/*
 * Add the top three bytes of the STA address to the bottom three bytes
 */
static unsigned
sta_prop_hash_fn(const void *k)
{
  return wmem_strong_hash((const uint8_t *)k, 6);
}

static gboolean
sta_prop_equal_fn(const void *v, const void *w)
{
  const uint8_t *k1 = (const uint8_t *)v;
  const uint8_t *k2 = (const uint8_t *)w;

  return memcmp(k1, k2, 6) == 0; /* Compare each address for equality */
}

/* bitmask for bits [l..h]
 * taken from kernel's include/linux/bitops.h
 */
#define GENMASK(h, l)  (((1U << ((h) - (l) + 1)) - 1) << (l))
#define GENMASK64(h, l)  (((UINT64_C(1) << ((h) - (l) + 1)) - 1) << (l))

/* Defragment fragmented 802.11 datagrams */
static bool wlan_defragment = true;

/* call subdissector for retransmitted frames */
static bool wlan_subdissector = true;

/* Check for the presence of the 802.11 FCS */
static bool wlan_check_fcs;

/* Check the FCS checksum */
static bool wlan_check_checksum;

/* Ignore vendor-specific HT elements */
static bool wlan_ignore_draft_ht;

/* Ignore the Protection bit; assume packet is decrypted */
#define WLAN_IGNORE_PROT_NO     0
#define WLAN_IGNORE_PROT_WO_IV  1
#define WLAN_IGNORE_PROT_W_IV   2
static int wlan_ignore_prot = WLAN_IGNORE_PROT_NO;

/* The Key MIC len has been set by the user */
static bool wlan_key_mic_len_enable;
static unsigned wlan_key_mic_len;

/* Counter incremented on each (re)association
 * This value will be assiged to each packet's pinfo->srcport/pinfo->destport
 * as a way to uniquely make a one to one mapping between conversations and
 * associations
 */
static uint32_t association_counter;

/* Treat all Wi-Fi frames as being S1G frames where it is important */
static bool treat_as_s1g;

/* Table for reassembly of fragments. */
static reassembly_table wlan_reassembly_table;

/* Statistical data */
static struct _wlan_stats wlan_stats;

/*-------------------------------------
 * UAT for WEP decoder
 *-------------------------------------
 */
static uat_wep_key_record_t *uat_wep_key_records;
static uat_t                *wep_uat;
static unsigned              num_wepkeys_uat;

static void *
uat_wep_key_record_copy_cb(void* n, const void* o, size_t siz _U_)
{
  uat_wep_key_record_t* new_key = (uat_wep_key_record_t *)n;
  const uat_wep_key_record_t* old_key = (const uat_wep_key_record_t *)o;

  new_key->string = g_strdup(old_key->string);

  return new_key;
}

static bool
uat_wep_key_record_update_cb(void* r, char** err)
{
  uat_wep_key_record_t* rec = (uat_wep_key_record_t *)r;
  decryption_key_t* dk;
  unsigned dk_type;

  if (rec->string == NULL) {
    *err = g_strdup("Key can't be blank");
    return false;
  }

  *err = NULL;
  g_strstrip(rec->string);
  dk = parse_key_string(rec->string, rec->key, err);

  if (dk != NULL) {
    dk_type = dk->type;
    free_key_string(dk);
    switch (dk_type) {
      case DOT11DECRYPT_KEY_TYPE_WEP:
      case DOT11DECRYPT_KEY_TYPE_WEP_40:
      case DOT11DECRYPT_KEY_TYPE_WEP_104:
        if (rec->key != DOT11DECRYPT_KEY_TYPE_WEP) {
          *err = g_strdup("Invalid WEP key format");
          return false;
        }
        break;
      case DOT11DECRYPT_KEY_TYPE_WPA_PWD:
        if (rec->key != DOT11DECRYPT_KEY_TYPE_WPA_PWD) {
          *err = g_strdup("Invalid WPA_PWD key format");
          return false;
        }
        break;
      case DOT11DECRYPT_KEY_TYPE_WPA_PSK:
        if (rec->key != DOT11DECRYPT_KEY_TYPE_WPA_PSK) {
          *err = g_strdup("Invalid WPA_PSK key format");
          return false;
        }
        break;
      case DOT11DECRYPT_KEY_TYPE_TK:
        if (rec->key != DOT11DECRYPT_KEY_TYPE_TK) {
          *err = g_strdup("Invalid TK key format");
          return false;
        }
        break;
      case DOT11DECRYPT_KEY_TYPE_MSK:
        if (rec->key != DOT11DECRYPT_KEY_TYPE_MSK) {
          *err = g_strdup("Invalid MSK key format");
          return false;
        }
        break;
      default:
        *err = g_strdup("Invalid key format");
        return false;
    }
  } else {
    if (*err == NULL) {
        *err = g_strdup("Invalid key format");
    }
    return false;
  }
  return true;
}

static void
uat_wep_key_record_free_cb(void*r)
{
  uat_wep_key_record_t* key = (uat_wep_key_record_t *)r;
  g_free(key->string);
}

UAT_VS_DEF(uat_wep_key_records, key, uat_wep_key_record_t, uint8_t, 0, STRING_KEY_TYPE_WEP)
UAT_CSTRING_CB_DEF(uat_wep_key_records, string, uat_wep_key_record_t)

/* Stuff for the WEP/WPA/WPA2 decoder */
static bool enable_decryption = true;

static void
ieee_80211_add_tagged_parameters(tvbuff_t *tvb, int offset, packet_info *pinfo,
                                  proto_tree *tree, int tagged_parameters_len, int ftype,
                                  association_sanity_check_t *association_sanity_check);


static void
save_proto_data(tvbuff_t *tvb, packet_info *pinfo, int offset, size_t size, int key);

static void
save_proto_data_value(packet_info *pinfo, unsigned value, int key);

static void try_scan_tdls_keys(tvbuff_t *tvb, packet_info *pinfo, int offset);

static void try_scan_ft_assoc_keys(packet_info *pinfo, const wlan_hdr_t *whdr);

static tvbuff_t *
try_decrypt(tvbuff_t *tvb, packet_info *pinfo, unsigned offset, unsigned len,
            uint8_t *algorithm, uint32_t *sec_trailer,
            PDOT11DECRYPT_KEY_ITEM used_key);

static int weak_iv(unsigned char *iv);

typedef struct mimo_control
{
  uint8_t nc;
  uint8_t nr;
  bool chan_width;
  uint8_t grouping;
  uint8_t coefficient_size;
  uint8_t codebook_info;
  uint8_t remaining_matrix_segment;
} mimo_control_t;

/* ************************************************************************* */
/*                          Miscellaneous Constants                          */
/* ************************************************************************* */
#define SHORT_STR 256

typedef enum {
  IS_DMG_KEY = 1,
  IS_AP_KEY,
  IS_CTRL_GRANT_OR_GRANT_ACK_KEY,
  IS_S1G_KEY,
  DECRYPTED_EAPOL_KEY,
  DECRYPTED_GTK_KEY,
  PACKET_DATA_KEY,
  ASSOC_COUNTER_KEY,
  STA_KEY,
  BSSID_KEY,
  NONCE_KEY,
  GROUP_CIPHER_KEY,
  CIPHER_KEY,
  AKM_KEY,
  MIC_KEY,
  MIC_LEN_KEY,
  KEY_VERSION_KEY,
  KEY_LEN_KEY,
  KEY_IV_KEY,
  KEY_DATA_KEY,
  KEY_DATA_LEN_KEY,
  GTK_KEY,
  GTK_LEN_KEY,
  MDID_KEY,
  FTE_R0KH_ID_KEY,
  FTE_R0KH_ID_LEN_KEY,
  FTE_R1KH_ID_KEY,
  FTE_R1KH_ID_LEN_KEY,
  FTE_ANONCE_KEY,
  FTE_SNONCE_KEY,
  FTE_MIC_KEY,
  FTE_MIC_LEN_KEY,
  FTE_TAG_KEY,
  MDE_TAG_KEY,
  RSNE_TAG_KEY,
  RDE_TAG_KEY,
  GTK_SUBELEM_KEY_LEN_KEY,
  PASN_DATA_KEY,
  HE_CHANNEL_WIDTH_KEY,
  FRAME_TYPE_KEY,
} wlan_proto_key_t;

/* ************************************************************************* */
/*  Define some very useful macros that are used to analyze frame types etc. */
/* ************************************************************************* */

/*
 * Fetch the frame control field and swap it if needed.  "fcf" and "tvb"
 * must be valid variables.
 */
#define FETCH_FCF(off) ((option_flags & IEEE80211_COMMON_OPT_BROKEN_FC) ? \
  GUINT16_SWAP_LE_BE(tvb_get_letohs(tvb, off)) : \
  tvb_get_letohs(tvb, off))

/*
 * Extract the fragment number and sequence number from the sequence
 * control field.
 */
#define SEQCTL_FRAGMENT_NUMBER(x) ((x) & 0x000F)
#define SEQCTL_SEQUENCE_NUMBER(x) (((x) & 0xFFF0) >> 4)

/*
 * Extract subfields from the QoS control field.
 */
#define QOS_TID(x)            ((x) & 0x000F)
#define QOS_PRIORITY(x)       ((x) & 0x0007)
#define QOS_EOSP(x)           (((x) & 0x0010) >> 4) /* end of service period */
#define QOS_ACK_POLICY(x)     (((x) & 0x0060) >> 5)
#define QOS_AMSDU_PRESENT(x)  (((x) & 0x0080) >> 6)
#define QOS_FIELD_CONTENT(x)  (((x) & 0xFF00) >> 8)
#define QOS_SCALING_FACTOR(x)  (((x) & 0xD0) >> 6)
#define QOS_UNSCALED_VALUE(x)  ((x) & 0x3F)
#define QOS_MESH_CONTROL_PRESENT(x) (((x) & 0x0100) >> 8)

#define QOS_FLAG_EOSP    0x0010

/*
 * Extract subfields from the result of QOS_FIELD_CONTENT().
 */
#define QOS_PS_BUF_STATE_INDICATED(x)  (((x) & 0x02) >> 1)
#define QOS_PS_HIGHEST_PRI_BUF_AC(x)   (((x) & 0x0C) >> 2)
#define QOS_PS_QAP_BUF_LOAD(x)         (((x) & 0xF0) >> 4)

/*
 * Bits from the HT Control field.
 * 802.11-2016 9.2.4.6, and 802.11ax draft, 32 bits.
 */
#define HTC_VHT              0x00000001
#define HTC_HE               0x00000002
#define HTC_MRQ              0x00000004
#define HTC_UNSOLICITED_MFB  0x20000000

/*
 * Extract subfields from the HT Control field.
 */
#define HTC_LAC(htc)           ((htc) & 0xFE)
#define HTC_LAC_MAI(htc)       (((htc) >> 2) & 0xF)
#define HTC_IS_ASELI(htc)      (HTC_LAC_MAI(htc) == 0xE)
#define HTC_LAC_MAI_MRQ(htc)   ((HTC_LAC_MAI(htc))  & 0x1)
#define HTC_LAC_MAI_MSI(htc)   ((HTC_LAC_MAI(htc) >> 1) & 0x7)
#define HTC_LAC_MFSI(htc)      (((htc) >> 4) & 0x7)
#define HTC_LAC_ASEL_CMD(htc)  (((htc) >> 9) & 0x7)
#define HTC_LAC_ASEL_DATA(htc) (((htc) >> 12) & 0xF)
#define HTC_LAC_MFB(htc)       (((htc) >> 9) & 0x7F)
#define HTC_CAL_POS(htc)       (((htc) >> 16) & 0x3)
#define HTC_CAL_SEQ(htc)       (((htc) >> 18) & 0x3)
#define HTC_CSI_STEERING(htc)  (((htc) >> 22) & 0x3)
#define HTC_NDP_ANN(htc)       (((htc) >> 24) & 0x1)
#define HTC_AC_CONSTRAINT(htc) (((htc) >> 30) & 0x1)
#define HTC_RDG_MORE_PPDU(htc) (((htc) >> 31) & 0x1)

#define HTC_MFB(htc)           (((htc) >> 9) & 0x7FFF)

/* VHT-MCS = 15, NUM_STS = 7 */
#define HTC_NO_FEEDBACK_PRESENT(mfb) (((mfb) & 0x7F) == 0x7F)

/*
 * Extract subfields from the key octet in WEP-encrypted frames.
 */
#define KEY_OCTET_WEP_KEY(x)   (((x) & 0xC0) >> 6)

#define KEY_EXTIV    0x20
#define EXTIV_LEN    8

/*
 * Bits from the Mesh Flags field
 */
#define MESH_FLAGS_ADDRESS_EXTENSION  0x3

/* ************************************************************************* */
/*              Constants used to identify cooked frame types                */
/* ************************************************************************* */
#define MGT_FRAME            0x00  /* Frame type is management */
#define CONTROL_FRAME        0x01  /* Frame type is control */
#define DATA_FRAME           0x02  /* Frame type is Data */
#define EXTENSION_FRAME      0x03  /* Frame type is Extension */

#define DATA_SHORT_HDR_LEN     24
#define DATA_LONG_HDR_LEN      30
#define MGT_FRAME_HDR_LEN      24  /* Length of Management frame-headers */

/* ************************************************************************* */
/*        Logical field codes (IEEE 802.11 encoding of tags)                 */
/* ************************************************************************* */
const value_string ie_tag_num_vals[] = {
  { TAG_SSID,                                 "SSID parameter set" },
  { TAG_SUPP_RATES,                           "Supported Rates" },
  { TAG_FH_PARAMETER,                         "FH Parameter set" },
  { TAG_DS_PARAMETER,                         "DS Parameter set" },
  { TAG_CF_PARAMETER,                         "CF Parameter set" },
  { TAG_TIM,                                  "Traffic Indication Map (TIM)" },
  { TAG_IBSS_PARAMETER,                       "IBSS Parameter set" },
  { TAG_COUNTRY_INFO,                         "Country Information" },
  { TAG_FH_HOPPING_PARAMETER,                 "Hopping Pattern Parameters" },
  { TAG_FH_HOPPING_TABLE,                     "Hopping Pattern Table" },
  { TAG_REQUEST,                              "Request" },
  { TAG_QBSS_LOAD,                            "QBSS Load Element" },
  { TAG_EDCA_PARAM_SET,                       "EDCA Parameter Set" },
  { TAG_TSPEC,                                "Traffic Specification" },
  { TAG_TCLAS,                                "Traffic Classification" },
  { TAG_SCHEDULE,                             "Schedule" },
  { TAG_CHALLENGE_TEXT,                       "Challenge text" },
  { TAG_POWER_CONSTRAINT,                     "Power Constraint" },
  { TAG_POWER_CAPABILITY,                     "Power Capability" },
  { TAG_TPC_REQUEST,                          "TPC Request" },
  { TAG_TPC_REPORT,                           "TPC Report" },
  { TAG_SUPPORTED_CHANNELS,                   "Supported Channels" },
  { TAG_CHANNEL_SWITCH_ANN,                   "Channel Switch Announcement" },
  { TAG_MEASURE_REQ,                          "Measurement Request" },
  { TAG_MEASURE_REP,                          "Measurement Report" },
  { TAG_QUIET,                                "Quiet" },
  { TAG_IBSS_DFS,                             "IBSS DFS" },
  { TAG_ERP_INFO,                             "ERP Information" },
  { TAG_TS_DELAY,                             "TS Delay" },
  { TAG_TCLAS_PROCESS,                        "TCLAS Processing" },
  { TAG_HT_CAPABILITY,                        "HT Capabilities (802.11n D1.10)" },
  { TAG_QOS_CAPABILITY,                       "QoS Capability" },
  { TAG_ERP_INFO_OLD,                         "ERP Information" }, /* Reserved... */
  { TAG_RSN_IE,                               "RSN Information" },
  { TAG_EXT_SUPP_RATES,                       "Extended Supported Rates" },
  { TAG_AP_CHANNEL_REPORT,                    "AP Channel Report" },
  { TAG_NEIGHBOR_REPORT,                      "Neighbor Report" },
  { TAG_RCPI,                                 "RCPI" },
  { TAG_MOBILITY_DOMAIN,                      "Mobility Domain" },
  { TAG_FAST_BSS_TRANSITION,                  "Fast BSS Transition" },
  { TAG_TIMEOUT_INTERVAL,                     "Timeout Interval" },
  { TAG_RIC_DATA,                             "RIC Data" },
  { TAG_DSE_REG_LOCATION,                     "DSE Registered Location" },
  { TAG_SUPPORTED_OPERATING_CLASSES,          "Supported Operating Classes" },
  { TAG_EXTENDED_CHANNEL_SWITCH_ANNOUNCEMENT, "Extended Channel Switch Announcement" },
  { TAG_HT_INFO,                              "HT Information (802.11n D1.10)" },
  { TAG_SECONDARY_CHANNEL_OFFSET,             "Secondary Channel Offset (802.11n D1.10)" },
  { TAG_BSS_AVG_ACCESS_DELAY,                 "BSS Average Access Delay" },
  { TAG_ANTENNA,                              "Antenna" },
  { TAG_RSNI,                                 "RSNI" },
  { TAG_MEASURE_PILOT_TRANS,                  "Measurement Pilot Transmission" },
  { TAG_BSS_AVB_ADM_CAPACITY,                 "BSS Available Admission Capacity" },
  { TAG_IE_68_CONFLICT,                       "BSS AC Access Delay/WAPI Parameter Set" },
  { TAG_TIME_ADV,                             "Time Advertisement" },
  { TAG_RM_ENABLED_CAPABILITY,                "RM Enabled Capabilities" },
  { TAG_MULTIPLE_BSSID,                       "Multiple BSSID" },
  { TAG_20_40_BSS_CO_EX,                      "20/40 BSS Coexistence" },
  { TAG_20_40_BSS_INTOL_CH_REP,               "20/40 BSS Intolerant Channel Report" },   /* IEEE P802.11n/D6.0 */
  { TAG_OVERLAP_BSS_SCAN_PAR,                 "Overlapping BSS Scan Parameters" },       /* IEEE P802.11n/D6.0 */
  { TAG_RIC_DESCRIPTOR,                       "RIC Descriptor" },
  { TAG_MMIE,                                 "Management MIC" },
  { TAG_EVENT_REQUEST,                        "Event Request" },
  { TAG_EVENT_REPORT,                         "Event Report" },
  { TAG_DIAGNOSTIC_REQUEST,                   "Diagnostic Request" },
  { TAG_DIAGNOSTIC_REPORT,                    "Diagnostic Report" },
  { TAG_LOCATION_PARAMETERS,                  "Location Parameters" },
  { TAG_NO_BSSID_CAPABILITY,                  "Non Transmitted BSSID Capability" },
  { TAG_SSID_LIST,                            "SSID List" },
  { TAG_MULTIPLE_BSSID_INDEX,                 "Multiple BSSID Index" },
  { TAG_FMS_DESCRIPTOR,                       "FMS Descriptor" },
  { TAG_FMS_REQUEST,                          "FMS Request" },
  { TAG_FMS_RESPONSE,                         "FMS Response" },
  { TAG_QOS_TRAFFIC_CAPABILITY,               "QoS Traffic Capability" },
  { TAG_BSS_MAX_IDLE_PERIOD,                  "BSS Max Idle Period" },
  { TAG_TFS_REQUEST,                          "TFS Request" },
  { TAG_TFS_RESPONSE,                         "TFS Response" },
  { TAG_WNM_SLEEP_MODE,                       "WNM-Sleep Mode" },
  { TAG_TIM_BROADCAST_REQUEST,                "TIM Broadcast Request" },
  { TAG_TIM_BROADCAST_RESPONSE,               "TIM Broadcast Response" },
  { TAG_COLLOCATED_INTER_REPORT,              "Collocated Interference Report" },
  { TAG_CHANNEL_USAGE,                        "Channel Usage" },
  { TAG_TIME_ZONE,                            "Time Zone" },
  { TAG_DMS_REQUEST,                          "DMS Request" },
  { TAG_DMS_RESPONSE,                         "DMS Response" },
  { TAG_LINK_IDENTIFIER,                      "Link Identifier" },
  { TAG_WAKEUP_SCHEDULE,                      "Wakeup Schedule" },
  { TAG_CHANNEL_SWITCH_TIMING,                "Channel Switch Timing" },
  { TAG_PTI_CONTROL,                          "PTI Control" },
  { TAG_PU_BUFFER_STATUS,                     "PU Buffer Status" },
  { TAG_INTERWORKING,                         "Interworking" },
  { TAG_ADVERTISEMENT_PROTOCOL,               "Advertisement Protocol"},
  { TAG_EXPIDITED_BANDWIDTH_REQ,              "Expedited Bandwidth Request" },
  { TAG_QOS_MAP_SET,                          "QoS Map Set" },
  { TAG_ROAMING_CONSORTIUM,                   "Roaming Consortium" },
  { TAG_EMERGENCY_ALERT_ID,                   "Emergency Alert Identifier" },
  { TAG_MESH_CONFIGURATION,                   "Mesh Configuration" },
  { TAG_MESH_ID,                              "Mesh ID" },
  { TAG_MESH_LINK_METRIC_REPORT,              "Mesh Link Metric Report" },
  { TAG_CONGESTION_NOTIFICATION,              "Congestion Notification" },
  { TAG_MESH_PEERING_MGMT,                    "Mesh Peering Management" },
  { TAG_MESH_CHANNEL_SWITCH,                  "Mesh Channel Switch Parameters" },
  { TAG_MESH_AWAKE_WINDOW,                    "Mesh Awake Window" },
  { TAG_BEACON_TIMING,                        "Beacon Timing" },
  { TAG_MCCAOP_SETUP_REQUEST,                 "MCCAOP Setup Request" },
  { TAG_MCCAOP_SETUP_REPLY,                   "MCCAOP SETUP Reply" },
  { TAG_MCCAOP_ADVERTISEMENT,                 "MCCAOP Advertisement" },
  { TAG_MCCAOP_TEARDOWN,                      "MCCAOP Teardown" },
  { TAG_GANN,                                 "Gate Announcement" },
  { TAG_RANN,                                 "Root Announcement" },
  { TAG_EXTENDED_CAPABILITIES,                "Extended Capabilities" },
  { TAG_AGERE_PROPRIETARY,                    "Agere Proprietary" },
  { TAG_MESH_PREQ,                            "Path Request" },
  { TAG_MESH_PREP,                            "Path Reply" },
  { TAG_MESH_PERR,                            "Path Error" },
  { TAG_CISCO_CCX1_CKIP,                      "Cisco CCX1 CKIP + Device Name" },
  { TAG_CISCO_CCX2,                           "Cisco CCX2" },
  { TAG_PXU,                                  "Proxy Update" },
  { TAG_PXUC,                                 "Proxy Update Confirmation"},
  { TAG_AUTH_MESH_PEERING_EXCH,               "Authenticated Mesh Peering Exchange" },
  { TAG_MIC,                                  "MIC (Message Integrity Code)" },
  { TAG_DESTINATION_URI,                      "Destination URI" },
  { TAG_U_APSD_COEX,                          "U-APSD Coexistence" },
  { TAG_WAKEUP_SCHEDULE_AD,                   "Wakeup Schedule 802.11ad" },
  { TAG_EXTENDED_SCHEDULE,                    "Extended Schedule" },
  { TAG_STA_AVAILABILITY,                     "STA Availability" },
  { TAG_DMG_TSPEC,                            "DMG TSPEC" },
  { TAG_NEXT_DMG_ATI,                         "Next DMG ATI" },
  { TAG_DMG_CAPABILITIES,                     "DMG Capabilities" },
  { TAG_CISCO_CCX3,                           "Cisco Unknown 95" },
  { TAG_CISCO_VENDOR_SPECIFIC,                "Vendor Specific" },
  { TAG_DMG_OPERATION,                        "DMG Operating" },
  { TAG_DMG_BSS_PARAMETER_CHANGE,             "DMG BSS Parameter Change" },
  { TAG_DMG_BEAM_REFINEMENT,                  "DMG Beam Refinement" },
  { TAG_CHANNEL_MEASURMENT_FB,                "Channel Measurement Feedback" },
  { TAG_AWAKE_WINDOW,                         "Awake Window" },
  { TAG_MULTI_BAND,                           "Multi Band" },
  { TAG_ADDBA_EXT,                            "ADDBA Extension" },
  { TAG_NEXTPCP_LIST,                         "NEXTPCP List" },
  { TAG_PCP_HANDOVER,                         "PCP Handover" },
  { TAG_DMG_LINK_MARGIN,                      "DMG Link Margin" },
  { TAG_SWITCHING_STREAM,                     "Switching Stream" },
  { TAG_SESSION_TRANSMISSION,                 "Session Transmission" },
  { TAG_DYN_TONE_PAIR_REP,                    "Dynamic Tone Pairing Report" },
  { TAG_CLUSTER_REP,                          "Cluster Report" },
  { TAG_RELAY_CAPABILITIES,                   "Relay Capabilities" },
  { TAG_RELAY_TRANSFER_PARAM,                 "Relay Transfer Parameter" },
  { TAG_BEAMLINK_MAINTENANCE,                 "Beamlink Maintenance" },
  { TAG_MULTIPLE_MAC_SUBLAYERS,               "Multiple MAC Sublayers" },
  { TAG_U_PID,                                "U-PID" },
  { TAG_DMG_LINK_ADAPTION_ACK,                "DMG Link Adaption Acknowledgment" },
  { TAG_SYMBOL_PROPRIETARY,                   "Symbol Proprietary" },
  { TAG_MCCAOP_ADVERTISEMENT_OV,              "MCCAOP Advertisement Overview" },
  { TAG_QUIET_PERIOD_REQ,                     "Quiet Period Request" },
  { TAG_QUIET_PERIOD_RES,                     "Quiet Period Response" },
  { TAG_ECAPC_POLICY,                         "ECAPC Policy" },
  { TAG_CLUSTER_TIME_OFFSET,                  "Cluster Time Offset" },
  { TAG_INTRA_ACCESS_CAT_PRIO,                "Intra-Access Category Priority" },
  { TAG_SCS_DESCRIPTOR,                       "SCS Descriptor" },
  { TAG_ANTENNA_SECTOR_ID,                    "Antenna Sector ID" },
  { TAG_VHT_CAPABILITY,                       "VHT Capabilities" },
  { TAG_VHT_OPERATION,                        "VHT Operation" },
  { TAG_EXT_BSS_LOAD,                         "Extended BSS Load" },
  { TAG_WIDE_BW_CHANNEL_SWITCH,               "Wide Bandwidth Channel Switch" },
  { TAG_TX_PWR_ENVELOPE,                      "Tx Power Envelope" },
  { TAG_CHANNEL_SWITCH_WRAPPER,               "Channel Switch Wrapper" },
  { TAG_OPERATING_MODE_NOTIFICATION,          "Operating Mode Notification" },
  { TAG_REDUCED_NEIGHBOR_REPORT,              "Reduced Neighbor Report" },
  { TAG_FINE_TIME_MEASUREMENT_PARAM,          "Fine Time Measurement Params" },
  { TAG_S1G_OPEN_LOOP_LINK_MARGIN_INDEX,      "S1G Open-Loop Link Margin Index" },
  { TAG_RPS,                                  "RPS" },
  { TAG_PAGE_SLICE,                           "Page Slice" },
  { TAG_AID_REQUEST,                          "AID Request" },
  { TAG_AID_RESPONSE,                         "AID Response" },
  { TAG_S1G_SECTOR_OPERATION,                 "Sector Operation" },
  { TAG_S1G_BEACON_COMPATIBILITY,             "S1G Beacon Compatibility" },
  { TAG_SHORT_BEACON_INTERVAL,                "Short Beacon Interval" },
  { TAG_CHANGE_SEQUENCE,                      "Change Sequence" },
  { TAG_TWT,                                  "Target Wake Time" },
  { TAG_S1G_CAPABILITIES,                     "S1G Capabilities" },
  { TAG_SUBCHANNEL_SELECTIVE_TRANSMISSION,    "Subchannel Selective Transmission" },
  { TAG_VENDOR_SPECIFIC_IE,                   "Vendor Specific" },
  { TAG_AUTHENTICATION_CONTROL,               "Authentication Control" },
  { TAG_TSF_TIMER_ACCURACY,                   "TSF Timer Accuracy" },
  { TAG_S1G_RELAY,                            "S1G Relay" },
  { TAG_REACHABLE_ADDRESS,                    "Reachable Address" },
  { TAG_S1G_RELAY_DISCOVERY,                  "S1G Relay Discovery" },
  { TAG_AID_ANNOUNCEMENT,                     "AID Announcement" },
  { TAG_PV1_PROBE_RESPONSE_OPTION,            "PV1 Probe Response Option" },
  { TAG_EL_OPERATION,                         "EL Operation" },
  { TAG_SECTORIZED_GROUP_ID_LIST,             "Sectorized Group ID List" },
  { TAG_S1G_OPERATION,                        "S1G Operation" },
  { TAG_HEADER_COMPRESSION,                   "Header Compression" },
  { TAG_SST_OPERATION,                        "SST Operation" },
  { TAG_MAD,                                  "MAD" },
  { TAG_S1G_RELAY_ACTIVATION,                 "S1G Relay Activation" },
  { TAG_CAG_NUMBER,                           "CAG Number"},
  { TAG_AP_CSN,                               "AP-CSN"},
  { TAG_FILS_INDICATION,                      "FILS Indication"},
  { TAG_DIFF_INITIAL_LINK_SETUP,              "Differential Initial Link Setup"},
  { TAG_FRAGMENT,                             "Fragment"},
  { TAG_RSNX,                                 "RSN eXtension"},
  { TAG_ELEMENT_ID_EXTENSION,                 "Element ID Extension" },
  { 0, NULL }
};

static value_string_ext tag_num_vals_ext = VALUE_STRING_EXT_INIT(ie_tag_num_vals);

#define ETAG_ASSOC_DELAY_INFO          1
#define ETAG_FILS_REQ_PARAMS           2
#define ETAG_FILS_KEY_CONFIRM          3
#define ETAG_FILS_SESSION              4
#define ETAG_FILS_HLP_CONTAINER        5
#define ETAG_FILS_IP_ADDRESS_ASSIGN    6
#define ETAG_KEY_DELIVERY              7
#define ETAG_FILS_WRAPPED_DATA         8
#define ETAG_FTM_SYNC_INFO             9
#define ETAG_EXTENDED_REQUEST          10
#define ETAG_ESTIMATED_SERVICE_PARAM   11
#define ETAG_FILS_PUBLIC_KEY           12
#define ETAG_FILS_NONCE                13
#define ETAG_FUTURE_CHANNEL_GUIDANCE   14

/* RFC 8110 */
#define ETAG_OWE_DH_PARAMETER          32

#define ETAG_PASSWORD_IDENTIFIER       33

/* 802.11AX defined tags */
#define ETAG_HE_CAPABILITIES                   35
#define ETAG_HE_OPERATION                      36
#define ETAG_UORA_PARAMETER_SET                37
#define ETAG_MU_EDCA_PARAMETER_SET             38
#define ETAG_SPATIAL_REUSE_PARAMETER_SET       39
#define ETAG_NDP_FEEDBACK_REPORT_PARAMETER_SET 41
#define ETAG_BSS_COLOR_CHANGE_ANNOUNCEMENT     42
#define ETAG_QUIET_TIME_PERIOD_SETUP           43
#define ETAG_ESS_REPORT                        45
#define ETAG_OPS                               46
#define ETAG_HE_BSS_LOAD                       47
#define ETAG_MAX_CHANNEL_SWITCH_TIME           52
#define ETAG_OCI                               54
#define ETAG_MULTIPLE_BSSID_CONFIGURATION      55
#define ETAG_NON_INHERITANCE                   56
#define ETAG_KNOWN_BSSID                       57
#define ETAG_SHORT_SSID                        58
#define ETAG_HE_6GHZ_BAND_CAPABILITIES         59
#define ETAG_UL_MU_POWER_CAPABILITIES          60
#define ETAG_MSCS_DESCRIPTOR_ELEMENT           88
#define ETAG_TCLAS_MASK                        89
#define ETAG_REJECTED_GROUPS                   92
#define ETAG_ANTI_CLOGGING_TOKEN               93

/* 802.11az */
#define ETAG_SECURE_LTF_PARAMETERS                      94
#define ETAG_ISTA_PASSIVE_TB_RANGING_MEASUREMENT_REPORT 95
#define ETAG_RSTA_PASSIVE_TB_RANGING_MEASUREMENT_REPORT 96
#define ETAG_PASSIVE_TB_RANGING_LCI_TABLE_ELEMENT       97
#define ETAG_ISTA_AVAILABILITY_WINDOW                   98
#define ETAG_RSTA_AVAILABILITY_WINDOW                   99
#define ETAG_PASN_PARAMETERS                            100
#define ETAG_RANGING_PARAMETERS                         101
#define ETAG_DIRECTION_MEASUREMENT_RESULTS              102
#define ETAG_MULTIPLE_AOD_FEEDBACK                      103
#define ETAG_MULTIPLE_BEST_AWV_ID                       104
#define ETAG_LOS_LIKELIHOOD                             105
#define ETAG_EHT_OPERATION                              106
#define ETAG_MULTI_LINK                                 107
#define ETAG_EHT_CAPABILITIES                           108
#define ETAG_TID_TO_LINK_MAPPING                        109
#define ETAG_MULTI_LINK_TRAFFIC                         110
#define ETAG_QOS_CHARACTERISTICS                        113
#define ETAG_AKM_SUITE_SELECTOR                         114
#define ETAG_MLO_LINK_INFORMATION                       133
#define ETAG_AID_BITMAP                                 134
#define ETAG_BANDWIDTH_INDICATION                       135


static const value_string tag_num_vals_eid_ext[] = {
  { ETAG_ASSOC_DELAY_INFO,                    "Association Delay Info" },
  { ETAG_FILS_REQ_PARAMS,                     "FILS Request Parameters" },
  { ETAG_FILS_KEY_CONFIRM,                    "FILS Key Confirmation" },
  { ETAG_FILS_SESSION,                        "FILS Session" },
  { ETAG_FILS_HLP_CONTAINER,                  "FILS HLP Container" },
  { ETAG_FILS_IP_ADDRESS_ASSIGN,              "FILS IP Address Assignment" },
  { ETAG_KEY_DELIVERY,                        "Key Delivery" },
  { ETAG_FILS_WRAPPED_DATA,                   "Wrapped Data" },
  { ETAG_FTM_SYNC_INFO,                       "FTM Synchronization Information" },
  { ETAG_EXTENDED_REQUEST,                    "Extended Request" },
  { ETAG_ESTIMATED_SERVICE_PARAM,             "Estimated Service Parameters" },
  { ETAG_FILS_PUBLIC_KEY,                     "FILS Public Key" },
  { ETAG_FILS_NONCE,                          "FILS Nonce" },
  { ETAG_FUTURE_CHANNEL_GUIDANCE,             "Future Channel Guidance" },
  { ETAG_OWE_DH_PARAMETER,                    "OWE Diffie-Hellman Parameter" },
  { ETAG_PASSWORD_IDENTIFIER,                 "Password Identifier" },
  { ETAG_HE_CAPABILITIES,                     "HE Capabilities" },
  { ETAG_HE_OPERATION,                        "HE Operation" },
  { ETAG_UORA_PARAMETER_SET,                  "UORA Parameter Set" },
  { ETAG_MU_EDCA_PARAMETER_SET,               "MU EDCA Parameter Set" },
  { ETAG_SPATIAL_REUSE_PARAMETER_SET,         "Spatial Reuse Parameter Set" },
  { ETAG_NDP_FEEDBACK_REPORT_PARAMETER_SET,   "NDP Feedback Report Parameter Set" },
  { ETAG_BSS_COLOR_CHANGE_ANNOUNCEMENT,       "BSS Color Change Announcement" },
  { ETAG_QUIET_TIME_PERIOD_SETUP,             "Quiet Time Period Setup" },
  { ETAG_ESS_REPORT,                          "ESS Report" },
  { ETAG_OPS,                                 "Opportunistic Power Save" },
  { ETAG_HE_BSS_LOAD,                         "HE BSS Load" },
  { ETAG_MAX_CHANNEL_SWITCH_TIME,             "Max Channel Switch Time" },
  { ETAG_OCI,                                 "Operating Channel Information" },
  { ETAG_MULTIPLE_BSSID_CONFIGURATION,        "Multiple BSSID Configuration" },
  { ETAG_NON_INHERITANCE,                     "Non-Inheritance"},
  { ETAG_KNOWN_BSSID,                         "Known BSSID" },
  { ETAG_SHORT_SSID,                          "Short SSID" },
  { ETAG_HE_6GHZ_BAND_CAPABILITIES,           "HE 6 GHz Band Capabilities" },
  { ETAG_UL_MU_POWER_CAPABILITIES,            "UL MU Power Capabilities" },
  { ETAG_MSCS_DESCRIPTOR_ELEMENT,             "MSCS Descriptor Element" },
  { ETAG_TCLAS_MASK,                          "TCLAS Mask" },
  { ETAG_REJECTED_GROUPS,                     "Rejected Groups" },
  { ETAG_ANTI_CLOGGING_TOKEN,                 "Anti-Clogging Token Container" },
  /* 802.11az */
  { ETAG_SECURE_LTF_PARAMETERS,               "Secure LTF Parameters" },
  { ETAG_ISTA_PASSIVE_TB_RANGING_MEASUREMENT_REPORT, "ISTA Passive TB Ranging Measurement Report" },
  { ETAG_RSTA_PASSIVE_TB_RANGING_MEASUREMENT_REPORT, "RSTA Passive TB Ranging Measurement Report" },
  { ETAG_PASSIVE_TB_RANGING_LCI_TABLE_ELEMENT, "Passive TB Ranging LCI Table element" },
  { ETAG_ISTA_AVAILABILITY_WINDOW,            "ISTA Availability Window" },
  { ETAG_RSTA_AVAILABILITY_WINDOW,            "RSTA Availability Window" },
  { ETAG_PASN_PARAMETERS,                     "PASN Parameters" },
  { ETAG_RANGING_PARAMETERS,                  "Ranging Parameters" },
  { ETAG_DIRECTION_MEASUREMENT_RESULTS,       "Direction Measurement Results" },
  { ETAG_MULTIPLE_AOD_FEEDBACK,               "Multiple AOD Feedback" },
  { ETAG_MULTIPLE_BEST_AWV_ID,                "Multiple Best AWV ID" },
  { ETAG_LOS_LIKELIHOOD,                      "LOS Likelihood" },
  { ETAG_EHT_OPERATION,                       "EHT Operation (802.11be D3.0)" },
  { ETAG_MULTI_LINK,                          "Multi-Link (802.11be D3.0)" },
  { ETAG_EHT_CAPABILITIES,                    "EHT Capabilities (802.11be D3.0)" },
  { ETAG_TID_TO_LINK_MAPPING,                 "TID-To-Link Mapping (802.11be D3.0)" },
  { ETAG_MULTI_LINK_TRAFFIC,                  "Multi-Link Traffic Indication (802.11be D3.0)" },
  { ETAG_QOS_CHARACTERISTICS,                 "QoS Characteristics (802.11be D3.0)" },
  { ETAG_AKM_SUITE_SELECTOR,                  "AKM Suite Selector" },
  { ETAG_MLO_LINK_INFORMATION,                "MLO Link Information (802.11be D3.0)" },
  { ETAG_AID_BITMAP,                          "AID Bitmap (802.11be D3.0)" },
  { ETAG_BANDWIDTH_INDICATION,                "Bandwidth Indication (802.11be D3.0)" },
  { 0, NULL }
};
static value_string_ext tag_num_vals_eid_ext_ext = VALUE_STRING_EXT_INIT(tag_num_vals_eid_ext);

static const value_string wfa_qos_subtype_vals[] = {
  { 0, "DSCP Policy Query" },
  { 1, "DSCP Policy Request" },
  { 2, "DSCP Policy Response" },
  { 0, NULL }
};

static const value_string wfa_action_subtype_vals[] = {
  { WFA_SUBTYPE_ACTION_QOS_MGMT, "QoS Management" },
  { 0, NULL }
};

const value_string wfa_subtype_vals[] = {
  { WFA_SUBTYPE_SUBSCRIPTION_REMEDIATION, "Subscription Remediation" },
  { WFA_SUBTYPE_DEAUTHENTICATION_IMMINENT, "Deauthentication Imminent" },
  { WFA_SUBTYPE_P2P, "P2P" },
  { WFA_SUBTYPE_HS20_INDICATION, "Hotspot 2.0 Indication" },
  { WFA_SUBTYPE_OSEN, "OSU Server-only l2 Encryption Network" },
  { WFA_SUBTYPE_NAN_IE, "NAN" },
  { WFA_SUBTYPE_MBO_OCE, "Multi Band Operation - Optimized Connectivity Experience"},
  { WFA_SUBTYPE_NAN_ACTION, "NAN Action" },
  { WFA_SUBTYPE_DPP, "Device Provisioning Protocol" },
  { WFA_SUBTYPE_IEEE1905_MULTI_AP, "IEEE1905 Multi-AP" },
  { WFA_SUBTYPE_OWE_TRANSITION_MODE, "OWE Transition Mode" },
  { WFA_SUBTYPE_WIFI_60G, "60GHz Information Element" },
  { WFA_WNM_SUBTYPE_NON_PREF_CHAN_REPORT, "Non-preferred Channel Report" },
  { WFA_WNM_SUBTYPE_CELL_DATA_CAPABILITIES, "Cellular Data Capabilities" },
  { WFA_SUBTYPE_TRANSITION_DISABLE_KDE, "Transition Disable KDE" },
  { WFA_SUBTYPE_QOS_MGMT, "QoS Management" },
  { 0, NULL }
};

static const value_string wfa_anqp_subtype_vals[] = {
  { WFA_ANQP_SUBTYPE_HS20, "Hotspot 2.0 ANQP" },
  { WFA_ANQP_SUBTYPE_MBO, "Multi Band Operation ANQP" },
  { 0, NULL }
};

#define DPP_CONFIGURATION_PROTOCOL 0x01

static const value_string dpp_subtype_vals[] = {
  { DPP_CONFIGURATION_PROTOCOL, "DPP Configuration Protocol" },
  { 0, NULL }
};

/* ************************************************************************* */
/*              Supported Rates (7.3.2.2)                                    */
/* ************************************************************************* */

static const value_string ieee80211_supported_rates_vals[] = {
  { 0x02, "1" },
  { 0x03, "1.5" },
  { 0x04, "2" },
  { 0x05, "2.5" },
  { 0x06, "3" },
  { 0x09, "4.5" },
  { 0x0B, "5.5" },
  { 0x0C, "6" },
  { 0x12, "9" },
  { 0x16, "11" },
  { 0x18, "12" },
  { 0x1B, "13.5" },
  { 0x24, "18" },
  { 0x2C, "22" },
  { 0x30, "24" },
  { 0x36, "27" },
  { 0x42, "33" },
  { 0x48, "36" },
  { 0x60, "48" },
  { 0x6C, "54" },
  { 0x82, "1(B)" },
  { 0x83, "1.5(B)" },
  { 0x84, "2(B)" },
  { 0x85, "2.5(B)" },
  { 0x86, "3(B)" },
  { 0x89, "4.5(B)" },
  { 0x8B, "5.5(B)" },
  { 0x8C, "6(B)" },
  { 0x92, "9(B)" },
  { 0x96, "11(B)" },
  { 0x98, "12(B)" },
  { 0x9B, "13.5(B)" },
  { 0xA4, "18(B)" },
  { 0xAC, "22(B)" },
  { 0xB0, "24(B)" },
  { 0xB6, "27(B)" },
  { 0xC2, "33(B)" },
  { 0xC8, "36(B)" },
  { 0xE0, "48(B)" },
  { 0xEC, "54(B)" },
  /* BSS membership selector */
  { 0xFA, "HE PHY" },
  { 0xFB, "SAE Hash to Element Only" },
  { 0xFC, "EPD" }, /* 802.11ak */
  { 0xFD, "GLK" }, /* 802.11ak */
  { 0xFE, "VHT PHY" },
  { 0xFF, "HT PHY" },
  { 0,    NULL}
};
value_string_ext ieee80211_supported_rates_vals_ext = VALUE_STRING_EXT_INIT(ieee80211_supported_rates_vals);

/* ************************************************************************* */
/*                         8.4.1.7 Reason Code field                         */
/* ************************************************************************* */
static const value_string ieee80211_reason_code[] = {
  {  1, "Unspecified reason" },
  {  2, "Previous authentication no longer valid" },
  {  3, "Deauthenticated because sending STA is leaving (or has left) the BSS" },
  {  4, "Disassociated due to inactivity" },
  {  5, "Disassociated because AP is unable to handle all currently associated STAs" },
  {  6, "Class 2 frame received from nonauthenticated STA" },
  {  7, "Class 3 frame received from nonassociated STA" },
  {  8, "Disassociated because sending STA is leaving (or has left) BSS" },
  {  9, "STA requesting (re)association is not authenticated with responding STA" },
  { 10, "Disassociated because the information in the Power Capability element is unacceptable" },
  { 11, "Disassociated because the information in the Supported Channels element is unacceptable" },
  { 12, "Disassociated due to BSS transition management" },
  { 13, "Invalid information element, i.e., an information element defined in this standard for which the content does not meet the specifications in Clause 9" },
  { 14, "Message integrity code (MIC) failure" },
  { 15, "4-way handshake timeout" },
  { 16, "Group key handshake timeout" },
  { 17, "Element in 4-way handshake different from (Re)Association Request/Probe Response/Beacon frame" },
  { 18, "Invalid group cipher" },
  { 19, "Invalid pairwise cipher" },
  { 20, "Invalid AKMP" },
  { 21, "Unsupported RSNE version" },
  { 22, "Invalid RSNE capabilities" },
  { 23, "IEEE 802.1X authentication failed" },
  { 24, "Cipher suite rejected because of the security policy" },
  { 25, "TDLS direct-link teardown due to TDLS peer STA unreachable via the TDLS direct link" },
  { 26, "TDLS direct-link teardown for unspecified reason" },
  { 27, "Disassociated because session terminated by SSP request" },
  { 28, "Disassociated because of lack of SSP roaming agreement" },
  { 29, "Requested service rejected because of SSP cipher suite or AKM requirement " },
  { 30, "Requested service not authorized in this location" },
  { 31, "TS deleted because QoS AP lacks sufficient bandwidth for this QoS STA due to a change in BSS service characteristics or operational mode" },
  { 32, "Disassociated for unspecified, QoS-related reason" },
  { 33, "Disassociated because QoS AP lacks sufficient bandwidth for this QoS STA" },
  { 34, "Disassociated because excessive number of frames need to be acknowledged, but are not acknowledged due to AP transmissions and/or poor channel conditions" },
  { 35, "Disassociated because STA is transmitting outside the limits of its TXOPs" },
  { 36, "Requested from peer STA as the STA is leaving the BSS (or resetting)" },
  { 37, "Requesting STA is no longer using the stream or session" },
  { 38, "Requesting STA received frames using a mechanism for which a setup has not been completed" },
  { 39, "Requested from peer STA due to timeout" },
  { 46, "Disassociated because authorized access limit reached" },
  { 47, "Disassociated due to external service requirements" },
  { 48, "Invalid FT Action frame count" },
  { 49, "Invalid pairwise master key identifier (PMKID)" },
  { 50, "Invalid MDE" },
  { 51, "Invalid FTE" },
  { 52, "Mesh peering canceled for unknown reasons" },
  { 53, "The mesh STA has reached the supported maximum number of peer mesh STAs" },
  { 54, "The received information violates the Mesh Configuration policy configured in the mesh STA profile" },
  { 55, "The mesh STA has received a Mesh Peering Close message requesting to close the mesh peering" },
  { 56, "The mesh STA has re-sent dot11MeshMaxRetries Mesh Peering Open messages, without receiving a Mesh Peering Confirm message" },
  { 57, "The confirmTimer for the mesh peering instance times out" },
  { 58, "The mesh STA fails to unwrap the GTK or the values in the wrapped contents do not match" },
  { 59, "The mesh STA receives inconsistent information about the mesh parameters between Mesh Peering Management frames" },
  { 60, "The mesh STA fails the authenticated mesh peering exchange because due to failure in selecting either the pairwise ciphersuite or group ciphersuite" },
  { 61, "The mesh STA does not have proxy information for this external destination" },
  { 62, "The mesh STA does not have forwarding information for this destination" },
  { 63, "The mesh STA determines that the link to the next hop of an active path in its forwarding information is no longer usable" },
  { 64, "The Deauthentication frame was sent because the MAC address of the STA already exists in the mesh BSS. See 11.3.3 (Additional mechanisms for an AP collocated with a mesh STA)" },
  { 65, "The mesh STA performs channel switch to meet regulatory requirements" },
  { 66, "The mesh STA performs channel switch with unspecified reason" },
  { 67, "Transmission link establishment in alternative channel failed" },
  { 68, "The alternative channel is occupied" },
  { 71, "Disassociated due to poor RSSI" },
  { 0,  NULL}
};
value_string_ext ieee80211_reason_code_ext = VALUE_STRING_EXT_INIT(ieee80211_reason_code);

/* ************************************************************************* */
/*                         8.4.1.9 Status Code field                         */
/* ************************************************************************* */
static const value_string ieee80211_status_code[] = {
  {  0, "Successful" },
  {  1, "Unspecified failure" },
  {  2, "TDLS wakeup schedule rejected but alternative schedule provided" },
  {  3, "TDLS wakeup schedule rejected" },
  {  4, "Reserved" },
  {  5, "Security disabled" },
  {  6, "Unacceptable lifetime" },
  {  7, "Not in same BSS" },
  {  8, "Reserved" },
  {  9, "Reserved" },
  { 10, "Cannot support all requested capabilities in the Capability Information field" },
  { 11, "Reassociation denied due to inability to confirm that association exists" },
  { 12, "Association denied due to reason outside the scope of this standard" },
  { 13, "Responding STA does not support the specified authentication algorithm" },
  { 14, "Received an Authentication frame with authentication transaction sequence number out of expected sequence" },
  { 15, "Authentication rejected because of challenge failure" },
  { 16, "Authentication rejected due to timeout waiting for next frame in sequence" },
  { 17, "Association denied because AP is unable to handle additional associated STAs" },
  { 18, "Association denied due to requesting STA not supporting all of the data rates in the BSSBasicRateSet parameter, the Basic HT-MCS Set field of the HT Operation parameter, or the Basic VHT-MCS and NSS Set field in the VHT Operation parameter" },
  { 19, "Association denied due to requesting STA not supporting the short preamble option" },
  { 20, "Reserved" },
  { 21, "Reserved" },
  { 22, "Association request rejected because spectrum management capability is required" },
  { 23, "Association request rejected because the information in the Power Capability element is unacceptable" },
  { 24, "Association request rejected because the information in the Supported Channels element is unacceptable" },
  { 25, "Association denied due to requesting STA not supporting short slot time" },
  { 26, "Reserved" },
  { 27, "Association denied because the requesting STA does not support HT features" },
  { 28, "R0KH unreachable" },
  { 29, "Reserved"},
  { 30, "Association request rejected temporarily; try again later" },
  { 31, "Robust management frame policy violation" },
  { 32, "Unspecified, QoS-related failure" },
  { 33, "Association denied because QoS AP or PCP has insufficient bandwidth to handle another QoS STA" },
  { 34, "Association denied due to excessive frame loss rates and/ or poor conditions on current operating channel" },
  { 35, "Association (with QoS BSS) denied because the requesting STA does not support the QoS facility" },
  { 36, "Reserved" },
  { 37, "The request has been declined" },
  { 38, "The request has not been successful as one or more parameters have invalid values" },
  { 39, "The allocation or TS has not been created because the request cannot be honored; however, a suggested TSPEC/DMG TSPEC is provided so that the initiating STA can attempt to set another allocation or TS with the suggested changes to the TSPEC/DMG TSPEC" },
  { 40, "Invalid element, i.e., an element defined in this standard for which the content does not meet the specifications in Clause 9 (Frame formats)" },
  { 41, "Invalid group cipher" },
  { 42, "Invalid pairwise cipher" },
  { 43, "Invalid AKMP" },
  { 44, "Unsupported RSNE version" },
  { 45, "Invalid RSNE capabilities" },
  { 46, "Cipher suite rejected because of security policy" },
  { 47, "The TS or allocation has not been created; however, the HC or PCP might be capable of creating a TS or allocation, in response to a request, after the time indicated in the TS Delay element" },
  { 48, "Reserved" },
  { 49, "The Destination STA is not present within this BSS" },
  { 50, "The Destination STA is not a QoS STA" },
  { 51, "Association denied because the listen interval is too large" },
  { 52, "Invalid FT Action frame count" },
  { 53, "Invalid pairwise master key identifier (PMKID)" },
  { 54, "Invalid MDE" },
  { 55, "Invalid FTE" },
  { 56, "Requested TCLAS processing is not supported by the AP or PCP" },
  { 57, "The AP or PCP has insufficient TCLAS processing resources to satisfy the request" },
  { 58, "The TS has not been created because the request cannot be honored; however, the HC or PCP suggests that the STA transition to a different BSS to set up the TS" },
  { 59, "GAS advertisement protocol not supported" },
  { 60, "No outstanding GAS request" },
  { 61, "GAS response not received from the advertisement server" },
  { 62, "STA timed out waiting for GAS query response" },
  { 63, "GAS response is larger than query response length limit" },
  { 64, "Request refused because home network does not support request" },
  { 65, "Advertisement server in the network is not currently reachable" },
  { 66, "Reserved" },
  { 67, "Request refused due to permissions received via SSPN interface" },
  { 68, "Request refused because the AP or PCP does not support unauthenticated access" },
  { 69, "Reserved" },
  { 70, "Reserved" },
  { 71, "Reserved" },
  { 72, "Invalid contents of RSNE, other than unsupported RSNE version or invalid RSNE capabilities, AKMP or pairwise cipher" },
  { 73, "U-APSD coexistence is not supported" },
  { 74, "Requested U-APSD coexistence mode is not supported" },
  { 75, "Requested interval/duration value cannot be supported with U-APSD coexistence" },
  { 76, "Authentication is rejected because an anti-clogging token is required" },
  { 77, "Authentication is rejected because the offered finite cyclic group is not supported" },
  { 78, "The TBTT adjustment request has not been successful because the STA could not find an alternative TBTT" },
  { 79, "Transmission failure" },
  { 80, "Requested TCLAS not supported" },
  { 81, "TCLAS resources exhausted" },
  { 82, "Rejected with suggested BSS transition" },
  { 83, "Reject with recommended schedule" },
  { 84, "Reject because no wakeup schedule specified" },
  { 85, "Success, the destination STA is in power save mode" },
  { 86, "FST pending, in process of admitting FST session" },
  { 87, "Performing FST now" },
  { 88, "FST pending, gap(s) in block ack window" },
  { 89, "Reject because of U-PID setting" },
  { 90, "Reserved" },
  { 91, "Reserved" },
  { 92, "(Re)Association refused for some external reason" },
  { 93, "(Re)Association refused because of memory limits at the AP" },
  { 94, "(Re)Association refused because emergency services are not supported at the AP" },
  { 95, "GAS query response not yet received" },
  { 96, "Reject since the request is for transition to a frequency band subject to DSE procedures and FST Initiator is a dependent STA" },
  { 97, "Requested TCLAS processing has been terminated by the AP" },
  { 98, "The TS schedule conflicts with an existing schedule; an alternative schedule is provided" },
  { 99, "The association has been denied; however, one or more Multi-band elements are included that can be used by the receiving STA to join the BSS" },
  { 100, "The request failed due to a reservation conflict" },
  { 101, "The request failed due to exceeded MAF limit" },
  { 102, "The request failed due to exceeded MCCA track limit" },
  { 103, "Association denied because the information in the Spectrum Management field is unacceptable" },
  { 104, "Association denied because the requesting STA does not support VHT features" },
  { 105, "Enablement denied" },
  { 106, "Enablement denied due to restriction from an authorized GDB" },
  { 107, "Authorization deenabled" },
  { 108, "Re(association) refused or disassociated because energy limited operation is not supported at the AP" },
  { 109, "BlockAck negotiation refused because, due to buffer constraints and other unspecified reasons, the recipient prefers to generate only NDP BlockAck frames" },
  { 110, "Association denied/disassociated because the suggested value for max away duration is unacceptable" },
  { 111, "Re(association) refused or disassociated because flow control operation is not supported by the non-AP STA" },
  { 112, "Authentication rejected due to FILS authentication failure" },
  { 113, "Authentication rejected due to unknown Authentication Server" },
  { 114, "Reserved" },
  { 115, "Reserved" },
  { 116, "Request denied because the allocation of notification period is failed" },
  { 117, "Request denied because the request of channel splitting is failed" },
  { 118, "Request denied because the allocation request is failed" },
  { 119, "Association denied because the requesting STA does not support CMMG features" },
  { 120, "The requested GAS fragment is not available" },
  { 121, "Success, the CAG Version provided by the requesting STA is the same as the latest CAG Version provided by the relevant server" },
  { 122, "The STA is not authorized to use GLK per local policy" },
  { 123, "Authentication rejected because the password identifier is unknown" },
  { 124, "Reserved"},
  { 125, "Request denied because source address of request is inconsistent with local MAC address policy" },
  { 126, "SAE authentication uses direct hashing, instead of looping, to obtain the PWE" },
  { 127, "Reserved"},
  { 128, "Requested TCLAS processing has been terminated by the AP due to insufficient QoS capacity" },
  { 129, "Requested TCLAS processing has been terminated by the AP due to conflict with higher layer QoS policies" },
  { 130, "Association denied because the requesting STA is affiliated with a non-AP MLD that is associated with the AP MLD"},
  { 131, "EPCS priority access denied because the non-AP MLD is not authorized to use the service"},
  { 132, "EPCS priority access denied due to reason outside the scope of this standard"},
  { 133, "Request denied because the requested TID-to-link mapping is unacceptable"},
  { 134, "Preferred TID-to-link mapping suggested"},
  { 135, "Association denied because the requesting STA does not support EHT features"},
  { 139, "Link not accepted because the link on which the (Re)Association Request frame is transmitted is not accepted"},
  { 140, "EPCS priority access is temporarily denied because the receiving AP MLD is unable to verify that the non-AP MLD is authorized for an unspecified reason"},
  { 141, "Operation parameter update denied because the requested operation parameters or capabilities are not acceptable"},
  {   0, NULL}
};
value_string_ext ieee80211_status_code_ext = VALUE_STRING_EXT_INIT(ieee80211_status_code);

static const value_string ieee80211_transition_reasons[] = {
  { 0, "Unspecified" },
  { 1, "Excessive frame loss rates and/or poor conditions" },
  { 2, "Excessive delay for current traffic streams" },
  { 3, "Insufficient QoS capacity for current traffic streams (TSPEC rejected)" },
  { 4, "First association to ESS (the association initiated by an Association Request frame instead of a Reassociation Request frame)" },
  { 5, "Load balancing" },
  { 6, "Better AP found" },
  { 7, "Deauthenticated or Disassociated from the previous AP" },
  { 8, "AP failed IEEE 802.1X EAP Authentication" },
  { 9, "AP failed 4-way handshake" },
  { 10, "Received too many replay counter failures" },
  { 11, "Received too many data MIC failures" },
  { 12, "Exceeded maximum number of retransmissions" },
  { 13, "Received too many broadcast disassociations" },
  { 14, "Received too many broadcast deauthentications" },
  { 15, "Previous transition failed" },
  { 16, "Low RSSI" },
  { 17, "Roam from a non-IEEE-802.11 system" },
  { 18, "Transition due to received BSS Transition Request frame" },
  { 19, "Preferred BSS transition candidate list included" },
  { 20, "Leaving ESS" },
  { 0,    NULL}
};
/* ************************************************************************* */
/*                         Frame types, and their names                      */
/* ************************************************************************* */
static const value_string frame_type_subtype_vals[] = {
  {MGT_ASSOC_REQ,             "Association Request"},
  {MGT_ASSOC_RESP,            "Association Response"},
  {MGT_REASSOC_REQ,           "Reassociation Request"},
  {MGT_REASSOC_RESP,          "Reassociation Response"},
  {MGT_PROBE_REQ,             "Probe Request"},
  {MGT_PROBE_RESP,            "Probe Response"},
  {MGT_MEASUREMENT_PILOT,     "Measurement Pilot"},
  {MGT_BEACON,                "Beacon frame"},
  {MGT_ATIM,                  "ATIM"},
  {MGT_DISASS,                "Disassociate"},
  {MGT_AUTHENTICATION,        "Authentication"},
  {MGT_DEAUTHENTICATION,      "Deauthentication"},
  {MGT_ACTION,                "Action"},
  {MGT_ACTION_NO_ACK,         "Action No Ack"},
  {MGT_ARUBA_WLAN,            "Aruba Management"},

  {CTRL_TRIGGER,              "Trigger"},
  {CTRL_TACK,                 "TWT Ack"},
  {CTRL_BEAMFORM_RPT_POLL,    "Beamforming Report Poll"},
  {CTRL_VHT_NDP_ANNC,         "VHT/HE/EHT/RANGING NDP Announcement"},
  {CTRL_CONTROL_WRAPPER,      "Control Wrapper"},
  {CTRL_BLOCK_ACK_REQ,        "802.11 Block Ack Req"},
  {CTRL_BLOCK_ACK,            "802.11 Block Ack"},
  {CTRL_PS_POLL,              "Power-Save poll"},
  {CTRL_RTS,                  "Request-to-send"},
  {CTRL_CTS,                  "Clear-to-send"},
  {CTRL_ACKNOWLEDGEMENT,      "Acknowledgement"},
  {CTRL_CFP_END,              "CF-End (Control-frame)"},
  {CTRL_CFP_ENDACK,           "CF-End + CF-Ack (Control-frame)"},

  {DATA,                      "Data"},
  {DATA_CF_ACK,               "Data + CF-Ack"},
  {DATA_CF_POLL,              "Data + CF-Poll"},
  {DATA_CF_ACK_POLL,          "Data + CF-Ack + CF-Poll"},
  {DATA_NULL_FUNCTION,        "Null function (No data)"},
  {DATA_CF_ACK_NOD,           "Acknowledgement (No data)"},
  {DATA_CF_POLL_NOD,          "CF-Poll (No data)"},
  {DATA_CF_ACK_POLL_NOD,      "CF-Ack/Poll (No data)"},
  {DATA_QOS_DATA,             "QoS Data"},
  {DATA_QOS_DATA_CF_ACK,      "QoS Data + CF-Acknowledgment"},
  {DATA_QOS_DATA_CF_POLL,     "QoS Data + CF-Poll"},
  {DATA_QOS_DATA_CF_ACK_POLL, "QoS Data + CF-Ack + CF-Poll"},
  {DATA_QOS_NULL,             "QoS Null function (No data)"},
  {DATA_QOS_CF_POLL_NOD,      "QoS CF-Poll (No Data)"},
  {DATA_QOS_CF_ACK_POLL_NOD,  "QoS CF-Ack + CF-Poll (No data)"},

  {EXTENSION_DMG_BEACON,      "DMG Beacon"},
  {EXTENSION_S1G_BEACON,      "S1G Beacon"},

  {CTRL_POLL,                 "Poll"},
  {CTRL_SPR,                  "Service Period Request"},
  {CTRL_GRANT,                "Grant"},
  {CTRL_DMG_CTS,              "DMG Clear-to-send"},
  {CTRL_DMG_DTS,              "DMG Denial-to-send"},
  {CTRL_GRANT_ACK,            "Grant Acknowledgment"},
  {CTRL_SSW,                  "Sector Sweep"},
  {CTRL_SSW_FEEDBACK,         "Sector Sweep Feedback"},
  {CTRL_SSW_ACK,              "Sector Sweep Acknowledgment"},

  {0,                         NULL}
};
static value_string_ext frame_type_subtype_vals_ext = VALUE_STRING_EXT_INIT(frame_type_subtype_vals);

/* ************************************************************************* */
/*                 802.1D Tag Name (by WME Access Category Names)            */
/* ************************************************************************* */
static const value_string ieee80211_qos_tags_acs[] = {
  { 0, "Best Effort (Best Effort)" },
  { 1, "Background (Background)" },
  { 2, "Spare (Background)" },
  { 3, "Excellent Effort (Best Effort)" },
  { 4, "Controlled Load (Video)" },
  { 5, "Video (Video)" },
  { 6, "Voice (Voice)" },
  { 7, "Network Control (Voice)" },
  { 0, NULL }
};

/* ************************************************************************* */
/*                   WME Access Category Names (by WME ACI)                  */
/* ************************************************************************* */
static const value_string wme_acs[] = {
  { 0, "Best Effort" },
  { 1, "Background" },
  { 2, "Video" },
  { 3, "Voice" },
  { 0, NULL }
};

/* ************************************************************************* */
/*                  Aruba Management Type                                    */
/* ************************************************************************* */
static const value_string aruba_mgt_typevals[] = {
  { 0x0001,       "Hello" },
  { 0x0002,       "Probe" },
  { 0x0003,       "MTU" },
  { 0x0004,       "Ageout" },
  { 0x0005,       "Heartbeat" },
  { 0x0006,       "Deauth" },
  { 0x0007,       "Disassoc" },
  { 0x0008,       "Probe response" },
  { 0x0009,       "Tunnel update" },
  { 0x000A,       "Laser beam active" },
  { 0x000B,       "Client IP" },
  { 0x000C,       "Laser beam active v2" },
  { 0x000D,       "AP statistics" },
  { 0,            NULL }
};
static value_string_ext aruba_mgt_typevals_ext = VALUE_STRING_EXT_INIT(aruba_mgt_typevals);

/*** Begin: Action Fixed Parameter ***/
#define CAT_SPECTRUM_MGMT          0
#define CAT_QOS                    1
#define CAT_DLS                    2
#define CAT_BLOCK_ACK              3
#define CAT_PUBLIC                 4
#define CAT_RADIO_MEASUREMENT      5
#define CAT_FAST_BSS_TRANSITION    6
#define CAT_HT                     7
#define CAT_SA_QUERY               8
#define CAT_PUBLIC_PROTECTED       9
#define CAT_WNM                   10
#define CAT_UNPROTECTED_WNM       11
#define CAT_TDLS                  12
#define CAT_MESH                  13
#define CAT_MULTIHOP              14
#define CAT_SELF_PROTECTED        15
#define CAT_DMG                   16
#define CAT_MGMT_NOTIFICATION     17
#define CAT_FAST_SESSION_TRANSFER 18
#define CAT_ROBUST_AV_STREAMING   19
#define CAT_UNPROTECTED_DMG       20
#define CAT_VHT                   21
#define CAT_S1G                   22
#define CAT_PROTECTED_S1G         23
#define CAT_FLOW_CONTROL          24
#define CAT_CONTROL_RESPONSE_MCS_NEG 25
#define CAT_FILS                  26
/* aj */
#define CAT_CDMG                  27
#define CAT_CMMG                  28
/* ak */
#define CAT_GLK                   29

#define CAT_HE                    30
#define CAT_PROTECTED_HE          31
#define CAT_PROTECTED_FTM         34
#define CAT_EHT                   36
#define CAT_PROTECTED_EHT         37
#define CAT_VENDOR_SPECIFIC_PROTECTED 126
#define CAT_VENDOR_SPECIFIC     127

#define CAT_MESH_LINK_METRIC               31
#define CAT_MESH_PATH_SELECTION            32
#define CAT_MESH_INTERWORKING              33
#define CAT_MESH_RESOURCE_COORDINATION     34
#define CAT_MESH_SECURITY_ARCHITECTURE     35

#define SM_ACTION_MEASUREMENT_REQUEST   0
#define SM_ACTION_MEASUREMENT_REPORT    1
#define SM_ACTION_TPC_REQUEST           2
#define SM_ACTION_TPC_REPORT            3
#define SM_ACTION_CHAN_SWITCH_ANNC      4
#define SM_ACTION_EXT_CHAN_SWITCH_ANNC  5

#define QOS_ACTION_ADDTS_REQUEST     0
#define QOS_ACTION_ADDTS_RESPONSE    1
#define QOS_ACTION_DELTS             2
#define QOS_ACTION_SCHEDULE      3
#define QOS_ACTION_MAP_CONFIGURE 4

#define DLS_ACTION_REQUEST       0
#define DLS_ACTION_RESPONSE      1
#define DLS_ACTION_TEARDOWN      2

#define BA_ADD_BLOCK_ACK_REQUEST      0
#define BA_ADD_BLOCK_ACK_RESPONSE     1
#define BA_DELETE_BLOCK_ACK           2

#define BA_NDP_ADD_BLOCK_ACK_REQUEST  128
#define BA_NDP_ADD_BLOCK_ACK_RESPONSE 129
#define BA_NDP_DELETE_BLOCK_ACK       130
#define BA_BAT_ADD_BLOCK_ACK_REQUEST  132
#define BA_BAT_ADD_BLOCK_ACK_RESPONSE 133
#define BA_BAT_DELETE_BLOCK_ACK       134

#define BA_ADD_BLOCK_ACK_REQUEST    0
#define BA_ADD_BLOCK_ACK_RESPONSE   1
#define BA_DELETE_BLOCK_ACK         2

/* Keep in sync with PPA_* defines */
#define PA_20_40_BSS_COEXISTENCE_MANAGEMENT 0
#define PA_DSE_ENABLEMENT                   1
#define PA_DSE_DEENABLEMENT                 2
#define PA_DSE_REG_LOC_ANNOUNCEMENT         3
#define PA_EXT_CHANNEL_SWITCH_ANNOUNCEMENT  4
#define PA_DSE_MEASUREMENT_REQUEST          5
#define PA_DSE_MEASUREMENT_REPORT           6
#define PA_MEASUREMENT_PILOT                7
#define PA_DSE_POWER_CONSTRAINT             8
#define PA_VENDOR_SPECIFIC                  9
#define PA_GAS_INITIAL_REQUEST             10
#define PA_GAS_INITIAL_RESPONSE            11
#define PA_GAS_COMEBACK_REQUEST            12
#define PA_GAS_COMEBACK_RESPONSE           13
#define PA_TDLS_DISCOVERY_RESPONSE         14
#define PA_LOCATION_TRACK_NOTIFICATION     15
#define PA_QAB_REQUEST                     16
#define PA_QAB_RESPONSE                    17
#define PA_QMF_POLICY                      18
#define PA_QMF_POLICY_CHANGE               19
#define PA_QLOAD_REQUEST                   20
#define PA_QLOAD_REPORT                    21
#define PA_HCCA_TXOP_ADVERTISEMENT         22
#define PA_HCCA_TXOP_RESPONSE              23
#define PA_PUBLIC_KEY                      24
#define PA_CHANNEL_AVAILABILITY_QUERY      25
#define PA_CHANNEL_SCHEDULE_MANAGEMENT     26
#define PA_CONTACT_VERIFICATION_SIGNAL     27
#define PA_GDD_ENABLEMENT_REQUEST          28
#define PA_GDD_ENABLEMENT_RESPONSE         29
#define PA_NETWORK_CHANNEL_CONTROL         30
#define PA_WHITE_SPACE_MAP_ANNOUNCEMENT    31
#define PA_FTM_REQUEST                     32
#define PA_FTM                             33
#define PA_FILS_DISCOVERY                  34
/* 802.11aj */
#define PA_DCS_MEASUREMENT_REQUEST               35
#define PA_DCS_MEASUREMENT_REPORT                36
#define PA_DCS_REQUEST                           37
#define PA_DCS_RESPONSE                          38
#define PA_EXTENDED_NOTIFICATION_PERIOD_REQUEST  39
#define PA_EXTENDED_NOTIFICATION_PERIOD_RESPONSE 40
#define PA_EXTENDED_CHANNEL_SPLITTING_REQUEST    41
#define PA_EXTENDED_CHANNEL_SPLITTING_RESPONSE   42
/* 802.11aq */
#define PA_GROUP_ADDRESSED_GAS_REQUEST     43
#define PA_GROUP_ADDRESSED_GAS_RESPONSE    44
/* Unknown */
#define PA_ON_CHANNEL_TUNNEL_REQUEST       45
#define PA_VALUE_46                        46
/* 802.11az */
#define PA_LOCATION_MEASUREMENT_REPORT                                      47
#define PA_ISTA_PASSIVE_TB_RANGING_MEASUREMENT_REPORT                       48
#define PA_PRIMARY_RSTA_BROADCAST_PASSIVE_TB_RANGING_MEASUREMENT_REPORT     49
#define PA_SECONDARY_RSTA_BROADCAST_PASSIVE_TB_RANGING_MEASUREMENT_REPORT   50

/* Keep in sync with PA_* defines */
#define PPA_DSE_ENABLEMENT                   1
#define PPA_DSE_DEENABLEMENT                 2
#define PPA_EXT_CHANNEL_SWITCH_ANNOUNCEMENT  4
#define PPA_DSE_MEASUREMENT_REQUEST          5
#define PPA_DSE_MEASUREMENT_REPORT           6
#define PPA_DSE_POWER_CONSTRAINT             8
#define PPA_VENDOR_SPECIFIC                  9
#define PPA_GAS_INITIAL_REQUEST             10
#define PPA_GAS_INITIAL_RESPONSE            11
#define PPA_GAS_COMEBACK_REQUEST            12
#define PPA_GAS_COMEBACK_RESPONSE           13
#define PPA_QAB_REQUEST                     16
#define PPA_QAB_RESPONSE                    17

#define HT_ACTION_NOTIFY_CHAN_WIDTH           0
#define HT_ACTION_SM_PWR_SAVE                 1
#define HT_ACTION_PSMP_ACTION                 2
#define HT_ACTION_SET_PCO_PHASE               3
#define HT_ACTION_MIMO_CSI                    4
#define HT_ACTION_MIMO_BEAMFORMING            5
#define HT_ACTION_MIMO_COMPRESSED_BEAMFORMING 6
#define HT_ACTION_ANT_SEL_FEEDBACK            7
#define HT_ACTION_HT_INFO_EXCHANGE            8

#define DMG_ACTION_PWR_SAVE_CONFIG_REQ           0
#define DMG_ACTION_PWR_SAVE_CONFIG_RES           1
#define DMG_ACTION_INFO_REQ                      2
#define DMG_ACTION_INFO_RES                      3
#define DMG_ACTION_HANDOVER_REQ                  4
#define DMG_ACTION_HANDOVER_RES                  5
#define DMG_ACTION_DTP_REQ                       6
#define DMG_ACTION_DTP_RES                       7
#define DMG_ACTION_RELAY_SEARCH_REQ              8
#define DMG_ACTION_RELAY_SEARCH_RES              9
#define DMG_ACTION_MUL_RELAY_CHANNEL_MEASURE_REQ 10
#define DMG_ACTION_MUL_RELAY_CHANNEL_MEASURE_RES 11
#define DMG_ACTION_RLS_REQ                       12
#define DMG_ACTION_RLS_RES                       13
#define DMG_ACTION_RLS_ANNOUNCE                  14
#define DMG_ACTION_RLS_TEARDOWN                  15
#define DMG_ACTION_RELAY_ACK_REQ                 16
#define DMG_ACTION_RELAY_ACK_RES                 17
#define DMG_ACTION_TPA_REQ                       18
#define DMG_ACTION_TPA_RES                       19
#define DMG_ACTION_TPA_REP                       20
#define DMG_ACTION_ROC_REQ                       21
#define DMG_ACTION_ROC_RES                       22

#define UNPROTECTED_DMG_ANNOUNCE                 0
#define UNPROTECTED_DMG_BRP                      1

#define FST_SETUP_REQUEST                        0
#define FST_SETUP_RESPONSE                       1
#define FST_TEAR_DOWN                            2
#define FST_ACK_REQUEST                          3
#define FST_ACK_RESPONSE                         4
#define FST_ON_CHANNEL_TUNNEL_REQUEST            5

#define ROBUST_AV_STREAMING_SCS_REQUEST          0
#define ROBUST_AV_STREAMING_SCS_RESPONSE         1
#define ROBUST_AV_STREAMING_GROUP_MEMBERSHIP_REQ 2
#define ROBUST_AV_STREAMING_GROUP_MEMBERSHIP_RSP 3
#define ROBUST_AV_STREAMING_MSCS_REQUEST         4
#define ROBUST_AV_STREAMING_MSCS_RESPONSE        5


/* IEEE Std 802.11r-2008, 7.4.8, Table 7-57g */
#define FT_ACTION_REQUEST               1
#define FT_ACTION_RESPONSE              2
#define FT_ACTION_CONFIRM               3
#define FT_ACTION_ACK                   4

/* SA Query Action frame codes (IEEE 802.11w-2009, 7.4.9) */
#define SA_QUERY_REQUEST                0
#define SA_QUERY_RESPONSE               1

/* IEEE Std 802.11z-2010, 7.4.11, Table 7-57v1 */
#define TDLS_SETUP_REQUEST              0
#define TDLS_SETUP_RESPONSE             1
#define TDLS_SETUP_CONFIRM              2
#define TDLS_TEARDOWN                   3
#define TDLS_PEER_TRAFFIC_INDICATION    4
#define TDLS_CHANNEL_SWITCH_REQUEST     5
#define TDLS_CHANNEL_SWITCH_RESPONSE    6
#define TDLS_PEER_PSM_REQUEST           7
#define TDLS_PEER_PSM_RESPONSE          8
#define TDLS_PEER_TRAFFIC_RESPONSE      9
#define TDLS_DISCOVERY_REQUEST          10

/* IEEE Std 802.11-2012, 8.5.7.1, Table 8-206 */
#define RM_ACTION_RADIO_MEASUREMENT_REQUEST         0
#define RM_ACTION_RADIO_MEASUREMENT_REPORT          1
#define RM_ACTION_LINK_MEASUREMENT_REQUEST          2
#define RM_ACTION_LINK_MEASUREMENT_REPORT           3
#define RM_ACTION_NEIGHBOR_REPORT_REQUEST           4
#define RM_ACTION_NEIGHBOR_REPORT_RESPONSE          5

/* 11s draft 12.0, table 7-57v30 */
#define MESH_ACTION_LINK_METRIC_REPORT              0
#define MESH_ACTION_HWMP                            1
#define MESH_ACTION_GATE_ANNOUNCE                   2
#define MESH_ACTION_CONGESTION_CTL                  3
#define MESH_ACTION_MCCA_SETUP_REQUEST              4
#define MESH_ACTION_MCCA_SETUP_REPLY                5
#define MESH_ACTION_MCCA_ADV_REQUEST                6
#define MESH_ACTION_MCCA_ADV                        7
#define MESH_ACTION_MCCA_TEARDOWN                   8
#define MESH_ACTION_TBTT_ADJ_REQUEST                9
#define MESH_ACTION_TBTT_ADJ_RESPONSE              10

/* 11s draft 12.0, table 7-57v42: Multihop Action field values */
#define MULTIHOP_ACTION_PROXY_UPDATE                0
#define MULTIHOP_ACTION_PROXY_UPDATE_CONF           1

/* 11s draft 12.0, table 7-57v24: Self-protected Action field values */
#define SELFPROT_ACTION_MESH_PEERING_OPEN           1
#define SELFPROT_ACTION_MESH_PEERING_CONFIRM        2
#define SELFPROT_ACTION_MESH_PEERING_CLOSE          3
#define SELFPROT_ACTION_MESH_GROUP_KEY_INFORM       4
#define SELFPROT_ACTION_MESH_GROUP_KEY_ACK          5

/* 11s draft 12.0, table 7-43bj6: Mesh Peering Protocol Identifier field values */
#define MESH_PEERING_PROTO_MGMT                     0
#define MESH_PEERING_PROTO_AMPE                     1
#define MESH_PEERING_PROTO_VENDOR                 255

/* Vendor actions */
/* MARVELL */
#define MRVL_ACTION_MESH_MANAGEMENT     1

#define MRVL_MESH_MGMT_ACTION_RREQ      0
#define MRVL_MESH_MGMT_ACTION_RREP      1
#define MRVL_MESH_MGMT_ACTION_RERR      2
#define MRVL_MESH_MGMT_ACTION_PLDM      3

#define ANQP_INFO_ANQP_QUERY_LIST                256
#define ANQP_INFO_ANQP_CAPAB_LIST                257
#define ANQP_INFO_VENUE_NAME_INFO                258
#define ANQP_INFO_EMERGENCY_CALL_NUMBER_INFO     259
#define ANQP_INFO_NETWORK_AUTH_TYPE_INFO         260
#define ANQP_INFO_ROAMING_CONSORTIUM_LIST        261
#define ANQP_INFO_IP_ADDR_TYPE_AVAILABILITY_INFO 262
#define ANQP_INFO_NAI_REALM_LIST                 263
#define ANQP_INFO_3GPP_CELLULAR_NETWORK_INFO     264
#define ANQP_INFO_AP_GEOSPATIAL_LOCATION         265
#define ANQP_INFO_AP_CIVIC_LOCATION              266
#define ANQP_INFO_AP_LOCATION_PUBLIC_ID_URI      267
#define ANQP_INFO_DOMAIN_NAME_LIST               268
#define ANQP_INFO_EMERGENCY_ALERT_ID_URI         269
#define ANQP_INFO_TDLS_CAPAB_INFO                270
#define ANQP_INFO_EMERGENCY_NAI                  271
#define ANQP_INFO_NEIGHBOR_REPORT                272
#define ANQP_INFO_QUERY_AP_LIST                  273
#define ANQP_INFO_AP_LIST_RESPONSE               274
#define ANQP_INFO_FILS_REALM_INFO                275
#define ANQP_INFO_CAG                            276
#define ANQP_INFO_VENUE_URL                      277
#define ANQP_INFO_ADVICE_OF_CHARGE               278
#define ANQP_INFO_LOCAL_CONTENT                  279
#define ANQP_INFO_NETWORK_AUTH_TYPE_TIMESTAMP    280
#define ANQP_INFO_ANQP_VENDOR_SPECIFIC_LIST    56797

/* ANQP information ID - IEEE Std 802.11u-2011 - Table 7-43bk */
static const value_string anqp_info_id_vals[] = {
  {ANQP_INFO_ANQP_QUERY_LIST, "ANQP Query list"},
  {ANQP_INFO_ANQP_CAPAB_LIST, "ANQP Capability list"},
  {ANQP_INFO_VENUE_NAME_INFO, "Venue Name information"},
  {ANQP_INFO_EMERGENCY_CALL_NUMBER_INFO, "Emergency Call Number information"},
  {ANQP_INFO_NETWORK_AUTH_TYPE_INFO,
   "Network Authentication Type information"},
  {ANQP_INFO_ROAMING_CONSORTIUM_LIST, "Roaming Consortium list"},
  {ANQP_INFO_IP_ADDR_TYPE_AVAILABILITY_INFO,
   "IP Address Type Availability information"},
  {ANQP_INFO_NAI_REALM_LIST, "NAI Realm list"},
  {ANQP_INFO_3GPP_CELLULAR_NETWORK_INFO, "3GPP Cellular Network information"},
  {ANQP_INFO_AP_GEOSPATIAL_LOCATION, "AP Geospatial Location"},
  {ANQP_INFO_AP_CIVIC_LOCATION, "AP Civic Location"},
  {ANQP_INFO_AP_LOCATION_PUBLIC_ID_URI, "AP Location Public Identifier URI"},
  {ANQP_INFO_DOMAIN_NAME_LIST, "Domain Name list"},
  {ANQP_INFO_EMERGENCY_ALERT_ID_URI, "Emergency Alert Identifier URI"},
  {ANQP_INFO_TDLS_CAPAB_INFO, "TDLS Capability information"},
  {ANQP_INFO_EMERGENCY_NAI, "Emergency NAI"},
  {ANQP_INFO_NEIGHBOR_REPORT, "Neighbor Report"},
  {ANQP_INFO_QUERY_AP_LIST, "Query AP List"},
  {ANQP_INFO_AP_LIST_RESPONSE, "AP List Response"},
  {ANQP_INFO_FILS_REALM_INFO, "FILS Realm Info"},
  {ANQP_INFO_CAG, "CAG"},
  {ANQP_INFO_VENUE_URL, "Venue URL"},
  {ANQP_INFO_ADVICE_OF_CHARGE, "Advice of Charge"},
  {ANQP_INFO_LOCAL_CONTENT, "Local Content"},
  {ANQP_INFO_NETWORK_AUTH_TYPE_TIMESTAMP,
   "Network Authentication Type with Timestamp"},
  {ANQP_INFO_ANQP_VENDOR_SPECIFIC_LIST, "ANQP vendor-specific list"},
  {0, NULL}
};
static value_string_ext anqp_info_id_vals_ext = VALUE_STRING_EXT_INIT(anqp_info_id_vals);

/* IEEE 802.11v - WNM Action field values */
enum wnm_action {
  WNM_EVENT_REQ = 0,
  WNM_EVENT_REPORT = 1,
  WNM_DIAGNOSTIC_REQ = 2,
  WNM_DIAGNOSTIC_REPORT = 3,
  WNM_LOCATION_CFG_REQ = 4,
  WNM_LOCATION_CFG_RESP = 5,
  WNM_BSS_TRANS_MGMT_QUERY = 6,
  WNM_BSS_TRANS_MGMT_REQ = 7,
  WNM_BSS_TRANS_MGMT_RESP = 8,
  WNM_FMS_REQ = 9,
  WNM_FMS_RESP = 10,
  WNM_COLLOCATED_INTERFERENCE_REQ = 11,
  WNM_COLLOCATED_INTERFERENCE_REPORT = 12,
  WNM_TFS_REQ = 13,
  WNM_TFS_RESP = 14,
  WNM_TFS_NOTIFY = 15,
  WNM_SLEEP_MODE_REQ = 16,
  WNM_SLEEP_MODE_RESP = 17,
  WNM_TIM_BROADCAST_REQ = 18,
  WNM_TIM_BROADCAST_RESP = 19,
  WNM_QOS_TRAFFIC_CAPAB_UPDATE = 20,
  WNM_CHANNEL_USAGE_REQ = 21,
  WNM_CHANNEL_USAGE_RESP = 22,
  WNM_DMS_REQ = 23,
  WNM_DMS_RESP = 24,
  WNM_TIMING_MEASUREMENT_REQ = 25,
  WNM_NOTIFICATION_REQ = 26,
  WNM_NOTIFICATION_RESP = 27
};

static const value_string wnm_action_codes[] = {
  { WNM_EVENT_REQ, "Event Request" },
  { WNM_EVENT_REPORT, "Event Report" },
  { WNM_DIAGNOSTIC_REQ, "Diagnostic Request" },
  { WNM_DIAGNOSTIC_REPORT, "Diagnostic Report" },
  { WNM_LOCATION_CFG_REQ, "Location Configuration Request" },
  { WNM_LOCATION_CFG_RESP, "Location Configuration Response" },
  { WNM_BSS_TRANS_MGMT_QUERY, "BSS Transition Management Query" },
  { WNM_BSS_TRANS_MGMT_REQ, "BSS Transition Management Request" },
  { WNM_BSS_TRANS_MGMT_RESP, "BSS Transition Management Response" },
  { WNM_FMS_REQ, "FMS Request" },
  { WNM_FMS_RESP, "FMS Response" },
  { WNM_COLLOCATED_INTERFERENCE_REQ, "Collocated Interference Request" },
  { WNM_COLLOCATED_INTERFERENCE_REPORT, "Collocated Interference Report" },
  { WNM_TFS_REQ, "TFS Request" },
  { WNM_TFS_RESP, "TFS Response" },
  { WNM_TFS_NOTIFY, "TFS Notify" },
  { WNM_SLEEP_MODE_REQ, "WNM-Sleep Mode Request" },
  { WNM_SLEEP_MODE_RESP, "WNM-Sleep Mode Response" },
  { WNM_TIM_BROADCAST_REQ, "TIM Broadcast Request" },
  { WNM_TIM_BROADCAST_RESP, "TIM Broadcast Response" },
  { WNM_QOS_TRAFFIC_CAPAB_UPDATE, "QoS Traffic Capability Update" },
  { WNM_CHANNEL_USAGE_REQ, "Channel Usage Request" },
  { WNM_CHANNEL_USAGE_RESP, "Channel Usage Response" },
  { WNM_DMS_REQ, "DMS Request" },
  { WNM_DMS_RESP, "DMS Response" },
  { WNM_TIMING_MEASUREMENT_REQ, "Timing Measurement Request" },
  { WNM_NOTIFICATION_REQ, "WNM-Notification Request" },
  { WNM_NOTIFICATION_RESP, "WNM-Notification Response" },
  { 0, NULL }
};
static value_string_ext wnm_action_codes_ext = VALUE_STRING_EXT_INIT(wnm_action_codes);

enum unprotected_wnm_action {
  UNPROTECTED_WNM_TIM = 0,
  UNPROTECTED_WNM_TIMING_MEASUREMENT = 1
};

static const value_string unprotected_wnm_action_codes[] = {
  { UNPROTECTED_WNM_TIM, "TIM" },
  { UNPROTECTED_WNM_TIMING_MEASUREMENT, "Timing Measurement" },
  { 0, NULL }
};
static value_string_ext unprotected_wnm_action_codes_ext = VALUE_STRING_EXT_INIT(unprotected_wnm_action_codes);

static const value_string wnm_notification_types[] = {
  { 0, "Firmware Update Notification" },
  { 1, "Reserved for use by WFA" },
  { 221, "Vendor Specific" },
  { 0, NULL }
};

static value_string_ext wnm_notification_types_ext =
  VALUE_STRING_EXT_INIT(wnm_notification_types);

static const range_string wnm_notification_response_code[] = {
  { 0, 0, "Notification Acknowledged" },
  { 1, 255, "Reserved" },
  { 0, 0, NULL }
};

/*** End: Action Fixed Parameter ***/

static const value_string ieee80211_tag_measure_request_type_flags[] = {
  {0x00, "Basic Request"},
  {0x01, "Clear Channel Assessment (CCA) Request"},
  {0x02, "Receive Power Indication (RPI) Histogram Request"},
  {0x03, "Channel Load Request"},
  {0x04, "Noise Histogram Request"},
  {0x05, "Beacon Request"},
  {0x06, "Frame Request"},
  {0x07, "STA Statistics Request"},
  {0x08, "Location Configuration Indication (LCI) Request"},
  {0x09, "Transmit Stream Measurement Request"},
  {0x0a, "Multicast Diagnostics Request"},
  {0x0b, "Location Civic Request"},
  {0x0c, "Location Identifier Request"},
  {0x0d, "Directional Channel Quality Request"},
  {0x0e, "Directional Measurement Request"},
  {0x0f, "Directional Statistics Request"},
  {0x10, "Fine Timing Measurement Range Request"},
  {0xFF, "Measurement Pause Request"},
  {0x00, NULL}
};
static value_string_ext ieee80211_tag_measure_request_type_flags_ext =
  VALUE_STRING_EXT_INIT(ieee80211_tag_measure_request_type_flags);

static const value_string ieee80211_tag_measure_report_type_flags[] = {
  { 0x00, "Basic Report" },
  { 0x01, "Clear Channel Assessment (CCA) Report" },
  { 0x02, "Receive Power Indication (RPI) Histogram Report" },
  { 0x03, "Channel Load Report" },
  { 0x04, "Noise Histogram Report" },
  { 0x05, "Beacon Report" },
  { 0x06, "Frame Report" },
  { 0x07, "STA Statistics Report" },
  { 0x08, "Location Configuration Information (LCI) Report" },
  { 0x09, "Transmit Stream Measurement Report" },
  { 0x0a, "Multicast Diagnostics Report"},
  { 0x0b, "Location Civic Report"},
  { 0x0c, "Location Identifier Report"},
  { 0x0d, "Directional Channel Quality Report"},
  { 0x0e, "Directional Measurement Report"},
  { 0x0f, "Directional Statistics Report"},
  { 0x10, "Fine Timing Measurement Range Report"},
  { 0x00, NULL }
};
static value_string_ext ieee80211_tag_measure_report_type_flags_ext =
  VALUE_STRING_EXT_INIT(ieee80211_tag_measure_report_type_flags);

static const true_false_string ieee80211_tag_measure_report_frame_info_frame_type_flag = {
  "Measurement Pilot Frame",
  "Beacon/Probe Response Frame"
};

static const true_false_string ig_tfs = {
  "Group address (multicast/broadcast)",
  "Individual address (unicast)"
};

static const true_false_string lg_tfs = {
  "Locally administered address (this is NOT the factory default)",
  "Globally unique address (factory default)"
};

static const true_false_string ieee80211_tag_measure_map_field_bss_flag = {
  "At least one valid MPDU was received by another BSS or IBSS during the measurement period.",
  "No valid MPDUs were received from another BSS or IBSS during the measurement period."
};

static const value_string ieee80211_tag_measure_request_measurement_mode_flags[] = {
  { 0x00, "Passive" },
  { 0x01, "Active" },
  { 0x02, "Beacon Table" },
  { 0x00, NULL }
};

#define MEASURE_REQ_BEACON_SUB_SSID 0
#define MEASURE_REQ_BEACON_SUB_BRI 1
#define MEASURE_REQ_BEACON_SUB_RD 2
#define MEASURE_REQ_BEACON_SUB_REQUEST 10
#define MEASURE_REQ_BEACON_SUB_REQUEST_EXT 11
#define MEASURE_REQ_BEACON_SUB_APCP 51
#define MEASURE_REQ_BEACON_SUB_WIDE_BW_CHANNEL_SWITCH 163
#define MEASURE_REQ_BEACON_SUB_LAST_REPORT_REQ 164
#define MEASURE_REQ_BEACON_SUB_VS 221

static const value_string ieee80211_tag_measure_request_beacon_sub_id_flags[] = {
  { MEASURE_REQ_BEACON_SUB_SSID, "SSID" },
  { MEASURE_REQ_BEACON_SUB_BRI, "Beacon Reporting Information" },
  { MEASURE_REQ_BEACON_SUB_RD, "Reporting Detail" },
  { MEASURE_REQ_BEACON_SUB_REQUEST, "Request" },
  { MEASURE_REQ_BEACON_SUB_REQUEST_EXT, "Extended Request" },
  { MEASURE_REQ_BEACON_SUB_APCP, "AP Channel Report" },
  { MEASURE_REQ_BEACON_SUB_WIDE_BW_CHANNEL_SWITCH, "Wide Channel Bandwidth Switch" },
  { MEASURE_REQ_BEACON_SUB_LAST_REPORT_REQ, "Last Beacon Report Indication Request" },
  { MEASURE_REQ_BEACON_SUB_VS, "Vendor Specific" },
  { 0x00, NULL}
};

static const value_string ieee80211_tag_measure_request_beacon_sub_bri_reporting_condition_flags[] = {
  { 0x00, "Report to be issued after each measurement." },
  { 0x01, "The measured RCPI level is greater than an absolute threshold." },
  { 0x02, "The measured RCPI level is less than an absolute threshold." },
  { 0x03, "The measured RSNI level is greater than an absolute threshold." },
  { 0x04, "The measured RSNI level is less than an absolute threshold." },
  { 0x05, "The measured RCPI level is greater than a threshold defined by an offset from the serving AP's reference RCPI." },
  { 0x06, "The measured RCPI level is less than a threshold defined by an offset from the serving AP's reference RCPI." },
  { 0x07, "The measured RSNI level is greater than a threshold defined by an offset from the serving AP's reference RSNI." },
  { 0x08, "The measured RSNI level is less than a threshold defined by an offset from the serving AP's reference RSNI." },
  { 0x09, "The measured RCPI level is in a range bound by the serving AP's reference RCPI and an offset from the serving AP's reference RCPI." },
  { 0x0a, "The measured RSNI level is in a range bound by the serving AP's reference RSNI and an offset from the serving AP's reference RSNI." },
  { 0xfe, "Report not required to be issued" },
  { 0x00, NULL }
};

static const value_string ieee80211_tag_measure_request_beacon_sub_reporting_detail_flags[] = {
  { 0, "No fixed length fields or elements" },
  { 1, "All fixed length fields and any requested elements in the Request information element if present" },
  { 2, "All fixed length fields and elements (default, used when Reporting Detail subelement is not included in Beacon Request" },
  { 0x00, NULL }
};

static const value_string ieee80211_tag_measure_request_group_id_flags[] = {
  { 0x00, "STA Counters from dot11CountersTable" },
  { 0x01, "STA Counters from dot11MacStatistics group" },
  { 0x02, "QoS STA Counters for UP0 from dot11QosCountersTable" },
  { 0x03, "QoS STA Counters for UP1 from dot11QosCountersTable" },
  { 0x04, "QoS STA Counters for UP2 from dot11QosCountersTable" },
  { 0x05, "QoS STA Counters for UP3 from dot11QosCountersTable" },
  { 0x06, "QoS STA Counters for UP4 from dot11QosCountersTable" },
  { 0x07, "QoS STA Counters for UP5 from dot11QosCountersTable" },
  { 0x08, "QoS STA Counters for UP6 from dot11QosCountersTable" },
  { 0x09, "QoS STA Counters for UP7 from dot11QosCountersTable" },
  { 0x0a, "BSS Average Access Delays" },
  { 0x0b, "STA Counters from dot11A-MSDU Group" },
  { 0x0c, "STA Counters from dot11A-MPDU Group" },
  { 0x0d, "STA Counters from dot11 BAR, Channel Width, PSMP Group" },
  { 0x0e, "STA Counters from dot11Protection Group" },
  { 0x0f, "STBC Group" },
  { 0x00, NULL }
};
static value_string_ext ieee80211_tag_measure_request_group_id_flags_ext =
  VALUE_STRING_EXT_INIT(ieee80211_tag_measure_request_group_id_flags);

static const value_string ieee80211_tag_measure_request_location_subject[] = {
  { 0, "Local" },
  { 1, "Remote" },
  { 2, "Third party" },
  { 0x00, NULL }
};

static const value_string ieee80211_tag_measure_request_civic_location_type[] = {
  { 0, "IETF RFC 4776" },
  { 1, "Vendor Specific" },
  { 0x00, NULL }
};

static const value_string ieee80211_tclas_process_flag[] = {
  {0x00, "Incoming MSDU's higher layer parameters have to match to the parameters in all associated TCLAS elements."},
  {0x01, "Incoming MSDU's higher layer parameters have to match to at least one of the associated TCLAS elements."},
  {0x02, "Incoming MSDU's that do not belong to any other TS are classified to the TS for which this TCLAS Processing element is used. In this case, there will not be any associated TCLAS elements."},
  {0, NULL}
};


#define MEASURE_REQ_CHANNEL_LOAD_SUB_REPORTING_INFO 1

static const value_string ieee80211_tag_measure_request_channel_load_sub_id_vals[] = {
  { MEASURE_REQ_CHANNEL_LOAD_SUB_REPORTING_INFO, "Channel Load Reporting Information" },
  { 221, "Vendor Specific" },
  { 0x00, NULL}
};

static const value_string ieee80211_tag_measure_request_channel_load_sub_reporting_condition_vals[] = {
  { 0x00, "Report to be issued after each measurement (default, used when Channel Load Reporting Information subelement is not included in Channel Load Request)." },
  { 0x01, "Report to be issued when measured Channel Load is equal to or greater than the reference value." },
  { 0x02, "Report to be issued when measured Channel Load is equal to or less than the reference value." },
  { 0x00, NULL}
};

#define MEASURE_REQ_NOISE_HISTOGRAM_SUB_REPORTING_INFO 1

static const value_string ieee80211_tag_measure_request_noise_histogram_sub_id_vals[] = {
  { MEASURE_REQ_NOISE_HISTOGRAM_SUB_REPORTING_INFO, "Noise Histogram Reporting Information" },
  { 221, "Vendor Specific" },
  { 0x00, NULL}
};

static const value_string ieee80211_tag_measure_request_noise_histogram_sub_reporting_condition_vals[] = {
  { 0x00, "Report to be issued after each measurement (default, used when Noise Histogram Reporting Information subelement is not included in Noise Histogram Request)." },
  { 0x01, "Noise Histogram Report to be issued when measured ANPI is equal to or greater than the reference value." },
  { 0x02, "Noise Histogram Report to be issued when measured ANPI is equal to or less than the reference value." },
  { 0x00, NULL}
};

#define MEASURE_REP_BEACON_SUB_REPORTED_FRAME_BODY 1
#define MEASURE_REP_BEACON_SUB_REPORTED_FRAME_BODY_FRAG_ID 2
#define MEASURE_REP_BEACON_SUB_WIDE_BW_CHANNEL_SWITCH 163
#define MEASURE_REP_BEACON_SUB_LAST_REPORT_INDICATION 164

static const value_string ieee80211_tag_measure_report_beacon_sub_id_vals[] = {
  { MEASURE_REP_BEACON_SUB_REPORTED_FRAME_BODY, "Reported Frame Body" },
  { MEASURE_REP_BEACON_SUB_REPORTED_FRAME_BODY_FRAG_ID, "Reported Frame Body Fragment ID" },
  { MEASURE_REP_BEACON_SUB_WIDE_BW_CHANNEL_SWITCH, "Wide Bandwidth Channel Switch"},
  { MEASURE_REP_BEACON_SUB_LAST_REPORT_INDICATION, "Last Beacon Report Indication"},
  { 221, "Vendor Specific" },
  { 0x00, NULL}
};

#define MEASURE_REP_LCI_SUB_REPORTED_LCI 0
#define MEASURE_REP_LCI_SUB_REPORTED_AZIMUTH_REPORT 1
#define MEASURE_REP_LCI_SUB_REPORTED_OR_STA 2
#define MEASURE_REP_LCI_SUB_REPORTED_T_MAC 3
#define MEASURE_REP_LCI_SUB_REPORTED_Z 4
#define MEASURE_REP_LCI_SUB_REPORTED_RLE 5
#define MEASURE_REP_LCI_SUB_REPORTED_URP 6
#define MEASURE_REP_LCI_SUB_REPORTED_CO_BSSID 7

static const value_string ieee80211_tag_measure_report_lci_sub_id_vals[] = {
  { MEASURE_REP_LCI_SUB_REPORTED_LCI, "LCI" },
  { MEASURE_REP_LCI_SUB_REPORTED_AZIMUTH_REPORT, "Azimuth Report" },
  { MEASURE_REP_LCI_SUB_REPORTED_OR_STA, "Originator Requesting STA MAC Address" },
  { MEASURE_REP_LCI_SUB_REPORTED_T_MAC, "Target MAC Address" },
  { MEASURE_REP_LCI_SUB_REPORTED_Z, "Z" },
  { MEASURE_REP_LCI_SUB_REPORTED_RLE, "Relative Location Error" },
  { MEASURE_REP_LCI_SUB_REPORTED_URP, "Usage Rules/Policy" },
  { MEASURE_REP_LCI_SUB_REPORTED_CO_BSSID, "Co-Located BSSID List" },
  { 221, "Vendor Specific" },
  { 0x00, NULL}
};

#define MEASURE_REP_CIVIC_SUB_REPORTED_LOCATION_CIVIC 0
#define MEASURE_REP_CIVIC_SUB_REPORTED_OR_STA 1
#define MEASURE_REP_CIVIC_SUB_REPORTED_T_MAC 2
#define MEASURE_REP_CIVIC_SUB_REPORTED_LOCATION_REFERENCE 3
#define MEASURE_REP_CIVIC_SUB_REPORTED_LOCATION_SHAPE 4
#define MEASURE_REP_CIVIC_SUB_REPORTED_MAP_IMAGE 5
#define MEASURE_REP_CIVIC_SUB_REPORTED_RESERVED 6
#define MEASURE_REP_CIVIC_SUB_REPORTED_CO_BSSID 7

static const value_string ieee80211_tag_measure_report_civic_sub_id_vals[] = {
  { MEASURE_REP_CIVIC_SUB_REPORTED_LOCATION_CIVIC, "Location Civic" },
  { MEASURE_REP_CIVIC_SUB_REPORTED_OR_STA, "Originator Requesting STA MAC Address" },
  { MEASURE_REP_CIVIC_SUB_REPORTED_T_MAC, "Target MAC Address" },
  { MEASURE_REP_CIVIC_SUB_REPORTED_LOCATION_REFERENCE, "Location Reference" },
  { MEASURE_REP_CIVIC_SUB_REPORTED_LOCATION_SHAPE, "Location Shape" },
  { MEASURE_REP_CIVIC_SUB_REPORTED_MAP_IMAGE, "Map Image" },
  { MEASURE_REP_CIVIC_SUB_REPORTED_RESERVED, "Reserved" },
  { MEASURE_REP_CIVIC_SUB_REPORTED_CO_BSSID, "Co-Located BSSID List" },
  { 221, "Vendor Specific" },
  { 0x00, NULL}
};

static const value_string frame_type[] = {
  {MGT_FRAME,       "Management frame"},
  {CONTROL_FRAME,   "Control frame"},
  {DATA_FRAME,      "Data frame"},
  {EXTENSION_FRAME, "Extension frame"},
  {0,               NULL}
};

static const value_string tofrom_ds[] = {
  {0,                     "Not leaving DS or network is operating "
    "in AD-HOC mode (To DS: 0 From DS: 0)"},
  {FLAG_TO_DS,            "Frame from STA to DS via an AP (To DS: 1 "
    "From DS: 0)"},
  {FLAG_FROM_DS,          "Frame from DS to a STA via AP(To DS: 0 "
    "From DS: 1)"},
  {FLAG_TO_DS|FLAG_FROM_DS, "WDS (AP to AP) or Mesh (MP to MP) Frame "
    "(To DS: 1 From DS: 1)"},
  {0, NULL}
};

static const true_false_string tods_flag = {
  "Frame is entering DS",
  "Frame is not entering DS"
};

static const true_false_string fromds_flag = {
  "Frame is exiting DS",
  "Frame is not exiting DS"
};

static const true_false_string more_fragments = {
  "More fragments follow",
  "This is the last fragment"
};

static const true_false_string retry_flags = {
  "Frame is being retransmitted",
  "Frame is not being retransmitted"
};

static const true_false_string pm_flags = {
  "STA will go to sleep",
  "STA will stay up"
};

static const true_false_string md_flags = {
  "Data is buffered for STA at AP",
  "No data buffered"
};

static const true_false_string protected_flags = {
  "Data is protected",
  "Data is not protected"
};

static const true_false_string order_flags = {
  "Strictly ordered",
  "Not strictly ordered"
};

static const true_false_string cf_ess_flags = {
  "Transmitter is an AP",
  "Transmitter is a STA"
};


static const true_false_string cf_privacy_flags = {
  "Data confidentiality required",
  "Data confidentiality not required"
};

static const true_false_string cf_ibss_flags = {
  "Transmitter belongs to an IBSS",
  "Transmitter belongs to a BSS"
};

static const true_false_string eosp_flag = {
  "End of service period",
  "Service period"
};

static const true_false_string bit4_flag = {
  "Bits 8-15 of QoS Control field are Queue Size",
  "Bits 8-15 of QoS Control field are TXOP Duration Requested"
};

static const true_false_string ieee80211_qos_amsdu_present_flag = {
  "A-MSDU",
  "MSDU"
};

static const true_false_string csa_txrestrict_flags = {
  "Tx Restrict",
  "No Tx Restrict"
};

static const true_false_string csa_initiator_flags = {
  "Initiator",
  "Non Initiator"
};

static const true_false_string mesh_config_cap_power_save_level_flags = {
   "At least one of the peer-specific mesh power modes is deep sleep mode",
   "None of the peer-specific mesh power modes is deep sleep mode"
};

static const true_false_string ieee80211_qos_mesh_ps = {
  "deep sleep mode",
  "light sleep mode"
};

#define AUTH_ALG_OPEN                   0
#define AUTH_ALG_SHARED                 1
#define AUTH_ALG_FAST_BSS_TRANS         2
#define AUTH_ALG_SAE                    3
#define AUTH_ALG_FILS_SK_WITHOUT_PFS    4
#define AUTH_ALG_FILS_SK_WITH_PFS       5
#define AUTH_ALG_FILS_PK                6
#define AUTH_ALG_PASN                   7
#define AUTH_ALG_NETWORK_EAP         0x80

static const value_string auth_alg[] = {
  {AUTH_ALG_OPEN,                "Open System"},
  {AUTH_ALG_SHARED,              "Shared key"},
  {AUTH_ALG_FAST_BSS_TRANS,      "Fast BSS Transition"},
  {AUTH_ALG_SAE,                 "Simultaneous Authentication of Equals (SAE)"},
  {AUTH_ALG_FILS_SK_WITHOUT_PFS, "FILS Shared Key authentication without PFS"},
  {AUTH_ALG_FILS_SK_WITH_PFS,    "FILS Shared Key authentication with PFS"},
  {AUTH_ALG_FILS_PK,             "FILS Public Key authentication"},
  {AUTH_ALG_PASN,                "Pre-Association Security Negotiation (PASN)"},
  {AUTH_ALG_NETWORK_EAP,         "Network EAP"},  /* Cisco proprietary? */
  {0, NULL}
};

/* IANA - Internet Key Exchange (IKE) Attributes - Group Description (https://www.iana.org/assignments/ipsec-registry/ipsec-registry.xhtml) */
static const value_string ff_finite_cyclic_group_vals[] = {
  { 1, "default 768-bit MODP group"},
  { 2, "alternate 1024-bit MODP group"},
  { 3, "EC2N group on GP[2^155]"},
  { 4, "EC2N group on GP[2^185]"},
  { 5, "1536-bit MODP group"},
  {14, "2048-bit MODP group"},
  {15, "3072-bit MODP group"},
  {16, "4096-bit MODP group"},
  {17, "6144-bit MODP group"},
  {18, "8192-bit MODP group"},
  {19, "256-bit random ECP group"},
  {20, "384-bit random ECP group"},
  {21, "521-bit random ECP group"},
  {22, "1024-bit MODP Group with 160-bit Prime Order Subgroup"},
  {23, "2048-bit MODP Group with 224-bit Prime Order Subgroup"},
  {24, "2048-bit MODP Group with 256-bit Prime Order Subgroup"},
  {25, "192-bit Random ECP Group"},
  {26, "224-bit Random ECP Group"},
  {27, "224-bit Brainpool ECP group"},
  {28, "256-bit Brainpool ECP group"},
  {29, "384-bit Brainpool ECP group"},
  {30, "512-bit Brainpool ECP group"},
  {0, NULL}
};

static const true_false_string ff_block_ack_params_amsdu_permitted_flag = {
  "Permitted in QoS Data MPDUs",
  "Not Permitted"
};

static const true_false_string ff_block_ack_params_policy_flag = {
  "Immediate Block Ack",
  "Delayed Block Ack"
};

static const value_string  ff_channel_width_vals[] = {
  {0x00, "20 MHz channel width only"},
  {0x01, "Any channel width in the STA's Supported Channel Width Set"},
  {0, NULL}
};

static const true_false_string ff_qos_info_ap_q_ack_flag = {
  "APs MIB attribute dot11QAckOptionImplemented is true",
  "APs MIB attribute dot11QAckOptionImplemented is false"
};

static const true_false_string ff_qos_info_ap_queue_req_flag = {
  "AP can process a nonzero Queue Size subfield in the QoS Control field in QoS data frames",
  "AP cannot process a nonzero Queue Size subfield in the QoS Control field in QoS data frames"
};

static const true_false_string ff_qos_info_ap_txop_request_flag = {
  "AP can process a nonzero TXOP Duration Requested subfield in the QoS Control field in QoS data frames",
  "AP cannot process a nonzero TXOP Duration Requested subfield in the QoS Control field in QoS data frames"
};

static const true_false_string ff_qos_info_sta_ac_flag = {
  "Trigger-enabled and Delivery-enabled",
  "Neither Trigger-enabled nor Delivery-enabled"
};

static const true_false_string ff_qos_info_sta_q_ack_flag = {
  "STAs MIB attribute dot11QAckOptionImplemented is true",
  "STAs MIB attribute dot11QAckOptionImplemented is false"
};

static const value_string ff_qos_info_sta_max_sp_len_flags[] = {
  {0x00, "AP may deliver all buffered MSDUs, A-MSDUs and MMPDUs"},
  {0x01, "AP may deliver a maximum of two MSDUs, A-MSDUs and MMPDUs per SP"},
  {0x02, "AP may deliver a maximum of four MSDUs, A-MSDUs and MMPDUs per SP"},
  {0x03, "AP may deliver a maximum of six MSDUs, A-MSDUs and MMPDUs per SP"},
  {0, NULL}
};

static const true_false_string ff_qos_info_sta_more_data_ack_flag = {
  "STA can process ACK frames with the More Data bit in the Frame Control field set to 1 and will remain in the wake state",
  "STA cannot process ACK frames with the More Data bit in the Frame Control field set to 1"
};

static const true_false_string ff_sm_pwr_save_sm_mode_flag = {
  "Dynamic SM Power Save mode",
  "Static SM Power Save mode"
};

static const true_false_string ff_pco_phase_cntrl_flag = {
  "40 MHz Phase",
  "20 MHz Phase"
};

static const true_false_string ff_psmp_param_set_more_psmp_flag = {
  "More PSMP Sequences Follow",
  "No PSMP Sequences Follow"
};

static const value_string ff_mimo_cntrl_nc_index_flags[] = {
  {0x00, "1 Column"},
  {0x01, "2 Columns"},
  {0x02, "3 Columns"},
  {0x03, "4 Columns"},
  {0, NULL}
};

static const value_string ff_mimo_cntrl_nr_index_flags[] = {
  {0x00, "1 Row"},
  {0x01, "2 Rows"},
  {0x02, "3 Rows"},
  {0x03, "4 Rows"},
  {0, NULL}
};

static const true_false_string ff_mimo_cntrl_channel_width_flag = {
  "40 MHz",
  "20 MHz"
};

static const true_false_string ff_ht_info_information_request_flag = {
  "Requesting HT Information Exchange management action frame",
  "Should not send an HT Information Exchange management action frame"
};

static const true_false_string ff_ht_info_40_mhz_intolerant_flag = {
  "Transmitting station is intolerant of 40 MHz operation",
  "Transmitting station permits 40 MHz operation"
};

static const true_false_string ff_ht_info_sta_chan_width_flag = {
  "40 MHz",
  "20 MHz"
};

static const value_string ff_ht_action_flags[] = {
  {HT_ACTION_NOTIFY_CHAN_WIDTH,           "Notify Channel Width"},
  {HT_ACTION_SM_PWR_SAVE,                 "Spatial Multiplexing (SM) Power Save"},
  {HT_ACTION_PSMP_ACTION,                 "Power Save Multi-Poll (PSMP) action frame"},
  {HT_ACTION_SET_PCO_PHASE,               "Set PCO Phase"},
  {HT_ACTION_MIMO_CSI,                    "MIMO CSI Matrices"},
  {HT_ACTION_MIMO_BEAMFORMING,            "MIMO Non-compressed Beamforming"},
  {HT_ACTION_MIMO_COMPRESSED_BEAMFORMING, "MIMO Compressed Beamforming"},
  {HT_ACTION_ANT_SEL_FEEDBACK,            "Antenna Selection Indices Feedback"},
  {HT_ACTION_HT_INFO_EXCHANGE,            "HT Information Exchange"},
  {0x00, NULL}
};

static const value_string ff_fst_action_flags[] = {
  {FST_SETUP_REQUEST,             "FST Setup Request"},
  {FST_SETUP_RESPONSE,            "FST Setup Response"},
  {FST_TEAR_DOWN,                 "FST Tear Down"},
  {FST_ACK_REQUEST,               "FST Ack Request"},
  {FST_ACK_RESPONSE,              "FST Ack Response"},
  {FST_ON_CHANNEL_TUNNEL_REQUEST, "FST On-channel Tunnel Request"},
  {0x00, NULL}
};

static const value_string ff_robust_av_streaming_action_flags[] = {
  {ROBUST_AV_STREAMING_SCS_REQUEST,          "SCS Request"},
  {ROBUST_AV_STREAMING_SCS_RESPONSE,         "SCS Response"},
  {ROBUST_AV_STREAMING_GROUP_MEMBERSHIP_REQ, "Group Membership  Request"},
  {ROBUST_AV_STREAMING_GROUP_MEMBERSHIP_RSP, "SCS Request"},
  {ROBUST_AV_STREAMING_MSCS_REQUEST,         "MSCS Request"},
  {ROBUST_AV_STREAMING_MSCS_RESPONSE,        "MSCS Response"},
  {0x00, NULL}
};

static const value_string ff_dmg_action_flags[] = {
  {DMG_ACTION_PWR_SAVE_CONFIG_REQ,           "Power Save Configuration Request"},
  {DMG_ACTION_PWR_SAVE_CONFIG_RES,           "Power Save Configuration Response"},
  {DMG_ACTION_INFO_REQ,                      "Information Request"},
  {DMG_ACTION_INFO_RES,                      "Information Response"},
  {DMG_ACTION_HANDOVER_REQ,                  "Handover Request"},
  {DMG_ACTION_HANDOVER_RES,                  "Handover Response"},
  {DMG_ACTION_DTP_REQ,                       "DTP Request"},
  {DMG_ACTION_DTP_RES,                       "DTP Response"},
  {DMG_ACTION_RELAY_SEARCH_REQ,              "Relay Search Request"},
  {DMG_ACTION_RELAY_SEARCH_RES,              "Relay Search Response"},
  {DMG_ACTION_MUL_RELAY_CHANNEL_MEASURE_REQ, "Multi Relay Channel Measurement Request"},
  {DMG_ACTION_MUL_RELAY_CHANNEL_MEASURE_RES, "Multi Relay Channel Measurement Response"},
  {DMG_ACTION_RLS_REQ,                       "RLS Request"},
  {DMG_ACTION_RLS_RES,                       "RLS Response"},
  {DMG_ACTION_RLS_ANNOUNCE,                  "RLS Announcement"},
  {DMG_ACTION_RLS_TEARDOWN,                  "RLS Teardown"},
  {DMG_ACTION_RELAY_ACK_REQ,                 "Relay ACK Request"},
  {DMG_ACTION_RELAY_ACK_RES,                 "Relay ACK Response"},
  {DMG_ACTION_TPA_REQ,                       "TPA Request"},
  {DMG_ACTION_TPA_RES,                       "TPA Response"},
  {DMG_ACTION_TPA_REP,                       "TPA Report"},
  {DMG_ACTION_ROC_REQ,                       "ROC Request"},
  {DMG_ACTION_ROC_RES,                       "ROC Response"},
  {0x00, NULL}
};

static const value_string ff_unprotected_dmg_action_flags[] = {
  {UNPROTECTED_DMG_ANNOUNCE,      "Announce"},
  {UNPROTECTED_DMG_BRP,           "BRP"},
  {0x00, NULL}
};
static const value_string ff_mimo_cntrl_grouping_flags[] = {
  {0x00, "No Grouping"},
  {0x01, "Carrier Groups of 2"},
  {0x02, "Carrier Groups of 4"},
  {0x03, "Reserved"},
  {0, NULL}
};

static const value_string ff_mimo_cntrl_coefficient_size_flags[] = {
  {0x00, "4 Bits"},
  {0x01, "5 Bits"},
  {0x02, "6 Bits"},
  {0x03, "8 Bits"},
  {0, NULL}
};

static const value_string ff_mimo_cntrl_codebook_info_flags[] = {
  {0x00, "1 bit for 'Capital Psi', 3 bits for 'Small Psi'"},
  {0x01, "2 bit for 'Capital Psi', 4 bits for 'Small Psi'"},
  {0x02, "3 bit for 'Capital Psi', 5 bits for 'Small Psi'"},
  {0x03, "4 bit for 'Capital Psi', 6 bits for 'Small Psi'"},
  {0, NULL}
};

static const value_string ff_ppa_action_codes[] = {
  {PPA_DSE_ENABLEMENT,                  "Protected DSE enablement"},
  {PPA_DSE_DEENABLEMENT,                "Protected DSE deenablement"},
  {PPA_EXT_CHANNEL_SWITCH_ANNOUNCEMENT, "Protected Extended Channel Switch Announcement"},
  {PPA_DSE_MEASUREMENT_REQUEST,         "Protected DSE measurement request"},
  {PPA_DSE_MEASUREMENT_REPORT,          "Protected DSE measurement report"},
  {PPA_DSE_POWER_CONSTRAINT,            "Protected DSE power constraint"},
  {PPA_VENDOR_SPECIFIC,                 "Protected Vendor Specific"},
  {PPA_GAS_INITIAL_REQUEST,             "Protected GAS Initial Request"},
  {PPA_GAS_INITIAL_RESPONSE,            "Protected GAS Initial Response"},
  {PPA_GAS_COMEBACK_REQUEST,            "Protected GAS Comeback Request"},
  {PPA_GAS_COMEBACK_RESPONSE,           "Protected GAS Comeback Response"},
  {PPA_QAB_REQUEST,                     "Protected QAB Request"},
  {PPA_QAB_RESPONSE,                    "Protected QAB Response"},
  {0x00, NULL}
};
static value_string_ext ff_ppa_action_codes_ext = VALUE_STRING_EXT_INIT(ff_ppa_action_codes);

static const value_string ff_pa_action_codes[] = {
  {PA_20_40_BSS_COEXISTENCE_MANAGEMENT, "20/40 BSS Coexistence Management"},
  {PA_DSE_ENABLEMENT,                  "DSE enablement"},
  {PA_DSE_DEENABLEMENT,                "DSE deenablement"},
  {PA_DSE_REG_LOC_ANNOUNCEMENT,        "DSE Registered Location Announcement"},
  {PA_EXT_CHANNEL_SWITCH_ANNOUNCEMENT, "Extended Channel Switch Announcement"},
  {PA_DSE_MEASUREMENT_REQUEST,         "DSE measurement request"},
  {PA_DSE_MEASUREMENT_REPORT,          "DSE measurement report"},
  {PA_MEASUREMENT_PILOT,               "Measurement Pilot"},
  {PA_DSE_POWER_CONSTRAINT,            "DSE power constraint"},
  {PA_VENDOR_SPECIFIC,                 "Vendor Specific"},
  {PA_GAS_INITIAL_REQUEST,             "GAS Initial Request"},
  {PA_GAS_INITIAL_RESPONSE,            "GAS Initial Response"},
  {PA_GAS_COMEBACK_REQUEST,            "GAS Comeback Request"},
  {PA_GAS_COMEBACK_RESPONSE,           "GAS Comeback Response"},
  {PA_TDLS_DISCOVERY_RESPONSE,         "TDLS Discovery Response"},
  {PA_LOCATION_TRACK_NOTIFICATION,     "Location Track Notification"},
  {PA_QAB_REQUEST,                     "QAB Request"},
  {PA_QAB_RESPONSE,                    "QAB Response"},
  {PA_QMF_POLICY,                      "QMF Policy"},
  {PA_QMF_POLICY_CHANGE,               "QMF Policy Change"},
  {PA_QLOAD_REQUEST,                   "QLoad Request"},
  {PA_QLOAD_REPORT,                    "QLoad Report"},
  {PA_HCCA_TXOP_ADVERTISEMENT,         "HCCA TXOP Advertisement"},
  {PA_HCCA_TXOP_RESPONSE,              "HCCA TXOP Response"},
  {PA_PUBLIC_KEY,                      "Public Key"},
  {PA_CHANNEL_AVAILABILITY_QUERY,      "Channel Availability Query"},
  {PA_CHANNEL_SCHEDULE_MANAGEMENT,     "Channel Schedule Management"},
  {PA_CONTACT_VERIFICATION_SIGNAL,     "Contact Verification Signal"},
  {PA_GDD_ENABLEMENT_REQUEST,          "GDD Enablement Request"},
  {PA_GDD_ENABLEMENT_RESPONSE,         "GDD Enablement Response"},
  {PA_NETWORK_CHANNEL_CONTROL,         "Network Channel Control"},
  {PA_WHITE_SPACE_MAP_ANNOUNCEMENT,    "White Space Map Announcement"},
  {PA_FTM_REQUEST,                     "FTM Request"},
  {PA_FTM,                             "FTM"},
  {PA_FILS_DISCOVERY,                  "FILS Discovery"},
  {PA_LOCATION_MEASUREMENT_REPORT,                                      "Location Measurement Report"},
  {PA_ISTA_PASSIVE_TB_RANGING_MEASUREMENT_REPORT,                       "ISTA Passive TB Ranging Measurement Report"},
  {PA_PRIMARY_RSTA_BROADCAST_PASSIVE_TB_RANGING_MEASUREMENT_REPORT,     "Primary RSTA Broadcast Passive TB Ranging Measurement Report"},
  {PA_SECONDARY_RSTA_BROADCAST_PASSIVE_TB_RANGING_MEASUREMENT_REPORT,   "Secondary RSTA Broadcast Passive TB Ranging Measurement Report"},
  {0x00, NULL}
};
value_string_ext ff_pa_action_codes_ext = VALUE_STRING_EXT_INIT(ff_pa_action_codes);

static const value_string protected_ftm_action_vals[] = {
  {0, "Reserved"},
  {1, "Protected FTM Request"},
  {2, "Protected FTM"},
  {3, "Protected Location Measurement Report"},
  {0, NULL}
};

static const value_string ftm_trigger_vals[] = {
  {0, "Stop sending FTM frames"},
  {1, "Start or continue sending FTM frames"},
  /* all other values reserved */
  {0, NULL}
};

static const value_string category_codes[] = {
  {CAT_SPECTRUM_MGMT,                    "Spectrum Management (SM)"},
  {CAT_QOS,                              "Quality of Service (QoS)"},
  {CAT_DLS,                              "Direct-Link Setup (DLS)"},
  {CAT_BLOCK_ACK,                        "Block Ack"},
  {CAT_PUBLIC,                           "Public Action"},
  {CAT_RADIO_MEASUREMENT,                "Radio Measurement"},
  {CAT_FAST_BSS_TRANSITION,              "Fast BSS Transition"},
  {CAT_HT,                               "High Throughput"},
  {CAT_SA_QUERY,                         "SA Query"},
  {CAT_PUBLIC_PROTECTED,                 "Protected Dual of Public Action"},
  {CAT_WNM,                              "WNM"},
  {CAT_UNPROTECTED_WNM,                  "Unprotected WNM"},
  {CAT_TDLS,                             "TDLS"},
  {CAT_MESH,                             "MESH"},
  {CAT_MULTIHOP,                         "Multihop"},
  {CAT_SELF_PROTECTED,                   "Self-protected"},
  {CAT_DMG,                              "DMG"},
  {CAT_MGMT_NOTIFICATION,                "Management Notification"},
  {CAT_FAST_SESSION_TRANSFER,            "Fast Session Transfer"},
  {CAT_ROBUST_AV_STREAMING,              "Robust AV Streaming"},
  {CAT_UNPROTECTED_DMG,                  "Unprotected DMG"},
  {CAT_VHT,                              "VHT"},
  {CAT_S1G,                              "S1G"},
  {CAT_PROTECTED_S1G,                    "Protected S1G"},
  {CAT_FLOW_CONTROL,                     "Flow Control"},
  {CAT_CONTROL_RESPONSE_MCS_NEG,         "Control Response MCS Negotiation"},
  {CAT_FILS,                             "FILS"},
  {CAT_HE,                               "HE"},
  {CAT_PROTECTED_HE,                     "Protected HE"},
  {CAT_PROTECTED_FTM,                    "Protected FTM"},
  {CAT_EHT,                              "EHT"},
  {CAT_PROTECTED_EHT,                    "Protected EHT"},
  {CAT_VENDOR_SPECIFIC_PROTECTED,        "Vendor-specific Protected"},
  {CAT_VENDOR_SPECIFIC,                  "Vendor Specific"},

  {0x80 | CAT_SPECTRUM_MGMT,             "Spectrum Management (SM) (error)"},
  {0x80 | CAT_QOS,                       "Quality of Service (QoS (error))"},
  {0x80 | CAT_DLS,                       "Direct-Link Setup (DLS) (error)"},
  {0x80 | CAT_BLOCK_ACK,                 "Block Ack (error)"},
  {0x80 | CAT_PUBLIC,                    "Public Action (error)"},
  {0x80 | CAT_RADIO_MEASUREMENT,         "Radio Measurement (error)"},
  {0x80 | CAT_FAST_BSS_TRANSITION,       "Fast BSS Transition (error)"},
  {0x80 | CAT_HT,                        "High Throughput (error)"},
  {0x80 | CAT_SA_QUERY,                  "SA Query (error)"},
  {0x80 | CAT_PUBLIC_PROTECTED,          "Protected Dual of Public Action (error)"},
  {0x80 | CAT_WNM,                       "WNM (error)"},
  {0x80 | CAT_UNPROTECTED_WNM,           "Unprotected WNM (error)"},
  {0x80 | CAT_TDLS,                      "TDLS (error)"},
  {0x80 | CAT_MESH,                      "Mesh (error)"},
  {0x80 | CAT_MULTIHOP,                  "Multihop (error)"},
  {0x80 | CAT_SELF_PROTECTED,            "Self-protected (error)"},
  {0x80 | CAT_DMG,                       "DMG (error)"},
  {0x80 | CAT_MGMT_NOTIFICATION,         "Management Notification (error)"},
  {0x80 | CAT_FAST_SESSION_TRANSFER,     "Fast Session Transfer (error)"},
  {0x80 | CAT_ROBUST_AV_STREAMING,       "Robust AV Streaming (error)"},
  {0x80 | CAT_UNPROTECTED_DMG,           "Unprotected DMG (error)"},
  {0x80 | CAT_VHT,                       "VHT (error)"},
  {0x80 | CAT_HE,                        "HE (error)"},
  {0x80 | CAT_PROTECTED_HE,              "Protected HE (error)"},
  {0x80 | CAT_PROTECTED_FTM,             "Protected FTM (error)"},
  {0x80 | CAT_EHT,                       "EHT (error)"},
  {0x80 | CAT_PROTECTED_EHT,             "Protected EHT (error)"},
  {0x80 | CAT_VENDOR_SPECIFIC_PROTECTED, "Vendor-specific Protected (error)"},
  {0x80 | CAT_VENDOR_SPECIFIC,           "Vendor Specific (error)"},
  {0, NULL}
};
static value_string_ext category_codes_ext = VALUE_STRING_EXT_INIT(category_codes);

#define NR_SUB_ID_TSF_INFO                 1
#define NR_SUB_ID_CON_COU_STR              2
#define NR_SUB_ID_BSS_TRN_CAN_PREF         3
#define NR_SUB_ID_BSS_TER_DUR              4
#define NR_SUB_ID_BEARING                  5
#define NR_SUB_ID_WIDE_BW_CHANNEL          6

#define NR_SUB_ID_MEASUREMENT_REPORT       39
#define NR_SUB_ID_HT_CAPABILITIES          45
#define NR_SUB_ID_HT_OPERATION             61
#define NR_SUB_ID_SEC_CHANNEL_OFFSET       62
#define NR_SUB_ID_MEASUREMENT_PILOT_INFO   66
#define NR_SUB_ID_RM_ENABLE_CAP            70
#define NR_SUB_ID_HT_MULTIPLE_BSSID        71
#define NR_SUB_ID_VHT_CAPABILITIES         191
#define NR_SUB_ID_VHT_OPERATION            192
#define NR_SUB_ID_HE_CAPABILITIES          193
#define NR_SUB_ID_HE_OPERATION             194
#define NR_SUB_ID_EHT_CAPABILITIES         199
#define NR_SUB_ID_EHT_OPERATION            200
#define NR_SUB_ID_BASIC_MULTI_LINK         201

#define NR_SUB_ID_VENDOR_SPECIFIC          221

static const value_string ieee80211_neighbor_report_subelement_id_vals[] = {
  {NR_SUB_ID_TSF_INFO, "TSF Information"},
  {NR_SUB_ID_CON_COU_STR, "Condensed Country String"},
  {NR_SUB_ID_BSS_TRN_CAN_PREF, "BSS Transition Candidate Preference"},
  {NR_SUB_ID_BSS_TER_DUR, "BSS Termination Duration"},
  {NR_SUB_ID_BEARING, "Bearing"},
  {NR_SUB_ID_WIDE_BW_CHANNEL, "Wide Bandwidth Channel"},
  {NR_SUB_ID_MEASUREMENT_REPORT, "Measurement Report"},
  {NR_SUB_ID_HT_CAPABILITIES, "HT Capabilities"},
  {NR_SUB_ID_HT_OPERATION, "HT Operation"},
  {NR_SUB_ID_SEC_CHANNEL_OFFSET, "Secondary Channel Offset"},
  {NR_SUB_ID_MEASUREMENT_PILOT_INFO, "Measurement Pilot Transmission"},
  {NR_SUB_ID_RM_ENABLE_CAP, "RM Enabled Capabilities"},
  {NR_SUB_ID_HT_MULTIPLE_BSSID, "Multiple BSSID"},
  {NR_SUB_ID_VHT_CAPABILITIES, "VHT Capabilities"},
  {NR_SUB_ID_VHT_OPERATION, "VHT Operation"},
  {NR_SUB_ID_HE_CAPABILITIES, "HE Capabilities"},
  {NR_SUB_ID_HE_OPERATION, "HE Operation"},
  {NR_SUB_ID_EHT_CAPABILITIES, "EHT Capabilities"},
  {NR_SUB_ID_EHT_OPERATION, "EHT Operation"},
  {NR_SUB_ID_BASIC_MULTI_LINK, "Basic Multi-Link"},
  {NR_SUB_ID_VENDOR_SPECIFIC, "Vendor Specific"},
  {0, NULL}
};

static const value_string ieee80211_neighbor_report_bssid_info_reachability_vals[] = {
  {0, "Reserved"},
  {1, "Not Reachable"},
  {2, "Unknown"},
  {3, "Reachable"},
  {0, NULL}
};

static const value_string action_codes[] = {
  {SM_ACTION_MEASUREMENT_REQUEST, "Measurement Request"},
  {SM_ACTION_MEASUREMENT_REPORT,  "Measurement Report"},
  {SM_ACTION_TPC_REQUEST,         "TPC Request"},
  {SM_ACTION_TPC_REPORT,          "TPC Report"},
  {SM_ACTION_CHAN_SWITCH_ANNC,    "Channel Switch Announcement"},
  {0, NULL}
};

static const value_string vendor_action_types_mrvl[] = {
  {MRVL_ACTION_MESH_MANAGEMENT, "Mesh Management"},
  {0, NULL}
};

static const value_string mesh_mgt_action_codes_mrvl[] = {
  {MRVL_MESH_MGMT_ACTION_RREQ, "Route Request"},
  {MRVL_MESH_MGMT_ACTION_RREP, "Route Response"},
  {MRVL_MESH_MGMT_ACTION_RERR, "Route Error"},
  {MRVL_MESH_MGMT_ACTION_PLDM, "Peer Link Down"},
  {0, NULL}
};

static const value_string mesh_path_selection_codes[] = {
  {0x0, "Hybrid Wireless Mesh Protocol"},
  {0, NULL}
};

static const value_string mesh_metric_codes[] = {
  {0x0, "Airtime Link Metric"},
  {0, NULL}
};

static const value_string wme_action_codes[] = {
  {0x00, "Setup request"},
  {0x01, "Setup response"},
  {0x02, "Teardown"},
  {0x00, NULL}
};

static const value_string wme_status_codes[] = {
  {0x00, "Admission accepted"},
  {0x01, "Invalid parameters"},
  {0x03, "Refused"},
  {0x00, NULL}
};

static const value_string mesh_action[] = {
  {MESH_ACTION_LINK_METRIC_REPORT, "Mesh Link Metric Report"},
  {MESH_ACTION_HWMP,               "HWMP Mesh Path Selection"},
  {MESH_ACTION_GATE_ANNOUNCE,      "Gate Announcement"},
  {MESH_ACTION_CONGESTION_CTL,     "Congestion Control Notification"},
  {MESH_ACTION_MCCA_SETUP_REQUEST, "MCCA Setup Request"},
  {MESH_ACTION_MCCA_SETUP_REPLY,   "MCCA Setup Reply"},
  {MESH_ACTION_MCCA_ADV_REQUEST,   "MCCA Advertisement Request"},
  {MESH_ACTION_MCCA_ADV,           "MCCA Advertisement"},
  {MESH_ACTION_MCCA_TEARDOWN,      "MCCA Teardown"},
  {MESH_ACTION_TBTT_ADJ_REQUEST,   "TBTT Adjustment Request"},
  {MESH_ACTION_TBTT_ADJ_RESPONSE,  "TBTT Adjustment Response"},
  {0, NULL}
};
static value_string_ext mesh_action_ext = VALUE_STRING_EXT_INIT(mesh_action);

static const value_string multihop_action[] = {
  {MULTIHOP_ACTION_PROXY_UPDATE,      "Proxy Update"},
  {MULTIHOP_ACTION_PROXY_UPDATE_CONF, "Proxy Update Confirmation"},
  {0, NULL}
};

static const value_string selfprot_action[] = {
  {SELFPROT_ACTION_MESH_PEERING_OPEN,     "Mesh Peering Open"},
  {SELFPROT_ACTION_MESH_PEERING_CONFIRM,  "Mesh Peering Confirm"},
  {SELFPROT_ACTION_MESH_PEERING_CLOSE,    "Mesh Peering Close"},
  {SELFPROT_ACTION_MESH_GROUP_KEY_INFORM, "Mesh Group Key Inform"},
  {SELFPROT_ACTION_MESH_GROUP_KEY_ACK,    "Mesh Group Key Ack"},
  {0, NULL}
};

static const value_string mesh_peering_proto_ids[] = {
  {MESH_PEERING_PROTO_MGMT,   "Mesh peering management protocol"},
  {MESH_PEERING_PROTO_AMPE,   "Authenticated mesh peering exchange protocol"},
  {MESH_PEERING_PROTO_VENDOR, "Vendor specific"},
  {0, NULL}
};

static const true_false_string hwmp_targ_usn_flags = {
  "[USN = 1] Target Sequence Number Unknown at Originator",
  "[USN = 0] Target Sequence Number Known at Originator"
};

static const true_false_string hwmp_targ_to_flags = {
  "[TO = 1] Only Target Will Respond",
  "[TO = 0] Intermediate Nodes May Respond"
};

static const value_string ack_policy[] = {
  {0x00, "Normal Ack"},
  {0x01, "No Ack"},
  {0x02, "No explicit acknowledgment"},
  {0x03, "Block Ack"},
  {0x00, NULL}
};

static const value_string qos_action_codes[] = {
  {QOS_ACTION_ADDTS_REQUEST,  "ADDTS Request"},
  {QOS_ACTION_ADDTS_RESPONSE, "ADDTS Response"},
  {QOS_ACTION_DELTS,          "DELTS"},
  {QOS_ACTION_SCHEDULE,   "Schedule"},
  {QOS_ACTION_MAP_CONFIGURE, "QoS Map Configure"},
  {0, NULL}
};

static const value_string ba_action_codes[] = {
  {BA_ADD_BLOCK_ACK_REQUEST,      "Add Block Ack Request"},
  {BA_ADD_BLOCK_ACK_RESPONSE,     "Add Block Ack Response"},
  {BA_DELETE_BLOCK_ACK,           "Delete Block Ack"},
  {BA_NDP_ADD_BLOCK_ACK_REQUEST,  "NDP ADDBA Request"},
  {BA_NDP_ADD_BLOCK_ACK_RESPONSE, "NDP ADDBA Response"},
  {BA_NDP_DELETE_BLOCK_ACK,       "NDP DELBA"},
  {BA_BAT_ADD_BLOCK_ACK_REQUEST,  "BAT ADDBA Request"},
  {BA_BAT_ADD_BLOCK_ACK_RESPONSE, "BAT ADDBA Request"},
  {BA_BAT_DELETE_BLOCK_ACK,       "BAT DELBA"},
  {0x00, NULL}
};

static const value_string dls_action_codes[] = {
  {DLS_ACTION_REQUEST,  "DLS Request"},
  {DLS_ACTION_RESPONSE, "DLS Response"},
  {DLS_ACTION_TEARDOWN, "DLS Teardown"},
  {0, NULL}
};

static const value_string tsinfo_type[] = {
  {0x0, "Aperiodic or unspecified Traffic"},
  {0x1, "Periodic Traffic"},
  {0, NULL}
};

static const value_string tsinfo_direction[] = {
  {0x00, "Uplink"},
  {0x01, "Downlink"},
  {0x02, "Direct link"},
  {0x03, "Bidirectional link"},
  {0, NULL}
};

static const value_string tsinfo_access[] = {
  {0x00, "Reserved"},
  {0x01, "EDCA"},
  {0x02, "HCCA"},
  {0x03, "HEMM"},
  {0, NULL}
};

static const value_string qos_up[] = {
  {0x00, "Best Effort"},
  {0x01, "Background"},
  {0x02, "Spare"},
  {0x03, "Excellent Effort"},
  {0x04, "Controlled Load"},
  {0x05, "Video"},
  {0x06, "Voice"},
  {0x07, "Network Control"},
  {0, NULL}
};

static const range_string classifier_type[] = {
  {0x00, 0x00, "Ethernet parameters"},
  {0x01, 0x01, "TCP/UDP IP parameters"},
  {0x02, 0x02, "IEEE 802.1D/Q parameters"},
  {0x03, 0x03, "Filter Offset parameters"},
  {0x04, 0x04, "IP and higher layer parameters"},
  {0x05, 0x05, "IEEE 802.1D/Q parameters"},
  {0x06, 0x06, "IEEE 802.11 MAC header parameters"},
  {0x07, 0x07, "IEEE Std 802.11 downlink PV1 MPDU MAC header parameters"},
  {0x08, 0x08, "IEEE Std 802.11 non-downlink PV1 MPDU MAC header parameters"},
  {0x09, 0x09, "IEEE Std 802.11 PV1 MPDU Full Address MAC header parameters"},
  {0x0A, 0x0A, "IP extensions and higher layer parameters"},
  {0x0B, 0xFF, "Reserved" },
  {0, 0, NULL}
};

static const true_false_string ieee80211_block_ack_control_ack_policy_flag = {
    "Sender Does Not Require Immediate Acknowledgement",
    "Immediate Acknowledgement Required"
};

static const value_string ft_action_codes[] = {
  {FT_ACTION_REQUEST, "FT Request"},
  {FT_ACTION_RESPONSE, "FT Response"},
  {FT_ACTION_CONFIRM, "FT Confirm"},
  {FT_ACTION_ACK, "FT Ack"},
  {0, NULL}
};

static const value_string sa_query_action_codes[] = {
  {SA_QUERY_REQUEST, "SA Query Request"},
  {SA_QUERY_RESPONSE, "SA Query Response"},
  {0, NULL}
};

static const value_string ieee80211_data_encap_payload_types[] = {
  {1, "Remote Request/Response"},
  {2, "TDLS"},
  {0, NULL}
};

static const true_false_string rsn_preauth_flags = {
  "Transmitter supports pre-authentication",
  "Transmitter does not support pre-authentication"
};

static const true_false_string rsn_no_pairwise_flags = {
  "Transmitter cannot support WEP default key 0 simultaneously with "
  "Pairwise key",
  "Transmitter can support WEP default key 0 simultaneously with "
  "Pairwise key"
};

static const value_string rsn_cap_replay_counter[] = {
  {0x00, "1 replay counter per PTKSA/GTKSA/STAKeySA"},
  {0x01, "2 replay counters per PTKSA/GTKSA/STAKeySA"},
  {0x02, "4 replay counters per PTKSA/GTKSA/STAKeySA"},
  {0x03, "16 replay counters per PTKSA/GTKSA/STAKeySA"},
  {0, NULL}
};

static const true_false_string ht_ldpc_coding_flag = {
  "Transmitter supports receiving LDPC coded packets",
  "Transmitter does not support receiving LDPC coded packets"
};

static const true_false_string ht_chan_width_flag = {
  "Transmitter supports 20MHz and 40MHz operation",
  "Transmitter only supports 20MHz operation"
};

static const value_string ht_sm_pwsave_flag[] = {
  {0x00, "Static SM Power Save mode"},
  {0x01, "Dynamic SM Power Save mode"},
  {0x02, "Reserved"},
  {0x03, "SM Power Save disabled"},
  {0x00, NULL}
};

static const true_false_string ht_green_flag = {
  "Transmitter is able to receive PPDUs with Green Field (GF) preamble",
  "Transmitter is not able to receive PPDUs with Green Field (GF) preamble"
};

static const value_string ht_rx_stbc_flag[] = {
  {0x00, "No Rx STBC support"},
  {0x01, "Rx support of one spatial stream"},
  {0x02, "Rx support of one and two spatial streams"},
  {0x03, "Rx support of one, two, and three spatial streams"},
  {0x00, NULL}
};

  /* IEEE Stc 802.11ac-2013 8.4.2.29 Extended Capabilities element*/
static const value_string vht_max_mpdu_in_amsdu[] = {
    {0x00, "No limit"},
    {0x01, "32"},
    {0x02, "16"},
    {0x03, "8"},
    {0, NULL}
};

  /* IEEE Stc 802.11ac/D3.1 */

static const value_string vht_max_mpdu_length_flag[] = {
  {0x00, "3 895"},
  {0x01, "7 991"},
  {0x02, "11 454"},
  {0x03, "Reserved"},
  {0x00, NULL}
};

static const value_string vht_supported_chan_width_set_flag[] = {
  {0x00, "Neither 160MHz nor 80+80 supported"},
  {0x01, "160MHz supported"},
  {0x02, "160MHz and 80+80 Supported"},
  {0x03, "Reserved"},
  {0x00, NULL}
};

static const value_string vht_rx_stbc_flag[] = {
  {0x00, "None"},
  {0x01, "1 Spatial Stream Supported"},
  {0x02, "1 to 2 Spatial Stream Supported"},
  {0x03, "1 to 3 Spatial Stream Supported"},
  {0x04, "1 to 4 Spatial Stream Supported"},
  {0x05, "Reserved"},
  {0x06, "Reserved"},
  {0x07, "Reserved"},
  {0x00, NULL}
};

static const value_string num_plus_one_3bit_flag[] = {
  {0x00, "1"},
  {0x01, "2"},
  {0x02, "3"},
  {0x03, "4"},
  {0x04, "5"},
  {0x05, "6"},
  {0x06, "7"},
  {0x07, "8"},
  {0x00, NULL}
};

static const value_string vht_max_ampdu_flag[] = {
  {0x00, "8 191"},
  {0x01, "16 383"},
  {0x02, "32 767"},
  {0x03, "65 535"},
  {0x04, "131 071"},
  {0x05, "262 143"},
  {0x06, "524 287"},
  {0x07, "1 048 575"},
  {0x00, NULL}
};

static const value_string vht_link_adapt_flag[] = {
  {0x00, "No Feedback"},
  {0x01, "Reserved (logically only solicited feedback)"},
  {0x02, "Unsolicited feedback only"},
  {0x03, "Both (can provide unsolicited feedback and respond to VHT MRQ)"},
  {0x00, NULL}
};

static const value_string vht_supported_mcs_flag[] = {
  {0x00, "MCS 0-7"},
  {0x01, "MCS 0-8"},
  {0x02, "MCS 0-9"},
  {0x03, "Not Supported"},
  {0x00, NULL}
};

static const value_string vht_tpe_pwr_units[] = {
  { 0, "Local EIRP" },
  { 1, "Local EIRP PSD" },
  { 2, "Regulatory client EIRP" },
  { 3, "Regulatory client EIRP PSD" },
  { 4, "Reserved" },
  { 5, "Reserved" },
  { 6, "Reserved" },
  { 7, "Reserved" },
  {0x00, NULL}
};

static const true_false_string vht_ndp_annc_sta_info_feedback_type = {
  "MU feedback requested",
  "SU feedback requested"
};

static const true_false_string ht_delayed_block_ack_flag = {
  "Transmitter supports HT-Delayed BlockAck",
  "Transmitter does not support HT-Delayed BlockAck"
};

static const true_false_string ht_max_amsdu_flag = {
  "7935 bytes",
  "3839 bytes"
};

static const true_false_string ht_dss_cck_40_flag = {
  "Will/Can use DSSS/CCK in 40 MHz",
  "Won't/Can't use of DSSS/CCK in 40 MHz"
};

static const true_false_string ht_psmp_flag = {
  "Will/Can support PSMP operation",
  "Won't/Can't support PSMP operation"
};

static const true_false_string ht_40_mhz_intolerant_flag = {
  "Use of 40 MHz transmissions restricted/disallowed",
  "Use of 40 MHz transmissions unrestricted/allowed"
};

static const value_string ampduparam_mpdu_start_spacing_flags[] = {
  {0x00, "no restriction"},
  {0x01, "1/4 [usec]"},
  {0x02, "1/2 [usec]"},
  {0x03, "1 [usec]"},
  {0x04, "2 [usec]"},
  {0x05, "4 [usec]"},
  {0x06, "8 [usec]"},
  {0x07, "16 [usec]"},
  {0x00, NULL}
};

static const true_false_string mcsset_tx_rx_mcs_set_not_equal_flag = {
  "Not Equal",
  "Equal",
};

static const value_string mcsset_tx_max_spatial_streams_flags[] = {
  {0x00, "1 spatial stream"},
  {0x01, "2 spatial streams"},
  {0x02, "3 spatial streams"},
  {0x03, "4 spatial streams"},
  {0x04, "TX MCS Set Not Defined"},
  {0x00, NULL}
};

static const value_string htex_transtime_flags[] = {
  {0x00, "No Transition"},
  {0x01, "400 usec"},
  {0x02, "1.5 msec"},
  {0x03, "5 msec"},
  {0x00, NULL}
};

static const value_string htex_mcs_flags[] = {
  {0x00, "STA does not provide MCS feedback"},
  {0x01, "Reserved"},
  {0x02, "STA provides only unsolicited MCS feedback"},
  {0x03, "STA can provide MCS feedback in response to MRQ as well as unsolicited MCS feedback"},
  {0x00, NULL}
};

static const value_string txbf_calib_flag[] = {
  {0x00, "incapable"},
  {0x01, "Limited involvement, cannot initiate"},
  {0x02, "Limited involvement, can initiate"},
  {0x03, "Fully capable"},
  {0x00, NULL}
};

static const value_string txbf_feedback_flags[] = {
  {0x00, "not supported"},
  {0x01, "delayed feedback capable"},
  {0x02, "immediate feedback capable"},
  {0x03, "delayed and immediate feedback capable"},
  {0x00, NULL}
};

static const value_string txbf_antenna_flags[] = {
  {0x00, "1 TX antenna sounding"},
  {0x01, "2 TX antenna sounding"},
  {0x02, "3 TX antenna sounding"},
  {0x03, "4 TX antenna sounding"},
  {0x00, NULL}
};

static const value_string txbf_csi_max_rows_bf_flags[] = {
  {0x00, "1 row of CSI"},
  {0x01, "2 rows of CSI"},
  {0x02, "3 rows of CSI"},
  {0x03, "4 rows of CSI"},
  {0x00, NULL}
};

static const value_string txbf_chan_est_flags[] = {
  {0x00, "1 space time stream"},
  {0x01, "2 space time streams"},
  {0x02, "3 space time streams"},
  {0x03, "4 space time streams"},
  {0x00, NULL}
};

static const value_string txbf_min_group_flags[] = {
  {0x00, "No grouping supported"},
  {0x01, "Groups of 1, 2 supported"},
  {0x02, "Groups of 1, 4 supported"},
  {0x03, "Groups of 1, 2, 4 supported"},
  {0x00, NULL}
};

static const value_string hta_ext_chan_offset_flag[] = {
  {0x00, "No Extension Channel"},
  {0x01, "Extension Channel above control channel"},
  {0x02, "Undefined"},
  {0x03, "Extension Channel below control channel"},
  {0x00, NULL}
};

static const true_false_string hta_rec_tx_width_flag = {
  "Any channel width enabled",
  "Use 20MHz channel (control)"
};

static const true_false_string hta_rifs_mode_flag = {
  "Use of RIFS permitted",
  "Use of RIFS prohibited"
};

static const true_false_string hta_controlled_access_flag = {
  "Not only PSMP",
  "PSMP only"
};

static const value_string hta_service_interval_flag[] = {
  {0x00, "5ms"},
  {0x01, "10ms"},
  {0x02, "15ms"},
  {0x03, "20ms"},
  {0x04, "25ms"},
  {0x05, "30ms"},
  {0x06, "35ms"},
  {0x07, "40ms"},
  {0x00, NULL}
};

static const value_string hta_operating_mode_flag[] = {
  {0x00, "Pure HT, no protection"},
  {0x01, "There may be non-HT devices (control & ext channel)"},
  {0x02, "No non-HT is associated, but at least 1 20MHz is. protect on"},
  {0x03, "Mixed: no non-HT is associated, protect on"},
  {0x00, NULL}
};

static const true_false_string hta_non_gf_devices_flag = {
  "All HT devices associated are GF capable",
  "One or More HT devices are not GF capable"
};

static const true_false_string hta_dual_stbc_protection_flag = {
  "Dual CTS protections is used",
  "Regular use of RTS/CTS"
};

static const true_false_string hta_secondary_beacon_flag = {
  "Secondary Beacon",
  "Primary Beacon"
};

static const true_false_string hta_lsig_txop_protection_flag = {
  "Full Support",
  "Not full support"
};

static const true_false_string hta_pco_active_flag = {
  "PCO is activated in the BSS",
  "PCO is not activated in the BSS"
};

static const true_false_string hta_pco_phase_flag = {
  "Switch to 20MHz phase/keep 20MHz",
  "Switch to 40MHz phase/keep 40MHz"
};

static const value_string ht_info_secondary_channel_offset_flags[] = {
  {0x00, "No secondary channel"},
  {0x01, "Secondary channel is above the primary channel"},
  {0x02, "Reserved"},
  {0x03, "Secondary channel is below the primary channel"},
  {0x00, NULL}
};

static const true_false_string ht_info_channel_sta_width_flag = {
  "Channel of any width supported",
  "20 MHz channel width only"
};

static const true_false_string ht_info_rifs_mode_flag = {
  "Permitted",
  "Prohibited"
};

static const value_string ht_info_operating_protection_mode_flags[] = {
  {0x00, "No protection mode"},
  {0x01, "HT non-member protection mode"},
  {0x02, "20 MHz protection mode"},
  {0x03, "non-HT mixed mode"},
  {0x00, NULL}
};

static const true_false_string ht_info_non_greenfield_sta_present_flag = {
  "One or more associated STAs are not greenfield capable",
  "All associated STAs are greenfield capable"
};

static const true_false_string ht_info_obss_non_ht_stas_present_flag = {
  "Use of protection for non-HT STAs by overlapping BSSs is needed",
  "Use of protection for non-HT STAs by overlapping BSSs is not needed"
};

static const true_false_string ht_info_dual_beacon_flag = {
  "AP transmits a secondary beacon",
  "No second beacon is transmitted"
};

static const true_false_string ht_info_secondary_beacon_flag = {
  "STBC beacon",
  "Primary beacon"
};

static const true_false_string ht_info_lsig_txop_protection_full_support_flag = {
  "All HT STAs in the BSS support L-SIG TXOP protection",
  "One or more HT STAs in the BSS do not support L-SIG TXOP protection"
};

static const true_false_string ht_info_pco_phase_flag = {
  "Switch to or continue 40 MHz phase",
  "Switch to or continue 20 MHz phase"
};

static const true_false_string htc_lac_trq_flag = {
  "Want sounding PPDU",
  "Don't want sounding PPDU"
};

static const true_false_string htc_lac_mai_mrq_flag = {
  "MCS feedback requested",
  "No MCS feedback requested"
};

static const value_string ieee80211_htc_lac_asel_command_flags[] = {
  {0x00, "Transmit Antenna Selection Sounding Indication (TXASSI)"},
  {0x01, "Transmit Antenna Selection Sounding Request (TXASSR)"},
  {0x02, "Receive Antenna Selection Sounding Indication (RXASSI)"},
  {0x03, "Receive Antenna Selection Sounding Request (RXASSR)"},
  {0x04, "Sounding Label"},
  {0x05, "No feedback, ASEL training failure"},
  {0x06, "Transmit Antenna Selection Sounding Indication (TXASSI) requesting feedback of explicit CSI"},
  {0x07, "Reserved"},
  {0x00, NULL}
};

static const value_string ieee80211_htc_cal_pos_flags[] = {
  {0x00, "Not a calibration frame"},
  {0x01, "Calibration Start"},
  {0x02, "Sounding Response"},
  {0x03, "Sounding Complete"},
  {0x00, NULL}
};

static const value_string ieee80211_htc_csi_steering_flags[] = {
  {0x00, "No feedback required"},
  {0x01, "CSI"},
  {0x02, "Non-compressed Beamforming Feedback Matrix"},
  {0x03, "Compressed Beamforming Feedback Matrix"},
  {0x00, NULL}
};

static const true_false_string ieee80211_htc_ndp_announcement_flag = {
  "NDP will follow",
  "No NDP will follow"
};

static const value_string ieee80211_htc_bw_recommended_vht_mcs_vals[] = {
  {0, "20 MHz"},
  {1, "40 MHz"},
  {2, "80 MHz"},
  {3, "160 MHz and 80+80 MHz"},
  {0, NULL}
};

static const value_string ieee80211_htc_coding_type_vals[] = {
  {0, "BCC"},
  {1, "LDPC"},
  {0, NULL}
};

static const value_string ieee80211_htc_fb_tx_type_vals[] = {
  {0, "Not beamformed"},
  {1, "Beamformed"},
  {0, NULL}
};

static const value_string ieee80211_tag_secondary_channel_offset_flags[] = {
  {0x00, "No Secondary Channel"},
  {0x01, "Above Primary Channel"},
  {0x02, "Reserved"},
  {0x03, "Below Primary Channel"},
  {0x00, NULL}
};

#define BSS_BITMASK_UP0   0x0001
#define BSS_BITMASK_UP1   0x0002
#define BSS_BITMASK_UP2   0x0004
#define BSS_BITMASK_UP3   0x0008
#define BSS_BITMASK_UP4   0x0010
#define BSS_BITMASK_UP5   0x0020
#define BSS_BITMASK_UP6   0x0040
#define BSS_BITMASK_UP7   0x0080
#define BSS_BITMASK_AC0   0x0100
#define BSS_BITMASK_AC1   0x0200
#define BSS_BITMASK_AC2   0x0400
#define BSS_BITMASK_AC3   0x0800
#define BSS_BITMASK_RSV   0xF000

static const value_string ieee80211_tag_ext_channel_switch_announcement_switch_mode_flags[] = {
  {0x00, "Frames may be transmitted before the channel switch has been completed"},
  {0x01, "No more frames are to be transmitted until the channel switch has been completed"},
  {0x00, NULL}
};

static const value_string service_interval_granularity_vals[] = {
  { 0, "5 ms" },
  { 1, "10 ms" },
  { 2, "15 ms" },
  { 3, "20 ms" },
  { 4, "25 ms" },
  { 5, "30 ms" },
  { 6, "35 ms" },
  { 7, "40 ms" },
  { 0x00, NULL }
};

static const value_string wep_type_vals[] = {
  { DOT11DECRYPT_KEY_TYPE_WEP, STRING_KEY_TYPE_WEP },
  { DOT11DECRYPT_KEY_TYPE_WPA_PWD, STRING_KEY_TYPE_WPA_PWD },
  { DOT11DECRYPT_KEY_TYPE_WPA_PSK, STRING_KEY_TYPE_WPA_PSK },
  { DOT11DECRYPT_KEY_TYPE_TK, STRING_KEY_TYPE_TK },
  { DOT11DECRYPT_KEY_TYPE_MSK, STRING_KEY_TYPE_MSK },
  { 0x00, NULL }
};

static const value_string ieee80211_ht_pren_type_vals[] = {
  { 51,  "HT Capabilities (802.11n D1.10)" },
  { 52,  "HT Additional Capabilities (802.11n D1.00)" },
  { 0, NULL }
};

static const true_false_string ieee80211_cf_ssw_direction = {
  "Transmitted by the beamforming responder",
  "Transmitted by the beamforming initiator"
};

static const value_string bss_type[] = {
  {0x0, "Reserved"},
  {0x1, "IBSS"},
  {0x2, "PBSS"},
  {0x3, "Infrastructure BSS"},
  {0,   NULL}
};

static const value_string band_id[] = {
  {0x0, "TV white spaces"},
  {0x1, "Sub-1 GHz (excluding TV white spaces)"},
  {0x2, "2.4 GHz"},
  {0x3, "3.6 GHz"},
  {0x4, "4.9 and 5 GHz"},
  {0x5, "60 GHz"},
  {0x6, "45 GHz"},
  {0x7, "6 GHz"},
  {0,   NULL}
};

static const value_string extended_sc_mcs[] = {
  {0x0, "None"},
  {0x1, "MCS 9.1"},
  {0x2, "MCS 12.1"},
  {0x3, "MCS 12.2"},
  {0x4, "MCS 12.3"},
  {0x5, "MCS 12.4"},
  {0x6, "MCS 12.5"},
  {0x7, "MCS 12.6"},
  {0, NULL}
};

static const range_string max_basic_sf_amsdu[] = {
  {0, 0, "No Limit"},
  {1, 1, "4 Basic subframes"},
  {2, 2, "8 Basic subframes"},
  {3, 3, "16 Basic subframes"},
  {4, 4, "32 Basic subframes"},
  {5, 5, "64 Basic subframes"},
  {6, 6, "128 Basic subframes"},
  {7, 7, "256 Basic subframes"},
  {8, 255, "reserved"},
  {0, 0, NULL}
};

static const range_string max_short_sf_amsdu[] = {
  {0, 0, "No Limit"},
  {1, 1, "32 Short subframes"},
  {2, 2, "64 Short subframes"},
  {3, 3, "128 Short subframes"},
  {4, 4, "256 Short subframes"},
  {5, 5, "512 Short subframes"},
  {6, 6, "1024 Short subframes"},
  {7, 255, "reserved"},
  {0, 0, NULL}
};

static const value_string allocation_type[] = {
  {0x0, "SP Allocation"},
  {0x1, "CBAP allocation"},
  {0,   NULL}
};

static const value_string vht_operation_info_channel_width[] = {
  {0x00, "20MHz or 40MHz"},
  {0x01, "80MHZ"},
  {0x10, "160MHz"},
  {0x11, "80MHz+80MHz"},
  {0, NULL}
};
static const value_string operating_mode_field_channel_width[] = {
  {0x00, "20MHz"},
  {0x01, "40MHZ"},
  {0x02, "80MHz"},
  {0x03, "160MHz or 80MHz+80MHz"},
  {0, NULL}
};

static const value_string operat_mode_field_rxnss[] = {
  {0x0, "1Nss"},
  {0x1, "2Nss"},
  {0x2, "3Nss"},
  {0x3, "4Nss"},
  {0x4, "5Nss"},
  {0x5, "6Nss"},
  {0x6, "7Nss"},
  {0x7, "8Nss"},
  {0, NULL}
};

#define VHT_ACT_VHT_COMPRESSED_BEAMFORMING  0
#define VHT_ACT_GROUP_ID_MANAGEMENT         1
#define VHT_ACT_OPERATION_MODE_NOTIFICATION 2

static const value_string vht_action_vals[] = {
  {VHT_ACT_VHT_COMPRESSED_BEAMFORMING, "VHT Compressed Beamforming"},
  {VHT_ACT_GROUP_ID_MANAGEMENT, "Group ID Management"},
  {VHT_ACT_OPERATION_MODE_NOTIFICATION, "Operating Mode Notification"},
  {0,   NULL}
};

static const value_string ff_vht_mimo_cntrl_nc_index_vals[] = {
  {0x00, "1 Column"},
  {0x01, "2 Columns"},
  {0x02, "3 Columns"},
  {0x03, "4 Columns"},
  {0x04, "5 Columns"},
  {0x05, "6 Columns"},
  {0x06, "7 Columns"},
  {0x07, "8 Columns"},
  {0, NULL}
};

static const value_string ff_vht_mimo_cntrl_nr_index_vals[] = {
  {0x00, "1 Row"},
  {0x01, "2 Rows"},
  {0x02, "3 Rows"},
  {0x03, "4 Rows"},
  {0x04, "5 Rows"},
  {0x05, "6 Rows"},
  {0x06, "7 Rows"},
  {0x07, "8 Rows"},
  {0, NULL}
};

static const value_string ff_vht_mimo_cntrl_channel_width_vals[] = {
  {0x00, "20 MHz"},
  {0x01, "40 MHz"},
  {0x02, "80 MHz"},
  {0x03, "160 MHz / 80+80 MHz"},
  {0, NULL}
};

static const value_string ff_vht_mimo_cntrl_grouping_vals[] = {
  {0x00, "1 (No Grouping)"},
  {0x01, "2"},
  {0x02, "4"},
  {0x03, "Reserved"},
  {0, NULL}
};

static const value_string ff_vht_mimo_cntrl_feedback_vals[] = {
  {0x00, "SU"},
  {0x01, "MU"},
  {0, NULL}
};

#define S1G_ACT_AID_SWITCH_REQUEST   0
#define S1G_ACT_AID_SWITCH_RESPONSE  1
#define S1G_ACT_SYNC_CONTROL         2
#define S1G_ACT_STA_INFO_ANNOUNCE    3
#define S1G_ACT_EDCA_PARAM_SET       4
#define S1G_ACT_EL_OPERATION         5
#define S1G_ACT_TWT_SETUP            6
#define S1G_ACT_TWT_TEARDOWN         7
#define S1G_ACT_SECT_GROUP_ID_LIST   8
#define S1G_ACT_SECT_ID_FEEDBACK     9
#define S1G_ACT_RESERVED             10
#define S1G_ACT_TWT_INFORMATION      11

static const value_string s1g_action_vals[] = {
  {S1G_ACT_AID_SWITCH_REQUEST, "AID Switch Request"},
  {S1G_ACT_AID_SWITCH_RESPONSE, "AID Switch Response"},
  {S1G_ACT_SYNC_CONTROL, "Sync Control"},
  {S1G_ACT_STA_INFO_ANNOUNCE, "STA Information Announcement"},
  {S1G_ACT_EDCA_PARAM_SET, "EDCA Parameter Set"},
  {S1G_ACT_EL_OPERATION, "EL Operation"},
  {S1G_ACT_TWT_SETUP, "TWT Setup"},
  {S1G_ACT_TWT_TEARDOWN, "TWT Teardown"},
  {S1G_ACT_SECT_GROUP_ID_LIST, "Sectorized Group ID List"},
  {S1G_ACT_SECT_ID_FEEDBACK, "Sector ID Feedback"},
  {S1G_ACT_RESERVED, "Reserved"},
  {S1G_ACT_TWT_INFORMATION, "TWT Information"},
  {0,   NULL},
};

#define PROT_S1G_ACT_REACH_ADDR_UPDATE    0
#define PROT_S1G_ACT_RELAY_ACTIVATE_REQ   1
#define PROT_S1G_ACT_RELAY_ACTIVATE_RESP  2
#define PROT_S1G_ACT_HEADER_COMPRESSION   3
#define PROT_S1G_ACT_TWT_SETUP            4
#define PROT_S1G_ACT_TWT_TEARDOWN         5
#define PROT_S1G_ACT_TWT_INFORMATION      6
#define PROT_S1G_ACT_AID_SWITCH_REQUEST   7
#define PROT_S1G_ACT_AID_SWITCH_RESPONSE  8
#define PROT_S1G_ACT_SYNC_CONTROL         9
#define PROT_S1G_ACT_STA_INFO_ANNOUNCE    10
#define PROT_S1G_ACT_EDCA_PARAM_SET       11
#define PROT_S1G_ACT_EL_OPERATION         12
#define PROT_S1G_ACT_SECT_GROUP_ID_LIST   13
#define PROT_S1G_ACT_SECT_ID_FEEDBACK     14

static const value_string prot_s1g_action_vals[] = {
  {PROT_S1G_ACT_REACH_ADDR_UPDATE, "Reachable Address Update"},
  {PROT_S1G_ACT_RELAY_ACTIVATE_REQ, "Relay Activation Request"},
  {PROT_S1G_ACT_RELAY_ACTIVATE_RESP, "Relay Activation Response"},
  {PROT_S1G_ACT_HEADER_COMPRESSION, "Header Compression"},
  {PROT_S1G_ACT_TWT_SETUP, "Protected TWT Setup"},
  {PROT_S1G_ACT_TWT_TEARDOWN, "Protected TWT Teardown"},
  {PROT_S1G_ACT_TWT_INFORMATION, "Protected TWT Information"},
  {PROT_S1G_ACT_AID_SWITCH_REQUEST, "Protected AID Switch Request"},
  {PROT_S1G_ACT_AID_SWITCH_RESPONSE, "Protected AID Switch Response"},
  {PROT_S1G_ACT_SYNC_CONTROL, "Protected Sync Control"},
  {PROT_S1G_ACT_STA_INFO_ANNOUNCE, "Protected STA Information Announcement"},
  {PROT_S1G_ACT_EDCA_PARAM_SET, "Protected EDCA Parameter Set"},
  {PROT_S1G_ACT_EL_OPERATION, "Protected EL Operation"},
  {PROT_S1G_ACT_SECT_GROUP_ID_LIST, "Protected Sectorized Group ID List"},
  {PROT_S1G_ACT_SECT_ID_FEEDBACK, "Protected Sector ID Feedback"},
  {0,   NULL},
};

static const value_string twt_neg_type_vals[] = {
  {0x0, "Individual TWT"},
  {0x1, "Wake TBTT"},
  {0x2, "Broadcast TWT"},
  {0x3, "Broadcast TWT"},
  {0,   NULL},
};

static const true_false_string twt_responder_pm_mode_tfs = {
  "AP may doze outside the TWT",
  "AP is always awake",
};

static const true_false_string twt_requester_tfs = {
  "This STA is a TWT Requesting STA",
  "This STA is a TWT Responding STA or a TWT scheduling AP",
};

static const true_false_string twt_info_frame_disabled_tfs = {
  "Reception of TWT Information frames is disabled",
  "Reception of TWT Information frames is enabled",
};

static const true_false_string twt_wake_duration_unit_tfs = {
  "1 TU",
  "256 microseconds",
};

#define REQUEST_TWT   0
#define SUGGEST_TWT   1
#define DEMAND_TWT    2
#define TWT_GROUPING  3
#define ACCEPT_TWT    4
#define ALTERNATE_TWT 5
#define DICTATE_TWT   6
#define REJECT_TWT    7

static const value_string twt_setup_cmd[] = {
  {REQUEST_TWT,   "Request TWT"},
  {SUGGEST_TWT,   "Suggest TWT"},
  {DEMAND_TWT,    "Demand TWT"},
  {TWT_GROUPING,  "TWT Grouping"},
  {ACCEPT_TWT,    "Accept TWT"},
  {ALTERNATE_TWT, "Alternate TWT"},
  {DICTATE_TWT,   "Dictate TWT"},
  {REJECT_TWT,    "Reject TWT"},
  {0,   NULL},
};

static const true_false_string twt_trigger = {
  "TWT SP includes trigger frames",
  "TWT SP does not include trigger frames",
};

static const true_false_string twt_implicit = {
  "TWT is implicit",
  "TWT is explicit",
};

static const true_false_string twt_flow_type = {
  "TWT is unannounced, the TWT responding STA can send frames at any time",
  "TWT is announced, the TWT Requesting STA will send trigger frames",
};

static const value_string he_phy_device_class_vals[] = {
  { 0, "Class B Device" },
  { 1, "Class A Device" },
  { 0, NULL }
};

static const value_string he_phy_midamble_tx_rx_max_nsts_vals[] = {
  { 0, "1 Space-Time Stream" },
  { 1, "2 Space-Time Streams" },
  { 2, "3 Space-Time Streams" },
  { 3, "4 Space-Time Streams" },
  { 0, NULL }
};

static const value_string he_phy_dcm_max_constellation_vals[] = {
  { 0, "DCM is not supported" },
  { 1, "BPSK" },
  { 2, "QPSK" },
  { 3, "16-QAM" },
  { 0, NULL }
};

static const value_string he_phy_dcm_max_nss_vals[] = {
  { 0, "1 Spatial Stream" },
  { 1, "2 Spatial Streams" },
  { 0, NULL }
};

static const value_string he_phy_dcm_max_ru_vals[] = {
  { 0, "242-tone RU" },
  { 1, "484-tone RU" },
  { 2, "996-tone RU" },
  { 3, "2x996-tone RU"},
  { 0, NULL }
};

static const value_string he_phy_nominal_packet_padding_vals[] = {
  { 0, "0 µs for all constellations, Nss and RU allocations" },
  { 1, "8 µs for all constellations, Nss and RU allocations" },
  { 2, "16 µs for all constellations, Nss and RU allocations" },
  { 3, "Reserved" },
  { 0, NULL }
};

// MBO-OCE attributes
#define MBO_AP_CAPABILTY_INDICATION     1
#define MBO_NON_PREF_CHANNEL_REPORT     2
#define MBO_CELLULAR_DATA_CAPABILITIES  3
#define MBO_ASSOCIATION_DISALLOWED      4
#define MBO_CELLULAR_DATA_PREFERENCE    5
#define MBO_TRANSITION_REASON           6
#define MBO_TRANSITION_REJECTION_REASON 7
#define MBO_ASSOCIATION_RETRY_DELAY     8
#define OCE_CAPABILTY_INDICATION        101
#define OCE_RSSI_ASSOCIATION_REJECTION  102
#define OCE_REDUCED_WAN_METRICS         103
#define OCE_RNR_COMPLETENESS            104
#define OCE_PROBE_SUPPR_BSSID           105
#define OCE_PROBE_SUPPR_SSID            106

static const value_string wfa_mbo_oce_attr_id_vals[] = {
  { MBO_AP_CAPABILTY_INDICATION, "MBO AP Capability Indication"},
  { MBO_NON_PREF_CHANNEL_REPORT, "Non-preferred Channel Report"},
  { MBO_CELLULAR_DATA_CAPABILITIES, "Cellular Data Capabilities"},
  { MBO_ASSOCIATION_DISALLOWED, "Association Disallowed"},
  { MBO_CELLULAR_DATA_PREFERENCE, "Cellular Data Connection Preference"},
  { MBO_TRANSITION_REASON, "Transition Reason Code BTM Request"},
  { MBO_TRANSITION_REJECTION_REASON, "Transition Rejection Reason Code"},
  { MBO_ASSOCIATION_RETRY_DELAY, "Association Retry Delay"},
  { OCE_CAPABILTY_INDICATION, "OCE Capability Indication" },
  { OCE_RSSI_ASSOCIATION_REJECTION, "RSSI-based (Re-)Association Rejection" },
  { OCE_REDUCED_WAN_METRICS, "Reduced WAN Metrics" },
  { OCE_RNR_COMPLETENESS, "RNR Completeness" },
  { OCE_PROBE_SUPPR_BSSID, "Probe Suppression BSSIDs" },
  { OCE_PROBE_SUPPR_SSID, "Probe Suppression SSIDs" },
  { 0, NULL}
};

static const value_string wfa_mbo_non_pref_chan_pref_vals[] = {
  { 0, "non-operable band/channel for the STA"},
  { 1, "band/channel the STA prefers not to operate in"},
  { 255, "band/channel the STA prefers to operate in"},
  { 0, NULL }
};

static const value_string wfa_mbo_non_pref_chan_reason_vals[] = {
  { 0, "Unspecified reason"},
  { 1, "An unacceptable level of interference is being experienced by STA in this channel"},
  { 2, "The STA has another active connection in this channel, "
    "or near enough to this channel to cause operating interference"},
  { 0, NULL }
};

static const value_string wfa_mbo_cellular_cap_vals[] = {
  { 1, "Cellular data connection available"},
  { 2, "Cellular data connection not available"},
  { 3, "Not Cellular data capable"},
  { 0, NULL }
};

static const value_string wfa_mbo_assoc_dissallow_reason_vals[] = {
  { 1, "Unspecified reason"},
  { 2, "Maximum number of associated STAs reached"},
  { 3, "Air interface is overloaded"},
  { 4, "Authentication server overloaded"},
  { 5, "Insufficient RSSI"},
  { 0, NULL }
};

static const value_string wfa_mbo_cellular_pref_vals[] = {
  { 0, "Excluded. The AP does not want STA to use the cellular data connection"},
  { 1, "The AP prefers the STA should not use cellular data connection"},
  { 255, "The AP prefers the STA should use cellular data connection"},
  { 0, NULL }
};

static const value_string wfa_mbo_transition_reason_vals[] = {
  { 0, "Unspecified"},
  { 1, "Excessive frame loss rate"},
  { 2, "Excessive delay for current traffic stream"},
  { 3, "Insufficient bandwidth for current traffic stream"},
  { 4, "Load balancing"},
  { 5, "Low RSSI"},
  { 6, "Received excessive number of retransmissions"},
  { 7, "High interference"},
  { 8, "Gray zone"},
  { 9, "Transitioning to a premium AP"},
  { 0, NULL }
};

static const value_string wfa_mbo_transition_rej_reason_vals[] = {
  { 0, "Unspecified"},
  { 1, "Excessive frame loss rate expected by the STA if it transitions"},
  { 2, "Excessive delay for current traffic stream would be incurred by BSS transition at this time"},
  { 3, "Insufficient QoS capacity for current traffic stream expected by the STA if it transitions"},
  { 4, "Low RSSI in frames being received by the STA from to the suggested candidate BSS(s)"},
  { 5, "High interference expected by STA if it transitions"},
  { 6, "Service Availability – the STA expects that services it needs "
    "which are available at its serving AP will not be available if it transitions"},
  { 0, NULL }
};

/* 802.11ai FILS Discovery */
#define PA_FILS_FC_SSID_LENGTH  0x001F
#define PA_FILS_FC_CAPABILITY   0x0020
#define PA_FILS_FC_SHORT_SSID   0x0040
#define PA_FILS_FC_AP_CSN       0x0080
#define PA_FILS_FC_ANO          0x0100
#define PA_FILS_FC_CCFS1        0x0200
#define PA_FILS_FC_PC           0x0400
#define PA_FILS_FC_RSN_INFO     0x0800
#define PA_FILS_FC_LENGTH       0x1000
#define PA_FILS_FC_MD           0x2000
#define PA_FILS_FC_RESERVED     0xC000

static const value_string fils_discovery_capability_bss_operating_channel_width[] = {
  {0, "20MHz (or 22Mhz) / TVHT_W"},
  {1, "40MHZ / TVHT_W+W"},
  {2, "80MHz / TVHT_2W"},
  {3, "160MHz or 80MHz+80MHz / TVHT_4W or TVHT_2W+2W"},
  {0, NULL}
};

static const value_string fils_discovery_capability_max_number_of_spatial_streams[] = {
  {0, "1 spatial stream"},
  {1, "2 spatial streams"},
  {2, "3 spatial streams"},
  {3, "4 spatial streams"},
  {4, "5-8 spatial streams"},
  {0, NULL}
};

static const value_string fils_discovery_capability_phy_index[] = {
  {0, "HR/DSSS"},
  {1, "ERP-OFDM"},
  {2, "HT"},
  {3, "VHT or TVHT"},
  {4, "HE"},
  {0x00, NULL}
};

static const value_string fils_discovery_capability_fils_minimum_rate_dsss[] = {
  {0, "1 Mbps"},
  {1, "2 Mbps"},
  {2, "5.5 Mbps"},
  {3, "11 Mbps"},
  {0x00, NULL}
};

static const value_string fils_discovery_capability_fils_minimum_rate_ofdm[] = {
  {0, "6 Mbps"},
  {1, "9 Mbps"},
  {2, "12 Mbps"},
  {3, "18 Mbps"},
  {4, "24 Mbps"},
  {0x00, NULL}
};

static const value_string fils_discovery_capability_fils_minimum_rate_ht_vht_tvht[] = {
  {0, "MCS 0"},
  {1, "MCS 1"},
  {2, "MCS 2"},
  {3, "MCS 3"},
  {4, "MCS 4"},
  {0x00, NULL}
};

static const value_string fils_discovery_capability_fils_minimum_rate_he[] = {
  {0, "HE-MCS 0"},
  {1, "HE-MCS 1"},
  {2, "HE-MCS 2"},
  {3, "HE-MCS 3"},
  {4, "HE-MCS 4"},
  {0x00, NULL}
};

static int proto_wlan;
static int proto_centrino;
static int proto_aggregate;
static bool ieee80211_tvb_invalid;

/* ************************************************************************* */
/*                Header field info values for FC-field                      */
/* ************************************************************************* */
static int hf_ieee80211_fc_field;
static int hf_ieee80211_fc_proto_version;
static int hf_ieee80211_fc_frame_type;
static int hf_ieee80211_fc_frame_subtype;
static int hf_ieee80211_fc_frame_extension;
static int hf_ieee80211_fc_frame_type_subtype;

static int hf_ieee80211_fc_flags;
static int hf_ieee80211_fc_flags_str;
static int hf_ieee80211_fc_to_ds;
static int hf_ieee80211_fc_from_ds;
static int hf_ieee80211_fc_data_ds;

static int hf_ieee80211_fc_more_frag;
static int hf_ieee80211_fc_retry;
static int hf_ieee80211_fc_pwr_mgt;
static int hf_ieee80211_fc_more_data;
static int hf_ieee80211_fc_protected;
static int hf_ieee80211_fc_order;

/* S1G Flags */
static int hf_ieee80211_fc_s1g_next_tbtt_present;
static int hf_ieee80211_fc_s1g_compressed_ssid_present;
static int hf_ieee80211_fc_s1g_ano_present;
static int hf_ieee80211_fc_s1g_bss_bw;
static int hf_ieee80211_fc_s1g_security;
static int hf_ieee80211_fc_s1g_ap_pm;

/* PV1 fields */
static int hf_ieee80211_fc_pv1_proto_version;
static int hf_ieee80211_fc_pv1_type;
static int hf_ieee80211_fc_pv1_ptid;
static int hf_ieee80211_fc_pv1_mgmt_subtype;
static int hf_ieee80211_fc_pv1_cntl_subtype;
static int hf_ieee80211_fc_pv1_unk_field;
static int hf_ieee80211_fc_pv1_bw_indication;
static int hf_ieee80211_fc_pv1_dynamic_indication;
static int hf_ieee80211_fc_pv1_cntl_power_mgmt;
static int hf_ieee80211_fc_pv1_cntl_more_data;
static int hf_ieee80211_fc_pv1_cntl_flow_control;
static int hf_ieee80211_fc_pv1_cntl_next_twt_info;
static int hf_ieee80211_fc_pv1_mgmt_pr_next_tbt;
static int hf_ieee80211_fc_pv1_mgmt_pr_full_ssid;
static int hf_ieee80211_fc_pv1_mgmt_pr_ano;
static int hf_ieee80211_fc_pv1_mgmt_pr_bss_bw;
static int hf_ieee80211_fc_pv1_mgmt_pr_security;
static int hf_ieee80211_fc_pv1_mgmt_pr_1mhz_pc;
static int hf_ieee80211_fc_pv1_mgmt_pr_slot_assign;
static int hf_ieee80211_fc_pv1_mgmt_pr_more_frag;
static int hf_ieee80211_fc_pv1_mgmt_pr_pwr_mgmt;
static int hf_ieee80211_fc_pv1_mgmt_pr_grp_indic;
static int hf_ieee80211_fc_pv1_mgmt_pr_protected;
static int hf_ieee80211_fc_pv1_mgmt_pr_end_of_svc;
static int hf_ieee80211_fc_pv1_mgmt_pr_relayed_frm;
static int hf_ieee80211_fc_pv1_mgmt_pr_ack_policy;
static int hf_ieee80211_fc_pv1_from_ds;
static int hf_ieee80211_fc_pv1_more_fragments;
static int hf_ieee80211_fc_pv1_power_mgmt;
static int hf_ieee80211_fc_pv1_more_data;
static int hf_ieee80211_fc_pv1_protected_frame;
static int hf_ieee80211_fc_pv1_end_service_per;
static int hf_ieee80211_fc_pv1_relayed_frame;
static int hf_ieee80211_fc_pv1_ack_policy;
static int hf_ieee80211_pv1_sid;
static int hf_ieee80211_pv1_sid_association_id;
static int hf_ieee80211_pv1_sid_a3_present;
static int hf_ieee80211_pv1_sid_a4_present;
static int hf_ieee80211_pv1_sid_a_msdu;

static int hf_ieee80211_pv1_cnt_stack_tetra_timest;
static int hf_ieee80211_pv1_cnt_bat_beacon_seq;
static int hf_ieee80211_pv1_cnt_bat_penta_timest;
static int hf_ieee80211_pv1_cnt_bat_next_twt_info;
static int hf_ieee80211_pv1_cnt_bat_stating_seq_cntl;
static int hf_ieee80211_pv1_cnt_bat_bitmap;

static int hf_ieee80211_pv1_mgmt_reserved;
static int hf_ieee80211_pv1_cntl_reserved;

typedef struct retransmit_key {
  uint8_t bssid[6];
  uint8_t src[6];
  uint16_t seq_control;
  unsigned   fnum;
} retransmit_key;

static GHashTable *fc_analyse_retransmit_table;
static GHashTable *fc_first_frame_table;

static int hf_ieee80211_fc_analysis_retransmission;
static int hf_ieee80211_fc_analysis_retransmission_frame;

/* ************************************************************************* */
/*                   Header values for Duration/ID field                     */
/* ************************************************************************* */
static int hf_ieee80211_did_duration;
static int hf_ieee80211_assoc_id;

/* ************************************************************************* */
/*         Header values for different address-fields (all 4 of them)        */
/* ************************************************************************* */
static int hf_ieee80211_addr_da;  /* Destination address subfield */
static int hf_ieee80211_addr_da_resolved;  /* Dst addr subfield resolved*/
static int hf_ieee80211_addr_da_oui;  /* Destination address subfield */
static int hf_ieee80211_addr_da_oui_resolved;  /* Dst addr subfield resolved*/
static int hf_ieee80211_addr_da_ig;  /* Destination address IG bit */
static int hf_ieee80211_addr_da_lg;  /* Destination address LG bit */

static int hf_ieee80211_addr_sa;  /* Source address subfield */
static int hf_ieee80211_addr_sa_resolved;  /* Src addr subfield resolved*/
static int hf_ieee80211_addr_sa_oui;  /* Source address subfield */
static int hf_ieee80211_addr_sa_oui_resolved;  /* Src addr subfield resolved*/
static int hf_ieee80211_addr_sa_ig;  /* Source address IG bit */
static int hf_ieee80211_addr_sa_lg;  /* Source address LG bit */

static int hf_ieee80211_addr_ra;  /* Receiver address subfield */
static int hf_ieee80211_addr_ra_resolved;  /* Rcv addr subfield resolved*/
static int hf_ieee80211_addr_ra_oui;  /* Receiver address subfield */
static int hf_ieee80211_addr_ra_oui_resolved;  /* Rcv addr subfield resolved*/
static int hf_ieee80211_addr_ra_ig;  /* Receiver address IG bit */
static int hf_ieee80211_addr_ra_lg;  /* Receiver address LG bit */

static int hf_ieee80211_addr_ta;  /* Transmitter address subfield */
static int hf_ieee80211_addr_ta_resolved;  /* Txm addr subfield resolved*/
static int hf_ieee80211_addr_ta_oui;  /* Transmitter address subfield */
static int hf_ieee80211_addr_ta_oui_resolved;  /* Txm addr subfield resolved*/
static int hf_ieee80211_addr_ta_ig;  /* Transmitter address IG bit */
static int hf_ieee80211_addr_ta_lg;  /* Transmitter address LG bit */

static int hf_ieee80211_addr_bssid;  /* address is bssid */
static int hf_ieee80211_addr_bssid_resolved;  /* bssid resolved*/
static int hf_ieee80211_addr_bssid_oui;  /* address is bssid */
static int hf_ieee80211_addr_bssid_oui_resolved;  /* bssid resolved*/
static int hf_ieee80211_addr_bssid_ig;  /* bssid address IG bit */
static int hf_ieee80211_addr_bssid_lg;  /* bssid address LG bit */

static int hf_ieee80211_addr_staa;  /* address is station address */
static int hf_ieee80211_addr_staa_resolved;  /* station address resolved*/
static int hf_ieee80211_addr_staa_oui;  /* address is station address */
static int hf_ieee80211_addr_staa_oui_resolved;  /* station address resolved*/
static int hf_ieee80211_addr_staa_ig;  /* station address IG bit */
static int hf_ieee80211_addr_staa_lg;  /* station address LG bit */

static int hf_ieee80211_addr;  /* Source or destination address subfield */
static int hf_ieee80211_addr_resolved;/*Src/dst address subfield resolved*/
static int hf_ieee80211_addr_oui;  /* Source or destination address subfield */
static int hf_ieee80211_addr_oui_resolved;/*Src/dst address subfield resolved*/
static int hf_ieee80211_addr_ig;  /* Src/dst address IG bit */
static int hf_ieee80211_addr_lg;  /* Src/dst address LG bit */

static int hf_ieee80211_mgt;

/* ************************************************************************* */
/*                Header values for QoS control field                        */
/* ************************************************************************* */
static int hf_ieee80211_qos;
static int hf_ieee80211_qos_tid;
static int hf_ieee80211_qos_priority;
static int hf_ieee80211_qos_ack_policy;
static int hf_ieee80211_qos_amsdu_present;
static int hf_ieee80211_qos_eosp;
static int hf_ieee80211_qos_bit4;
static int hf_ieee80211_qos_txop_limit;
static int hf_ieee80211_qos_ps_buf_state;
static int hf_ieee80211_qos_buf_state_indicated;
static int hf_ieee80211_qos_highest_pri_buf_ac;
static int hf_ieee80211_qos_qap_buf_load;
static int hf_ieee80211_qos_txop_dur_req;
static int hf_ieee80211_qos_queue_size;
static int hf_ieee80211_qos_mesh_ctl_present;
static int hf_ieee80211_qos_mesh_ps_rsvd;
static int hf_ieee80211_qos_mesh_ps_unicast;
static int hf_ieee80211_qos_mesh_ps_multicast;
static int hf_ieee80211_qos_mesh_rspi;

/* ************************************************************************* */
/*                Header values for HT control field (+HTC) and HE control   */
/* ************************************************************************* */
/* 802.11-2012 and 802.11ac-2013 8.2.4.6 */
static int hf_ieee80211_htc;
static int hf_ieee80211_htc_vht;
static int hf_ieee80211_htc_he;
static int hf_ieee80211_htc_he_ctrl_id;
static int hf_ieee80211_he_a_control_padding;
static int hf_ieee80211_he_a_control_ones;
static int hf_ieee80211_he_trs_he_tb_ppdu_len;
static int hf_ieee80211_he_trs_ru_allocation;
static int hf_ieee80211_he_dl_tx_power;
static int hf_ieee80211_he_ul_target_rssi;
static int hf_ieee80211_he_ul_mcs;
static int hf_ieee80211_he_ul_reserved;
static int hf_ieee80211_he_om_rx_nss;
static int hf_ieee80211_he_om_channel_width;
static int hf_ieee80211_he_om_ul_mu_disable;
static int hf_ieee80211_he_om_tx_nsts;
static int hf_ieee80211_he_om_er_su_disable;
static int hf_ieee80211_he_om_dl_mu_mimo_resound;
static int hf_ieee80211_he_om_ul_mu_data_disable;
static int hf_ieee80211_he_hla_unsolicited_mfb;
static int hf_ieee80211_he_hla_mrq;
static int hf_ieee80211_he_hla_nss;
static int hf_ieee80211_he_hla_he_mcs;
static int hf_ieee80211_he_hla_dcm;
static int hf_ieee80211_he_hla_ru;
static int hf_ieee80211_he_hla_bw;
static int hf_ieee80211_he_hla_msi_ppdu_type;
static int hf_ieee80211_he_hla_tx_bf;
static int hf_ieee80211_he_hla_reserved;
static int hf_ieee80211_he_bsr_aci_bitmap;
static int hf_ieee80211_he_bsr_delta_tid;
static int hf_ieee80211_he_bsr_aci_high;
static int hf_ieee80211_he_bsr_scaling_factor;
static int hf_ieee80211_he_bsr_queue_size_high;
static int hf_ieee80211_he_bsr_queue_size_all;
static int hf_ieee80211_he_uph_ul_power_headroom;
static int hf_ieee80211_he_uph_ul_min_transmit_power_flag;
static int hf_ieee80211_he_uph_reserved;
static int hf_ieee80211_he_cci_ac_constraint;
static int hf_ieee80211_he_cci_rdg_more_ppdu;
static int hf_ieee80211_he_cci_sr_ppdu_indic;
static int hf_ieee80211_he_cci_reserved;
static int hf_ieee80211_he_eht_om_rx_nss_ext;
static int hf_ieee80211_he_eht_om_chan_w_ext;
static int hf_ieee80211_he_eht_om_tx_nsts_ext;
static int hf_ieee80211_he_eht_om_reserved;
static int hf_ieee80211_he_srs_ppdu_resp_dur;
static int hf_ieee80211_he_srs_reserved;
static int hf_ieee80211_he_aar_assisted_ap_bitmap;
static int hf_ieee80211_he_aar_reserved;
static int hf_ieee80211_he_btc_avail_chan;
static int hf_ieee80211_he_btc_reserved;
static int hf_ieee80211_he_trigger_common_info;
static int hf_ieee80211_he_trigger_type;
static int hf_ieee80211_he_trigger_ul_length;
static int hf_ieee80211_he_trigger_more_tf;
static int hf_ieee80211_he_trigger_cs_required;
static int hf_ieee80211_he_trigger_ul_bw;
static int hf_ieee80211_he_trigger_gi_and_ltf_type;
static int hf_ieee80211_he_trigger_mu_mimo_ltf_mode;
static int hf_ieee80211_he_trigger_num_he_ltf_syms_etc;
static int hf_ieee80211_he_trigger_ul_stbc;
static int hf_ieee80211_he_trigger_ldpc_extra_sym_seg;
static int hf_ieee80211_he_trigger_ap_tx_power;
static int hf_ieee80211_he_trigger_pre_fec_padding_factor;
static int hf_ieee80211_he_trigger_pe_disambiguity;
static int hf_ieee80211_he_trigger_ul_spatial_reuse;
static int hf_ieee80211_he_trigger_doppler;
static int hf_ieee80211_he_trigger_ul_he_sig_a_reserved;
static int hf_ieee80211_he_trigger_reserved;
static int hf_ieee80211_he_trigger_user_info;
static int hf_ieee80211_he_trigger_user_info_padding_start;
static int hf_ieee80211_he_trigger_padding;
static int hf_ieee80211_he_trigger_bar_ctrl;
static int hf_ieee80211_he_trigger_bar_ctrl_ba_ack_policy;
static int hf_ieee80211_he_trigger_bar_ctrl_ba_type;
static int hf_ieee80211_he_trigger_bar_ctrl_reserved;
static int hf_ieee80211_he_trigger_bar_ctrl_tid_info;
static int hf_ieee80211_he_trigger_bar_info;
static int hf_ieee80211_he_trigger_bar_info_blk_ack_seq_ctrl;
static int hf_ieee80211_he_trigger_mpdu_mu_spacing;
static int hf_ieee80211_he_trigger_tid_aggregation_limit;
static int hf_ieee80211_he_trigger_dependent_reserved1;
static int hf_ieee80211_he_trigger_preferred_ac;
static int hf_ieee80211_he_trigger_starting_aid;
static int hf_ieee80211_he_trigger_dependent_reserved2;
static int hf_ieee80211_he_trigger_feedback_type;
static int hf_ieee80211_he_trigger_dependent_reserved3;
static int hf_ieee80211_he_trigger_nfrp_target_rssi;
static int hf_ieee80211_he_trigger_multiplexing_flag;
static int hf_ieee80211_he_trigger_dep_nfrp_user_info;
static int hf_ieee80211_he_trigger_feedback_seg_retrans_bm;
static int hf_ieee80211_he_trigger_aid12;
static int hf_ieee80211_he_trigger_ru_allocation;
static int hf_ieee80211_he_trigger_ru_allocation_region;
static int hf_ieee80211_he_trigger_ru_starting_spatial_stream;
static int hf_ieee80211_he_trigger_ru_number_spatial_streams;
static int hf_ieee80211_he_trigger_ru_number_ra_ru;
static int hf_ieee80211_he_trigger_ru_no_more_ra_ru;
static int hf_ieee80211_he_trigger_ul_fec_coding_type;
static int hf_ieee80211_he_trigger_ul_mcs;
static int hf_ieee80211_he_trigger_ul_dcm;
static int hf_ieee80211_he_trigger_ul_target_rssi;
static int hf_ieee80211_he_trigger_user_reserved;
static int hf_ieee80211_he_trigger_dep_basic_user_info;
static int hf_ieee80211_he_trigger_ranging_common_info_1;
static int hf_ieee80211_he_trigger_ranging_common_info_2;
static int hf_ieee80211_eht_trigger_common_info;
static int hf_ieee80211_eht_trigger_type;
static int hf_ieee80211_eht_trigger_ul_length;
static int hf_ieee80211_eht_trigger_more_tf;
static int hf_ieee80211_eht_trigger_cs_required;
static int hf_ieee80211_eht_trigger_ul_bw;
static int hf_ieee80211_eht_trigger_gi_and_eht_ltf_type;
static int hf_ieee80211_eht_trigger_num_he_eht_ltf_syms_etc;
static int hf_ieee80211_eht_trigger_reserved2;
static int hf_ieee80211_eht_trigger_ldpc_extra_sym_seg;
static int hf_ieee80211_eht_trigger_ap_tx_power;
static int hf_ieee80211_eht_trigger_pre_fec_padding_factor;
static int hf_ieee80211_eht_trigger_pe_disambiguity;
static int hf_ieee80211_eht_trigger_ul_spatial_reuse;
static int hf_ieee80211_eht_trigger_reserved3;
static int hf_ieee80211_eht_trigger_he_eht_p160;
static int hf_ieee80211_eht_trigger_special_user_info_flag;
static int hf_ieee80211_eht_trigger_eht_reserved;
static int hf_ieee80211_eht_trigger_reserved4;
static int hf_ieee80211_eht_trigger_reserved;
static int hf_ieee80211_eht_trigger_aid12;
static int hf_ieee80211_eht_trigger_special_user_info;
static int hf_ieee80211_eht_trigger_phy_version_identifier;
static int hf_ieee80211_eht_trigger_ul_bw_extenstion;
static int hf_ieee80211_eht_trigger_eht_spatial_reuse_1;
static int hf_ieee80211_eht_trigger_eht_spatial_reuse_2;
static int hf_ieee80211_eht_trigger_disregard_u_sig_1;
static int hf_ieee80211_eht_trigger_validate_u_sig_2;
static int hf_ieee80211_eht_trigger_disregard_u_sig_2_4lsb;
static int hf_ieee80211_eht_trigger_disregard_u_sig_2_msb;
static int hf_ieee80211_eht_trigger_special_reserved;
static int hf_ieee80211_eht_trigger_user_info;
static int hf_ieee80211_eht_trigger_ru_allocation_region;
static int hf_ieee80211_eht_trigger_ru_allocation;
static int hf_ieee80211_eht_trigger_ul_fec_coding_type;
static int hf_ieee80211_eht_trigger_ul_eht_mcs;
static int hf_ieee80211_eht_trigger_ru_starting_spatial_stream;
static int hf_ieee80211_eht_trigger_ru_number_spatial_streams;
static int hf_ieee80211_eht_trigger_ul_target_recv_power;
static int hf_ieee80211_eht_trigger_ps160;
static int hf_ieee80211_eht_trigger_user_info_reserved;
static int hf_ieee80211_ranging_trigger_subtype1;
static int hf_ieee80211_ranging_trigger_reserved1;
static int hf_ieee80211_ranging_trigger_token;
static int hf_ieee80211_ranging_trigger_subtype2;
static int hf_ieee80211_ranging_trigger_reserved2;
static int hf_ieee80211_ranging_trigger_sounding_dialog_token;
static int hf_ieee80211_he_trigger_ranging_trigger_poll_rpt;
static int hf_ieee80211_ranging_pol_rpt_aid12_rsid12;
static int hf_ieee80211_ranging_pol_rpt_ru_alloc_region;
static int hf_ieee80211_ranging_pol_rpt_ru_alloc;
static int hf_ieee80211_ranging_pol_rpt_ul_fec_coding_type;
static int hf_ieee80211_ranging_pol_rpt_ulmcs;
static int hf_ieee80211_ranging_pol_rpt_uldcm;
static int hf_ieee80211_ranging_pol_rpt_starting_spatial_stream;
static int hf_ieee80211_ranging_pol_rpt_number_spatial_streams;
static int hf_ieee80211_ranging_pol_rpt_ul_target_rssi;
static int hf_ieee80211_ranging_pol_rpt_reserved;
static int hf_ieee80211_he_trigger_ranging_trigger_sounding;
static int hf_ieee80211_ranging_sounding_aid12_rsid12;
static int hf_ieee80211_ranging_sounding_reserved1;
static int hf_ieee80211_ranging_sounding_i2r_rep;
static int hf_ieee80211_ranging_sounding_reserved2;
static int hf_ieee80211_ranging_sounding_starting_spatial_stream;
static int hf_ieee80211_ranging_sounding_number_spatial_streams;
static int hf_ieee80211_ranging_sounding_ul_target_rssi;
static int hf_ieee80211_ranging_sounding_reserved3;
static int hf_ieee80211_he_trigger_ranging_trigger_sec_sound;
static int hf_ieee80211_ranging_sec_sound_aid12_rsid12;
static int hf_ieee80211_ranging_sec_sound_reserved1;
static int hf_ieee80211_ranging_sec_sound_i2r_rep;
static int hf_ieee80211_ranging_sec_sound_reserved2;
static int hf_ieee80211_ranging_sec_sound_starting_spatial_stream;
static int hf_ieee80211_ranging_sec_sound_number_spatial_streams;
static int hf_ieee80211_ranging_sec_sound_ul_target_rssi;
static int hf_ieee80211_ranging_sec_sound_reserved3;
static int hf_ieee80211_he_trigger_ranging_user_info_sac;
static int hf_ieee80211_he_ndp_annc_sta;
static int hf_ieee80211_he_ndp_annc_aid11;
static int hf_ieee80211_he_ndp_annc_ru_start;
static int hf_ieee80211_he_ndp_annc_ru_end;
static int hf_ieee80211_he_ndp_annc_feedback_type_and_ng;
static int hf_ieee80211_he_ndp_annc_disambiguation;
static int hf_ieee80211_he_ndp_annc_codebook_size;
static int hf_ieee80211_he_ndp_annc_nc;
static int hf_ieee80211_he_ndp_annc_disallowed_bitmap;
static int hf_ieee80211_he_ndp_annc_reserved1;
static int hf_ieee80211_he_ndp_annc_reserved2;
static int hf_ieee80211_he_qtp_control;
static int hf_ieee80211_he_qtp_setup_quiet_period_duration;
static int hf_ieee80211_he_qtp_setup_srv_specific_identif;
static int hf_ieee80211_he_qtp_request_dialog_token;
static int hf_ieee80211_he_qtp_request_quiet_period_offset;
static int hf_ieee80211_he_qtp_request_quiet_period_duration;
static int hf_ieee80211_he_qtp_request_quiet_period_interval;
static int hf_ieee80211_he_qtp_request_repetition_count;
static int hf_ieee80211_he_qtp_request_srv_specific_identif;
static int hf_ieee80211_he_qtp_response_dialog_token;
static int hf_ieee80211_he_qtp_response_status_code;
static int hf_ieee80211_he_qtp_response_quiet_period_offset;
static int hf_ieee80211_he_qtp_response_quiet_period_duration;
static int hf_ieee80211_he_qtp_response_quiet_period_interval;
static int hf_ieee80211_he_qtp_response_repetition_count;
static int hf_ieee80211_he_qtp_response_srv_specific_identif;
static int hf_ieee80211_htc_ht_lac;
static int hf_ieee80211_htc_lac_trq;
static int hf_ieee80211_htc_lac_mai_aseli;
static int hf_ieee80211_htc_lac_mai_mrq;
static int hf_ieee80211_htc_lac_mai_msi;
static int hf_ieee80211_htc_lac_mai_reserved;
static int hf_ieee80211_htc_lac_mfsi;
static int hf_ieee80211_htc_lac_mfb;
static int hf_ieee80211_htc_lac_asel_command;
static int hf_ieee80211_htc_lac_asel_data;
static int hf_ieee80211_htc_cal_pos;
static int hf_ieee80211_htc_cal_seq;
static int hf_ieee80211_htc_reserved1;
static int hf_ieee80211_htc_csi_steering;
static int hf_ieee80211_htc_ndp_announcement;
static int hf_ieee80211_htc_reserved2;
static int hf_ieee80211_htc_mrq;
static int hf_ieee80211_htc_msi;
static int hf_ieee80211_htc_msi_stbc_reserved;
static int hf_ieee80211_htc_compressed_msi;
static int hf_ieee80211_htc_ppdu_stbc_encoded;
static int hf_ieee80211_htc_mfsi;
static int hf_ieee80211_htc_gid_l;
static int hf_ieee80211_htc_mfb;
static int hf_ieee80211_htc_num_sts;
static int hf_ieee80211_htc_vht_mcs;
static int hf_ieee80211_htc_bw;
static int hf_ieee80211_htc_snr;
static int hf_ieee80211_htc_reserved3;
static int hf_ieee80211_htc_gid_h;
static int hf_ieee80211_htc_coding_type;
static int hf_ieee80211_htc_fb_tx_type;
static int hf_ieee80211_htc_unsolicited_mfb;
static int hf_ieee80211_htc_ac_constraint;
static int hf_ieee80211_htc_rdg_more_ppdu;

/* ************************************************************************* */
/*                Header values for sequence number field                    */
/* ************************************************************************* */
static int hf_ieee80211_frag_number;
static int hf_ieee80211_seq_number;

/* ************************************************************************* */
/*                   Header values for Frame Check field                     */
/* ************************************************************************* */
static int hf_ieee80211_fcs;
static int hf_ieee80211_fcs_status;

/* ************************************************************************* */
/*                   Header values for reassembly                            */
/* ************************************************************************* */
static int hf_ieee80211_fragments;
static int hf_ieee80211_fragment;
static int hf_ieee80211_fragment_overlap;
static int hf_ieee80211_fragment_overlap_conflict;
static int hf_ieee80211_fragment_multiple_tails;
static int hf_ieee80211_fragment_too_long_fragment;
static int hf_ieee80211_fragment_error;
static int hf_ieee80211_fragment_count;
static int hf_ieee80211_reassembled_in;
static int hf_ieee80211_reassembled_length;

static int proto_wlan_ext;

/* ************************************************************************* */
/*                      Fixed fields found in mgt frames                     */
/* ************************************************************************* */
static int hf_ieee80211_fixed_parameters;  /* Protocol payload for management frames */

static int hf_ieee80211_ff_auth_alg;            /* Authentication algorithm field            */
static int hf_ieee80211_ff_auth_seq;            /* Authentication transaction sequence       */
static int hf_ieee80211_ff_current_ap;          /* Current AP MAC address                    */
static int hf_ieee80211_ff_listen_ival;         /* Listen interval fixed field               */
static int hf_ieee80211_ff_timestamp;           /* 64 bit timestamp                          */
static int hf_ieee80211_ff_beacon_interval;     /* 16 bit Beacon interval                    */
static int hf_ieee80211_ff_assoc_id;            /* 16 bit AID field                          */
static int hf_ieee80211_ff_reason;              /* 16 bit reason code                        */
static int hf_ieee80211_ff_status_code;         /* Status code                               */
static int hf_ieee80211_ff_category_code;       /* 8 bit Category code */
static int hf_ieee80211_ff_action_code;         /* 8 bit Action code */
static int hf_ieee80211_ff_dialog_token;        /* 8 bit Dialog token */
static int hf_ieee80211_ff_trigger;
static int hf_ieee80211_ff_ftm_tod;
static int hf_ieee80211_ff_ftm_toa;
static int hf_ieee80211_ff_ftm_tod_err;
static int hf_ieee80211_ff_ftm_toa_err;
static int hf_ieee80211_ff_followup_dialog_token;
static int hf_ieee80211_ff_wme_action_code;     /* Management notification action code */
static int hf_ieee80211_ff_wme_status_code;     /* Management notification setup response status code */
static int hf_ieee80211_ff_qos_action_code;
static int hf_ieee80211_ff_dls_action_code;
static int hf_ieee80211_ff_dst_mac_addr;        /* DLS destination MAC addressi */
static int hf_ieee80211_ff_src_mac_addr;        /* DLS source MAC addressi */
static int hf_ieee80211_ff_req_ap_addr;
static int hf_ieee80211_ff_res_ap_addr;
static int hf_ieee80211_ff_check_beacon;
static int hf_ieee80211_ff_dls_timeout;         /* DLS timeout value */
static int hf_ieee80211_ff_ft_action_code; /* 8 bit FT Action code */
static int hf_ieee80211_ff_sta_address;
static int hf_ieee80211_ff_target_ap_address;
static int hf_ieee80211_ff_gas_comeback_delay;
static int hf_ieee80211_ff_gas_fragment_id;
static int hf_ieee80211_ff_more_gas_fragments;
static int hf_ieee80211_ff_query_request_length;
static int hf_ieee80211_ff_query_request;
static int hf_ieee80211_ff_query_response_length;
static int hf_ieee80211_ff_query_response;
static int hf_ieee80211_ff_anqp_info_id;
static int hf_ieee80211_ff_anqp_info_length;
static int hf_ieee80211_ff_anqp_info;
static int hf_ieee80211_ff_anqp_query_id;
static int hf_ieee80211_ff_anqp_capability;
static int hf_ieee80211_ff_anqp_capability_vlen;
static int hf_ieee80211_ff_anqp_capability_vendor;
static int hf_ieee80211_ff_venue_info_group;
static int hf_ieee80211_ff_venue_info_type;
static int hf_ieee80211_ff_anqp_venue_length;
static int hf_ieee80211_ff_anqp_venue_language;
static int hf_ieee80211_ff_anqp_venue_name;
static int hf_ieee80211_ff_anqp_nw_auth_type_indicator;
static int hf_ieee80211_ff_anqp_nw_auth_type_url_len;
static int hf_ieee80211_ff_anqp_nw_auth_type_url;
static int hf_ieee80211_ff_anqp_nw_auth_type_ts_indicator;
static int hf_ieee80211_ff_anqp_nw_auth_type_ts_url_len;
static int hf_ieee80211_ff_anqp_nw_auth_type_ts_url;
static int hf_ieee80211_ff_anqp_nw_auth_type_ts_year;
static int hf_ieee80211_ff_anqp_nw_auth_type_ts_mon;
static int hf_ieee80211_ff_anqp_nw_auth_type_ts_day;
static int hf_ieee80211_ff_anqp_nw_auth_type_ts_hr;
static int hf_ieee80211_ff_anqp_nw_auth_type_ts_min;
static int hf_ieee80211_ff_anqp_nw_auth_type_ts_sec;
static int hf_ieee80211_ff_anqp_nw_auth_type_ts_msec;
static int hf_ieee80211_ff_anqp_nw_auth_type_ts_rsvd;
static int hf_ieee80211_ff_anqp_roaming_consortium_oi_len;
static int hf_ieee80211_ff_anqp_roaming_consortium_oi;
static int hf_ieee80211_ff_anqp_ip_addr_avail_ipv6;
static int hf_ieee80211_ff_anqp_ip_addr_avail_ipv4;
static int hf_ieee80211_ff_anqp_nai_realm_count;
static int hf_ieee80211_ff_anqp_nai_field_len;
static int hf_ieee80211_ff_anqp_nai_realm_encoding;
static int hf_ieee80211_ff_anqp_nai_realm_length;
static int hf_ieee80211_ff_anqp_nai_realm;
static int hf_ieee80211_ff_anqp_nai_realm_eap_count;
static int hf_ieee80211_ff_anqp_nai_realm_eap_len;
static int hf_ieee80211_ff_anqp_nai_realm_eap_method;
static int hf_ieee80211_ff_anqp_nai_realm_auth_param_count;
static int hf_ieee80211_ff_anqp_nai_realm_auth_param_id;
static int hf_ieee80211_ff_anqp_nai_realm_auth_param_len;
static int hf_ieee80211_ff_anqp_nai_realm_auth_param_value;
static int hf_ieee80211_3gpp_gc_gud;
static int hf_ieee80211_3gpp_gc_udhl;
static int hf_ieee80211_3gpp_gc_iei;
static int hf_ieee80211_3gpp_gc_num_plmns;
static int hf_ieee80211_3gpp_gc_plmn;
static int hf_ieee80211_3gpp_gc_plmn_len;
static int hf_ieee80211_ff_anqp_domain_name_len;
static int hf_ieee80211_ff_anqp_domain_name;
static int hf_ieee80211_ff_tdls_action_code;
static int hf_ieee80211_ff_target_channel;
static int hf_ieee80211_ff_operating_class;
static int hf_ieee80211_ff_wnm_action_code;
static int hf_ieee80211_ff_unprotected_wnm_action_code;
static int hf_ieee80211_ff_key_data_length;
static int hf_ieee80211_ff_key_data;
static int hf_ieee80211_ff_wnm_notification_type;
static int hf_ieee80211_ff_wnm_notification_response_status;
static int hf_ieee80211_ff_rm_action_code;
static int hf_ieee80211_ff_rm_dialog_token;
static int hf_ieee80211_ff_rm_repetitions;
static int hf_ieee80211_ff_rm_tx_power;
static int hf_ieee80211_ff_rm_max_tx_power;
static int hf_ieee80211_ff_tpc;
static int hf_ieee80211_ff_tpc_element_id;
static int hf_ieee80211_ff_tpc_length;
static int hf_ieee80211_ff_tpc_tx_power;
static int hf_ieee80211_ff_tpc_link_margin;
static int hf_ieee80211_ff_rm_rx_antenna_id;
static int hf_ieee80211_ff_rm_tx_antenna_id;
static int hf_ieee80211_ff_rm_rcpi;
static int hf_ieee80211_ff_rm_rsni;
static int hf_ieee80211_ff_request_mode_pref_cand;
static int hf_ieee80211_ff_request_mode_abridged;
static int hf_ieee80211_ff_request_mode_disassoc_imminent;
static int hf_ieee80211_ff_request_mode_bss_term_included;
static int hf_ieee80211_ff_request_mode_ess_disassoc_imminent;
static int hf_ieee80211_ff_request_mode_link_removal_imminent;
static int hf_ieee80211_ff_request_mode_reserved;
static int hf_ieee80211_ff_disassoc_timer;
static int hf_ieee80211_ff_validity_interval;
static int hf_ieee80211_ff_url_len;
static int hf_ieee80211_ff_url;
static int hf_ieee80211_ff_target_bss;
static int hf_ieee80211_ff_bss_transition_query_reason;
static int hf_ieee80211_ff_bss_transition_status_code;
static int hf_ieee80211_ff_bss_termination_delay;
static int hf_ieee80211_ff_bss_transition_candidate_list_entries;

static int hf_ieee80211_ff_sa_query_action_code;
static int hf_ieee80211_ff_transaction_id;

static int hf_ieee80211_ff_send_confirm;
static int hf_ieee80211_ff_scalar;
static int hf_ieee80211_ff_finite_field_element;
static int hf_ieee80211_ff_confirm;
static int hf_ieee80211_ff_finite_cyclic_group;
static int hf_ieee80211_ff_sae_message_type;
static int hf_ieee80211_ff_sae_anti_clogging_token;


/* Vendor specific */
static int hf_ieee80211_ff_marvell_action_type;
static int hf_ieee80211_ff_marvell_mesh_mgt_action_code;
static int hf_ieee80211_ff_marvell_mesh_mgt_length;     /* Mesh Management length */
static int hf_ieee80211_ff_marvell_mesh_mgt_mode;       /* Mesh Management mode */
static int hf_ieee80211_ff_marvell_mesh_mgt_ttl;        /* Mesh Management TTL */
static int hf_ieee80211_ff_marvell_mesh_mgt_dstcount;   /* Mesh Management dst count */
static int hf_ieee80211_ff_marvell_mesh_mgt_hopcount;   /* Mesh Management hop count */
static int hf_ieee80211_ff_marvell_mesh_mgt_rreqid;     /* Mesh Management RREQ ID */
static int hf_ieee80211_ff_marvell_mesh_mgt_sa;         /* Mesh Management src addr */
static int hf_ieee80211_ff_marvell_mesh_mgt_ssn;        /* Mesh Management src sequence number */
static int hf_ieee80211_ff_marvell_mesh_mgt_metric;     /* Mesh Management metric */
static int hf_ieee80211_ff_marvell_mesh_mgt_flags;      /* Mesh Management RREQ flags */
static int hf_ieee80211_ff_marvell_mesh_mgt_da;         /* Mesh Management dst addr */
static int hf_ieee80211_ff_marvell_mesh_mgt_dsn;        /* Mesh Management dst sequence number */
static int hf_ieee80211_ff_marvell_mesh_mgt_lifetime;   /* Mesh Management lifetime */


static int hf_ieee80211_ff_ba_action;

static int hf_ieee80211_ff_block_ack_params;
static int hf_ieee80211_ff_block_ack_params_amsdu_permitted;
static int hf_ieee80211_ff_block_ack_params_policy;
static int hf_ieee80211_ff_block_ack_params_tid;
static int hf_ieee80211_ff_block_ack_params_buffer_size;

static int * const ieee80211_ff_block_ack_params_fields[] = {
  &hf_ieee80211_ff_block_ack_params_amsdu_permitted,
  &hf_ieee80211_ff_block_ack_params_policy,
  &hf_ieee80211_ff_block_ack_params_tid,
  &hf_ieee80211_ff_block_ack_params_buffer_size,
  NULL
};

static int hf_ieee80211_ff_block_ack_timeout;

static int hf_ieee80211_ff_block_ack_ssc;
static int hf_ieee80211_ff_block_ack_ssc_fragment;
static int hf_ieee80211_ff_block_ack_ssc_sequence;

static int * const ieee80211_ff_block_ack_ssc_fields[] = {
  &hf_ieee80211_ff_block_ack_ssc_fragment,
  &hf_ieee80211_ff_block_ack_ssc_sequence,
  NULL
};

static int hf_ieee80211_ff_delba_param;
static int hf_ieee80211_ff_delba_param_reserved;
static int hf_ieee80211_ff_delba_param_init;
static int hf_ieee80211_ff_delba_param_tid;

static int * const ieee80211_ff_delba_param_fields[] = {
  &hf_ieee80211_ff_delba_param_reserved,
  &hf_ieee80211_ff_delba_param_init,
  &hf_ieee80211_ff_delba_param_tid,
  NULL
};

static int hf_ieee80211_ff_max_reg_pwr;
static int hf_ieee80211_ff_measurement_pilot_int;
static int hf_ieee80211_ff_country_str;
static int hf_ieee80211_ff_max_tx_pwr;
static int hf_ieee80211_ff_tx_pwr_used;
static int hf_ieee80211_ff_transceiver_noise_floor;
static int hf_ieee80211_ff_channel_width;

static int hf_ieee80211_ff_qos_info_ap;
static int hf_ieee80211_ff_qos_info_ap_edca_param_set_counter;
static int hf_ieee80211_ff_qos_info_ap_q_ack;
static int hf_ieee80211_ff_qos_info_ap_queue_req;
static int hf_ieee80211_ff_qos_info_ap_txop_request;
static int hf_ieee80211_ff_qos_info_ap_more_data_ack;

static int * const ieee80211_ff_qos_info_ap_fields[] = {
  &hf_ieee80211_ff_qos_info_ap_edca_param_set_counter,
  &hf_ieee80211_ff_qos_info_ap_q_ack,
  &hf_ieee80211_ff_qos_info_ap_queue_req,
  &hf_ieee80211_ff_qos_info_ap_txop_request,
  &hf_ieee80211_ff_qos_info_ap_more_data_ack,
  NULL
};

static int hf_ieee80211_ff_qos_info_sta;
static int hf_ieee80211_ff_qos_info_sta_ac_vo;
static int hf_ieee80211_ff_qos_info_sta_ac_vi;
static int hf_ieee80211_ff_qos_info_sta_ac_bk;
static int hf_ieee80211_ff_qos_info_sta_ac_be;
static int hf_ieee80211_ff_qos_info_sta_q_ack;
static int hf_ieee80211_ff_qos_info_sta_max_sp_length;
static int hf_ieee80211_ff_qos_info_sta_more_data_ack;

static int * const ieee80211_ff_qos_info_sta_fields[] = {
  &hf_ieee80211_ff_qos_info_sta_ac_vo,
  &hf_ieee80211_ff_qos_info_sta_ac_vi,
  &hf_ieee80211_ff_qos_info_sta_ac_bk,
  &hf_ieee80211_ff_qos_info_sta_ac_be,
  &hf_ieee80211_ff_qos_info_sta_q_ack,
  &hf_ieee80211_ff_qos_info_sta_max_sp_length,
  &hf_ieee80211_ff_qos_info_sta_more_data_ack,
  NULL
};

static int hf_ieee80211_ff_sm_pwr_save;
static int hf_ieee80211_ff_sm_pwr_save_enabled;
static int hf_ieee80211_ff_sm_pwr_save_sm_mode;
static int hf_ieee80211_ff_sm_pwr_save_reserved;

static int * const ieee80211_ff_sw_pwr_save_fields[] = {
  &hf_ieee80211_ff_sm_pwr_save_enabled,
  &hf_ieee80211_ff_sm_pwr_save_sm_mode,
  &hf_ieee80211_ff_sm_pwr_save_reserved,
  NULL
};

static int hf_ieee80211_ff_pco_phase_cntrl;

static int hf_ieee80211_ff_psmp_param_set;
static int hf_ieee80211_ff_psmp_param_set_n_sta;
static int hf_ieee80211_ff_psmp_param_set_more_psmp;
static int hf_ieee80211_ff_psmp_param_set_psmp_sequence_duration;

static int * const ieee80211_ff_psmp_param_set_fields[] = {
  &hf_ieee80211_ff_psmp_param_set_n_sta,
  &hf_ieee80211_ff_psmp_param_set_more_psmp,
  &hf_ieee80211_ff_psmp_param_set_psmp_sequence_duration,
  NULL
};

static int hf_ieee80211_ff_mimo_cntrl;
static int hf_ieee80211_ff_mimo_cntrl_nc_index;
static int hf_ieee80211_ff_mimo_cntrl_nr_index;
static int hf_ieee80211_ff_mimo_cntrl_channel_width;
static int hf_ieee80211_ff_mimo_cntrl_grouping;
static int hf_ieee80211_ff_mimo_cntrl_coefficient_size;
static int hf_ieee80211_ff_mimo_cntrl_codebook_info;
static int hf_ieee80211_ff_mimo_cntrl_remaining_matrix_segment;
static int hf_ieee80211_ff_mimo_cntrl_reserved;
static int hf_ieee80211_ff_mimo_cntrl_sounding_timestamp;

static int hf_ieee80211_ff_ftm_param_delim1;
static int hf_ieee80211_ff_ftm_param_status_indication;
static int hf_ieee80211_ff_ftm_param_value;
static int hf_ieee80211_ff_ftm_param_reserved1;
static int hf_ieee80211_ff_ftm_param_burst_exponent;
static int hf_ieee80211_ff_ftm_param_burst_duration;

static int hf_ieee80211_ff_ftm_param_delim2;
static int hf_ieee80211_ff_ftm_param_min_delta_ftm;
static int hf_ieee80211_ff_ftm_param_partial_tsf_timer;
static int hf_ieee80211_ff_ftm_param_partial_tsf_no_pref;
static int hf_ieee80211_ff_ftm_param_asap_capable;
static int hf_ieee80211_ff_ftm_param_asap;
static int hf_ieee80211_ff_ftm_param_ftm_per_burst;

static int hf_ieee80211_ff_ftm_param_delim3;
static int hf_ieee80211_ff_ftm_param_reserved2;
static int hf_ieee80211_ff_ftm_param_format_and_bw;
static int hf_ieee80211_ff_ftm_param_burst_period;

/* az D3.0 introduces a 1-octet TOD Error field; use a different name to avoid
 * conflicting with the existing hf_ieee80211_ff_ftm_tod_err (which is 2
 * octets).
 */
static int hf_ieee80211_ff_ftm_tod_err1;
static int hf_ieee80211_ff_ftm_max_tod_error_exponent;
static int hf_ieee80211_ff_ftm_tod_err_reserved;
static int hf_ieee80211_ff_ftm_tod_not_continuous;

/* Same situation with ...toa_err1 as ...tod_err1 */
static int hf_ieee80211_ff_ftm_toa_err1;
static int hf_ieee80211_ff_ftm_max_toa_error_exponent;
static int hf_ieee80211_ff_ftm_toa_err_reserved;
static int hf_ieee80211_ff_ftm_invalid_measurement;
static int hf_ieee80211_ff_ftm_toa_type;

static int hf_ieee80211_ff_ftm_cfo;
static int hf_ieee80211_ff_ftm_r2i_ndp_tx_power;
static int hf_ieee80211_ff_ftm_i2r_ndp_target_rssi;

/* az: FTM Ranging Parameters Element */
static int hf_ieee80211_tag_ranging_parameters;
static int hf_ieee80211_tag_ranging_subelt_tag;
static int hf_ieee80211_tag_ranging_subelt_len;
static int hf_ieee80211_tag_ranging_status_indication;
static int hf_ieee80211_tag_ranging_value;
static int hf_ieee80211_tag_ranging_i2r_lmr_feedback;
static int hf_ieee80211_tag_ranging_secure_ltf_required;
static int hf_ieee80211_tag_ranging_secure_ltf_support;
static int hf_ieee80211_tag_ranging_ranging_priority;
static int hf_ieee80211_tag_ranging_r2i_toa_type;
static int hf_ieee80211_tag_ranging_i2r_toa_type;
static int hf_ieee80211_tag_ranging_r2i_aoa_requested;
static int hf_ieee80211_tag_ranging_i2r_aoa_requested;
static int hf_ieee80211_tag_ranging_format_and_bandwidth;
static int hf_ieee80211_tag_ranging_immediate_r2i_feedback;
static int hf_ieee80211_tag_ranging_immediate_i2r_feedback;
static int hf_ieee80211_tag_ranging_max_i2r_repetition;
static int hf_ieee80211_tag_ranging_max_r2i_repetition;
static int hf_ieee80211_tag_ranging_reserved1;
static int hf_ieee80211_tag_ranging_reserved2;
static int hf_ieee80211_tag_ranging_max_r2i_sts_le_80_mhz;
static int hf_ieee80211_tag_ranging_max_r2i_sts_gt_80_mhz;
static int hf_ieee80211_tag_ranging_max_r2i_ltf_total;
static int hf_ieee80211_tag_ranging_max_i2r_ltf_total;
static int hf_ieee80211_tag_ranging_max_i2r_sts_le_80_mhz;
static int hf_ieee80211_tag_ranging_max_i2r_sts_gt_80_mhz;
static int hf_ieee80211_tag_ranging_bss_color_info;

/* az: FTM Ranging Parameters NTB-specific subelement */
static int hf_ieee80211_tag_ranging_ntb;
static int hf_ieee80211_tag_ranging_ntb_reserved1;
static int hf_ieee80211_tag_ranging_ntb_min_time_msmts;
static int hf_ieee80211_tag_ranging_ntb_max_time_msmts;
static int hf_ieee80211_tag_ranging_ntb_r2i_tx_power;
static int hf_ieee80211_tag_ranging_ntb_i2r_tx_power;
static int hf_ieee80211_tag_ranging_ntb_reserved2;

/* az: FTM Ranging Specific TB subelement */
static int hf_ieee80211_tag_ranging_aid_rsid;
static int hf_ieee80211_tag_ranging_device_class;
static int hf_ieee80211_tag_ranging_full_bw_ul_mu_mimo;
static int hf_ieee80211_tag_ranging_trigger_frame_paddur;
static int hf_ieee80211_tag_ranging_max_sess_exp;
static int hf_ieee80211_tag_ranging_passive_tb_ranging;
static int hf_ieee80211_tag_ranging_tb_specific_reserved;

/* az: PASN subelements etc. */
static int hf_ieee80211_tag_pasn_parameters_control;
static int hf_ieee80211_tag_pasn_params_comeback_info_present;
static int hf_ieee80211_tag_pasn_params_group_and_key_present;
static int hf_ieee80211_tag_pasn_parameters_reserved;
static int hf_ieee80211_tag_pasn_parameters_wrapped_fmt;
static int hf_ieee80211_tag_pasn_comeback_after;
static int hf_ieee80211_tag_pasn_cookie_length;
static int hf_ieee80211_tag_pasn_cookie;
static int hf_ieee80211_tag_pasn_finite_cyclic_group_id;
static int hf_ieee80211_tag_pasn_ephemeral_public_key_len;
static int hf_ieee80211_tag_pasn_ephemeral_public_key;
static int hf_ieee80211_pasn_auth1_frame_len;
static int hf_ieee80211_pasn_auth2_frame_len;

/* az: Secure LTF Parameters */
static int hf_ieee80211_tag_secure_ltf_params_counter;
static int hf_ieee80211_tag_secure_ltf_generation_sac;
static int hf_ieee80211_tag_secure_ltf_management_sac;
static int hf_ieee80211_tag_secure_ltf_result_ltf_ofs;

/* az: ista and rsta availability details */
static int hf_ieee80211_ftm_ista_availability_count;
static int hf_ieee80211_ftm_ista_availability_reserved;
static int hf_ieee80211_ftm_ista_avail_bits;
static int hf_ieee80211_ftm_ista_avail_pad;

static int hf_ieee80211_ftm_rsta_header;
static int hf_ieee80211_ftm_rsta_count;
static int hf_ieee80211_ftm_rsta_avail_window_bcast_fmt;
static int hf_ieee80211_ftm_rsta_partial_tsf_timer1;
static int hf_ieee80211_ftm_rsta_duration1;
static int hf_ieee80211_ftm_rsta_passive_tb_ranging_reserved1;
static int hf_ieee80211_ftm_rsta_periodicity1;
static int hf_ieee80211_ftm_rsta_partial_tsf_timer;
static int hf_ieee80211_ftm_rsta_duration;
static int hf_ieee80211_ftm_rsta_passive_tb_ranging_reserved;
static int hf_ieee80211_ftm_rsta_periodicity;
static int hf_ieee80211_ftm_rsta_format_and_bandwidth;
static int hf_ieee80211_ftm_rsta_reserved;
static int hf_ieee80211_ftm_rsta_avail_subfield_short;
static int hf_ieee80211_ftm_rsta_avail_subfield_long;

/* be: Multi-link elements and other fields */
static int hf_ieee80211_eht_multi_link_control;
static int hf_ieee80211_eht_multi_link_control_type;
static int hf_ieee80211_eht_multi_link_control_reserved;
static int hf_ieee80211_eht_multi_link_control_link_id_present;
static int hf_ieee80211_eht_multi_link_control_bss_parms_ch_count;
static int hf_ieee80211_eht_multi_link_control_medium_sync_delay;
static int hf_ieee80211_eht_multi_link_control_eml_capa;
static int hf_ieee80211_eht_multi_link_control_mld_capa;
static int hf_ieee80211_eht_multi_link_control_basic_mld_id_present;
static int hf_ieee80211_eht_multi_link_control_ext_mld_capa;
static int hf_ieee80211_eht_multi_link_control_bitmap_reserved;
static int hf_ieee80211_eht_multi_link_control_probe_mld_id_present;
static int hf_ieee80211_eht_multi_link_control_probe_reserved;
static int hf_ieee80211_eht_multi_link_control_reconfig_mld_mac;
static int hf_ieee80211_eht_multi_link_control_reconfig_eml_capa;
static int hf_ieee80211_eht_multi_link_control_reconfig_mld_capa_oper;
static int hf_ieee80211_eht_multi_link_control_reconfig_reserved;
static int hf_ieee80211_eht_multi_link_control_tdls_reserved;
static int hf_ieee80211_eht_multi_link_control_prio_access_reserved;
static int hf_ieee80211_eht_common_field_length;
static int hf_ieee80211_eht_common_field_mld_mac;
static int hf_ieee80211_eht_common_field_link_id_field;
static int hf_ieee80211_eht_common_info_link_id;
static int hf_ieee80211_eht_common_info_link_id_reserved;
static int hf_ieee80211_eht_common_field_bss_param_change_count;
static int hf_ieee80211_eht_common_field_medium_sync_field;
static int hf_ieee80211_eht_common_info_medium_sync_duration;
static int hf_ieee80211_eht_common_info_medium_sync_threshold;
static int hf_ieee80211_eht_common_info_medium_sync_max_txops;
static int hf_ieee80211_eht_common_field_eml_capabilities;
static int hf_ieee80211_eht_common_info_eml_capa_emlsr_support;
static int hf_ieee80211_eht_common_info_eml_capa_emlsr_padding_delay;
static int hf_ieee80211_eht_common_info_eml_capa_emlsr_transition_delay;
static int hf_ieee80211_eht_common_info_eml_capa_emlmr_support;
static int hf_ieee80211_eht_common_info_eml_capa_emlmr_delay;
static int hf_ieee80211_eht_common_info_eml_capa_transition_timeout;
static int hf_ieee80211_eht_common_info_eml_capa_reserved;
static int hf_ieee80211_eht_common_field_mld_capabilities;
static int hf_ieee80211_eht_common_info_mld_max_simul_links;
static int hf_ieee80211_eht_common_info_mld_srs_support;
static int hf_ieee80211_eht_common_info_mld_tid_to_link_map_neg;
static int hf_ieee80211_eht_common_info_mld_freq_sep_for_str;
static int hf_ieee80211_eht_common_info_mld_aar_support;
static int hf_ieee80211_eht_common_info_mld_link_reconf_op_support;
static int hf_ieee80211_eht_common_info_mld_aligned_twt_support;
static int hf_ieee80211_eht_common_info_mld_reserved;
static int hf_ieee80211_eht_common_field_mld_id;
static int hf_ieee80211_eht_common_field_ap_mld_mac;
static int hf_ieee80211_eht_common_field_ext_mld_capabilities;
static int hf_ieee80211_eht_common_info_ext_mld_op_update_support;
static int hf_ieee80211_eht_common_info_ext_mld_max_simul_links;
static int hf_ieee80211_eht_common_info_ext_mld_reserved;
static int hf_ieee80211_eht_multi_link_subelt_tag;
static int hf_ieee80211_eht_multi_link_subelt_len;
static int hf_ieee80211_eht_multi_link_type_0_link_count;
static int hf_ieee80211_eht_multi_link_type_1_link_count;
static int hf_ieee80211_eht_multi_link_type_2_link_count;
static int hf_ieee80211_eht_multi_link_type_3_link_count;
static int hf_ieee80211_eht_multi_link_type_4_link_count;
static int hf_ieee80211_eht_multi_link_link_id_list;
static int hf_ieee80211_eht_profile_sta_control;
static int hf_ieee80211_eht_profile_link_id;
static int hf_ieee80211_eht_profile_complete_profile;
static int hf_ieee80211_eht_profile_mac_address_present;
static int hf_ieee80211_eht_profile_beacon_interval_present;
static int hf_ieee80211_eht_profile_tsf_offset_present;
static int hf_ieee80211_eht_profile_dtim_info_present;
static int hf_ieee80211_eht_profile_nstr_link_pair_present;
static int hf_ieee80211_eht_profile_nstr_bitmap_size;
static int hf_ieee80211_eht_profile_bss_params_change_count_present;
static int hf_ieee80211_eht_profile_reserved;
static int hf_ieee80211_eht_profile_probe_reserved;
static int hf_ieee80211_eht_profile_removal_timer_present;
static int hf_ieee80211_eht_profile_reconfig_operation_type;
static int hf_ieee80211_eht_profile_operation_para_present;
static int hf_ieee80211_eht_profile_reconfig_nstr_bitmap_size;
static int hf_ieee80211_eht_profile_reconfig_reserved;
static int hf_ieee80211_eht_profile_prio_acc_reserved;
static int hf_ieee80211_eht_sta_profile_info_len;
static int hf_ieee80211_eht_sta_profile_info_mac;
static int hf_ieee80211_eht_sta_profile_info_beacon;
static int hf_ieee80211_eht_sta_profile_info_tsf_offset;
static int hf_ieee80211_eht_sta_profile_info_dtim_count;
static int hf_ieee80211_eht_sta_profile_info_dtim_period;
static int hf_ieee80211_eht_sta_profile_info_bitmap;
static int hf_ieee80211_eht_sta_profile_bss_params_change_count;
static int hf_ieee80211_eht_sta_profile_removal_timer;
static int hf_ieee80211_eht_sta_profile_presence_indi;
static int hf_ieee80211_eht_sta_profile_presence_indi_max_mpdu_length_present;
static int hf_ieee80211_eht_sta_profile_presence_indi_max_amsdu_length_present;
static int hf_ieee80211_eht_sta_profile_presence_indi_reserved;
static int hf_ieee80211_eht_sta_profile_operation_para_info;
static int hf_ieee80211_eht_sta_profile_operation_para_info_max_mpdu_length;
static int hf_ieee80211_eht_sta_profile_operation_para_info_amsdu_length;
static int hf_ieee80211_eht_sta_profile_operation_para_info_pad;
static int hf_ieee80211_eht_operation_parameters;
static int hf_ieee80211_eht_basic_eht_mcs_nss_set;
static int hf_ieee80211_eht_operation_control_chan_width;
static int hf_ieee80211_eht_operation_control_reserved;
static int hf_ieee80211_eht_operation_info_present;
static int hf_ieee80211_eht_operation_subchannel_bitmap_present;
static int hf_ieee80211_eht_operation_default_pe_duration;
static int hf_ieee80211_eht_operation_group_addressed_bu_indication_limit;
static int hf_ieee80211_eht_operation_group_addressed_bu_indication_exp;
static int hf_ieee80211_eht_operation_reserved;
static int hf_ieee80211_eht_operation_control;
static int hf_ieee80211_eht_operation_ccfs0;
static int hf_ieee80211_eht_operation_ccfs1;
static int hf_ieee80211_eht_operation_disabled_bitmap;
static int hf_ieee80211_eht_mac_capabilities;
static int hf_ieee80211_eht_mac_capa_epcs_prio_access_support;
static int hf_ieee80211_eht_mac_capa_eht_om_control_support;
static int hf_ieee80211_eht_mac_capa_trig_txop_sharing_mode_1_support;
static int hf_ieee80211_eht_mac_capa_trig_txop_sharing_mode_2_support;
static int hf_ieee80211_eht_mac_capa_restricted_twt_support;
static int hf_ieee80211_eht_mac_capa_scs_traffic_description_support;
static int hf_ieee80211_eht_mac_capa_maximum_mpdu_length;
static int hf_ieee80211_eht_mac_capa_maximum_ampdu_length_exp_ext;
static int hf_ieee80211_eht_mac_capa_eht_trs_support;
static int hf_ieee80211_eht_mac_capa_txop_return_support_txop_sha_mode;
static int hf_ieee80211_eht_mac_capa_two_bqrs_support;
static int hf_ieee80211_eht_mac_capa_eht_link_adaptation_support;
static int hf_ieee80211_eht_mac_capa_reserved;
static int hf_ieee80211_eht_phy_bits_0_15;
static int hf_ieee80211_eht_phy_bits_0_15_reserved;
static int hf_ieee80211_eht_phy_bits_0_15_320_mhz_in_6ghz;
static int hf_ieee80211_eht_phy_bits_0_15_242_tone_ru_bw_wider_20mhz;
static int hf_ieee80211_eht_phy_bits_0_15_ndp_and_3_2_us_gi;
static int hf_ieee80211_eht_phy_bits_0_15_partial_bw_ul_mu_mimo;
static int hf_ieee80211_eht_phy_bits_0_15_su_beamformer;
static int hf_ieee80211_eht_phy_bits_0_15_su_beamformee;
static int hf_ieee80211_eht_phy_bits_0_15_su_beamformee_le_80mhz;
static int hf_ieee80211_eht_phy_bits_0_15_su_beamformee_eq_160mhz;
static int hf_ieee80211_eht_phy_bits_0_15_su_beamformee_eq_320mhz;
static int hf_ieee80211_eht_phy_bits_16_31;
static int hf_ieee80211_eht_phy_bits_16_31_num_sounding_dims_lt_80mhz;
static int hf_ieee80211_eht_phy_bits_16_31_num_sounding_dims_eq_160mhz;
static int hf_ieee80211_eht_phy_bits_16_31_num_sounding_dims_eq_320mhz;
static int hf_ieee80211_eht_phy_bits_16_31_num_ng_eq_16_su_feedback;
static int hf_ieee80211_eht_phy_bits_16_31_num_ng_eq_16_mu_feedback;
static int hf_ieee80211_eht_phy_bits_16_31_codebook_size_4_2_su_fbck;
static int hf_ieee80211_eht_phy_bits_16_31_codebook_size_7_5_mu_fbck;
static int hf_ieee80211_eht_phy_bits_16_31_triggered_su_beemform_fbck;
static int hf_ieee80211_eht_phy_bits_16_31_triggered_mu_beemform_p_bw_fbck;
static int hf_ieee80211_eht_phy_bits_16_31_triggered_cqi_feedback;
static int hf_ieee80211_eht_phy_bits_32_39;
static int hf_ieee80211_eht_phy_bits_32_39_partial_bw_dl_mu_mimo;
static int hf_ieee80211_eht_phy_bits_32_39_eht_psr_based_sr_support;
static int hf_ieee80211_eht_phy_bits_32_39_power_boost_factor_support;
static int hf_ieee80211_eht_phy_bits_32_39_eht_mu_ppdu_w_4x_eht_ltf_08_gi;
static int hf_ieee80211_eht_phy_bits_32_39_max_nc;
static int hf_ieee80211_eht_phy_bits_40_63;
static int hf_ieee80211_eht_phy_bits_40_63_non_triggered_cqi_fbck;
static int hf_ieee80211_eht_phy_bits_40_63_tx_1024_4096_qam_lt_242_ru_support;
static int hf_ieee80211_eht_phy_bits_40_63_rx_1024_4096_qam_lt_242_ru_support;
static int hf_ieee80211_eht_phy_bits_40_63_ppe_thresholds_present;
static int hf_ieee80211_eht_phy_bits_40_63_common_nominal_packet_padding;
static int hf_ieee80211_eht_phy_bits_40_63_max_num_supported_eht_ltfs;
static int hf_ieee80211_eht_phy_bits_40_63_support_of_mcx_15;
static int hf_ieee80211_eht_phy_bits_40_63_support_of_eht_dup_in_6_ghz;
static int hf_ieee80211_eht_phy_bits_40_63_support_20_mhz_sta_ndp_wide_bw;
static int hf_ieee80211_eht_phy_bits_40_63_non_ofdma_ul_mu_bw_le_80_mhz;
static int hf_ieee80211_eht_phy_bits_40_63_non_ofdma_ul_mu_bw_eq_160_mhz;
static int hf_ieee80211_eht_phy_bits_40_63_non_ofdma_ul_mu_bw_eq_320_mhz;
static int hf_ieee80211_eht_phy_bits_40_63_mu_beamformer_bw_le_80_mhz;
static int hf_ieee80211_eht_phy_bits_40_63_mu_beamformer_bw_eq_160_mhz;
static int hf_ieee80211_eht_phy_bits_40_63_mu_beamformer_bw_eq_320_mhz;
static int hf_ieee80211_eht_phy_bits_40_63_tb_sounding_feedback_rate_limit;
static int hf_ieee80211_eht_phy_bits_64_71;
static int hf_ieee80211_eht_phy_bits_64_71_rx_1024_qam_wid_bw_dl_ofdma_sup;
static int hf_ieee80211_eht_phy_bits_64_71_rx_4096_qam_wid_bw_dl_ofdma_sup;
static int hf_ieee80211_eht_phy_bits_64_71_reserved;
static int hf_ieee80211_eht_supported_mcs_nss_bytes;
static int hf_ieee80211_eht_mcs_and_nss_non_ap;
static int hf_ieee80211_eht_rx_max_nss_20mhz_0_7;
static int hf_ieee80211_eht_tx_max_nss_20mhz_0_7;
static int hf_ieee80211_eht_rx_max_nss_20mhz_8_9;
static int hf_ieee80211_eht_tx_max_nss_20mhz_8_9;
static int hf_ieee80211_eht_rx_max_nss_20mhz_10_11;
static int hf_ieee80211_eht_tx_max_nss_20mhz_10_11;
static int hf_ieee80211_eht_rx_max_nss_20mhz_12_13;
static int hf_ieee80211_eht_tx_max_nss_20mhz_12_13;
static int hf_ieee80211_eht_le_80_rx_max_nss_0_9;
static int hf_ieee80211_eht_le_80_tx_max_nss_0_9;
static int hf_ieee80211_eht_le_80_rx_max_nss_10_11;
static int hf_ieee80211_eht_le_80_tx_max_nss_10_11;
static int hf_ieee80211_eht_le_80_rx_max_nss_12_13;
static int hf_ieee80211_eht_le_80_tx_max_nss_12_13;
static int hf_ieee80211_eht_160_rx_max_nss_0_9;
static int hf_ieee80211_eht_160_tx_max_nss_0_9;
static int hf_ieee80211_eht_160_rx_max_nss_10_11;
static int hf_ieee80211_eht_160_tx_max_nss_10_11;
static int hf_ieee80211_eht_160_rx_max_nss_12_13;
static int hf_ieee80211_eht_160_tx_max_nss_12_13;
static int hf_ieee80211_eht_320_rx_max_nss_0_9;
static int hf_ieee80211_eht_320_tx_max_nss_0_9;
static int hf_ieee80211_eht_320_rx_max_nss_10_11;
static int hf_ieee80211_eht_320_tx_max_nss_10_11;
static int hf_ieee80211_eht_320_rx_max_nss_12_13;
static int hf_ieee80211_eht_320_tx_max_nss_12_13;
static int hf_ieee80211_eht_mcs_and_nss_le_80mhz;
static int hf_ieee80211_eht_mcs_and_nss_eq_160mhz;
static int hf_ieee80211_eht_mcs_and_nss_eq_320mhz;
static int hf_ieee80211_eht_ppe_thresholds;
static int hf_ieee80211_eht_ttl_mapping_control;
static int hf_ieee80211_eht_ttl_mapping_direction;
static int hf_ieee80211_eht_ttl_default_link_mapping;
static int hf_ieee80211_eht_ttl_mapping_switch_time_pres;
static int hf_ieee80211_eht_ttl_expected_dura_pres;
static int hf_ieee80211_eht_ttl_link_mapping_size;
static int hf_ieee80211_eht_ttl_mapping_reserved;
static int hf_ieee80211_eht_ttl_mapping_presence;
static int hf_ieee80211_eht_ttl_mapping_switch_time;
static int hf_ieee80211_eht_ttl_mapping_expected_duration;
static int hf_ieee80211_eht_ttl_mapping_tid_0_link_mapping;
static int hf_ieee80211_eht_ttl_mapping_tid_1_link_mapping;
static int hf_ieee80211_eht_ttl_mapping_tid_2_link_mapping;
static int hf_ieee80211_eht_ttl_mapping_tid_3_link_mapping;
static int hf_ieee80211_eht_ttl_mapping_tid_4_link_mapping;
static int hf_ieee80211_eht_ttl_mapping_tid_5_link_mapping;
static int hf_ieee80211_eht_ttl_mapping_tid_6_link_mapping;
static int hf_ieee80211_eht_ttl_mapping_tid_7_link_mapping;
static int hf_ieee80211_eht_multi_link_traffic_control;
static int hf_ieee80211_eht_multi_link_tc_bitmap_size;
static int hf_ieee80211_eht_multi_link_tc_aid_offset;
static int hf_ieee80211_eht_multi_link_tc_reserved;
static int hf_ieee80211_eht_multi_link_traffic_indication;
static int hf_ieee80211_eht_qos_chars_dirn;
static int hf_ieee80211_eht_qos_chars_tid;
static int hf_ieee80211_eht_qos_chars_user_prio;
static int hf_ieee80211_eht_qos_chars_bitmap;
static int hf_ieee80211_eht_qos_chars_linkid;
static int hf_ieee80211_eht_qos_chars_resrvd;
static int hf_ieee80211_eht_qos_chars_min_svc_interval;
static int hf_ieee80211_eht_qos_chars_max_svc_interval;
static int hf_ieee80211_eht_qos_chars_min_data_rate;
static int hf_ieee80211_eht_qos_chars_delay_bound;
static int hf_ieee80211_eht_qos_chars_max_msdu_size;
static int hf_ieee80211_eht_qos_chars_service_start_time;
static int hf_ieee80211_eht_qos_chars_service_start_time_linkid;
static int hf_ieee80211_eht_qos_chars_mean_data_rate;
static int hf_ieee80211_eht_qos_chars_burst_size;
static int hf_ieee80211_eht_qos_chars_msdu_lifetime;
static int hf_ieee80211_eht_qos_chars_msdu_delivery_ratio;
static int hf_ieee80211_eht_qos_chars_msdu_count_exponent;
static int hf_ieee80211_eht_qos_chars_medium_time;
static int hf_ieee80211_eht_link_id_bitmap;
static int hf_ieee80211_eht_aid_bitmap_length;
static int hf_ieee80211_eht_aid_bitmap_control;
static int hf_ieee80211_eht_aid_bitmap_control_reserved;
static int hf_ieee80211_eht_aid_bitmap_control_offset;
static int hf_ieee80211_eht_aid_bitmap_partial_aid_bitmap;
static int hf_ieee80211_eht_aid_bitmap_aid;
static int hf_ieee80211_eht_bw_indi_param;
static int hf_ieee80211_eht_bw_indi_param_reserved;
static int hf_ieee80211_eht_bw_indi_param_disabled_subchan_bitmap;
static int hf_ieee80211_eht_bw_indi_param_reserved1;
static int hf_ieee80211_eht_bw_indi_diabled_bitmap;
static int hf_ieee80211_eht_mimo_ctrl_field;
static int hf_ieee80211_eht_mimo_ctrl_nc_index;
static int hf_ieee80211_eht_mimo_ctrl_nr_index;
static int hf_ieee80211_eht_mimo_ctrl_bw;
static int hf_ieee80211_eht_mimo_ctrl_grouping;
static int hf_ieee80211_eht_mimo_ctrl_feedback_type;
static int hf_ieee80211_eht_mimo_ctrl_reserved1;
static int hf_ieee80211_eht_mimo_ctrl_remaining_feedback_segments;
static int hf_ieee80211_eht_mimo_ctrl_first_feedback_segment;
static int hf_ieee80211_eht_mimo_ctrl_partial_bw_info;
static int hf_ieee80211_eht_mimo_ctrl_sounding_dialog_token_number;
static int hf_ieee80211_eht_mimo_ctrl_codebook_info;
static int hf_ieee80211_eht_mimo_ctrl_reserved2;

/* be: Compressed beamforming report etc */
static int hf_ieee80211_eht_compressed_beamforming_report_snr;
static int hf_ieee80211_eht_compressed_beamform_scidx;

/* be: MU Exclusive beamforming report */
static int hf_ieee80211_eht_mu_exclusive_beamforming_report_delta_snr;

static int hf_ieee80211_eht_eml_control_field;
static int hf_ieee80211_eht_eml_control_emlsr_mode;
static int hf_ieee80211_eht_eml_control_emlmr_mode;
static int hf_ieee80211_eht_eml_control_emlsr_para_update_control;
static int hf_ieee80211_eht_eml_control_device_coexist_activities;
static int hf_ieee80211_eht_eml_control_reserved;
static int hf_ieee80211_eht_eml_control_link_bitmap;
static int hf_ieee80211_eht_eml_control_link_enable_id;
static int hf_ieee80211_eht_eml_control_mcs_map_count;
static int hf_ieee80211_eht_eml_control_mcs_map_count_bw;
static int hf_ieee80211_eht_eml_control_mcs_map_count_reserved;
static int hf_ieee80211_eht_emlsr_para_update;
static int hf_ieee80211_eht_emlsr_para_update_padding_delay;
static int hf_ieee80211_eht_emlsr_para_update_tran_delay;
static int hf_ieee80211_eht_emlsr_para_update_reserved;

static int hf_ieee80211_ff_ant_selection;
static int hf_ieee80211_ff_ant_selection_0;
static int hf_ieee80211_ff_ant_selection_1;
static int hf_ieee80211_ff_ant_selection_2;
static int hf_ieee80211_ff_ant_selection_3;
static int hf_ieee80211_ff_ant_selection_4;
static int hf_ieee80211_ff_ant_selection_5;
static int hf_ieee80211_ff_ant_selection_6;
static int hf_ieee80211_ff_ant_selection_7;

static int * const ieee80211_ff_ant_selection_fields[] = {
  &hf_ieee80211_ff_ant_selection_0,
  &hf_ieee80211_ff_ant_selection_1,
  &hf_ieee80211_ff_ant_selection_2,
  &hf_ieee80211_ff_ant_selection_3,
  &hf_ieee80211_ff_ant_selection_4,
  &hf_ieee80211_ff_ant_selection_5,
  &hf_ieee80211_ff_ant_selection_6,
  &hf_ieee80211_ff_ant_selection_7,
  NULL
};

static int hf_ieee80211_ff_ext_channel_switch_announcement;
static int hf_ieee80211_ff_ext_channel_switch_announcement_switch_mode;
static int hf_ieee80211_ff_ext_channel_switch_announcement_new_ope_class;
static int hf_ieee80211_ff_ext_channel_switch_announcement_new_chan_number;
static int hf_ieee80211_ff_ext_channel_switch_announcement_switch_count;

static int * const ieee80211_ff_ext_channel_switch_announcement_fields[] = {
  &hf_ieee80211_ff_ext_channel_switch_announcement_switch_mode,
  &hf_ieee80211_ff_ext_channel_switch_announcement_new_ope_class,
  &hf_ieee80211_ff_ext_channel_switch_announcement_new_chan_number,
  &hf_ieee80211_ff_ext_channel_switch_announcement_switch_count,
  NULL
};

static int hf_ieee80211_ff_ht_info;
static int hf_ieee80211_ff_ht_info_information_request;
static int hf_ieee80211_ff_ht_info_40_mhz_intolerant;
static int hf_ieee80211_ff_ht_info_sta_chan_width;
static int hf_ieee80211_ff_ht_info_reserved;

static int * const ieee80211_ff_ht_info_fields[] = {
  &hf_ieee80211_ff_ht_info_information_request,
  &hf_ieee80211_ff_ht_info_40_mhz_intolerant,
  &hf_ieee80211_ff_ht_info_sta_chan_width,
  &hf_ieee80211_ff_ht_info_reserved,
  NULL
};

static int hf_ieee80211_ff_ht_action;

static int hf_ieee80211_ff_psmp_sta_info;
static int hf_ieee80211_ff_psmp_sta_info_type;
static int hf_ieee80211_ff_psmp_sta_info_dtt_start_offset;
static int hf_ieee80211_ff_psmp_sta_info_dtt_duration;
static int hf_ieee80211_ff_psmp_sta_info_sta_id;
static int hf_ieee80211_ff_psmp_sta_info_utt_start_offset;
static int hf_ieee80211_ff_psmp_sta_info_utt_duration;
static int hf_ieee80211_ff_psmp_sta_info_reserved_small;
static int hf_ieee80211_ff_psmp_sta_info_reserved_large;
static int hf_ieee80211_ff_psmp_sta_info_psmp_multicast_id;

static int hf_ieee80211_ff_mimo_csi_snr;
static int hf_ieee80211_ff_mimo_csi_matrices;
static int hf_ieee80211_ff_mimo_csi_bf_matrices;
static int hf_ieee80211_ff_mimo_csi_cbf_matrices;

/*** Begin: 802.11s additions ***/
static int hf_ieee80211_mesh_control_field;

static int hf_ieee80211_ff_mesh_action;
static int hf_ieee80211_ff_multihop_action;
static int hf_ieee80211_ff_mesh_flags;
static int hf_ieee80211_ff_mesh_ttl;
static int hf_ieee80211_ff_mesh_sequence;
static int hf_ieee80211_ff_mesh_addr4;
static int hf_ieee80211_ff_mesh_addr5;
static int hf_ieee80211_ff_mesh_addr6;
static int hf_ieee80211_ff_selfprot_action;

static int hf_ieee80211_mesh_peering_proto;
static int hf_ieee80211_mesh_peering_local_link_id;
static int hf_ieee80211_mesh_peering_peer_link_id;

static int hf_ieee80211_ff_hwmp_flags;
static int hf_ieee80211_ff_hwmp_hopcount;
static int hf_ieee80211_ff_hwmp_ttl;
static int hf_ieee80211_ff_hwmp_pdid;
static int hf_ieee80211_ff_hwmp_orig_sta;
static int hf_ieee80211_ff_hwmp_orig_sn;
static int hf_ieee80211_ff_hwmp_orig_ext;
static int hf_ieee80211_ff_hwmp_lifetime;
static int hf_ieee80211_ff_hwmp_metric;
static int hf_ieee80211_ff_hwmp_targ_count;
static int hf_ieee80211_ff_hwmp_targ_flags;
static int hf_ieee80211_ff_hwmp_targ_to_flags;
static int hf_ieee80211_ff_hwmp_targ_usn_flags;
static int hf_ieee80211_ff_hwmp_targ_sta;
static int hf_ieee80211_ff_hwmp_targ_sn;
static int hf_ieee80211_ff_hwmp_targ_ext;
static int hf_ieee80211_rann_flags;
static int hf_ieee80211_rann_root_sta;
static int hf_ieee80211_rann_sn;
static int hf_ieee80211_rann_interval;

static int hf_ieee80211_mesh_channel_switch_ttl;
static int hf_ieee80211_mesh_channel_switch_flag;
static int hf_ieee80211_mesh_channel_switch_reason_code;
static int hf_ieee80211_mesh_channel_switch_precedence_value;
static int hf_ieee80211_mesh_chswitch_flag_txrestrict;
static int hf_ieee80211_mesh_chswitch_flag_initiator;

static int hf_ieee80211_mesh_config_path_sel_protocol;
static int hf_ieee80211_mesh_config_path_sel_metric;
static int hf_ieee80211_mesh_config_congestion_control;
static int hf_ieee80211_mesh_config_sync_method;
static int hf_ieee80211_mesh_config_auth_protocol;
static int hf_ieee80211_mesh_config_formation_info;
static int hf_ieee80211_mesh_config_capability;
static int hf_ieee80211_mesh_id;
static int hf_ieee80211_mesh_config_cap_accepting;
static int hf_ieee80211_mesh_config_cap_mcca_support;
static int hf_ieee80211_mesh_config_cap_mcca_enabled;
static int hf_ieee80211_mesh_config_cap_forwarding;
static int hf_ieee80211_mesh_config_cap_mbca_enabled;
static int hf_ieee80211_mesh_config_cap_tbtt_adjusting;
static int hf_ieee80211_mesh_config_cap_power_save_level;
static int hf_ieee80211_mesh_config_cap_reserved;
static int hf_ieee80211_mesh_form_info_conn_to_mesh_gate;
static int hf_ieee80211_mesh_form_info_num_of_peerings;
static int hf_ieee80211_mesh_form_info_conn_to_as;
static int hf_ieee80211_mesh_awake_window;
static int hf_ieee80211_mesh_mic;
static int hf_ieee80211_mesh_ampe_encrypted_data;

static int hf_ieee80211_bcn_timing_rctrl;
static int hf_ieee80211_bcn_timing_rctrl_more;
static int hf_ieee80211_bcn_timing_rctrl_element_num;
static int hf_ieee80211_bcn_timing_rctrl_status_num;
static int hf_ieee80211_bcn_timing_info;
static int hf_ieee80211_bcn_timing_info_nsta_id;
static int hf_ieee80211_bcn_timing_info_nsta_tbtt;
static int hf_ieee80211_bcn_timing_info_nsta_bi;

static int hf_ieee80211_gann_flags;
static int hf_ieee80211_gann_flags_reserved;
static int hf_ieee80211_gann_hop_count;
static int hf_ieee80211_gann_elem_ttl;
static int hf_ieee80211_gann_mesh_gate_addr;
static int hf_ieee80211_gann_seq_num;
static int hf_ieee80211_gann_interval;

static int hf_ieee80211_pxu_pxu_id;
static int hf_ieee80211_pxu_pxu_origin_mac;
static int hf_ieee80211_pxu_no_proxy_info;
static int hf_ieee80211_pxu_proxy_info;
static int hf_ieee80211_pxu_proxy_info_flags;
static int hf_ieee80211_pxu_proxy_info_flags_delete;
static int hf_ieee80211_pxu_proxy_info_flags_orig_is_proxy;
static int hf_ieee80211_pxu_proxy_info_flags_lifetime;
static int hf_ieee80211_pxu_proxy_info_flags_reserved;
static int hf_ieee80211_pxu_proxy_info_ext_mac;
static int hf_ieee80211_pxu_proxy_info_seq_num;
static int hf_ieee80211_pxu_proxy_info_proxy_mac;
static int hf_ieee80211_pxu_proxy_info_lifetime;

static int hf_ieee80211_pxuc_pxu_id;
static int hf_ieee80211_pxuc_pxu_recip_mac;

static int hf_ieee80211_ff_public_action;
static int hf_ieee80211_ff_protected_public_action;
static int hf_ieee80211_ff_tod;
static int hf_ieee80211_ff_toa;
static int hf_ieee80211_ff_max_tod_err;
static int hf_ieee80211_ff_max_toa_err;

/* ************************************************************************* */
/*            Flags found in the capability field (fixed field)              */
/* ************************************************************************* */
static int hf_ieee80211_ff_capture;
static int hf_ieee80211_ff_cf_ess;
static int hf_ieee80211_ff_cf_ibss;
static int hf_ieee80211_ff_cf_reserved1;
static int hf_ieee80211_ff_cf_reserved2;
static int hf_ieee80211_ff_cf_privacy;
static int hf_ieee80211_ff_cf_preamble;
static int hf_ieee80211_ff_cf_critical_update_flag;
static int hf_ieee80211_ff_cf_nontran_bss_critical_update_flag;
static int hf_ieee80211_ff_cf_spec_man;
static int hf_ieee80211_ff_cf_qos;
static int hf_ieee80211_ff_cf_short_slot_time;
static int hf_ieee80211_ff_cf_apsd;
static int hf_ieee80211_ff_cf_radio_measurement;
static int hf_ieee80211_ff_cf_epd;
static int hf_ieee80211_ff_cf_reserved5;
static int hf_ieee80211_ff_cf_reserved6;

/* ************************************************************************* */
/*                       A-MSDU fields                                       */
/* ************************************************************************* */
static int hf_ieee80211_amsdu_subframe;
static int hf_ieee80211_amsdu_length;
static int hf_ieee80211_amsdu_padding;

/* ************************************************************************* */
/*                       Tagged value format fields                          */
/* ************************************************************************* */
static int hf_ieee80211_tagged_parameters;  /* Tagged payload item */
static int hf_ieee80211_tag;
static int hf_ieee80211_tag_number;
static int hf_ieee80211_tag_length;
static int hf_ieee80211_tag_data;
static int hf_ieee80211_tag_oui;
static int hf_ieee80211_tag_oui_wfa_subtype;
static int hf_ieee80211_tag_oui_wfa_action_type;
static int hf_ieee80211_tag_ssid;
static int hf_ieee80211_tag_supp_rates;
static int hf_ieee80211_tag_fh_dwell_time;
static int hf_ieee80211_tag_fh_hop_set;
static int hf_ieee80211_tag_fh_hop_pattern;
static int hf_ieee80211_tag_fh_hop_index;
static int hf_ieee80211_tag_ds_param_channel;
static int hf_ieee80211_tag_cfp_count;
static int hf_ieee80211_tag_cfp_period;
static int hf_ieee80211_tag_cfp_max_duration;
static int hf_ieee80211_tag_cfp_dur_remaining;
static int hf_ieee80211_tim_dtim_count;
static int hf_ieee80211_tim_dtim_period;
static int hf_ieee80211_tim_bmapctl;
static int hf_ieee80211_tim_bmapctl_mcast;
static int hf_ieee80211_tim_bmapctl_offset;
static int hf_ieee80211_tim_partial_virtual_bitmap;
static int hf_ieee80211_tim_aid;
static int hf_ieee80211_tag_ibss_atim_window;
static int hf_ieee80211_tag_country_info_code;
static int hf_ieee80211_tag_country_info_env;
static int hf_ieee80211_tag_country_info_pad;
static int hf_ieee80211_tag_country_info_fnm;
static int hf_ieee80211_tag_country_info_fnm_fcn;
static int hf_ieee80211_tag_country_info_fnm_nc;
static int hf_ieee80211_tag_country_info_fnm_mtpl;
static int hf_ieee80211_tag_country_info_rrc;
static int hf_ieee80211_tag_country_info_rrc_oei;
static int hf_ieee80211_tag_country_info_rrc_oc;
static int hf_ieee80211_tag_country_info_rrc_cc;
static int hf_ieee80211_tag_fh_hopping_parameter_prime_radix;
static int hf_ieee80211_tag_fh_hopping_parameter_nb_channels;
static int hf_ieee80211_tag_fh_hopping_table_flag;
static int hf_ieee80211_tag_fh_hopping_table_number_of_sets;
static int hf_ieee80211_tag_fh_hopping_table_modulus;
static int hf_ieee80211_tag_fh_hopping_table_offset;
static int hf_ieee80211_tag_fh_hopping_random_table;
static int hf_ieee80211_tag_request;
static int hf_ieee80211_tag_extended_request_id;
static int hf_ieee80211_tag_extended_request_extension;
static int hf_ieee80211_tag_challenge_text;

static int hf_ieee80211_oui_qos_subtype;
static int hf_ieee80211_oui_qos_mgmt_dialog_token;
static int hf_ieee80211_oui_qos_mgmt_resp_control;
static int hf_ieee80211_oui_qos_mgmt_rsp_ctrl_more;
static int hf_ieee80211_oui_qos_mgmt_rsp_ctrl_reset;
static int hf_ieee80211_oui_qos_mgmt_rsp_reserved;
static int hf_ieee80211_oui_qos_mgmt_rqst_control;
static int hf_ieee80211_oui_qos_mgmt_rq_ctrl_more;
static int hf_ieee80211_oui_qos_mgmt_rq_ctrl_reset;
static int hf_ieee80211_oui_qos_mgmt_rq_reserved;
static int hf_ieee80211_oui_qos_mgmt_count;
static int hf_ieee80211_dscp_policy_id;
static int hf_ieee80211_dscp_policy_status;
static int hf_ieee80211_dscp_policy_scs_sts_list;

static int hf_ieee80211_tag_he_6ghz_cap_inf;
static int hf_ieee80211_tag_he_6ghz_cap_inf_b0_b2;
static int hf_ieee80211_tag_he_6ghz_cap_inf_b3_b5;
static int hf_ieee80211_tag_he_6ghz_cap_inf_b6_b7;
static int hf_ieee80211_tag_he_6ghz_cap_inf_b8;
static int hf_ieee80211_tag_he_6ghz_cap_inf_b9_b10;
static int hf_ieee80211_tag_he_6ghz_cap_inf_b11;
static int hf_ieee80211_tag_he_6ghz_cap_inf_b12;
static int hf_ieee80211_tag_he_6ghz_cap_inf_b13;
static int hf_ieee80211_tag_he_6ghz_cap_inf_b14_b15;

static int hf_ieee80211_tag_ftm_tsf_sync_info;

static int * const ieee80211_tag_he_6ghz_cap_inf[] = {
  &hf_ieee80211_tag_he_6ghz_cap_inf_b0_b2,
  &hf_ieee80211_tag_he_6ghz_cap_inf_b3_b5,
  &hf_ieee80211_tag_he_6ghz_cap_inf_b6_b7,
  &hf_ieee80211_tag_he_6ghz_cap_inf_b8,
  &hf_ieee80211_tag_he_6ghz_cap_inf_b9_b10,
  &hf_ieee80211_tag_he_6ghz_cap_inf_b11,
  &hf_ieee80211_tag_he_6ghz_cap_inf_b12,
  &hf_ieee80211_tag_he_6ghz_cap_inf_b13,
  &hf_ieee80211_tag_he_6ghz_cap_inf_b14_b15,
  NULL
};


static int hf_ieee80211_wep_iv;
static int hf_ieee80211_wep_iv_weak;
static int hf_ieee80211_tkip_extiv;
static int hf_ieee80211_ccmp_extiv;
static int hf_ieee80211_wep_key;
static int hf_ieee80211_wep_icv;
static int hf_ieee80211_fc_analysis_pmk;
static int hf_ieee80211_fc_analysis_kck;
static int hf_ieee80211_fc_analysis_kek;
static int hf_ieee80211_fc_analysis_tk;
static int hf_ieee80211_fc_analysis_gtk;

static int hf_ieee80211_block_ack_control;
static int hf_ieee80211_block_ack_control_ack_policy;
static int hf_ieee80211_block_ack_control_type;
static int hf_ieee80211_block_ack_control_reserved;
static int hf_ieee80211_block_ack_control_tid_info;

static int hf_ieee80211_block_ack_multi_tid_reserved;
static int hf_ieee80211_block_ack_multi_tid_value;
static int hf_ieee80211_block_ack_bitmap;
static int hf_ieee80211_block_ack_bitmap_missing_frame;
static int hf_ieee80211_block_ack_gcr_addr;

static int hf_ieee80211_block_ack_multi_sta_aid11;
static int hf_ieee80211_block_ack_multi_sta_ack_type;
static int hf_ieee80211_block_ack_multi_sta_tid;
static int hf_ieee80211_block_ack_multi_sta_aid_tid;
static int hf_ieee80211_block_ack_multi_sta_reserved;
static int hf_ieee80211_block_ack_multi_sta_ra;

static int hf_ieee80211_tag_measure_request_measurement_mode;
static int hf_ieee80211_tag_measure_request_bssid;

static int hf_ieee80211_tag_measure_request_subelement_length;
static int hf_ieee80211_tag_measure_request_beacon_sub_id;
static int hf_ieee80211_tag_measure_request_beacon_sub_ssid;
static int hf_ieee80211_tag_measure_request_beacon_sub_bri_reporting_condition;
static int hf_ieee80211_tag_measure_request_beacon_sub_bri_threshold_offset;
static int hf_ieee80211_tag_measure_request_beacon_sub_reporting_detail;
static int hf_ieee80211_tag_measure_request_beacon_sub_last_report_indication_request;
static int hf_ieee80211_tag_measure_request_beacon_unknown;

static int hf_ieee80211_tag_measure_request_channel_load_sub_id;
static int hf_ieee80211_tag_measure_request_channel_load_sub_reporting_condition;
static int hf_ieee80211_tag_measure_request_channel_load_sub_reporting_ref;

static int hf_ieee80211_tag_measure_request_noise_histogram_sub_id;
static int hf_ieee80211_tag_measure_request_noise_histogram_sub_reporting_condition;
static int hf_ieee80211_tag_measure_request_noise_histogram_sub_reporting_anpi_ref;

static int hf_ieee80211_tag_measure_request_frame_request_type;
static int hf_ieee80211_tag_measure_request_mac_address;
static int hf_ieee80211_tag_measure_request_peer_mac_address;
static int hf_ieee80211_tag_measure_request_group_id;

static int hf_ieee80211_tag_measure_request_location_subject;
static int hf_ieee80211_tag_measure_request_civic_location_type;
static int hf_ieee80211_tag_measure_request_location_service_interval_units;
static int hf_ieee80211_tag_measure_request_location_service_interval;

static int hf_ieee80211_tag_measure_request_unknown;

static int hf_ieee80211_ht_pren_type;
static int hf_ieee80211_ht_pren_unknown;

static int hf_ieee80211_ht_cap;
static int hf_ieee80211_ht_vs_cap;
static int hf_ieee80211_ht_ldpc_coding;
static int hf_ieee80211_ht_chan_width;
static int hf_ieee80211_ht_sm_pwsave;
static int hf_ieee80211_ht_green;
static int hf_ieee80211_ht_short20;
static int hf_ieee80211_ht_short40;
static int hf_ieee80211_ht_tx_stbc;
static int hf_ieee80211_ht_rx_stbc;
static int hf_ieee80211_ht_delayed_block_ack;
static int hf_ieee80211_ht_max_amsdu;
static int hf_ieee80211_ht_dss_cck_40;
static int hf_ieee80211_ht_psmp;
static int hf_ieee80211_ht_40_mhz_intolerant;
static int hf_ieee80211_ht_l_sig;

static int hf_ieee80211_ext_bss_mu_mimo_capable_sta_count;
static int hf_ieee80211_ext_bss_ss_underutilization;
static int hf_ieee80211_ext_bss_observable_sec_20mhz_utilization;
static int hf_ieee80211_ext_bss_observable_sec_40mhz_utilization;
static int hf_ieee80211_ext_bss_observable_sec_80mhz_utilization;
static int hf_ieee80211_wide_bw_new_channel_width;
static int hf_ieee80211_wide_bw_new_channel_center_freq_segment0;
static int hf_ieee80211_wide_bw_new_channel_center_freq_segment1;

static int hf_ieee80211_operat_notification_mode;
static int hf_ieee80211_operat_mode_field_channel_width;
static int hf_ieee80211_operat_mode_field_reserved;
static int hf_ieee80211_operat_mode_field_rxnss;
static int hf_ieee80211_operat_mode_field_rxnsstype;

static int hf_ieee80211_tbtt_info;
static int hf_ieee80211_tbtt_filtered_nap;
static int hf_ieee80211_tbtt_info_count;
static int hf_ieee80211_tbtt_info_length;

static int hf_ieee80211_tbtt_operating_class;
static int hf_ieee80211_tbtt_channel_number;

static int hf_ieee80211_tbtt_offset;
static int hf_ieee80211_tbtt_bssid;
static int hf_ieee80211_tbtt_short_ssid;
static int hf_ieee80211_rnr_bss_params;
static int hf_ieee80211_rnr_oct_recommended;
static int hf_ieee80211_rnr_same_ssid;
static int hf_ieee80211_rnr_multiple_bssid;
static int hf_ieee80211_rnr_transmitted_bssid;
static int hf_ieee80211_rnr_ess_with_colocated_ap;
static int hf_ieee80211_rnr_unsolicited_probe_responses;
static int hf_ieee80211_rnr_same_colocated_ap;
static int hf_ieee80211_rnr_same_reserved;
static int hf_ieee80211_rnr_20mhz_psd_subfield;
static int hf_ieee80211_rnr_reserved_data;
static int hf_ieee80211_rnr_mld_params;
static int hf_ieee80211_rnr_mld_id;
static int hf_ieee80211_rnr_mld_link_id;
static int hf_ieee80211_rnr_mld_bss_params_change_count;
static int hf_ieee80211_rnr_mld_all_updates_included;
static int hf_ieee80211_rnr_mld_disabled_link_indication;
static int hf_ieee80211_rnr_mld_reserved;

static int hf_ieee80211_ampduparam;
static int hf_ieee80211_ampduparam_vs;
static int hf_ieee80211_ampduparam_mpdu;
static int hf_ieee80211_ampduparam_mpdu_start_spacing;
static int hf_ieee80211_ampduparam_reserved;

static int hf_ieee80211_beacon_sequence;
static int hf_ieee80211_pentapartial_timestamp;
static int hf_ieee80211_tack_next_twt_info;
static int hf_ieee80211_tack_next_twt;
static int hf_ieee80211_tack_flow_identifier;

static int hf_ieee80211_ff_s1g_action;
static int hf_ieee80211_ff_prot_s1g_action;
static int hf_ieee80211_ff_s1g_timestamp;
static int hf_ieee80211_ff_s1g_change_sequence;
static int hf_ieee80211_ff_s1g_next_tbtt;
static int hf_ieee80211_ff_s1g_compressed_ssid;
static int hf_ieee80211_ff_s1g_access_network_options;

static int hf_ieee80211_s1g_sync_control;
static int hf_ieee80211_s1g_sync_control_uplink_sync_request;
static int hf_ieee80211_s1g_sync_control_time_slot_protection_request;
static int hf_ieee80211_s1g_sync_control_reserved;

static int hf_ieee80211_s1g_sector_id_index;
static int hf_ieee80211_s1g_sector_id_preferred_sector_id;
static int hf_ieee80211_s1g_sector_id_snr;
static int hf_ieee80211_s1g_sector_id_receive_sector_bitmap;

static int hf_ieee80211_s1g_twt_information_control;
static int hf_ieee80211_s1g_twt_flow_identifier;
static int hf_ieee80211_s1g_twt_response_required;
static int hf_ieee80211_s1g_twt_next_twt_request;
static int hf_ieee80211_s1g_twt_next_twt_subfield_size;
static int hf_ieee80211_s1g_twt_reserved;
static int hf_ieee80211_s1g_twt_next_twt_32;
static int hf_ieee80211_s1g_twt_next_twt_48;
static int hf_ieee80211_s1g_twt_next_twt_64;

static int hf_ieee80211_s1g_update_edca_info;
static int hf_ieee80211_s1g_update_edca_override;
static int hf_ieee80211_s1g_update_edca_ps_poll_aci;
static int hf_ieee80211_s1g_update_edca_raw_aci;
static int hf_ieee80211_s1g_update_edca_sta_type;
static int hf_ieee80211_s1g_update_edca_reserved;

static int hf_ieee80211_s1g_cap_byte1;
static int hf_ieee80211_s1g_cap_byte2;
static int hf_ieee80211_s1g_cap_byte3;
static int hf_ieee80211_s1g_cap_byte4;
static int hf_ieee80211_s1g_cap_byte5;
static int hf_ieee80211_s1g_cap_byte6;
static int hf_ieee80211_s1g_cap_byte7;
static int hf_ieee80211_s1g_cap_byte8;
static int hf_ieee80211_s1g_cap_byte9;
static int hf_ieee80211_s1g_cap_byte10;
static int hf_ieee80211_s1g_cap_s1g_long_support;
static int hf_ieee80211_s1g_cap_short_gi_for_1_mhz;
static int hf_ieee80211_s1g_cap_short_gi_for_2_mhz;
static int hf_ieee80211_s1g_cap_short_gi_for_4_mhz;
static int hf_ieee80211_s1g_cap_short_gi_for_8_mhz;
static int hf_ieee80211_s1g_cap_short_gi_for_16_mhz;
static int hf_ieee80211_s1g_cap_supported_channel_width;
static int hf_ieee80211_s1g_cap_rx_lpdc;
static int hf_ieee80211_s1g_cap_tx_stbc;
static int hf_ieee80211_s1g_cap_rx_stbc;
static int hf_ieee80211_s1g_cap_su_beamformer_capable;
static int hf_ieee80211_s1g_cap_su_beamformee_capable;
static int hf_ieee80211_s1g_cap_beamformee_sts_capability;
static int hf_ieee80211_s1g_cap_number_sounding_dimensions;
static int hf_ieee80211_s1g_cap_mu_beamformer_capable;
static int hf_ieee80211_s1g_cap_mu_beamformee_capable;
static int hf_ieee80211_s1g_cap_htc_vht_capable;
static int hf_ieee80211_s1g_cap_travelling_pilot_support;
static int hf_ieee80211_s1g_cap_rd_responder;
static int hf_ieee80211_s1g_cap_ht_delayed_block_ack;
static int hf_ieee80211_s1g_cap_maximum_mpdu_length;
static int hf_ieee80211_s1g_cap_maximum_a_mpdu_length_exp;
static int hf_ieee80211_s1g_cap_minimum_mpdu_start_spacing;
static int hf_ieee80211_s1g_cap_uplink_sync_capable;
static int hf_ieee80211_s1g_cap_dynamic_aid;
static int hf_ieee80211_s1g_cap_bat_support;
static int hf_ieee80211_s1g_cap_tim_ade_support;
static int hf_ieee80211_s1g_cap_non_tim_support;
static int hf_ieee80211_s1g_cap_group_aid_support;
static int hf_ieee80211_s1g_cap_sta_type_support;
static int hf_ieee80211_s1g_cap_centralized_authentication_control;
static int hf_ieee80211_s1g_cap_distributed_authentication_control;
static int hf_ieee80211_s1g_cap_a_msdu_support;
static int hf_ieee80211_s1g_cap_a_mpdu_support;
static int hf_ieee80211_s1g_cap_asymmetic_block_ack_support;
static int hf_ieee80211_s1g_cap_flow_control_support;
static int hf_ieee80211_s1g_cap_sectorized_beam_capable;
static int hf_ieee80211_s1g_cap_obss_mitigation_support;
static int hf_ieee80211_s1g_cap_fragment_ba_support;
static int hf_ieee80211_s1g_cap_ndp_ps_poll_supported;
static int hf_ieee80211_s1g_cap_raw_operation_support;
static int hf_ieee80211_s1g_cap_page_slicing_support;
static int hf_ieee80211_s1g_cap_txop_sharing_implicit_ack_support;
static int hf_ieee80211_s1g_cap_vht_link_adaptation_capable;
static int hf_ieee80211_s1g_cap_tack_support_as_ps_poll_response;
static int hf_ieee80211_s1g_cap_duplicate_1_mhz_support;
static int hf_ieee80211_s1g_cap_mcs_negotiation_support;
static int hf_ieee80211_s1g_cap_1_mhz_control_response_preamble_support;
static int hf_ieee80211_s1g_cap_ndp_beamforming_report_poll_support;
static int hf_ieee80211_s1g_cap_unsolicited_dynamic_aid;
static int hf_ieee80211_s1g_cap_sector_training_operation_supported;
static int hf_ieee80211_s1g_cap_temporary_ps_mode_switch;
static int hf_ieee80211_s1g_cap_twt_grouping_support;
static int hf_ieee80211_s1g_cap_bdt_capable;
static int hf_ieee80211_s1g_cap_color;
static int hf_ieee80211_s1g_cap_twt_requester_support;
static int hf_ieee80211_s1g_cap_twt_responder_support;
static int hf_ieee80211_s1g_cap_pv1_frame_support;
static int hf_ieee80211_s1g_cap_link_adaptation_per_normal_control_response_capable;
static int hf_ieee80211_s1g_cap_reserved;
static int hf_ieee80211_s1g_mcs_and_nss_set;
static int hf_ieee80211_s1g_rx_s1g_mcs_map;
static int hf_ieee80211_s1g_rx_highest_supported_long_gi_data_rate;
static int hf_ieee80211_s1g_tx_s1g_mcs_map;
static int hf_ieee80211_s1g_tx_highest_supported_long_gi_data_rate;
static int hf_ieee80211_s1g_rx_single_spatial_stream_map_for_1_mhz;
static int hf_ieee80211_s1g_tx_single_spatial_stream_map_for_1_mhz;
static int hf_ieee80211_s1g_mcs_and_nss_reserved;
static int hf_ieee80211_s1g_subchannel_selective_transmission;
static int hf_ieee80211_s1g_sst_sounding_option;
static int hf_ieee80211_s1g_channel_activity_bitmap;
static int hf_ieee80211_s1g_ul_activity;
static int hf_ieee80211_s1g_dl_activity;
static int hf_ieee80211_s1g_max_trans_width;
static int hf_ieee80211_s1g_activity_start_time;
static int hf_ieee80211_s1g_sst_sounding_option1;
static int hf_ieee80211_s1g_channel_activity_bitmap1;
static int hf_ieee80211_s1g_sounding_start_time_present;
static int hf_ieee80211_s1g_channel_activity_reserved;
static int hf_ieee80211_s1g_max_trans_width1;
static int hf_ieee80211_s1g_sounding_start_time;
static int hf_ieee80211_s1g_open_loop_link_margin;
static int hf_ieee80211_s1g_raw_control;
static int hf_ieee80211_s1g_raw_type;
static int hf_ieee80211_s1g_raw_type_options;
static int hf_ieee80211_s1g_raw_start_time_indication;
static int hf_ieee80211_s1g_raw_raw_group_indication;
static int hf_ieee80211_s1g_raw_channel_indication_preference;
static int hf_ieee80211_s1g_raw_periodic_raw_indication;
static int hf_ieee80211_s1g_raw_slot_def;
static int hf_ieee80211_s1g_slot_def_format_indication;
static int hf_ieee80211_s1g_slot_def_cross_slot_boundary;
static int hf_ieee80211_s1g_slot_def_slot_duration_count8;
static int hf_ieee80211_s1g_slot_def_num_slots6;
static int hf_ieee80211_s1g_slot_def_slot_duration_count11;
static int hf_ieee80211_s1g_slot_def_num_slots3;
static int hf_ieee80211_s1g_raw_start_time;
static int hf_ieee80211_s1g_raw_group_subfield;
static int hf_ieee80211_s1g_raw_group_page_index;
static int hf_ieee80211_s1g_raw_group_start_aid;
static int hf_ieee80211_s1g_raw_group_end_aid;
static int hf_ieee80211_s1g_raw_channel_indication;
static int hf_ieee80211_s1g_raw_ci_channel_activity_bitmap;
static int hf_ieee80211_s1g_raw_ci_max_trans_width;
static int hf_ieee80211_s1g_raw_ci_ul_activity;
static int hf_ieee80211_s1g_raw_ci_dl_activity;
static int hf_ieee80211_s1g_raw_ci_reserved;
static int hf_ieee80211_s1g_raw_praw_periodicity;
static int hf_ieee80211_s1g_raw_praw_validity;
static int hf_ieee80211_s1g_raw_praw_start_offset;
static int hf_ieee80211_s1g_page_slice_page_period;
static int hf_ieee80211_s1g_page_slice_control;
static int hf_ieee80211_s1g_page_slice_page_index;
static int hf_ieee80211_s1g_page_slice_page_slice_length;
static int hf_ieee80211_s1g_page_slice_page_slice_count;
static int hf_ieee80211_s1g_page_slice_block_offset;
static int hf_ieee80211_s1g_page_slice_tim_offset;
static int hf_ieee80211_s1g_page_slice_reserved;
static int hf_ieee80211_s1g_page_slice_page_bitmap;
static int hf_ieee80211_s1g_aid_request_mode;
static int hf_ieee80211_s1g_aid_request_interval_present;
static int hf_ieee80211_s1g_aid_request_per_sta_address_present;
static int hf_ieee80211_s1g_aid_request_service_characteristic_present;
static int hf_ieee80211_s1g_aid_request_non_tim_mode_switch;
static int hf_ieee80211_s1g_aid_request_tim_mode_switch;
static int hf_ieee80211_s1g_aid_request_group_address_present;
static int hf_ieee80211_s1g_aid_request_reserved;
static int hf_ieee80211_s1g_aid_request_interval;
static int hf_ieee80211_s1g_aid_request_characteristic_sensor;
static int hf_ieee80211_s1g_aid_request_characteristic_offload;
static int hf_ieee80211_s1g_aid_request_characteristic_official_service;
static int hf_ieee80211_s1g_aid_request_characteristic_reserved;
static int hf_ieee80211_s1g_aid_req_peer_sta_addr;
static int hf_ieee80211_s1g_aid_request_characteristic;
static int hf_ieee80211_s1g_aid_req_group_addr;
static int hf_ieee80211_s1g_aid_rsp_aid_group_aid;
static int hf_ieee80211_s1g_aid_rsp_aid_switch_count;
static int hf_ieee80211_s1g_aid_rsp_aid_response_interval;
static int hf_ieee80211_s1g_sector_op_control_16b;
static int hf_ieee80211_s1g_sector_op_sectorization_type_b16;
static int hf_ieee80211_s1g_sector_op_periodic_training_indicator;
static int hf_ieee80211_s1g_sector_op_training_period;
static int hf_ieee80211_s1g_sector_op_remaining_beacon_interval;
static int hf_ieee80211_s1g_sector_op_reserved_b16;
static int hf_ieee80211_s1g_sector_op_control;
static int hf_ieee80211_s1g_sector_op_sectorization_type;
static int hf_ieee80211_s1g_sector_op_period;
static int hf_ieee80211_s1g_sector_op_omni;
static int hf_ieee80211_s1g_sector_op_group_info;
static int hf_ieee80211_s1g_short_beacon_interval;
static int hf_ieee80211_s1g_change_sequence;
static int hf_ieee80211_s1g_auth_control_control;
static int hf_ieee80211_s1g_auth_control_deferral;
static int hf_ieee80211_s1g_auth_control_reserved;
static int hf_ieee80211_s1g_auth_control_thresh;
static int hf_ieee80211_s1g_auth_control_thresh_tus;
static int hf_ieee80211_s1g_auth_slot_duration;
static int hf_ieee80211_s1g_auth_max_trans_int;
static int hf_ieee80211_s1g_auth_min_trans_int;
static int hf_ieee80211_s1g_tsf_timer_accuracy;
static int hf_ieee80211_s1g_relay_control;
static int hf_ieee80211_s1g_relay_control_rootap_bssid;
static int hf_ieee80211_s1g_relay_function_activation_mode;
static int hf_ieee80211_s1g_relay_function_direction;
static int hf_ieee80211_s1g_relay_function_enable_relay_function;
static int hf_ieee80211_s1g_relay_function_stas_present_indic;
static int hf_ieee80211_s1g_relay_function_reserved;
static int hf_ieee80211_s1g_number_of_stas;
static int hf_ieee80211_s1g_initiator_mac_address;
static int hf_ieee80211_s1g_address_count;
static int hf_ieee80211_s1g_reachable_add_remove;
static int hf_ieee80211_s1g_reachable_relay_capable;
static int hf_ieee80211_s1g_reachable_reserved;
static int hf_ieee80211_s1g_reachable_mac_address;
static int hf_ieee80211_s1g_relay_discovery_control;
static int hf_ieee80211_s1g_min_data_rate_included;
static int hf_ieee80211_s1g_mean_data_rate_included;
static int hf_ieee80211_s1g_max_data_rate_included;
static int hf_ieee80211_s1g_delay_and_min_phy_rate;
static int hf_ieee80211_s1g_information_not_available;
static int hf_ieee80211_s1g_relay_discovery_reserved;
static int hf_ieee80211_s1g_relay_control_ul_min;
static int hf_ieee80211_s1g_relay_control_ul_mean;
static int hf_ieee80211_s1g_relay_control_ul_max;
static int hf_ieee80211_s1g_relay_control_dl_min;
static int hf_ieee80211_s1g_relay_control_dl_mean;
static int hf_ieee80211_s1g_relay_control_dl_max;
static int hf_ieee80211_s1g_relay_hierarchy_identifier;
static int hf_ieee80211_s1g_relay_no_more_relay_flag;
static int hf_ieee80211_s1g_aid_entry_mac_addr;
static int hf_ieee80211_s1g_aid_entry_assoc_id;
static int hf_ieee80211_s1g_beacon_compatibility_info;
static int hf_ieee80211_s1g_beacon_interval;
static int hf_ieee80211_s1g_tsf_completion;
static int hf_ieee80211_s1g_channel_width;
static int hf_ieee80211_s1g_primary_channel_width;
static int hf_ieee80211_s1g_bss_operating_channel_width;
static int hf_ieee80211_s1g_primary_channel_location;
static int hf_ieee80211_s1g_reserved_b6;
static int hf_ieee80211_s1g_mcs10_use;
static int hf_ieee80211_s1g_operating_class;
static int hf_ieee80211_s1g_primary_channel_number;
static int hf_ieee80211_s1g_channel_center_frequency;
static int hf_ieee80211_s1g_basic_mcs_and_nss_set;
static int hf_ieee80211_s1g_sst_enabled_channel_bitmap;
static int hf_ieee80211_s1g_sst_primary_channel_offset;
static int hf_ieee80211_s1g_sst_channel_unit;
static int hf_ieee80211_s1g_sst_reserved;
static int hf_ieee80211_s1g_max_away_duration;
static int hf_ieee80211_s1g_tim_bmapctrl;
static int hf_ieee80211_s1g_tim_bmapctl_traffic_indicator;
static int hf_ieee80211_s1g_tim_page_slice_number;
static int hf_ieee80211_s1g_tim_page_index;
static int hf_ieee80211_s1g_pvb_block_control_byte;
static int hf_ieee80211_s1g_pvb_encoding_mode;
static int hf_ieee80211_s1g_pvb_inverse_bitmap;
static int hf_ieee80211_s1g_pvb_block_offset;
static int hf_ieee80211_s1g_block_bitmap;
static int hf_ieee80211_s1g_block_bitmap_sta_aid13;
static int hf_ieee80211_s1g_block_bitmap_single_aid;
static int hf_ieee80211_s1g_block_bitmap_olb_length;
static int hf_ieee80211_s1g_block_bitmap_ade;
static int hf_ieee80211_s1g_block_bitmap_ewl;
static int hf_ieee80211_s1g_block_bitmap_len;
static int hf_ieee80211_s1g_block_bitmap_ade_bytes;
static int hf_ieee80211_s1g_probe_response_group_bitmap;
static int hf_ieee80211_s1g_probe_resp_subfield_0;
static int hf_ieee80211_pv1_probe_response_req_full_ssid;
static int hf_ieee80211_pv1_probe_response_req_next_tbtt;
static int hf_ieee80211_pv1_probe_response_req_access_network_option;
static int hf_ieee80211_pv1_probe_response_req_s1g_beacon_compatibility;
static int hf_ieee80211_pv1_probe_response_req_supported_rates;
static int hf_ieee80211_pv1_probe_response_req_s1g_capability;
static int hf_ieee80211_pv1_probe_response_req_s1g_operation;
static int hf_ieee80211_pv1_probe_response_req_rsn;
static int hf_ieee80211_s1g_el_op_max_awake_duration;
static int hf_ieee80211_s1g_el_op_recovery_time_duration;
static int hf_ieee80211_s1g_sectorized_group_id_list;
static int hf_ieee80211_s1g_header_comp_control;
static int hf_ieee80211_s1g_header_comp_req_resp;
static int hf_ieee80211_s1g_header_comp_store_a3;
static int hf_ieee80211_s1g_header_comp_store_a4;
static int hf_ieee80211_s1g_header_comp_ccmp_update_present;
static int hf_ieee80211_s1g_header_comp_pv1_data_type_3_supported;
static int hf_ieee80211_s1g_header_comp_reserved;
static int hf_ieee80211_s1g_header_comp_a3;
static int hf_ieee80211_s1g_header_comp_a4;
static int hf_ieee80211_s1g_header_comp_ccmp_update;

static int hf_ieee80211_mcsset;
static int hf_ieee80211_mcsset_vs;
static int hf_ieee80211_mcsset_rx_bitmask;
static int hf_ieee80211_mcsset_rx_bitmask_0to7;
static int hf_ieee80211_mcsset_rx_bitmask_8to15;
static int hf_ieee80211_mcsset_rx_bitmask_16to23;
static int hf_ieee80211_mcsset_rx_bitmask_24to31;
static int hf_ieee80211_mcsset_rx_bitmask_32;
static int hf_ieee80211_mcsset_rx_bitmask_33to38;
static int hf_ieee80211_mcsset_rx_bitmask_39to52;
static int hf_ieee80211_mcsset_rx_bitmask_53to76;
static int hf_ieee80211_mcsset_highest_data_rate;
static int hf_ieee80211_mcsset_tx_mcs_set_defined;
static int hf_ieee80211_mcsset_tx_rx_mcs_set_not_equal;
static int hf_ieee80211_mcsset_tx_max_spatial_streams;
static int hf_ieee80211_mcsset_tx_unequal_modulation;

static int hf_ieee80211_htex_cap;
static int hf_ieee80211_htex_vs_cap;
static int hf_ieee80211_htex_pco;
static int hf_ieee80211_htex_transtime;
static int hf_ieee80211_htex_mcs;
static int hf_ieee80211_htex_htc_support;
static int hf_ieee80211_htex_rd_responder;

static int hf_ieee80211_txbf;
static int hf_ieee80211_txbf_vs;
static int hf_ieee80211_txbf_cap;
static int hf_ieee80211_txbf_rcv_ssc;
static int hf_ieee80211_txbf_tx_ssc;
static int hf_ieee80211_txbf_rcv_ndp;
static int hf_ieee80211_txbf_tx_ndp;
static int hf_ieee80211_txbf_impl_txbf;
static int hf_ieee80211_txbf_calib;
static int hf_ieee80211_txbf_expl_csi;
static int hf_ieee80211_txbf_expl_uncomp_fm;
static int hf_ieee80211_txbf_expl_comp_fm;
static int hf_ieee80211_txbf_expl_bf_csi;
static int hf_ieee80211_txbf_expl_uncomp_fm_feed;
static int hf_ieee80211_txbf_expl_comp_fm_feed;
static int hf_ieee80211_txbf_csi_num_bf_ant;
static int hf_ieee80211_txbf_min_group;
static int hf_ieee80211_txbf_uncomp_sm_bf_ant;
static int hf_ieee80211_txbf_comp_sm_bf_ant;
static int hf_ieee80211_txbf_csi_max_rows_bf;
static int hf_ieee80211_txbf_chan_est;
static int hf_ieee80211_txbf_resrv;

/*** Begin: 802.11n D1.10 - HT Information IE  ***/
static int hf_ieee80211_ht_info_primary_channel;

static int hf_ieee80211_ht_info_delimiter1;
static int hf_ieee80211_ht_info_secondary_channel_offset;
static int hf_ieee80211_ht_info_sta_channel_width;
static int hf_ieee80211_ht_info_rifs_mode;
static int hf_ieee80211_ht_info_reserved_b4_b7;

static int hf_ieee80211_ht_info_delimiter2;
static int hf_ieee80211_ht_info_protection;
static int hf_ieee80211_ht_info_non_greenfield_sta_present;
static int hf_ieee80211_ht_info_reserved_b11;
static int hf_ieee80211_ht_info_obss_non_ht_stas_present;
static int hf_ieee80211_ht_info_channel_center_freq_seg_2;
static int hf_ieee80211_ht_info_reserved_b21_b23;

static int hf_ieee80211_ht_info_delimiter3;
static int hf_ieee80211_ht_info_reserved_b24_b29;
static int hf_ieee80211_ht_info_dual_beacon;
static int hf_ieee80211_ht_info_dual_cts_protection;
static int hf_ieee80211_ht_info_secondary_beacon;
static int hf_ieee80211_ht_info_lsig_txop_protection_full_support;
static int hf_ieee80211_ht_info_pco_active;
static int hf_ieee80211_ht_info_pco_phase;
static int hf_ieee80211_ht_info_reserved_b36_b39;
/*** End: 802.11n D1.10 - HT Information IE  ***/

static int hf_ieee80211_tag_ap_channel_report_operating_class;
static int hf_ieee80211_tag_ap_channel_report_channel_list;

static int hf_ieee80211_tag_secondary_channel_offset;

static int hf_ieee80211_tag_bss_ap_avg_access_delay;

static int hf_ieee80211_tag_antenna_id;

static int hf_ieee80211_tag_rsni;

static int hf_ieee80211_tag_bss_avb_adm_cap_bitmask;
static int hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up0;
static int hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up1;
static int hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up2;
static int hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up3;
static int hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up4;
static int hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up5;
static int hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up6;
static int hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up7;
static int hf_ieee80211_tag_bss_avb_adm_cap_bitmask_ac0;
static int hf_ieee80211_tag_bss_avb_adm_cap_bitmask_ac1;
static int hf_ieee80211_tag_bss_avb_adm_cap_bitmask_ac2;
static int hf_ieee80211_tag_bss_avb_adm_cap_bitmask_ac3;
static int hf_ieee80211_tag_bss_avb_adm_cap_bitmask_rsv;
static int hf_ieee80211_tag_bss_avb_adm_cap_up0;
static int hf_ieee80211_tag_bss_avb_adm_cap_up1;
static int hf_ieee80211_tag_bss_avb_adm_cap_up2;
static int hf_ieee80211_tag_bss_avb_adm_cap_up3;
static int hf_ieee80211_tag_bss_avb_adm_cap_up4;
static int hf_ieee80211_tag_bss_avb_adm_cap_up5;
static int hf_ieee80211_tag_bss_avb_adm_cap_up6;
static int hf_ieee80211_tag_bss_avb_adm_cap_up7;
static int hf_ieee80211_tag_bss_avb_adm_cap_ac0;
static int hf_ieee80211_tag_bss_avb_adm_cap_ac1;
static int hf_ieee80211_tag_bss_avb_adm_cap_ac2;
static int hf_ieee80211_tag_bss_avb_adm_cap_ac3;

static int hf_ieee80211_tag_bss_avg_ac_access_delay_be;
static int hf_ieee80211_tag_bss_avg_ac_access_delay_bk;
static int hf_ieee80211_tag_bss_avg_ac_access_delay_vi;
static int hf_ieee80211_tag_bss_avg_ac_access_delay_vo;

static int hf_ieee80211_tag_rm_enabled_capabilities;
static int hf_ieee80211_tag_rm_enabled_capabilities_b0;
static int hf_ieee80211_tag_rm_enabled_capabilities_b1;
static int hf_ieee80211_tag_rm_enabled_capabilities_b2;
static int hf_ieee80211_tag_rm_enabled_capabilities_b3;
static int hf_ieee80211_tag_rm_enabled_capabilities_b4;
static int hf_ieee80211_tag_rm_enabled_capabilities_b5;
static int hf_ieee80211_tag_rm_enabled_capabilities_b6;
static int hf_ieee80211_tag_rm_enabled_capabilities_b7;
static int hf_ieee80211_tag_rm_enabled_capabilities_b8;
static int hf_ieee80211_tag_rm_enabled_capabilities_b9;
static int hf_ieee80211_tag_rm_enabled_capabilities_b10;
static int hf_ieee80211_tag_rm_enabled_capabilities_b11;
static int hf_ieee80211_tag_rm_enabled_capabilities_b12;
static int hf_ieee80211_tag_rm_enabled_capabilities_b13;
static int hf_ieee80211_tag_rm_enabled_capabilities_b14;
static int hf_ieee80211_tag_rm_enabled_capabilities_b15;
static int hf_ieee80211_tag_rm_enabled_capabilities_b16;
static int hf_ieee80211_tag_rm_enabled_capabilities_b17;
static int hf_ieee80211_tag_rm_enabled_capabilities_b18to20;
static int hf_ieee80211_tag_rm_enabled_capabilities_b21to23;
static int hf_ieee80211_tag_rm_enabled_capabilities_b24to26;
static int hf_ieee80211_tag_rm_enabled_capabilities_b27;
static int hf_ieee80211_tag_rm_enabled_capabilities_b28;
static int hf_ieee80211_tag_rm_enabled_capabilities_b29;
static int hf_ieee80211_tag_rm_enabled_capabilities_b30;
static int hf_ieee80211_tag_rm_enabled_capabilities_b31;
static int hf_ieee80211_tag_rm_enabled_capabilities_b32;
static int hf_ieee80211_tag_rm_enabled_capabilities_b33;
static int hf_ieee80211_tag_rm_enabled_capabilities_b34;
static int hf_ieee80211_tag_rm_enabled_capabilities_b35;
static int hf_ieee80211_tag_rm_enabled_capabilities_o5;

static int hf_ieee80211_tag_rcpi;
static int hf_ieee80211_tag_multiple_bssid;
static int hf_ieee80211_tag_multiple_bssid_subelem_id;
static int hf_ieee80211_tag_multiple_bssid_subelem_len;
static int hf_ieee80211_tag_multiple_bssid_subelem_reserved;
static int hf_ieee80211_tag_multiple_bssid_subelem_nontrans_profile;

static int hf_ieee80211_tag_20_40_bc;
static int hf_ieee80211_tag_20_40_bc_information_request;
static int hf_ieee80211_tag_20_40_bc_forty_mhz_intolerant;
static int hf_ieee80211_tag_20_40_bc_20_mhz_bss_width_request;
static int hf_ieee80211_tag_20_40_bc_obss_scanning_exemption_request;
static int hf_ieee80211_tag_20_40_bc_obss_scanning_exemption_grant;
static int hf_ieee80211_tag_20_40_bc_reserved;

static int hf_ieee80211_tag_intolerant_operating_class;
static int hf_ieee80211_tag_intolerant_channel_list;
static int hf_ieee80211_tag_intolerant_channel;

static int hf_ieee80211_tag_power_constraint_local;

static int hf_ieee80211_tag_power_capability_min;
static int hf_ieee80211_tag_power_capability_max;

static int hf_ieee80211_tag_tpc_report_trsmt_pow;
static int hf_ieee80211_tag_tpc_report_link_mrg;
static int hf_ieee80211_tag_tpc_report_reserved;

static int hf_ieee80211_tag_supported_channels;
static int hf_ieee80211_tag_supported_channels_first;
static int hf_ieee80211_tag_supported_channels_range;

static int hf_ieee80211_csa_channel_switch_mode;
static int hf_ieee80211_csa_new_channel_number;
static int hf_ieee80211_csa_channel_switch_count;

static int hf_ieee80211_tag_measure_request_token;
static int hf_ieee80211_tag_measure_request_mode;
static int hf_ieee80211_tag_measure_request_mode_parallel;
static int hf_ieee80211_tag_measure_request_mode_enable;
static int hf_ieee80211_tag_measure_request_mode_request;
static int hf_ieee80211_tag_measure_request_mode_report;
static int hf_ieee80211_tag_measure_request_mode_duration_mandatory;
static int hf_ieee80211_tag_measure_request_mode_reserved;
static int hf_ieee80211_tag_measure_request_type;

static int hf_ieee80211_tag_measure_request_channel_number;
static int hf_ieee80211_tag_measure_request_start_time;
static int hf_ieee80211_tag_measure_request_duration;

static int hf_ieee80211_tag_measure_request_operating_class;
static int hf_ieee80211_tag_measure_request_randomization_interval;

static int hf_ieee80211_tag_measure_report_measurement_token;
static int hf_ieee80211_tag_measure_report_mode;
static int hf_ieee80211_tag_measure_report_mode_late;
static int hf_ieee80211_tag_measure_report_mode_incapable;
static int hf_ieee80211_tag_measure_report_mode_refused;
static int hf_ieee80211_tag_measure_report_mode_reserved;
static int hf_ieee80211_tag_measure_report_type;
static int hf_ieee80211_tag_measure_report_channel_number;
static int hf_ieee80211_tag_measure_report_start_time;
static int hf_ieee80211_tag_measure_report_duration;

static int hf_ieee80211_tag_measure_basic_map_field;
static int hf_ieee80211_tag_measure_map_field_bss;
static int hf_ieee80211_tag_measure_map_field_ofdm;
static int hf_ieee80211_tag_measure_map_field_unident_signal;
static int hf_ieee80211_tag_measure_map_field_radar;
static int hf_ieee80211_tag_measure_map_field_unmeasured;
static int hf_ieee80211_tag_measure_map_field_reserved;

static int hf_ieee80211_tag_measure_cca_busy_fraction;

static int hf_ieee80211_tag_measure_rpi_histogram_report;
static int hf_ieee80211_tag_measure_rpi_histogram_report_0;
static int hf_ieee80211_tag_measure_rpi_histogram_report_1;
static int hf_ieee80211_tag_measure_rpi_histogram_report_2;
static int hf_ieee80211_tag_measure_rpi_histogram_report_3;
static int hf_ieee80211_tag_measure_rpi_histogram_report_4;
static int hf_ieee80211_tag_measure_rpi_histogram_report_5;
static int hf_ieee80211_tag_measure_rpi_histogram_report_6;
static int hf_ieee80211_tag_measure_rpi_histogram_report_7;

static int hf_ieee80211_tag_measure_report_operating_class;
static int hf_ieee80211_tag_measure_report_channel_load;
static int hf_ieee80211_tag_measure_report_frame_info;
static int hf_ieee80211_tag_measure_report_frame_info_phy_type;
static int hf_ieee80211_tag_measure_report_frame_info_frame_type;
static int hf_ieee80211_tag_measure_report_rcpi;
static int hf_ieee80211_tag_measure_report_rsni;
static int hf_ieee80211_tag_measure_report_bssid;
static int hf_ieee80211_tag_measure_report_ant_id;
static int hf_ieee80211_tag_measure_report_anpi;
static int hf_ieee80211_tag_measure_report_ipi_density_0;
static int hf_ieee80211_tag_measure_report_ipi_density_1;
static int hf_ieee80211_tag_measure_report_ipi_density_2;
static int hf_ieee80211_tag_measure_report_ipi_density_3;
static int hf_ieee80211_tag_measure_report_ipi_density_4;
static int hf_ieee80211_tag_measure_report_ipi_density_5;
static int hf_ieee80211_tag_measure_report_ipi_density_6;
static int hf_ieee80211_tag_measure_report_ipi_density_7;
static int hf_ieee80211_tag_measure_report_ipi_density_8;
static int hf_ieee80211_tag_measure_report_ipi_density_9;
static int hf_ieee80211_tag_measure_report_ipi_density_10;
static int hf_ieee80211_tag_measure_report_parent_tsf;

static int hf_ieee80211_tag_measure_report_subelement_length;
static int hf_ieee80211_tag_measure_report_beacon_sub_id;
static int hf_ieee80211_tag_measure_report_beacon_unknown;
static int hf_ieee80211_tag_measure_report_beacon_sub_last_report_indication;
static int hf_ieee80211_tag_measure_reported_frame_frag_id;
static int hf_ieee80211_tag_measure_reported_frame_frag_rep_id;
static int hf_ieee80211_tag_measure_reported_frame_frag_number;
static int hf_ieee80211_tag_measure_reported_frame_frag_more;

static int hf_ieee80211_tag_measure_report_lci_sub_id;
static int hf_ieee80211_tag_measure_report_lci_lci;
static int hf_ieee80211_tag_measure_report_lci_z_sta_floor_info;
static int hf_ieee80211_tag_measure_report_lci_z_sta_floor_info_expected_to_move;
static int hf_ieee80211_tag_measure_report_lci_z_sta_floor_info_sta_floor_number;
static int hf_ieee80211_tag_measure_report_lci_z_sta_height_above_floor;
static int hf_ieee80211_tag_measure_report_lci_z_sta_height_above_floor_uncertainty;
static int hf_ieee80211_tag_measure_report_lci_urp;
static int hf_ieee80211_tag_measure_report_lci_urp_retransmission_allowed;
static int hf_ieee80211_tag_measure_report_lci_urp_retention_expires_relative_present;
static int hf_ieee80211_tag_measure_report_lci_urp_sta_location_policy;
static int hf_ieee80211_tag_measure_report_lci_urp_reserved;
static int hf_ieee80211_tag_measure_report_lci_urp_retention_expires_relative;
static int hf_ieee80211_tag_measure_report_lci_unknown;

static int hf_ieee80211_tag_measure_report_civic_location_type;
static int hf_ieee80211_tag_measure_report_civic_sub_id;
static int hf_ieee80211_tag_measure_report_location_civic_country;
static int hf_ieee80211_tag_measure_report_location_civic_type;
static int hf_ieee80211_tag_measure_report_location_civic_length;
static int hf_ieee80211_tag_measure_report_location_civic;

static int hf_ieee80211_tag_measure_report_unknown;

static int hf_ieee80211_tag_quiet_count;
static int hf_ieee80211_tag_quiet_period;
static int hf_ieee80211_tag_quiet_duration;
static int hf_ieee80211_tag_quiet_offset;

static int hf_ieee80211_tag_dfs_owner;
static int hf_ieee80211_tag_dfs_recovery_interval;
static int hf_ieee80211_tag_dfs_channel_map;
static int hf_ieee80211_tag_dfs_channel_number;
static int hf_ieee80211_tag_dfs_map;

static int hf_ieee80211_tag_erp_info;
static int hf_ieee80211_tag_erp_info_erp_present;
static int hf_ieee80211_tag_erp_info_use_protection;
static int hf_ieee80211_tag_erp_info_barker_preamble_mode;
static int hf_ieee80211_tag_erp_info_reserved;

static int hf_ieee80211_tag_extended_capabilities;
static int hf_ieee80211_tag_extended_capabilities_b0;
static int hf_ieee80211_tag_extended_capabilities_b1;
static int hf_ieee80211_tag_extended_capabilities_b2;
static int hf_ieee80211_tag_extended_capabilities_b3;
static int hf_ieee80211_tag_extended_capabilities_b4;
static int hf_ieee80211_tag_extended_capabilities_b5;
static int hf_ieee80211_tag_extended_capabilities_b6;
static int hf_ieee80211_tag_extended_capabilities_b7;
static int hf_ieee80211_tag_extended_capabilities_b8;
static int hf_ieee80211_tag_extended_capabilities_b9;
static int hf_ieee80211_tag_extended_capabilities_b10;
static int hf_ieee80211_tag_extended_capabilities_b11;
static int hf_ieee80211_tag_extended_capabilities_b12;
static int hf_ieee80211_tag_extended_capabilities_b13;
static int hf_ieee80211_tag_extended_capabilities_b14;
static int hf_ieee80211_tag_extended_capabilities_b15;
static int hf_ieee80211_tag_extended_capabilities_b16;
static int hf_ieee80211_tag_extended_capabilities_b17;
static int hf_ieee80211_tag_extended_capabilities_b18;
static int hf_ieee80211_tag_extended_capabilities_b19;
static int hf_ieee80211_tag_extended_capabilities_b20;
static int hf_ieee80211_tag_extended_capabilities_b21;
static int hf_ieee80211_tag_extended_capabilities_b22;
static int hf_ieee80211_tag_extended_capabilities_b23;
static int hf_ieee80211_tag_extended_capabilities_b24;
static int hf_ieee80211_tag_extended_capabilities_b25;
static int hf_ieee80211_tag_extended_capabilities_b26;
static int hf_ieee80211_tag_extended_capabilities_b27;
static int hf_ieee80211_tag_extended_capabilities_b28;
static int hf_ieee80211_tag_extended_capabilities_b29;
static int hf_ieee80211_tag_extended_capabilities_b30;
static int hf_ieee80211_tag_extended_capabilities_b31;
static int hf_ieee80211_tag_extended_capabilities_b32;
static int hf_ieee80211_tag_extended_capabilities_b33;
static int hf_ieee80211_tag_extended_capabilities_b34;
static int hf_ieee80211_tag_extended_capabilities_b35;
static int hf_ieee80211_tag_extended_capabilities_b36;
static int hf_ieee80211_tag_extended_capabilities_b37;
static int hf_ieee80211_tag_extended_capabilities_b38;
static int hf_ieee80211_tag_extended_capabilities_b39;
static int hf_ieee80211_tag_extended_capabilities_b40;
static int hf_ieee80211_tag_extended_capabilities_serv_int_granularity;
static int hf_ieee80211_tag_extended_capabilities_b44;
static int hf_ieee80211_tag_extended_capabilities_b45;
static int hf_ieee80211_tag_extended_capabilities_b46;
static int hf_ieee80211_tag_extended_capabilities_b47;
static int hf_ieee80211_tag_extended_capabilities_b48;
static int hf_ieee80211_tag_extended_capabilities_b49;
static int hf_ieee80211_tag_extended_capabilities_b50;
static int hf_ieee80211_tag_extended_capabilities_b51;
static int hf_ieee80211_tag_extended_capabilities_b52;
static int hf_ieee80211_tag_extended_capabilities_b53;
static int hf_ieee80211_tag_extended_capabilities_b54;
static int hf_ieee80211_tag_extended_capabilities_b55;
static int hf_ieee80211_tag_extended_capabilities_b56;
static int hf_ieee80211_tag_extended_capabilities_b57;
static int hf_ieee80211_tag_extended_capabilities_b58;
static int hf_ieee80211_tag_extended_capabilities_b59;
static int hf_ieee80211_tag_extended_capabilities_b60;
static int hf_ieee80211_tag_extended_capabilities_b61;
static int hf_ieee80211_tag_extended_capabilities_b62;
static int hf_ieee80211_tag_extended_capabilities_b63;
/* Used for the two-byte ext-cap field when present */
static int hf_ieee80211_tag_extended_capabilities_2;
static int hf_ieee80211_tag_extended_capabilities_b56_2;
static int hf_ieee80211_tag_extended_capabilities_b57_2;
static int hf_ieee80211_tag_extended_capabilities_b58_2;
static int hf_ieee80211_tag_extended_capabilities_b59_2;
static int hf_ieee80211_tag_extended_capabilities_b60_2;
static int hf_ieee80211_tag_extended_capabilities_b61_2;
static int hf_ieee80211_tag_extended_capabilities_b62_2;
static int hf_ieee80211_tag_extended_capabilities_max_num_msdus;
static int hf_ieee80211_tag_extended_capabilities_b65_2;
static int hf_ieee80211_tag_extended_capabilities_b66_2;
static int hf_ieee80211_tag_extended_capabilities_b67_2;
static int hf_ieee80211_tag_extended_capabilities_b68_2;
static int hf_ieee80211_tag_extended_capabilities_b69_2;
static int hf_ieee80211_tag_extended_capabilities_b70_2;
static int hf_ieee80211_tag_extended_capabilities_b71_2;

static int hf_ieee80211_tag_extended_capabilities_b72;
static int hf_ieee80211_tag_extended_capabilities_b73;
static int hf_ieee80211_tag_extended_capabilities_b74;
static int hf_ieee80211_tag_extended_capabilities_b75;
static int hf_ieee80211_tag_extended_capabilities_b76;
static int hf_ieee80211_tag_extended_capabilities_b77;
static int hf_ieee80211_tag_extended_capabilities_b78;
static int hf_ieee80211_tag_extended_capabilities_b79;
static int hf_ieee80211_tag_extended_capabilities_b80;
static int hf_ieee80211_tag_extended_capabilities_b81;
static int hf_ieee80211_tag_extended_capabilities_b82;
static int hf_ieee80211_tag_extended_capabilities_b83;
static int hf_ieee80211_tag_extended_capabilities_b84;
static int hf_ieee80211_tag_extended_capabilities_b85;
static int hf_ieee80211_tag_extended_capabilities_b86;
static int hf_ieee80211_tag_extended_capabilities_b87;

static int hf_ieee80211_tag_extended_capabilities_b88;
static int hf_ieee80211_tag_extended_capabilities_b89;
static int hf_ieee80211_tag_extended_capabilities_b90;
static int hf_ieee80211_tag_extended_capabilities_b91;
static int hf_ieee80211_tag_extended_capabilities_b92;
static int hf_ieee80211_tag_extended_capabilities_b93;
static int hf_ieee80211_tag_extended_capabilities_b94;
static int hf_ieee80211_tag_extended_capabilities_b95;

static int hf_ieee80211_tag_extended_capabilities_b96;
static int hf_ieee80211_tag_extended_capabilities_b97;
static int hf_ieee80211_tag_extended_capabilities_reserved2;

static int hf_ieee80211_tag_cisco_ccx1_unknown;
static int hf_ieee80211_tag_cisco_ccx1_name;
static int hf_ieee80211_tag_cisco_ccx1_clients;
static int hf_ieee80211_tag_cisco_ccx1_unknown2;

static int hf_ieee80211_vht_cap;
static int hf_ieee80211_vht_max_mpdu_length;
static int hf_ieee80211_vht_supported_chan_width_set;
static int hf_ieee80211_vht_rx_ldpc;
static int hf_ieee80211_vht_short_gi_for_80;
static int hf_ieee80211_vht_short_gi_for_160;
static int hf_ieee80211_vht_tx_stbc;
static int hf_ieee80211_vht_rx_stbc;
static int hf_ieee80211_vht_su_beamformer_cap;
static int hf_ieee80211_vht_su_beamformee_cap;
static int hf_ieee80211_vht_beamformer_antennas;
static int hf_ieee80211_vht_sounding_dimensions;
static int hf_ieee80211_vht_mu_beamformer_cap;
static int hf_ieee80211_vht_mu_beamformee_cap;
static int hf_ieee80211_vht_txop_ps;
static int hf_ieee80211_vht_var_htc_field;
static int hf_ieee80211_vht_max_ampdu;
static int hf_ieee80211_vht_link_adaptation_cap;
static int hf_ieee80211_vht_rx_pattern;
static int hf_ieee80211_vht_tx_pattern;
static int hf_ieee80211_vht_ext_nss_bw_support;

static int hf_ieee80211_vht_mcsset;

static int hf_ieee80211_vht_mcsset_rx_mcs_map;
static int hf_ieee80211_vht_mcsset_rx_max_mcs_for_1_ss;
static int hf_ieee80211_vht_mcsset_rx_max_mcs_for_2_ss;
static int hf_ieee80211_vht_mcsset_rx_max_mcs_for_3_ss;
static int hf_ieee80211_vht_mcsset_rx_max_mcs_for_4_ss;
static int hf_ieee80211_vht_mcsset_rx_max_mcs_for_5_ss;
static int hf_ieee80211_vht_mcsset_rx_max_mcs_for_6_ss;
static int hf_ieee80211_vht_mcsset_rx_max_mcs_for_7_ss;
static int hf_ieee80211_vht_mcsset_rx_max_mcs_for_8_ss;

static int hf_ieee80211_vht_mcsset_max_nsts_total;
static int hf_ieee80211_vht_mcsset_rx_highest_long_gi;
static int hf_ieee80211_vht_mcsset_extended_nss_bw_capable;
static int hf_ieee80211_vht_mcsset_reserved;

static int hf_ieee80211_vht_mcsset_tx_mcs_map;
static int hf_ieee80211_vht_mcsset_tx_max_mcs_for_1_ss;
static int hf_ieee80211_vht_mcsset_tx_max_mcs_for_2_ss;
static int hf_ieee80211_vht_mcsset_tx_max_mcs_for_3_ss;
static int hf_ieee80211_vht_mcsset_tx_max_mcs_for_4_ss;
static int hf_ieee80211_vht_mcsset_tx_max_mcs_for_5_ss;
static int hf_ieee80211_vht_mcsset_tx_max_mcs_for_6_ss;
static int hf_ieee80211_vht_mcsset_tx_max_mcs_for_7_ss;
static int hf_ieee80211_vht_mcsset_tx_max_mcs_for_8_ss;

static int hf_ieee80211_vht_op;
static int hf_ieee80211_vht_op_channel_width;
static int hf_ieee80211_vht_op_channel_center0;
static int hf_ieee80211_vht_op_channel_center1;

static int hf_ieee80211_vht_op_basic_mcs_map;
static int hf_ieee80211_vht_op_max_basic_mcs_for_1_ss;
static int hf_ieee80211_vht_op_max_basic_mcs_for_2_ss;
static int hf_ieee80211_vht_op_max_basic_mcs_for_3_ss;
static int hf_ieee80211_vht_op_max_basic_mcs_for_4_ss;
static int hf_ieee80211_vht_op_max_basic_mcs_for_5_ss;
static int hf_ieee80211_vht_op_max_basic_mcs_for_6_ss;
static int hf_ieee80211_vht_op_max_basic_mcs_for_7_ss;
static int hf_ieee80211_vht_op_max_basic_mcs_for_8_ss;
static int hf_ieee80211_vht_mcsset_tx_highest_long_gi;

static int hf_ieee80211_vht_tpe_pwr_info;
static int hf_ieee80211_vht_tpe_pwr_info_count;
static int hf_ieee80211_vht_tpe_pwr_info_unit;
static int hf_ieee80211_vht_tpe_pwr_info_category;
static int hf_ieee80211_vht_tpe_pwr_constr_20;
static int hf_ieee80211_vht_tpe_pwr_constr_40;
static int hf_ieee80211_vht_tpe_pwr_constr_80;
static int hf_ieee80211_vht_tpe_pwr_constr_160;
static int hf_ieee80211_vht_tpe_any_bw_psd;
static int hf_ieee80211_vht_tpe_psd;

static int hf_ieee80211_beamform_feedback_seg_retrans_bitmap;

static int hf_ieee80211_ndp_annc_token;
static int hf_ieee80211_ndp_annc_variant;
static int hf_ieee80211_ndp_annc_token_number;
static int hf_ieee80211_vht_ndp_annc_sta_info_aid12;
static int hf_ieee80211_vht_ndp_annc_sta_info_feedback_type;
static int hf_ieee80211_vht_ndp_annc_sta_info_nc_index;
static int hf_ieee80211_vht_ndp_annc_sta_info_reserved;

static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_aid11;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_ltf_offset;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_r2i_n_sts;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_r2i_rep;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_i2r_n_sts;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_reserved1;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_disambiguation;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_i2r_rep;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_reserved2;

static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2043;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2043_aid11;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2043_sac;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2043_disambiguation;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2043_reserved;

static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2044;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2044_aid11;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2044_partial_tsf;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2044_disambiguation;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2044_reserved;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2044_token;

static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2045;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2045_aid11;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2045_i2r_ndp_tx_power;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2045_r2i_ndp_target_rssi;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2045_disambiguation;
static int hf_ieee80211_vht_ndp_annc_sta_info_ranging_2045_reserved;


static int hf_ieee80211_ndp_eht_annc_sta_info;
static int hf_ieee80211_ndp_eht_annc_aid11;
static int hf_ieee80211_ndp_eht_annc_resolution;
static int hf_ieee80211_ndp_eht_annc_feedback_map;
static int hf_ieee80211_ndp_eht_annc_reserved1;
static int hf_ieee80211_ndp_eht_annc_nc_index;
static int hf_ieee80211_ndp_eht_annc_feedback_type;
static int hf_ieee80211_ndp_eht_annc_disambiguation;
static int hf_ieee80211_ndp_eht_annc_codebook_size;
static int hf_ieee80211_ndp_eht_annc_reserved2;

static int hf_ieee80211_ff_vht_action;
static int hf_ieee80211_ff_vht_mimo_cntrl;
static int hf_ieee80211_ff_vht_mimo_cntrl_nc_index;
static int hf_ieee80211_ff_vht_mimo_cntrl_nr_index;
static int hf_ieee80211_ff_vht_mimo_cntrl_channel_width;
static int hf_ieee80211_ff_vht_mimo_cntrl_grouping;
static int hf_ieee80211_ff_vht_mimo_cntrl_codebook_info;
static int hf_ieee80211_ff_vht_mimo_cntrl_feedback_type;
static int hf_ieee80211_ff_vht_mimo_cntrl_remaining_feedback_seg;
static int hf_ieee80211_ff_vht_mimo_cntrl_first_feedback_seg;
static int hf_ieee80211_ff_vht_mimo_cntrl_reserved;
static int hf_ieee80211_ff_vht_mimo_cntrl_sounding_dialog_token_number;

static int * const hf_ieee80211_ff_vht_mimo_cntrl_fields[] = {
  &hf_ieee80211_ff_vht_mimo_cntrl_nc_index,
  &hf_ieee80211_ff_vht_mimo_cntrl_nr_index,
  &hf_ieee80211_ff_vht_mimo_cntrl_channel_width,
  &hf_ieee80211_ff_vht_mimo_cntrl_grouping,
  &hf_ieee80211_ff_vht_mimo_cntrl_codebook_info,
  &hf_ieee80211_ff_vht_mimo_cntrl_feedback_type,
  &hf_ieee80211_ff_vht_mimo_cntrl_remaining_feedback_seg,
  &hf_ieee80211_ff_vht_mimo_cntrl_first_feedback_seg,
  &hf_ieee80211_ff_vht_mimo_cntrl_reserved,
  &hf_ieee80211_ff_vht_mimo_cntrl_sounding_dialog_token_number,
  NULL,
};

static int hf_ieee80211_vht_compressed_beamforming_report;
static int hf_ieee80211_vht_compressed_beamforming_report_snr;
static int hf_ieee80211_vht_compressed_beamform_scidx;
static int hf_ieee80211_vht_group_id_management;
static int hf_ieee80211_vht_membership_status_array;
static int hf_ieee80211_vht_user_position_array;
static int hf_ieee80211_vht_operation_mode_notification;
static int hf_ieee80211_vht_membership_status_field;
static int hf_ieee80211_vht_user_position_field;
static int hf_ieee80211_vht_mu_exclusive_beamforming_report;
static int hf_ieee80211_vht_mu_exclusive_beamforming_delta_snr;

static int hf_ieee80211_ff_he_action;
static int hf_ieee80211_ff_protected_he_action;
static int hf_ieee80211_ff_protected_ftm_action;
static int hf_ieee80211_ff_eht_action;
static int hf_ieee80211_ff_protected_eht_action;
static int hf_ieee80211_he_mimo_control_nc_index;
static int hf_ieee80211_he_mimo_control_nr_index;
static int hf_ieee80211_he_mimo_control_bw;
static int hf_ieee80211_he_mimo_control_grouping;
static int hf_ieee80211_he_mimo_control_codebook_info;
static int hf_ieee80211_he_mimo_control_feedback_type;
static int hf_ieee80211_he_mimo_control_remaining_feedback_segs;
static int hf_ieee80211_he_mimo_control_first_feedback_seg;
static int hf_ieee80211_he_mimo_control_ru_start_index;
static int hf_ieee80211_he_mimo_control_ru_end_index;
static int hf_ieee80211_he_mimo_control_sounding_dialog_token_num;
static int hf_ieee80211_he_mimo_control_reserved;
static int hf_ieee80211_he_mimo_control_field;
static int hf_ieee80211_he_compressed_beamforming_report_snr;
static int hf_ieee80211_he_compressed_beamform_scidx;
static int hf_ieee80211_he_beamforming_report_len;

static int hf_ieee80211_tag_neighbor_report_bssid;
static int hf_ieee80211_tag_neighbor_report_bssid_info;
static int hf_ieee80211_tag_neighbor_report_bssid_info_reachability;
static int hf_ieee80211_tag_neighbor_report_bssid_info_security;
static int hf_ieee80211_tag_neighbor_report_bssid_info_key_scope;
static int hf_ieee80211_tag_neighbor_report_bssid_info_capability;
static int hf_ieee80211_tag_neighbor_report_bssid_info_capability_spec_mng;
static int hf_ieee80211_tag_neighbor_report_bssid_info_capability_qos;
static int hf_ieee80211_tag_neighbor_report_bssid_info_capability_apsd;
static int hf_ieee80211_tag_neighbor_report_bssid_info_capability_radio_msnt;
static int hf_ieee80211_tag_neighbor_report_bssid_info_capability_dback;
static int hf_ieee80211_tag_neighbor_report_bssid_info_capability_iback;
static int hf_ieee80211_tag_neighbor_report_bssid_info_mobility_domain;
static int hf_ieee80211_tag_neighbor_report_bssid_info_high_throughput;
static int hf_ieee80211_tag_neighbor_report_bssid_info_very_high_throughput;
static int hf_ieee80211_tag_neighbor_report_bssid_info_ftm;
static int hf_ieee80211_tag_neighbor_report_bssid_info_high_efficiency;
static int hf_ieee80211_tag_neighbor_report_bssid_info_er_bss;
static int hf_ieee80211_tag_neighbor_report_bssid_info_colocated_ap;
static int hf_ieee80211_tag_neighbor_report_bssid_info_unsolicited_probe_responses_active;
static int hf_ieee80211_tag_neighbor_report_bssid_info_ess_with_colocated_ap;
static int hf_ieee80211_tag_neighbor_report_bssid_info_oct_supported_with_reporting_ap;
static int hf_ieee80211_tag_neighbor_report_bssid_info_colocated_6ghz_ap;
static int hf_ieee80211_tag_neighbor_report_bssid_info_eht;
static int hf_ieee80211_tag_neighbor_report_bssid_info_reserved;
static int hf_ieee80211_tag_neighbor_report_ope_class;
static int hf_ieee80211_tag_neighbor_report_channel_number;
static int hf_ieee80211_tag_neighbor_report_phy_type;
static int hf_ieee80211_tag_neighbor_report_subelement_id;
static int hf_ieee80211_tag_neighbor_report_subelement_length;
static int hf_ieee80211_tag_neighbor_report_subelement_data;
static int hf_ieee80211_tag_neighbor_report_subelement_bss_trn_can_pref;
static int hf_ieee80211_tag_neighbor_report_subelement_bss_ter_tsf;
static int hf_ieee80211_tag_neighbor_report_subelement_bss_dur;
static int hf_ieee80211_tag_neighbor_report_subelement_tsf_offset;
static int hf_ieee80211_tag_neighbor_report_subelement_beacon_interval;
static int hf_ieee80211_tag_neighbor_report_subelement_country_code;
static int hf_ieee80211_tag_supported_ope_classes_current;
static int hf_ieee80211_tag_supported_ope_classes_alternate;

static int hf_ieee80211_tag_dirn_meas_results_aoa_results;
static int hf_ieee80211_tag_ftm_aoa_results_aoa_azimuth;
static int hf_ieee80211_tag_ftm_aoa_results_aoa_elevation;
static int hf_ieee80211_tag_ftm_aoa_results_aoa_azimuth_accuracy;
static int hf_ieee80211_tag_ftm_aoa_results_aoa_elevation_accuracy;
static int hf_ieee80211_tag_ftm_aoa_results_best_awv_id;
static int hf_ieee80211_tag_ftm_aoa_results_aoa_reference;
static int hf_ieee80211_tag_ftm_aoa_results_reserved;

/* IEEE Std 802.11r-2008 7.3.2.47 */
static int hf_ieee80211_tag_mobility_domain_mdid;
static int hf_ieee80211_tag_mobility_domain_ft_capab;
static int hf_ieee80211_tag_mobility_domain_ft_capab_ft_over_ds;
static int hf_ieee80211_tag_mobility_domain_ft_capab_resource_req;
static int hf_ieee80211_tag_mobility_domain_ft_capab_reserved;
static int * const ieee80211_tag_mobility_domain_ft_capab_fields[] = {
  &hf_ieee80211_tag_mobility_domain_ft_capab_ft_over_ds,
  &hf_ieee80211_tag_mobility_domain_ft_capab_resource_req,
  &hf_ieee80211_tag_mobility_domain_ft_capab_reserved,
  NULL
};

/* IEEE Std 802.11r-2008 7.3.2.48 */
static int hf_ieee80211_tag_ft_mic_control;
static int hf_ieee80211_tag_ft_mic_control_rsnxe_used;
static int hf_ieee80211_tag_ft_mic_control_mic_length;
static int hf_ieee80211_tag_ft_mic_control_reserved;
static int hf_ieee80211_tag_ft_mic_control_element_count;
static int * const ieee80211_tag_ft_mic_control_fields[] = {
  &hf_ieee80211_tag_ft_mic_control_rsnxe_used,
  &hf_ieee80211_tag_ft_mic_control_mic_length,
  &hf_ieee80211_tag_ft_mic_control_reserved,
  &hf_ieee80211_tag_ft_mic_control_element_count,
  NULL
};
static int hf_ieee80211_tag_ft_mic;
static int hf_ieee80211_tag_ft_anonce;
static int hf_ieee80211_tag_ft_snonce;
static int hf_ieee80211_tag_ft_subelem_id;
static int hf_ieee80211_tag_ft_subelem_len;
static int hf_ieee80211_tag_ft_subelem_data;
static int hf_ieee80211_tag_ft_subelem_r1kh_id;
static int hf_ieee80211_tag_ft_subelem_gtk_key_info;
static int hf_ieee80211_tag_ft_subelem_gtk_key_id;
static int hf_ieee80211_tag_ft_subelem_gtk_key_length;
static int hf_ieee80211_tag_ft_subelem_gtk_rsc;
static int hf_ieee80211_tag_ft_subelem_gtk_key;
static int hf_ieee80211_tag_ft_subelem_gtk_key_encrypted;
static int hf_ieee80211_tag_ft_subelem_r0kh_id;
static int hf_ieee80211_tag_ft_subelem_igtk_key_id;
static int hf_ieee80211_tag_ft_subelem_igtk_ipn;
static int hf_ieee80211_tag_ft_subelem_igtk_key_length;
static int hf_ieee80211_tag_ft_subelem_igtk_key;
static int hf_ieee80211_tag_ft_subelem_oci_op_class;
static int hf_ieee80211_tag_ft_subelem_oci_prim_chan_num;
static int hf_ieee80211_tag_ft_subelem_oci_freq_seg_1;
static int hf_ieee80211_tag_ft_subelem_oci_oct_op_class;
static int hf_ieee80211_tag_ft_subelem_oci_oct_prim_chan_num;
static int hf_ieee80211_tag_ft_subelem_oci_oct_freq_seg_1;
static int hf_ieee80211_tag_ft_subelem_bigtk_key_id;
static int hf_ieee80211_tag_ft_subelem_bigtk_bipn;
static int hf_ieee80211_tag_ft_subelem_bigtk_key_length;
static int hf_ieee80211_tag_ft_subelem_bigtk_key;
static int hf_ieee80211_tag_ft_subelem_mlo_gtk_key_info;
static int hf_ieee80211_tag_ft_subelem_mlo_gtk_key_id;
static int hf_ieee80211_tag_ft_subelem_mlo_gtk_link_id_info;
static int hf_ieee80211_tag_ft_subelem_mlo_gtk_link_id;
static int hf_ieee80211_tag_ft_subelem_mlo_gtk_key_length;
static int hf_ieee80211_tag_ft_subelem_mlo_gtk_rsc;
static int hf_ieee80211_tag_ft_subelem_mlo_gtk_key;
static int hf_ieee80211_tag_ft_subelem_mlo_igtk_key_id;
static int hf_ieee80211_tag_ft_subelem_mlo_igtk_ipn;
static int hf_ieee80211_tag_ft_subelem_mlo_igtk_link_id_info;
static int hf_ieee80211_tag_ft_subelem_mlo_igtk_link_id;
static int hf_ieee80211_tag_ft_subelem_mlo_igtk_key_length;
static int hf_ieee80211_tag_ft_subelem_mlo_igtk_key;
static int hf_ieee80211_tag_ft_subelem_mlo_bigtk_key_id;
static int hf_ieee80211_tag_ft_subelem_mlo_bigtk_bipn;
static int hf_ieee80211_tag_ft_subelem_mlo_bigtk_link_id_info;
static int hf_ieee80211_tag_ft_subelem_mlo_bigtk_link_id;
static int hf_ieee80211_tag_ft_subelem_mlo_bigtk_key_length;
static int hf_ieee80211_tag_ft_subelem_mlo_bigtk_key;

/* IEEE Std 802.11-2012: 11r 8.4.2.52 */
static int hf_ieee80211_tag_ric_data_id;
static int hf_ieee80211_tag_ric_data_desc_cnt;
static int hf_ieee80211_tag_ric_data_status_code;

/* IEEE Std 802.11-2012: 11r 8.4.2.53 */
static int hf_ieee80211_tag_ric_desc_rsrc_type;
static int hf_ieee80211_tag_ric_desc_var_params;

/* IEEE Std 802.11w-2009 7.3.2.55 */
static int hf_ieee80211_tag_mmie_keyid;
static int hf_ieee80211_tag_mmie_ipn;
static int hf_ieee80211_tag_mmie_mic;

/* IEEE Std 802.11-2016: 9.4.2.72 */
static int hf_ieee80211_tag_no_bssid_capability_dmg_bss_control;
static int hf_ieee80211_tag_no_bssid_capability_dmg_bss_control_type;
static int hf_ieee80211_tag_no_bssid_capability_dmg_bss_control_reserved;

/* IEEE Std 802.11-2016: 9.4.2.74 */
static int hf_ieee80211_tag_multiple_bssid_index_bssid_index;
static int hf_ieee80211_tag_multiple_bssid_index_dtim_period;
static int hf_ieee80211_tag_multiple_bssid_index_dtim_count;

/* IEEE Std 802.11-2012: 8.4.2.61 */
static int hf_ieee80211_tag_obss_spd;
static int hf_ieee80211_tag_obss_sad;
static int hf_ieee80211_tag_obss_cwtsi;
static int hf_ieee80211_tag_obss_sptpc;
static int hf_ieee80211_tag_obss_satpc;
static int hf_ieee80211_tag_obss_wctdf;
static int hf_ieee80211_tag_obss_sat;

/* IEEE Std 802.11-2012: 8.4.2.25.1 */
static int hf_ieee80211_group_data_cipher_suite_oui;
static int hf_ieee80211_group_data_cipher_suite_type;
static int hf_ieee80211_osen_pairwise_cipher_suite_oui;
static int hf_ieee80211_osen_pairwise_cipher_suite_type;
static int hf_ieee80211_osen_pcs_count;
static int hf_ieee80211_osen_akm_count;
static int hf_ieee80211_osen_akm_cipher_suite_oui;
static int hf_ieee80211_osen_akm_cipher_suite_type;
static int hf_ieee80211_osen_rsn_cap_preauth;
static int hf_ieee80211_osen_rsn_cap_no_pairwise;
static int hf_ieee80211_osen_rsn_cap_ptksa_replay_counter;
static int hf_ieee80211_osen_rsn_cap_gtksa_replay_counter;
static int hf_ieee80211_osen_rsn_cap_mfpr;
static int hf_ieee80211_osen_rsn_cap_mfpc;
static int hf_ieee80211_osen_rsn_cap_jmr;
static int hf_ieee80211_osen_rsn_cap_peerkey;
static int hf_ieee80211_osen_rsn_spp_a_msdu_capable;
static int hf_ieee80211_osen_rsn_spp_a_msdu_required;
static int hf_ieee80211_osen_rsn_pbac;
static int hf_ieee80211_osen_extended_key_id_iaf;
static int hf_ieee80211_osen_reserved;
static int hf_ieee80211_osen_rsn_cap_flags;
static int hf_ieee80211_osen_pmkid_count;
static int hf_ieee80211_osen_pmkid;
static int hf_ieee80211_osen_group_management_cipher_suite_oui;
static int hf_ieee80211_osen_group_management_cipher_suite_type;

/*WAPI-Specification 7.3.2.25 : WAPI Parameter Set*/
static int hf_ieee80211_tag_wapi_param_set_version;

static int hf_ieee80211_tag_wapi_param_set_akm_suite_count;
static int hf_ieee80211_tag_wapi_param_set_akm_suite_oui;
static int hf_ieee80211_tag_wapi_param_set_akm_suite_type;

static int hf_ieee80211_tag_wapi_param_set_ucast_cipher_suite_count;
static int hf_ieee80211_tag_wapi_param_set_ucast_cipher_suite_oui;
static int hf_ieee80211_tag_wapi_param_set_ucast_cipher_suite_type;

static int hf_ieee80211_tag_wapi_param_set_mcast_cipher_suite_oui;
static int hf_ieee80211_tag_wapi_param_set_mcast_cipher_suite_type;

static int hf_ieee80211_tag_wapi_param_set_capab;
static int hf_ieee80211_tag_wapi_param_set_capab_preauth;
static int hf_ieee80211_tag_wapi_param_set_capab_rsvd;
static int hf_ieee80211_tag_wapi_param_set_bkid_count;
static int hf_ieee80211_tag_wapi_param_set_bkid_list;

/* IEEE Std 802.11v-2011 7.3.2.61 */
static int hf_ieee80211_tag_time_adv_timing_capab;
static int hf_ieee80211_tag_time_adv_time_value;
static int hf_ieee80211_tag_time_adv_time_value_year;
static int hf_ieee80211_tag_time_adv_time_value_month;
static int hf_ieee80211_tag_time_adv_time_value_day;
static int hf_ieee80211_tag_time_adv_time_value_hours;
static int hf_ieee80211_tag_time_adv_time_value_minutes;
static int hf_ieee80211_tag_time_adv_time_value_seconds;
static int hf_ieee80211_tag_time_adv_time_value_milliseconds;
static int hf_ieee80211_tag_time_adv_time_value_reserved;
static int hf_ieee80211_tag_time_adv_time_error;
static int hf_ieee80211_tag_time_adv_time_update_counter;

/* IEEE Std 802.11-2012 8.4.2.81 */
static int hf_ieee80211_tag_bss_max_idle_period;
static int hf_ieee80211_tag_bss_max_idle_options;
static int hf_ieee80211_tag_bss_max_idle_options_protected;
static int hf_ieee80211_tag_bss_idle_options_reserved;

/* IEEE Std 802.11-2012 8.4.2.82 */
static int hf_ieee80211_tag_tfs_request_id;
static int hf_ieee80211_tag_tfs_request_ac_delete_after_match;
static int hf_ieee80211_tag_tfs_request_ac_notify;
static int hf_ieee80211_tag_tfs_request_subelem_id;
static int hf_ieee80211_tag_tfs_request_subelem_len;
static int hf_ieee80211_tag_tfs_request_subelem;

/* IEEE Std 802.11-2012 8.4.2.83 */
static int hf_ieee80211_tag_tfs_response_subelem_id;
static int hf_ieee80211_tag_tfs_response_subelem_len;
static int hf_ieee80211_tag_tfs_response_subelem;
static int hf_ieee80211_tag_tfs_response_status;
static int hf_ieee80211_tag_tfs_response_id;

/* IEEE Std 802.11-2012 8.4.2.84 */
static int hf_ieee80211_tag_wnm_sleep_mode_action_type;
static int hf_ieee80211_tag_wnm_sleep_mode_response_status;
static int hf_ieee80211_tag_wnm_sleep_mode_interval;

static int hf_ieee80211_wnm_sub_elt_id;
static int hf_ieee80211_wnm_sub_elt_len;

/* IEEE Std 802.11v-2011 7.3.2.87 */
static int hf_ieee80211_tag_time_zone;

/* IEEE Std 802.11u-2011 7.3.2.92 */
static int hf_ieee80211_tag_interworking_access_network_type;
static int hf_ieee80211_tag_interworking_internet;
static int hf_ieee80211_tag_interworking_asra;
static int hf_ieee80211_tag_interworking_esr;
static int hf_ieee80211_tag_interworking_uesa;
static int hf_ieee80211_tag_interworking_hessid;

/* IEEE Std 802.11-2012, 8.4.2.97 */
static int hf_ieee80211_tag_qos_map_set_dscp_exc;
static int hf_ieee80211_tag_qos_map_set_dscp_exc_val;
static int hf_ieee80211_tag_qos_map_set_dscp_exc_up;
static int hf_ieee80211_tag_qos_map_set_range;
static int hf_ieee80211_tag_qos_map_set_low;
static int hf_ieee80211_tag_qos_map_set_high;

/* IEEE Std 802.11u-2011 7.3.2.93 */
static int hf_ieee80211_tag_adv_proto_resp_len_limit;
static int hf_ieee80211_tag_adv_proto_pame_bi;
static int hf_ieee80211_tag_adv_proto_id;
static int hf_ieee80211_tag_adv_vs_len;
/* static int hf_ieee80211_tag_adv_proto_vs_info; */

/* IEEE Std 802.11u-2011 7.3.2.96 */
static int hf_ieee80211_tag_roaming_consortium_num_anqp_oi;
static int hf_ieee80211_tag_roaming_consortium_oi1_len;
static int hf_ieee80211_tag_roaming_consortium_oi2_len;
static int hf_ieee80211_tag_roaming_consortium_oi1;
static int hf_ieee80211_tag_roaming_consortium_oi2;
static int hf_ieee80211_tag_roaming_consortium_oi3;

/* 802.11n 7.3.2.48 */
static int hf_ieee80211_hta_cc;
static int hf_ieee80211_hta_cap1;
static int hf_ieee80211_hta_cap2;
static int hf_ieee80211_hta_ext_chan_offset;
static int hf_ieee80211_hta_rec_tx_width;
static int hf_ieee80211_hta_rifs_mode;
static int hf_ieee80211_hta_controlled_access;
static int hf_ieee80211_hta_service_interval;
static int hf_ieee80211_hta_operating_mode;
static int hf_ieee80211_hta_non_gf_devices;
static int hf_ieee80211_hta_basic_stbc_mcs;
static int hf_ieee80211_hta_dual_stbc_protection;
static int hf_ieee80211_hta_secondary_beacon;
static int hf_ieee80211_hta_lsig_txop_protection;
static int hf_ieee80211_hta_pco_active;
static int hf_ieee80211_hta_pco_phase;

static int hf_ieee80211_antsel;
static int hf_ieee80211_antsel_vs;
static int hf_ieee80211_antsel_b0;
static int hf_ieee80211_antsel_b1;
static int hf_ieee80211_antsel_b2;
static int hf_ieee80211_antsel_b3;
static int hf_ieee80211_antsel_b4;
static int hf_ieee80211_antsel_b5;
static int hf_ieee80211_antsel_b6;
static int hf_ieee80211_antsel_b7;

static int hf_ieee80211_rsn_version;
static int hf_ieee80211_rsn_gcs;
static int hf_ieee80211_rsn_gcs_oui;
static int hf_ieee80211_rsn_gcs_type;
static int hf_ieee80211_rsn_gcs_80211_type;
static int hf_ieee80211_rsn_pcs_count;
static int hf_ieee80211_rsn_pcs_list;
static int hf_ieee80211_rsn_pcs;
static int hf_ieee80211_rsn_pcs_oui;
static int hf_ieee80211_rsn_pcs_80211_type;
static int hf_ieee80211_rsn_pcs_type;
static int hf_ieee80211_rsn_akms_count;
static int hf_ieee80211_rsn_akms_list;
static int hf_ieee80211_rsn_akms;
static int hf_ieee80211_rsn_akms_oui;
static int hf_ieee80211_rsn_akms_80211_type;
static int hf_ieee80211_rsn_akms_type;
static int hf_ieee80211_rsn_cap;
static int hf_ieee80211_rsn_cap_preauth;
static int hf_ieee80211_rsn_cap_no_pairwise;
static int hf_ieee80211_rsn_cap_ptksa_replay_counter;
static int hf_ieee80211_rsn_cap_gtksa_replay_counter;
static int hf_ieee80211_rsn_cap_mfpr;
static int hf_ieee80211_rsn_cap_mfpc;
static int hf_ieee80211_rsn_cap_jmr;
static int hf_ieee80211_rsn_cap_peerkey;
static int hf_ieee80211_rsn_cap_extended_key_id_iaf;
static int hf_ieee80211_rsn_cap_ocvc;
static int hf_ieee80211_rsn_pmkid_count;
static int hf_ieee80211_rsn_pmkid_list;
static int hf_ieee80211_rsn_pmkid;
static int hf_ieee80211_rsn_gmcs;
static int hf_ieee80211_rsn_gmcs_oui;
static int hf_ieee80211_rsn_gmcs_type;
static int hf_ieee80211_rsn_gmcs_80211_type;

static int hf_ieee80211_wfa_ie_type;
static int hf_ieee80211_wfa_ie_wpa_version;
static int hf_ieee80211_wfa_ie_wpa_mcs;
static int hf_ieee80211_wfa_ie_wpa_mcs_oui;
static int hf_ieee80211_wfa_ie_wpa_mcs_type;
static int hf_ieee80211_wfa_ie_wpa_mcs_wfa_type;
static int hf_ieee80211_wfa_ie_wpa_ucs_count;
static int hf_ieee80211_wfa_ie_wpa_ucs_list;
static int hf_ieee80211_wfa_ie_wpa_ucs;
static int hf_ieee80211_wfa_ie_wpa_ucs_oui;
static int hf_ieee80211_wfa_ie_wpa_ucs_wfa_type;
static int hf_ieee80211_wfa_ie_wpa_ucs_type;
static int hf_ieee80211_wfa_ie_wpa_akms_count;
static int hf_ieee80211_wfa_ie_wpa_akms_list;
static int hf_ieee80211_wfa_ie_wpa_akms;
static int hf_ieee80211_wfa_ie_wpa_akms_oui;
static int hf_ieee80211_wfa_ie_wpa_akms_wfa_type;
static int hf_ieee80211_wfa_ie_wpa_akms_type;
static int hf_ieee80211_wfa_ie_wme_subtype;
static int hf_ieee80211_wfa_ie_wme_version;
static int hf_ieee80211_wfa_ie_wme_qos_info;
static int hf_ieee80211_wfa_ie_wme_qos_info_sta_max_sp_length;
static int hf_ieee80211_wfa_ie_wme_qos_info_sta_ac_be;
static int hf_ieee80211_wfa_ie_wme_qos_info_sta_ac_bk;
static int hf_ieee80211_wfa_ie_wme_qos_info_sta_ac_vi;
static int hf_ieee80211_wfa_ie_wme_qos_info_sta_ac_vo;
static int hf_ieee80211_wfa_ie_wme_qos_info_sta_reserved;
static int hf_ieee80211_wfa_ie_wme_qos_info_ap_u_apsd;
static int hf_ieee80211_wfa_ie_wme_qos_info_ap_parameter_set_count;
static int hf_ieee80211_wfa_ie_wme_qos_info_ap_reserved;
static int hf_ieee80211_wfa_ie_wme_reserved;
static int hf_ieee80211_wfa_ie_wme_ac_parameters;
static int hf_ieee80211_wfa_ie_wme_acp_aci_aifsn;
static int hf_ieee80211_wfa_ie_wme_acp_aci_be;
static int hf_ieee80211_wfa_ie_wme_acp_acm_be;
static int hf_ieee80211_wfa_ie_wme_acp_aifsn_be;
static int hf_ieee80211_wfa_ie_wme_acp_reserved_be;
static int hf_ieee80211_wfa_ie_wme_acp_aci_bk;
static int hf_ieee80211_wfa_ie_wme_acp_acm_bk;
static int hf_ieee80211_wfa_ie_wme_acp_aifsn_bk;
static int hf_ieee80211_wfa_ie_wme_acp_reserved_bk;
static int hf_ieee80211_wfa_ie_wme_acp_aci_vi;
static int hf_ieee80211_wfa_ie_wme_acp_acm_vi;
static int hf_ieee80211_wfa_ie_wme_acp_aifsn_vi;
static int hf_ieee80211_wfa_ie_wme_acp_reserved_vi;
static int hf_ieee80211_wfa_ie_wme_acp_aci_vo;
static int hf_ieee80211_wfa_ie_wme_acp_acm_vo;
static int hf_ieee80211_wfa_ie_wme_acp_aifsn_vo;
static int hf_ieee80211_wfa_ie_wme_acp_reserved_vo;
static int hf_ieee80211_wfa_ie_wme_acp_ecw;
static int hf_ieee80211_wfa_ie_wme_acp_ecw_max_be;
static int hf_ieee80211_wfa_ie_wme_acp_ecw_max_bk;
static int hf_ieee80211_wfa_ie_wme_acp_ecw_max_vo;
static int hf_ieee80211_wfa_ie_wme_acp_ecw_max_vi;
static int hf_ieee80211_wfa_ie_wme_acp_ecw_min_be;
static int hf_ieee80211_wfa_ie_wme_acp_ecw_min_bk;
static int hf_ieee80211_wfa_ie_wme_acp_ecw_min_vo;
static int hf_ieee80211_wfa_ie_wme_acp_ecw_min_vi;
static int hf_ieee80211_wfa_ie_wme_acp_txop_limit_be;
static int hf_ieee80211_wfa_ie_wme_acp_txop_limit_bk;
static int hf_ieee80211_wfa_ie_wme_acp_txop_limit_vo;
static int hf_ieee80211_wfa_ie_wme_acp_txop_limit_vi;
static int hf_ieee80211_wfa_ie_wme_tspec_tsinfo;
static int hf_ieee80211_wfa_ie_wme_tspec_tsinfo_tid;
static int hf_ieee80211_wfa_ie_wme_tspec_tsinfo_direction;
static int hf_ieee80211_wfa_ie_wme_tspec_tsinfo_psb;
static int hf_ieee80211_wfa_ie_wme_tspec_tsinfo_up;
static int hf_ieee80211_wfa_ie_wme_tspec_tsinfo_reserved;
static int hf_ieee80211_wfa_ie_wme_tspec_nor_msdu;
static int hf_ieee80211_wfa_ie_wme_tspec_max_msdu;
static int hf_ieee80211_wfa_ie_wme_tspec_min_srv;
static int hf_ieee80211_wfa_ie_wme_tspec_max_srv;
static int hf_ieee80211_wfa_ie_wme_tspec_inact_int;
static int hf_ieee80211_wfa_ie_wme_tspec_susp_int;
static int hf_ieee80211_wfa_ie_wme_tspec_srv_start;
static int hf_ieee80211_wfa_ie_wme_tspec_min_data;
static int hf_ieee80211_wfa_ie_wme_tspec_mean_data;
static int hf_ieee80211_wfa_ie_wme_tspec_peak_data;
static int hf_ieee80211_wfa_ie_wme_tspec_burst_size;
static int hf_ieee80211_wfa_ie_wme_tspec_delay_bound;
static int hf_ieee80211_wfa_ie_wme_tspec_min_phy;
static int hf_ieee80211_wfa_ie_wme_tspec_surplus;
static int hf_ieee80211_wfa_ie_wme_tspec_medium;
static int hf_ieee80211_wfa_ie_owe_bssid;
static int hf_ieee80211_wfa_ie_owe_ssid_length;
static int hf_ieee80211_wfa_ie_owe_ssid;
static int hf_ieee80211_wfa_ie_owe_band_info;
static int hf_ieee80211_wfa_ie_owe_channel_info;
static int hf_ieee80211_wfa_ie_mbo_oce_attr;
static int hf_ieee80211_wfa_ie_mbo_oce_attr_id;
static int hf_ieee80211_wfa_ie_mbo_oce_attr_len;
static int hf_ieee80211_wfa_ie_mbo_ap_cap;
static int hf_ieee80211_wfa_ie_mbo_ap_cap_cell;
static int hf_ieee80211_wfa_ie_mbo_ap_cap_reserved;
static int hf_ieee80211_wfa_ie_mbo_non_pref_chan_op_class;
static int hf_ieee80211_wfa_ie_mbo_non_pref_chan_chan;
static int hf_ieee80211_wfa_ie_mbo_non_pref_chan_pref;
static int hf_ieee80211_wfa_ie_mbo_non_pref_chan_reason;
static int hf_ieee80211_wfa_ie_mbo_cellular_cap;
static int hf_ieee80211_wfa_ie_mbo_assoc_disallow_reason;
static int hf_ieee80211_wfa_ie_mbo_cellular_pref;
static int hf_ieee80211_wfa_ie_mbo_transition_reason;
static int hf_ieee80211_wfa_ie_mbo_transition_rej_reason;
static int hf_ieee80211_wfa_ie_mbo_assoc_retry_delay;
static int hf_ieee80211_wfa_ie_oce_cap_ctrl;
static int hf_ieee80211_wfa_ie_oce_cap_release;
static int hf_ieee80211_wfa_ie_oce_cap_sta_cfon;
static int hf_ieee80211_wfa_ie_oce_cap_11b_only_ap;
static int hf_ieee80211_wfa_ie_oce_cap_hlp;
static int hf_ieee80211_wfa_ie_oce_cap_non_oce_ap;
static int hf_ieee80211_wfa_ie_oce_cap_reserved;
static int hf_ieee80211_wfa_ie_oce_rssi_assoc_rej_delta;
static int hf_ieee80211_wfa_ie_oce_rssi_assoc_rej_delay;
static int hf_ieee80211_wfa_ie_oce_wan_metrics_avail_cap;
static int hf_ieee80211_wfa_ie_oce_wan_metrics_avail_cap_downlink;
static int hf_ieee80211_wfa_ie_oce_wan_metrics_avail_cap_uplink;
static int hf_ieee80211_wfa_ie_oce_rnr_completeness_short_ssid;
static int hf_ieee80211_wfa_ie_oce_probe_suppr_bssid;
static int hf_ieee80211_wfa_ie_oce_probe_suppr_ssid;
static int hf_ieee80211_wfa_anqp_mbo_subtype;
static int hf_ieee80211_wfa_anqp_mbo_query;
static int hf_ieee80211_wfa_anqp_mbo_cellular_pref;
static int hf_ieee80211_wfa_ie_transition_disable_bitmap;
static int hf_ieee80211_wfa_ie_transition_disable_wpa3_personal;
static int hf_ieee80211_wfa_ie_transition_disable_sae_pk;
static int hf_ieee80211_wfa_ie_transition_disable_wpa3_enterprise;
static int hf_ieee80211_wfa_ie_transition_disable_enhanced_open;
static int hf_ieee80211_wfa_ie_transition_disable_reserved_b4thru7;
static int hf_ieee80211_wfa_ie_transition_disable_reserved;

static int hf_ieee80211_aironet_ie_type;
static int hf_ieee80211_aironet_ie_dtpc;
static int hf_ieee80211_aironet_ie_dtpc_unknown;
static int hf_ieee80211_aironet_ie_version;
static int hf_ieee80211_aironet_ie_data;
static int hf_ieee80211_aironet_ie_qos_reserved;
static int hf_ieee80211_aironet_ie_qos_paramset;
static int hf_ieee80211_aironet_ie_qos_val;
static int hf_ieee80211_aironet_ie_clientmfp;

static int hf_ieee80211_vs_sgdsn_tag;
static int hf_ieee80211_vs_sgdsn_type;
static int hf_ieee80211_vs_sgdsn_length;
static int hf_ieee80211_vs_sgdsn_version;
static int hf_ieee80211_vs_sgdsn_icaomfrcode;
static int hf_ieee80211_vs_sgdsn_manufacturer;
static int hf_ieee80211_vs_sgdsn_model;
static int hf_ieee80211_vs_sgdsn_serialnumber;
static int hf_ieee80211_vs_sgdsn_serialnumber_len;
static int hf_ieee80211_vs_sgdsn_gpscoord;
static int hf_ieee80211_vs_sgdsn_altitude;
static int hf_ieee80211_vs_sgdsn_speed;
static int hf_ieee80211_vs_sgdsn_heading;

static int hf_ieee80211_vs_nintendo_type;
static int hf_ieee80211_vs_nintendo_length;
static int hf_ieee80211_vs_nintendo_servicelist;
static int hf_ieee80211_vs_nintendo_service;
static int hf_ieee80211_vs_nintendo_consoleid;
static int hf_ieee80211_vs_nintendo_unknown;

static int hf_ieee80211_vs_aruba_subtype;
static int hf_ieee80211_vs_aruba_apname;
static int hf_ieee80211_vs_aruba_data;

static int hf_ieee80211_vs_routerboard_unknown;
static int hf_ieee80211_vs_routerboard_subitem;
static int hf_ieee80211_vs_routerboard_subtype;
static int hf_ieee80211_vs_routerboard_sublength;
static int hf_ieee80211_vs_routerboard_subdata;
static int hf_ieee80211_vs_routerboard_subtype1_prefix;
static int hf_ieee80211_vs_routerboard_subtype1_data;

static int hf_ieee80211_vs_meru_subitem;
static int hf_ieee80211_vs_meru_subtype;
static int hf_ieee80211_vs_meru_sublength;
static int hf_ieee80211_vs_meru_subdata;

static int hf_ieee80211_vs_extreme_subtype;
static int hf_ieee80211_vs_extreme_subdata;
static int hf_ieee80211_vs_extreme_unknown;
static int hf_ieee80211_vs_extreme_ap_length;
static int hf_ieee80211_vs_extreme_ap_name;

static int hf_ieee80211_vs_aerohive_version;
static int hf_ieee80211_vs_aerohive_subtype;
static int hf_ieee80211_vs_aerohive_hostname_length;
static int hf_ieee80211_vs_aerohive_hostname;
static int hf_ieee80211_vs_aerohive_data;

static int hf_ieee80211_vs_mist_ap_name;
static int hf_ieee80211_vs_mist_data;

static int hf_ieee80211_vs_ruckus_ap_name;
static int hf_ieee80211_vs_ruckus_data;

static int hf_ieee80211_vs_alcatel_ap_name;
static int hf_ieee80211_vs_alcatel_data;

static int hf_ieee80211_vs_fortinet_subtype;
static int hf_ieee80211_vs_fortinet_system_type;
static int hf_ieee80211_vs_fortinet_system_length;
static int hf_ieee80211_vs_fortinet_system_apname;
static int hf_ieee80211_vs_fortinet_system_apmodel;
static int hf_ieee80211_vs_fortinet_system_apserial;
static int hf_ieee80211_vs_fortinet_data;

static int hf_ieee80211_vs_arista_subtype;
static int hf_ieee80211_vs_arista_apname;
static int hf_ieee80211_vs_arista_data;

static int hf_ieee80211_vs_wisun_type;
static int hf_ieee80211_vs_wisun_ptkid;
static int hf_ieee80211_vs_wisun_gtkl;
static int hf_ieee80211_vs_wisun_gtkl_gtk0;
static int hf_ieee80211_vs_wisun_gtkl_gtk1;
static int hf_ieee80211_vs_wisun_gtkl_gtk2;
static int hf_ieee80211_vs_wisun_gtkl_gtk3;
static int hf_ieee80211_vs_wisun_nr;
static int hf_ieee80211_vs_wisun_lgtkl;
static int hf_ieee80211_vs_wisun_lgtkl_lgtk0;
static int hf_ieee80211_vs_wisun_lgtkl_lgtk1;
static int hf_ieee80211_vs_wisun_lgtkl_lgtk2;
static int hf_ieee80211_vs_wisun_lgtk_key_id;
static int hf_ieee80211_vs_wisun_lgtk_lgtk;
static int hf_ieee80211_vs_wisun_data;

static int hf_ieee80211_rsn_ie_ptk_keyid;

static int hf_ieee80211_rsn_ie_gtk_kde_data_type;
static int hf_ieee80211_rsn_ie_gtk_kde_key_id;
static int hf_ieee80211_rsn_ie_gtk_kde_tx;
static int hf_ieee80211_rsn_ie_gtk_kde_reserved1;
static int hf_ieee80211_rsn_ie_gtk_kde_reserved2;
static int hf_ieee80211_rsn_ie_gtk_kde_gtk;

static int hf_ieee80211_rsn_ie_mac_address_kde_mac;

static int hf_ieee80211_rsn_ie_pmkid;

static int hf_ieee80211_rsn_ie_unknown;

static int hf_ieee80211_rsn_ie_gtk_kde_nonce;
static int hf_ieee80211_rsn_ie_gtk_kde_lifetime;
static int hf_ieee80211_rsn_ie_error_kde_res;
static int hf_ieee80211_rsn_ie_error_kde_error_type;
static int hf_ieee80211_rsn_ie_igtk_kde_keyid;
static int hf_ieee80211_rsn_ie_igtk_kde_ipn;
static int hf_ieee80211_rsn_ie_igtk_kde_igtk;
static int hf_ieee80211_rsn_ie_oci_operating_class;
static int hf_ieee80211_rsn_ie_oci_primary_channel_number;
static int hf_ieee80211_rsn_ie_oci_frequency_segment_1;
static int hf_ieee80211_rsn_ie_bigtk_key_id;
static int hf_ieee80211_rsn_ie_bigtk_bipn;
static int hf_ieee80211_rsn_ie_bigtk_bigtk;
static int hf_ieee80211_rsn_ie_mlo_link_info;
static int hf_ieee80211_rsn_ie_mlo_linkid;
static int hf_ieee80211_rsn_ie_mlo_rnse_present;
static int hf_ieee80211_rsn_ie_mlo_rnsxe_present;
static int hf_ieee80211_rsn_ie_mlo_reserved;
static int hf_ieee80211_rsn_ie_mlo_mac_addr;
static int hf_ieee80211_rsn_ie_mlo_gtk_kde_key_id;
static int hf_ieee80211_rsn_ie_mlo_gtk_kde_tx;
static int hf_ieee80211_rsn_ie_mlo_gtk_kde_reserved;
static int hf_ieee80211_rsn_ie_mlo_gtk_kde_linkid;
static int hf_ieee80211_rsn_ie_mlo_gtk_kde_pn;
static int hf_ieee80211_rsn_ie_mlo_gtk_kde_gtk;

static int hf_ieee80211_rsn_ie_mlo_igtk_kde_key_id;
static int hf_ieee80211_rsn_ie_mlo_igtk_kde_ipn;
static int hf_ieee80211_rsn_ie_mlo_igtk_kde_reserved;
static int hf_ieee80211_rsn_ie_mlo_igtk_kde_linkid;
static int hf_ieee80211_rsn_ie_mlo_igtk_kde_igtk;

static int hf_ieee80211_rsn_ie_mlo_bigtk_kde_key_id;
static int hf_ieee80211_rsn_ie_mlo_bigtk_kde_ipn;
static int hf_ieee80211_rsn_ie_mlo_bigtk_kde_reserved;
static int hf_ieee80211_rsn_ie_mlo_bigtk_kde_linkid;
static int hf_ieee80211_rsn_ie_mlo_bigtk_kde_bigtk;

static int hf_ieee80211_marvell_ie_type;
static int hf_ieee80211_marvell_ie_mesh_subtype;
static int hf_ieee80211_marvell_ie_mesh_version;
static int hf_ieee80211_marvell_ie_mesh_active_proto_id;
static int hf_ieee80211_marvell_ie_mesh_active_metric_id;
static int hf_ieee80211_marvell_ie_mesh_cap;
static int hf_ieee80211_marvell_ie_data;

static int hf_ieee80211_extreme_mesh_ie_type;
static int hf_ieee80211_extreme_mesh_ie_services;
static int hf_ieee80211_extreme_mesh_ie_hello_f_root;
static int hf_ieee80211_extreme_mesh_ie_hello_f_proxy;
static int hf_ieee80211_extreme_mesh_ie_hello_f_geo;
static int hf_ieee80211_extreme_mesh_ie_hello_f_path_pref;
static int hf_ieee80211_extreme_mesh_ie_hello_f_mobile;
static int hf_ieee80211_extreme_mesh_ie_htr;
static int hf_ieee80211_extreme_mesh_ie_mtr;
static int hf_ieee80211_extreme_mesh_ie_root;
static int hf_ieee80211_extreme_mesh_ie_nh;
static int hf_ieee80211_extreme_mesh_ie_mesh_id;
static int hf_ieee80211_extreme_mesh_ie_mp_id;

static int hf_ieee80211_atheros_ie_type;
static int hf_ieee80211_atheros_ie_subtype;
static int hf_ieee80211_atheros_ie_version;
static int hf_ieee80211_atheros_ie_cap_f_turbop;
static int hf_ieee80211_atheros_ie_cap_f_comp;
static int hf_ieee80211_atheros_ie_cap_f_ff;
static int hf_ieee80211_atheros_ie_cap_f_xr;
static int hf_ieee80211_atheros_ie_cap_f_ar;
static int hf_ieee80211_atheros_ie_cap_f_burst;
static int hf_ieee80211_atheros_ie_cap_f_wme;
static int hf_ieee80211_atheros_ie_cap_f_boost;
static int hf_ieee80211_atheros_ie_advcap_cap;
static int hf_ieee80211_atheros_ie_advcap_defkey;
static int hf_ieee80211_atheros_ie_xr_info;
static int hf_ieee80211_atheros_ie_xr_base_bssid;
static int hf_ieee80211_atheros_ie_xr_xr_bssid;
static int hf_ieee80211_atheros_ie_xr_xr_beacon;
static int hf_ieee80211_atheros_ie_xr_base_cap;
static int hf_ieee80211_atheros_ie_xr_xr_cap;
static int hf_ieee80211_atheros_ie_data;

/*QBSS - Version 1,2,802.11e*/

static int hf_ieee80211_qbss2_cal;
static int hf_ieee80211_qbss2_gl;
static int hf_ieee80211_qbss_cu;
static int hf_ieee80211_qbss2_cu;
static int hf_ieee80211_qbss_scount;
static int hf_ieee80211_qbss2_scount;
static int hf_ieee80211_qbss_version;
static int hf_ieee80211_qbss_adc;

static int hf_ieee80211_tsinfo;
static int hf_ieee80211_tsinfo_type;
static int hf_ieee80211_tsinfo_tsid;
static int hf_ieee80211_tsinfo_dir;
static int hf_ieee80211_tsinfo_access;
static int hf_ieee80211_tsinfo_agg;
static int hf_ieee80211_tsinfo_apsd;
static int hf_ieee80211_tsinfo_up;
static int hf_ieee80211_tsinfo_ack;
static int hf_ieee80211_tsinfo_sched;
static int hf_ieee80211_tsinfo_rsv;

static int * const ieee80211_tsinfo_fields[] = {
  &hf_ieee80211_tsinfo_type,
  &hf_ieee80211_tsinfo_tsid,
  &hf_ieee80211_tsinfo_dir,
  &hf_ieee80211_tsinfo_access,
  &hf_ieee80211_tsinfo_agg,
  &hf_ieee80211_tsinfo_apsd,
  &hf_ieee80211_tsinfo_up,
  &hf_ieee80211_tsinfo_ack,
  &hf_ieee80211_tsinfo_sched,
  &hf_ieee80211_tsinfo_rsv,
  NULL
};

static int hf_ieee80211_tspec_nor_msdu;
static int hf_ieee80211_tspec_max_msdu;
static int hf_ieee80211_tspec_min_srv;
static int hf_ieee80211_tspec_max_srv;
static int hf_ieee80211_tspec_inact_int;
static int hf_ieee80211_tspec_susp_int;
static int hf_ieee80211_tspec_srv_start;
static int hf_ieee80211_tspec_min_data;
static int hf_ieee80211_tspec_mean_data;
static int hf_ieee80211_tspec_peak_data;
static int hf_ieee80211_tspec_burst_size;
static int hf_ieee80211_tspec_delay_bound;
static int hf_ieee80211_tspec_min_phy;
static int hf_ieee80211_tspec_surplus;
static int hf_ieee80211_tspec_medium;
static int hf_ieee80211_tspec_dmg;
static int hf_ieee80211_ts_delay;
static int hf_ieee80211_tclas_process;
static int hf_ieee80211_tag_ext_supp_rates;
static int hf_ieee80211_sched_info;
static int hf_ieee80211_sched_info_agg;
static int hf_ieee80211_sched_info_tsid;
static int hf_ieee80211_sched_info_dir;
static int hf_ieee80211_sched_srv_start;
static int hf_ieee80211_sched_srv_int;
static int hf_ieee80211_sched_spec_int;
static int hf_ieee80211_tclas_up;
static int hf_ieee80211_tclas_class_type;
static int hf_ieee80211_tclas_class_mask;
static int hf_ieee80211_tclas_mask_reserved;
static int hf_ieee80211_tclas_class_mask0_src_addr;
static int hf_ieee80211_tclas_class_mask0_dst_addr;
static int hf_ieee80211_tclas_class_mask0_type;
static int hf_ieee80211_tclas_class_mask1_ver;
static int hf_ieee80211_tclas_class_mask1_src_ip;
static int hf_ieee80211_tclas_class_mask1_dst_ip;
static int hf_ieee80211_tclas_class_mask1_src_port;
static int hf_ieee80211_tclas_class_mask1_dst_port;
static int hf_ieee80211_tclas_class_mask1_ipv4_dscp;
static int hf_ieee80211_tclas_class_mask1_ipv4_proto;
static int hf_ieee80211_tclas_class_mask1_reserved;
static int hf_ieee80211_tclas_class_mask1_ipv6_flow;
static int hf_ieee80211_tclas_class_mask2_tci;
static int hf_ieee80211_tclas_src_mac_addr;
static int hf_ieee80211_tclas_dst_mac_addr;
static int hf_ieee80211_tclas_ether_type;
static int hf_ieee80211_tclas_version;
static int hf_ieee80211_tclas_ipv4_src;
static int hf_ieee80211_tclas_ipv4_dst;
static int hf_ieee80211_tclas_src_port;
static int hf_ieee80211_tclas_dst_port;
static int hf_ieee80211_tclas_dscp;
static int hf_ieee80211_tclas_protocol;
static int hf_ieee80211_tclas_ipv6_src;
static int hf_ieee80211_tclas_ipv6_dst;
static int hf_ieee80211_tclas_flow;
static int hf_ieee80211_tclas_tag_type;
static int hf_ieee80211_tclas_filter_offset;
static int hf_ieee80211_tclas_filter_value;
static int hf_ieee80211_tclas_filter_mask;
static int hf_ieee80211_tclas4_version;
static int hf_ieee80211_tclas_class_mask4_ver;
static int hf_ieee80211_tclas_class_mask4_4_src_ip;
static int hf_ieee80211_tclas_class_mask4_4_dst_ip;
static int hf_ieee80211_tclas_class_mask4_src_port;
static int hf_ieee80211_tclas_class_mask4_dst_port;
static int hf_ieee80211_tclas_class_mask4_dscp;
static int hf_ieee80211_tclas_class_mask4_ipv4_proto;
static int hf_ieee80211_tclas_class_mask4_reserved;
static int hf_ieee80211_tclas_class_mask4_6_src_ip;
static int hf_ieee80211_tclas_class_mask4_6_dst_ip;
static int hf_ieee80211_tclas_reserved_bytes;
static int hf_ieee80211_tclas_class_mask4_next_hdr;
static int hf_ieee80211_tclas_class_mask4_flow_label;
static int hf_ieee80211_tclas4_ipv4_src;
static int hf_ieee80211_tclas4_ipv4_dst;
static int hf_ieee80211_tclas4_src_port;
static int hf_ieee80211_tclas4_dst_port;
static int hf_ieee80211_tclas4_dscp;
static int hf_ieee80211_tclas4_protocol;
static int hf_ieee80211_tclas4_reserved;
static int hf_ieee80211_tclas4_ipv6_src;
static int hf_ieee80211_tclas4_ipv6_dst;
static int hf_ieee80211_tclas4_next_hdr;
static int hf_ieee80211_tclas4_flow;
static int hf_ieee80211_tclas_tclas_8021d_up_pcp;
static int hf_ieee80211_tclas_8021q_dei;
static int hf_ieee80211_tclas_8021q_vid;

static int hf_ieee80211_tclas_class_mask5_up_prio;
static int hf_ieee80211_tclas_class_mask5_dei;
static int hf_ieee80211_tclas_class_mask5_vid;
static int hf_ieee80211_tclas_class_mask5_reserved;

static int hf_ieee80211_tclas_class_mask6_a_above;
static int hf_ieee80211_tclas_class_mask6_frame_control_match_spec;
static int hf_ieee80211_tclas_class_mask6_duration_id_match_spec;
static int hf_ieee80211_tclas_class_mask6_address_1_match_spec;
static int hf_ieee80211_tclas_class_mask6_address_2_match_spec;
static int hf_ieee80211_tclas_class_mask6_address_3_match_spec;
static int hf_ieee80211_tclas_class_mask6_sequence_control_spec;
static int hf_ieee80211_tclas_class_mask6_address_4_match_spec;
static int hf_ieee80211_tclas_class_mask6_qos_control_spec;
static int hf_ieee80211_tclas_class_mask6_ht_control_spec;
static int hf_ieee80211_tclas_class_mask6_reserved;
static int hf_ieee80211_tclas6_frame_control_spec;
static int hf_ieee80211_tclas6_frame_control_mask;
static int hf_ieee80211_tclas6_duration_spec;
static int hf_ieee80211_tclas6_duration_mask;
static int hf_ieee80211_tclas6_address_1_spec;
static int hf_ieee80211_tclas6_address_1_mask;
static int hf_ieee80211_tclas6_address_2_spec;
static int hf_ieee80211_tclas6_address_2_mask;
static int hf_ieee80211_tclas6_address_3_spec;
static int hf_ieee80211_tclas6_address_3_mask;
static int hf_ieee80211_tclas6_sequence_control_spec;
static int hf_ieee80211_tclas6_sequence_control_mask;
static int hf_ieee80211_tclas6_address_4_spec;
static int hf_ieee80211_tclas6_address_4_mask;
static int hf_ieee80211_tclas6_qos_control_spec;
static int hf_ieee80211_tclas6_qos_control_mask;
static int hf_ieee80211_tclas6_ht_control_spec;
static int hf_ieee80211_tclas6_ht_control_mask;

static int hf_ieee80211_tclas_class_mask7_frame_control_match_spec;
static int hf_ieee80211_tclas_class_mask7_address_1_sid_match_spec;
static int hf_ieee80211_tclas_class_mask7_address_2_match_spec;
static int hf_ieee80211_tclas_class_mask7_sequence_control_spec;
static int hf_ieee80211_tclas_class_mask7_address_3_match_spec;
static int hf_ieee80211_tclas_class_mask7_address_4_match_spec;
static int hf_ieee80211_tclas_class_mask7_reserved;
static int hf_ieee80211_tclas7_frame_control_spec;
static int hf_ieee80211_tclas7_frame_control_mask;
static int hf_ieee80211_tclas7_address_1_sid_spec;
static int hf_ieee80211_tclas7_address_1_sid_mask;
static int hf_ieee80211_tclas7_address_2_spec;
static int hf_ieee80211_tclas7_address_2_mask;
static int hf_ieee80211_tclas7_sequence_control_spec;
static int hf_ieee80211_tclas7_sequence_control_mask;
static int hf_ieee80211_tclas7_address_3_spec;
static int hf_ieee80211_tclas7_address_3_mask;
static int hf_ieee80211_tclas7_address_4_spec;
static int hf_ieee80211_tclas7_address_4_mask;

static int hf_ieee80211_tclas_class_mask8_frame_control_match_spec;
static int hf_ieee80211_tclas_class_mask8_address_1_bssid_match_spec;
static int hf_ieee80211_tclas_class_mask8_address_2_sid_match_spec;
static int hf_ieee80211_tclas_class_mask8_sequence_control_spec;
static int hf_ieee80211_tclas_class_mask8_address_3_match_spec;
static int hf_ieee80211_tclas_class_mask8_address_4_match_spec;
static int hf_ieee80211_tclas_class_mask8_reserved;
static int hf_ieee80211_tclas8_frame_control_spec;
static int hf_ieee80211_tclas8_frame_control_mask;
static int hf_ieee80211_tclas8_address_1_bssid_spec;
static int hf_ieee80211_tclas8_address_1_bssid_mask;
static int hf_ieee80211_tclas8_address_2_sid_spec;
static int hf_ieee80211_tclas8_address_2_sid_mask;
static int hf_ieee80211_tclas8_sequence_control_spec;
static int hf_ieee80211_tclas8_sequence_control_mask;
static int hf_ieee80211_tclas8_address_3_spec;
static int hf_ieee80211_tclas8_address_3_mask;
static int hf_ieee80211_tclas8_address_4_spec;
static int hf_ieee80211_tclas8_address_4_mask;

static int hf_ieee80211_tclas_class_mask9_frame_control_match_spec;
static int hf_ieee80211_tclas_class_mask9_address_1_match_spec;
static int hf_ieee80211_tclas_class_mask9_address_2_match_spec;
static int hf_ieee80211_tclas_class_mask9_sequence_control_spec;
static int hf_ieee80211_tclas_class_mask9_reserved;
static int hf_ieee80211_tclas9_frame_control_spec;
static int hf_ieee80211_tclas9_frame_control_mask;
static int hf_ieee80211_tclas9_address_1_spec;
static int hf_ieee80211_tclas9_address_1_mask;
static int hf_ieee80211_tclas9_address_2_spec;
static int hf_ieee80211_tclas9_address_2_mask;
static int hf_ieee80211_tclas9_sequence_control_spec;
static int hf_ieee80211_tclas9_sequence_control_mask;

static int hf_ieee80211_tclas10_protocol_instance;
static int hf_ieee80211_tclas10_protocol_num_next_hdr;

static int hf_ieee80211_aruba;
static int hf_ieee80211_aruba_hb_seq;
static int hf_ieee80211_aruba_mtu;

static int hf_ieee80211_tag_vendor_oui_type;
static int hf_ieee80211_tag_vendor_data;

static int hf_ieee80211_symbp_extreme_assoc_clients;
static int hf_ieee80211_symbp_extreme_load_kbps;
static int hf_ieee80211_symbp_extreme_load_pps;
static int hf_ieee80211_symbp_extreme_client_tx_power;
static int hf_ieee80211_symbp_extreme_timestamp;

static int hf_ieee80211_tag_symbol_proprietary_oui;
static int hf_ieee80211_tag_symbol_proprietary_data;

/* IEEE Std 802.11z-2010 7.3.2.62 */
static int hf_ieee80211_tag_link_id_bssid;
static int hf_ieee80211_tag_link_id_init_sta;
static int hf_ieee80211_tag_link_id_resp_sta;

/* IEEE Std 802.11z-2010 7.3.2.63 */
static int hf_ieee80211_tag_wakeup_schedule_offset;
static int hf_ieee80211_tag_wakeup_schedule_interval;
static int hf_ieee80211_tag_wakeup_schedule_awake_window_slots;
static int hf_ieee80211_tag_wakeup_schedule_max_awake_dur;
static int hf_ieee80211_tag_wakeup_schedule_idle_count;

/* IEEE Std 802.11z-2010 7.3.2.64 */
static int hf_ieee80211_tag_channel_switch_timing_switch_time;
static int hf_ieee80211_tag_channel_switch_timing_switch_timeout;

/* IEEE Std 802.11z-2010 7.3.2.65 */
static int hf_ieee80211_tag_pti_control_tid;
static int hf_ieee80211_tag_pti_control_sequence_control;

/* IEEE Std 802.11z-2010 7.3.2.66 */
static int hf_ieee80211_tag_pu_buffer_status_ac_bk;
static int hf_ieee80211_tag_pu_buffer_status_ac_be;
static int hf_ieee80211_tag_pu_buffer_status_ac_vi;
static int hf_ieee80211_tag_pu_buffer_status_ac_vo;

/* IEEE Std 802.11r-2008 7.3.2.49 */
static int hf_ieee80211_tag_timeout_int_type;
static int hf_ieee80211_tag_timeout_int_value;

/* Ethertype 89-0d */
static int hf_ieee80211_data_encap_payload_type;

static int hf_ieee80211_anqp_wfa_subtype;

static int hf_ieee80211_dpp_subtype;

/* Hotspot 2.0 */
static int hf_ieee80211_hs20_indication_dgaf_disabled;
static int hf_ieee80211_hs20_indication_pps_mo_id_present;
static int hf_ieee80211_hs20_indication_anqp_domain_id_present;
static int hf_ieee80211_hs20_reserved;
static int hf_ieee80211_hs20_indication_version_number;
static int hf_ieee80211_hs20_indication_pps_mo_id;
static int hf_ieee80211_hs20_indication_anqp_domain_id;

static int hf_ieee80211_hs20_anqp_subtype;
static int hf_ieee80211_hs20_anqp_reserved;
static int hf_ieee80211_hs20_anqp_payload;
static int hf_ieee80211_hs20_anqp_hs_query_list;
static int hf_ieee80211_hs20_anqp_hs_capability_list;
static int hf_ieee80211_hs20_anqp_ofn_length;
static int hf_ieee80211_hs20_anqp_ofn_language;
static int hf_ieee80211_hs20_anqp_ofn_name;
static int hf_ieee80211_hs20_anqp_wan_metrics_link_status;
static int hf_ieee80211_hs20_anqp_wan_metrics_symmetric_link;
static int hf_ieee80211_hs20_anqp_wan_metrics_at_capacity;
static int hf_ieee80211_hs20_anqp_wan_metrics_reserved;
static int hf_ieee80211_hs20_anqp_wan_metrics_downlink_speed;
static int hf_ieee80211_hs20_anqp_wan_metrics_uplink_speed;
static int hf_ieee80211_hs20_anqp_wan_metrics_downlink_load;
static int hf_ieee80211_hs20_anqp_wan_metrics_uplink_load;
static int hf_ieee80211_hs20_anqp_wan_metrics_lmd;
static int hf_ieee80211_hs20_anqp_cc_proto_ip_proto;
static int hf_ieee80211_hs20_anqp_cc_proto_port_num;
static int hf_ieee80211_hs20_anqp_cc_proto_status;
static int hf_ieee80211_hs20_anqp_nai_hrq_count;
static int hf_ieee80211_hs20_anqp_nai_hrq_encoding_type;
static int hf_ieee80211_hs20_anqp_nai_hrq_length;
static int hf_ieee80211_hs20_anqp_nai_hrq_realm_name;
static int hf_ieee80211_hs20_anqp_oper_class_indic;
static int hf_ieee80211_hs20_osu_friendly_names_len;
static int hf_ieee80211_hs20_osu_friendly_name_length;
static int hf_ieee80211_hs20_osu_friendly_name_language;
static int hf_ieee80211_hs20_osu_friendly_name_name;
static int hf_ieee80211_hs20_osu_server_uri_len;
static int hf_ieee80211_hs20_osu_server_uri;
static int hf_ieee80211_hs20_osu_method_list_len;
static int hf_ieee80211_hs20_osu_method_val;
static int hf_ieee80211_hs20_icons_avail_len;
static int hf_ieee80211_hs20_osu_providers_list_ssid_len;
static int hf_ieee80211_hs20_osu_providers_ssid;
static int hf_ieee80211_hs20_osu_providers_count;
static int hf_ieee80211_hs20_osu_prov_length;
static int hf_ieee80211_hs20_icon_request_filename;
static int hf_ieee80211_hs20_icon_binary_file_status;
static int hf_ieee80211_hs20_icon_type_length;
static int hf_ieee80211_hs20_icon_type;
static int hf_ieee80211_hs20_icon_binary_data_len;
static int hf_ieee80211_hs20_icon_binary_data;
static int hf_ieee80211_osu_icon_avail_width;
static int hf_ieee80211_osu_icon_avail_height;
static int hf_ieee80211_osu_icon_avail_lang_code;
static int hf_ieee80211_osu_icon_avail_icon_type_len;
static int hf_ieee80211_osu_icon_avail_icon_type;
static int hf_ieee80211_osu_icon_avail_filename_len;
static int hf_ieee80211_osu_icon_avail_filename;
static int hf_ieee80211_hs20_osu_nai_len;
static int hf_ieee80211_hs20_osu_nai;
static int hf_ieee80211_hs20_osu_service_desc_len;
static int hf_ieee80211_hs20_osu_service_desc_duple_len;
static int hf_ieee80211_hs20_osu_service_desc_lang;
static int hf_ieee80211_hs20_osu_service_desc;
static int hf_ieee80211_hs20_anqp_venue_url_length;
static int hf_ieee80211_hs20_anqp_venue_number;
static int hf_ieee80211_hs20_anqp_venue_url;
static int hf_ieee80211_hs20_anqp_advice_of_charge_length;
static int hf_ieee80211_hs20_anqp_advice_of_charge_type;
static int hf_ieee80211_hs20_anqp_aoc_nai_realm_encoding;
static int hf_ieee80211_hs20_anqp_aoc_nai_realm_len;
static int hf_ieee80211_hs20_anqp_aoc_nai_realm;
static int hf_ieee80211_hs20_anqp_aoc_plan_len;
static int hf_ieee80211_hs20_anqp_aoc_plan_lang;
static int hf_ieee80211_hs20_anqp_aoc_plan_curcy;
static int hf_ieee80211_hs20_anqp_aoc_plan_information;

static int hf_ieee80211_hs20_subscription_remediation_url_len;
static int hf_ieee80211_hs20_subscription_remediation_server_url;
static int hf_ieee80211_hs20_subscription_remediation_server_method;
static int hf_ieee80211_hs20_deauth_reason_code;
static int hf_ieee80211_hs20_reauth_delay;
static int hf_ieee80211_hs20_deauth_reason_url_len;
static int hf_ieee80211_hs20_deauth_imminent_reason_url;

/* IEEE Std 802.11ai : FILS Discovery */
static int hf_ieee80211_ff_fils_discovery_frame_control;
static int hf_ieee80211_ff_fils_discovery_frame_control_ssid_length;
static int hf_ieee80211_ff_fils_discovery_frame_control_capability;
static int hf_ieee80211_ff_fils_discovery_frame_control_short_ssid;
static int hf_ieee80211_ff_fils_discovery_frame_control_ap_csn;
static int hf_ieee80211_ff_fils_discovery_frame_control_ano;
static int hf_ieee80211_ff_fils_discovery_frame_control_channel_center_frequency;
static int hf_ieee80211_ff_fils_discovery_frame_control_primary_channel;
static int hf_ieee80211_ff_fils_discovery_frame_control_rsn_info;
static int hf_ieee80211_ff_fils_discovery_frame_control_length;
static int hf_ieee80211_ff_fils_discovery_frame_control_md;
static int hf_ieee80211_ff_fils_discovery_frame_control_reserved;
static int hf_ieee80211_ff_fils_discovery_ssid;
static int hf_ieee80211_ff_fils_discovery_capability;
static int hf_ieee80211_ff_fils_discovery_capability_ess;
static int hf_ieee80211_ff_fils_discovery_capability_privacy;
static int hf_ieee80211_ff_fils_discovery_capability_bss_operating_channel_width;
static int hf_ieee80211_ff_fils_discovery_capability_max_number_of_spatial_streams;
static int hf_ieee80211_ff_fils_discovery_capability_reserved;
static int hf_ieee80211_ff_fils_discovery_capability_multiple_bssid;
static int hf_ieee80211_ff_fils_discovery_capability_phy_index;
static int hf_ieee80211_ff_fils_discovery_capability_fils_minimum_rate_dsss;
static int hf_ieee80211_ff_fils_discovery_capability_fils_minimum_rate_ofdm;
static int hf_ieee80211_ff_fils_discovery_capability_fils_minimum_rate_ht_vht_tvht;
static int hf_ieee80211_ff_fils_discovery_capability_fils_minimum_rate_he;
static int hf_ieee80211_ff_fils_discovery_capability_fils_minimum_rate;

static int hf_ieee80211_ff_fils_discovery_short_ssid;
static int hf_ieee80211_ff_fils_discovery_ap_csn;
static int hf_ieee80211_ff_fils_discovery_ano;
static int hf_ieee80211_ff_fils_discovery_ccfs1;
static int hf_ieee80211_ff_fils_discovery_operating_class;
static int hf_ieee80211_ff_fils_discovery_primary_channel;
static int hf_ieee80211_ff_fils_discovery_rsn_info;
static int hf_ieee80211_ff_fils_discovery_length;
static int hf_ieee80211_ff_fils_discovery_md;

/* IEEE Std 802.11ad */
static int hf_ieee80211_block_ack_RBUFCAP;
static int hf_ieee80211_cf_response_offset;
static int hf_ieee80211_grant_ack_reserved;
static int hf_ieee80211_ff_dynamic_allocation;
static int hf_ieee80211_ff_TID;
static int hf_ieee80211_ff_alloc_type;
static int hf_ieee80211_ff_src_aid;
static int hf_ieee80211_ff_dest_aid;
static int hf_ieee80211_ff_alloc_duration;
static int hf_ieee80211_ff_b39;
static int hf_ieee80211_ff_ssw;
static int hf_ieee80211_ff_ssw_direction;
static int hf_ieee80211_ff_ssw_cdown;
static int hf_ieee80211_ff_ssw_sector_id;
static int hf_ieee80211_ff_ssw_dmg_ant_id;
static int hf_ieee80211_ff_ssw_rxss_len;
static int hf_ieee80211_ff_bf;
static int hf_ieee80211_ff_bf_train;
static int hf_ieee80211_ff_bf_is_init;
static int hf_ieee80211_ff_bf_is_resp;
static int hf_ieee80211_ff_bf_num_sectors;
static int hf_ieee80211_ff_bf_num_rx_dmg_ants;
static int hf_ieee80211_ff_bf_b12b15;
static int hf_ieee80211_ff_bf_rxss_len;
static int hf_ieee80211_ff_bf_rxss_rate;
static int hf_ieee80211_ff_bf_b10b15;
static int hf_ieee80211_addr_nav_da;
static int hf_ieee80211_addr_nav_sa;
static int hf_ieee80211_ff_sswf;
static int hf_ieee80211_ff_sswf_num_rx_dmg_ants;
static int hf_ieee80211_ff_sswf_poll_required;
static int hf_ieee80211_ff_sswf_total_sectors;
static int hf_ieee80211_ff_sswf_reserved1;
static int hf_ieee80211_ff_sswf_reserved2;
static int hf_ieee80211_ff_sswf_sector_select;
static int hf_ieee80211_ff_sswf_dmg_antenna_select;
static int hf_ieee80211_ff_sswf_snr_report;
static int hf_ieee80211_ff_brp;
static int hf_ieee80211_ff_brp_L_RX;
static int hf_ieee80211_ff_brp_TX_TRN_REQ;
static int hf_ieee80211_ff_brp_MID_REQ;
static int hf_ieee80211_ff_brp_BC_REQ;
static int hf_ieee80211_ff_brp_MID_GRANT;
static int hf_ieee80211_ff_brp_BC_GRANT;
static int hf_ieee80211_ff_brp_chan_FBCK_CAP;
static int hf_ieee80211_ff_brp_tx_sector;
static int hf_ieee80211_ff_brp_other_aid;
static int hf_ieee80211_ff_brp_tx_antenna;
static int hf_ieee80211_ff_brp_reserved;
static int hf_ieee80211_ff_blm;
static int hf_ieee80211_ff_blm_unit_index;
static int hf_ieee80211_ff_blm_maint_value;
static int hf_ieee80211_ff_blm_is_master;
static int hf_ieee80211_ff_bic;
static int hf_ieee80211_ff_bic_cc_present;
static int hf_ieee80211_ff_bic_discovery_mode;
static int hf_ieee80211_ff_bic_next_beacon;
static int hf_ieee80211_ff_bic_ati_present;
static int hf_ieee80211_ff_bic_abft_len;
static int hf_ieee80211_ff_bic_fss;
static int hf_ieee80211_ff_bic_is_resp;
static int hf_ieee80211_ff_bic_next_abft;
static int hf_ieee80211_ff_bic_frag_txss;
static int hf_ieee80211_ff_bic_txss_span;
static int hf_ieee80211_ff_bic_NBI_abft;
static int hf_ieee80211_ff_bic_abft_count;
static int hf_ieee80211_ff_bic_nabft;
static int hf_ieee80211_ff_bic_pcp;
static int hf_ieee80211_ff_bic_reserved;
static int * const ieee80211_ff_bic_fields[] = {
  &hf_ieee80211_ff_bic_cc_present,
  &hf_ieee80211_ff_bic_discovery_mode,
  &hf_ieee80211_ff_bic_next_beacon,
  &hf_ieee80211_ff_bic_ati_present,
  &hf_ieee80211_ff_bic_abft_len,
  &hf_ieee80211_ff_bic_fss,
  &hf_ieee80211_ff_bic_is_resp,
  &hf_ieee80211_ff_bic_next_abft,
  &hf_ieee80211_ff_bic_frag_txss,
  &hf_ieee80211_ff_bic_txss_span,
  &hf_ieee80211_ff_bic_NBI_abft,
  &hf_ieee80211_ff_bic_abft_count,
  &hf_ieee80211_ff_bic_nabft,
  &hf_ieee80211_ff_bic_pcp,
  &hf_ieee80211_ff_bic_reserved,
  NULL
};
static int hf_ieee80211_ff_dmg_params;
static int hf_ieee80211_ff_dmg_params_bss;
static int hf_ieee80211_ff_dmg_params_cbap_only;
static int hf_ieee80211_ff_dmg_params_cbap_src;
static int hf_ieee80211_ff_dmg_params_privacy;
static int hf_ieee80211_ff_dmg_params_policy;
static int hf_ieee80211_ff_dmg_params_spec_mgmt;
static int hf_ieee80211_ff_dmg_params_radio_measure;
static int hf_ieee80211_ff_cc;
static int hf_ieee80211_ff_cc_abft_resp_addr;
static int hf_ieee80211_ff_cc_sp_duration;
static int hf_ieee80211_ff_cc_cluster_id;
static int hf_ieee80211_ff_cc_role;
static int hf_ieee80211_ff_cc_max_mem;
static int hf_ieee80211_ff_dmg_action_code;
static int hf_ieee80211_ff_dmg_pwr_mgmt;
static int hf_ieee80211_ff_subject_address;
static int hf_ieee80211_ff_handover_reason;
static int hf_ieee80211_ff_handover_remaining_bi;
static int hf_ieee80211_ff_handover_result;
static int hf_ieee80211_ff_handover_reject_reason;
static int hf_ieee80211_ff_destination_reds_aid;
static int hf_ieee80211_ff_destination_aid;
static int hf_ieee80211_ff_relay_aid;
static int hf_ieee80211_ff_source_aid;
static int hf_ieee80211_ff_timing_offset;
static int hf_ieee80211_ff_sampling_frequency_offset;
static int hf_ieee80211_ff_relay_operation_type;
static int hf_ieee80211_ff_peer_sta_aid;
static int hf_ieee80211_ff_snr;
static int hf_ieee80211_ff_internal_angle;
static int hf_ieee80211_ff_recommend;
static int hf_ieee80211_ff_unprotected_dmg_action_code;
static int hf_ieee80211_ff_fst_action_code;
static int hf_ieee80211_ff_robust_av_streaming_action_code;
static int hf_ieee80211_ff_llt;
static int hf_ieee80211_ff_fsts_id;
static int hf_ieee80211_ff_mmpdu_len;
static int hf_ieee80211_ff_mmpdu_ctrl;
static int hf_ieee80211_ff_oct_mmpdu;
static int hf_ieee80211_ff_scs_scsid;
static int hf_ieee80211_ff_scs_status;
static int hf_ieee80211_ff_scs_response_count;

#if 0
static int hf_ieee80211_ff_rcsi;
static int hf_ieee80211_ff_rcsi_aid;
#endif
static int hf_ieee80211_ff_band_id;
static int hf_ieee80211_tag_relay_support;
static int hf_ieee80211_tag_relay_use;
static int hf_ieee80211_tag_relay_permission;
static int hf_ieee80211_tag_AC_power;
static int hf_ieee80211_tag_relay_prefer;
static int hf_ieee80211_tag_duplex;
static int hf_ieee80211_tag_cooperation;
static int hf_ieee80211_tag_move;
static int hf_ieee80211_tag_size;
static int hf_ieee80211_tag_tbtt_offset;
static int hf_ieee80211_tag_bi_duration;
static int hf_ieee80211_tag_dmg_capa_sta_addr;
static int hf_ieee80211_tag_dmg_capa_aid;
static int hf_ieee80211_tag_reverse_direction;
static int hf_ieee80211_tag_hlts;
static int hf_ieee80211_tag_tpc;
static int hf_ieee80211_tag_spsh;
static int hf_ieee80211_tag_rx_antenna;
static int hf_ieee80211_tag_fast_link;
static int hf_ieee80211_tag_num_sectors;
static int hf_ieee80211_tag_rxss_length;
static int hf_ieee80211_tag_reciprocity;
static int hf_ieee80211_tag_max_ampdu_exp;
static int hf_ieee80211_tag_min_mpdu_spacing;
static int hf_ieee80211_tag_ba_flow_control;
static int hf_ieee80211_tag_max_sc_rx_mcs;
static int hf_ieee80211_tag_max_ofdm_rx_mcs;
static int hf_ieee80211_tag_max_sc_tx_mcs;
static int hf_ieee80211_tag_max_ofdm_tx_mcs;
static int hf_ieee80211_tag_low_power_supported;
static int hf_ieee80211_tag_code_rate;
static int hf_ieee80211_tag_dtp;
static int hf_ieee80211_tag_appdu_supp;
static int hf_ieee80211_tag_heartbeat;
static int hf_ieee80211_tag_other_aid;
static int hf_ieee80211_tag_pattern_recip;
static int hf_ieee80211_tag_heartbeat_elapsed;
static int hf_ieee80211_tag_grant_ack_supp;
static int hf_ieee80211_tag_RXSSTxRate_supp;
static int hf_ieee80211_tag_pcp_tddti;
static int hf_ieee80211_tag_pcp_PSA;
static int hf_ieee80211_tag_pcp_handover;
static int hf_ieee80211_tag_pcp_max_assoc;
static int hf_ieee80211_tag_pcp_power_src;
static int hf_ieee80211_tag_pcp_decenter;
static int hf_ieee80211_tag_pcp_forwarding;
static int hf_ieee80211_tag_pcp_center;
static int hf_ieee80211_tag_sta_beam_track;
static int hf_ieee80211_tag_ext_sc_mcs_max_tx;
static int hf_ieee80211_tag_ext_sc_mcs_tx_code_7_8;
static int hf_ieee80211_tag_ext_sc_mcs_max_rx;
static int hf_ieee80211_tag_ext_sc_mcs_rx_code_7_8;
static int hf_ieee80211_tag_max_basic_sf_amsdu;
static int hf_ieee80211_tag_max_short_sf_amsdu;
static int hf_ieee80211_tag_PSRSI;
static int hf_ieee80211_tag_min_BHI_duration;
static int hf_ieee80211_tag_brdct_sta_info_dur;
static int hf_ieee80211_tag_assoc_resp_confirm_time;
static int hf_ieee80211_tag_min_pp_duration;
static int hf_ieee80211_tag_SP_idle_timeout;
static int hf_ieee80211_tag_max_lost_beacons;
static int hf_ieee80211_tag_type;
static int hf_ieee80211_tag_tap1;
static int hf_ieee80211_tag_state1;
static int hf_ieee80211_tag_tap2;
static int hf_ieee80211_tag_state2;
static int hf_ieee80211_tag_allocation_id;
static int hf_ieee80211_tag_allocation_type;
static int hf_ieee80211_tag_pseudo_static;
static int hf_ieee80211_tag_truncatable;
static int hf_ieee80211_tag_extendable;
static int hf_ieee80211_tag_pcp_active;
static int hf_ieee80211_tag_lp_sc_used;
static int hf_ieee80211_tag_src_aid;
static int hf_ieee80211_tag_dest_aid;
static int hf_ieee80211_tag_alloc_start;
static int hf_ieee80211_tag_alloc_block_duration;
static int hf_ieee80211_tag_num_blocks;
static int hf_ieee80211_tag_alloc_block_period;
static int hf_ieee80211_tag_aid;
static int hf_ieee80211_tag_cbap;
static int hf_ieee80211_tag_pp_avail;
static int hf_ieee80211_tag_next_ati_start_time;
static int hf_ieee80211_tag_next_ati_duration;
static int hf_ieee80211_tag_old_bssid;
static int hf_ieee80211_tag_new_pcp_addr;
static int hf_ieee80211_tag_bssid;
static int hf_ieee80211_tag_duplex_relay;
static int hf_ieee80211_tag_cooperation_relay;
static int hf_ieee80211_tag_tx_mode;
static int hf_ieee80211_tag_link_change_interval;
static int hf_ieee80211_tag_data_sensing_time;
static int hf_ieee80211_tag_first_period;
static int hf_ieee80211_tag_second_period;
static int hf_ieee80211_tag_initiator;
static int hf_ieee80211_tag_tx_train_res;
static int hf_ieee80211_tag_rx_train_res;
static int hf_ieee80211_tag_tx_trn_ok;
static int hf_ieee80211_tag_txss_fbck_req;
static int hf_ieee80211_tag_bs_fbck;
static int hf_ieee80211_tag_bs_fbck_antenna_id;
static int hf_ieee80211_tag_snr_requested;
static int hf_ieee80211_tag_channel_measurement_requested;
static int hf_ieee80211_tag_number_of_taps_requested;
static int hf_ieee80211_tag_sector_id_order_req;
static int hf_ieee80211_tag_snr_present;
static int hf_ieee80211_tag_channel_measurement_present;
static int hf_ieee80211_tag_tap_delay_present;
static int hf_ieee80211_tag_number_of_taps_present;
static int hf_ieee80211_tag_number_of_measurement;
static int hf_ieee80211_tag_sector_id_order_present;
static int hf_ieee80211_tag_number_of_beams;
static int hf_ieee80211_tag_mid_extension;
static int hf_ieee80211_tag_capability_request;
static int hf_ieee80211_tag_beam_refine_reserved;
static int hf_ieee80211_tag_nextpcp_list;
static int hf_ieee80211_tag_nextpcp_token;
static int hf_ieee80211_tag_reamaining_BI;
static int hf_ieee80211_tag_request_token;
static int hf_ieee80211_tag_bi_start_time;
static int hf_ieee80211_tag_sleep_cycle;
static int hf_ieee80211_tag_num_awake_bis;
static int hf_ieee80211_tag_tspec_allocation_id;
static int hf_ieee80211_tag_tspec_allocation_type;
static int hf_ieee80211_tag_tspec_allocation_format;
static int hf_ieee80211_tag_tspec_pseudo_static;
static int hf_ieee80211_tag_tspec_truncatable;
static int hf_ieee80211_tag_tspec_extendable;
static int hf_ieee80211_tag_tspec_lp_sc_used;
static int hf_ieee80211_tag_tspec_up;
static int hf_ieee80211_tag_tspec_dest_aid;
static int hf_ieee80211_tag_tspec_allocation_period;
static int hf_ieee80211_tag_tspec_min_allocation;
static int hf_ieee80211_tag_tspec_max_allocation;
static int hf_ieee80211_tag_tspec_min_duration;
static int hf_ieee80211_tag_tspec_num_of_constraints;
static int hf_ieee80211_tag_tspec_tsconst_start_time;
static int hf_ieee80211_tag_tspec_tsconst_duration;
static int hf_ieee80211_tag_tspec_tsconst_period;
static int hf_ieee80211_tag_tspec_tsconst_interferer_mac;
static int hf_ieee80211_tag_channel_measurement_feedback_relative_I;
static int hf_ieee80211_tag_channel_measurement_feedback_relative_Q;
static int hf_ieee80211_tag_channel_measurement_feedback_tap_delay;
static int hf_ieee80211_tag_channel_measurement_feedback_sector_id;
static int hf_ieee80211_tag_channel_measurement_feedback_antenna_id;
static int hf_ieee80211_tag_awake_window;
static int hf_ieee80211_tag_addba_ext_no_frag;
static int hf_ieee80211_tag_addba_ext_he_fragmentation_operation;
static int hf_ieee80211_tag_addba_ext_reserved;
static int hf_ieee80211_tag_addba_ext_buffer_size;
static int hf_ieee80211_tag_multi_band_ctrl_sta_role;
static int hf_ieee80211_tag_multi_band_ctrl_addr_present;
static int hf_ieee80211_tag_multi_band_ctrl_cipher_present;
static int hf_ieee80211_tag_multi_band_oper_class;
static int hf_ieee80211_tag_multi_band_channel_number;
static int hf_ieee80211_tag_multi_band_tsf_offset;
static int hf_ieee80211_tag_multi_band_conn_ap;
static int hf_ieee80211_tag_multi_band_conn_pcp;
static int hf_ieee80211_tag_multi_band_conn_dls;
static int hf_ieee80211_tag_multi_band_conn_tdls;
static int hf_ieee80211_tag_multi_band_conn_ibss;
static int hf_ieee80211_tag_multi_band_fst_timeout;
static int hf_ieee80211_tag_multi_band_sta_mac;
static int hf_ieee80211_tag_activity;
static int hf_ieee80211_tag_dmg_link_adapt_mcs;
static int hf_ieee80211_tag_dmg_link_adapt_link_margin;
static int hf_ieee80211_tag_ref_timestamp;
static int hf_ieee80211_tag_switching_stream_non_qos;
static int hf_ieee80211_tag_switching_stream_param_num;
static int hf_ieee80211_tag_switching_stream_old_tid;
static int hf_ieee80211_tag_switching_stream_old_direction;
static int hf_ieee80211_tag_switching_stream_new_tid;
static int hf_ieee80211_tag_switching_stream_new_direction;
static int hf_ieee80211_tag_switching_stream_new_valid_id;
static int hf_ieee80211_tag_switching_stream_llt_type;

static int hf_ieee80211_mysterious_extra_stuff;

static int hf_ieee80211_mscs_descriptor_type;
static int hf_ieee80211_mscs_user_prio_control_reserved;
static int hf_ieee80211_user_prio_bitmap;
static int hf_ieee80211_user_prio_bitmap_bit0;
static int hf_ieee80211_user_prio_bitmap_bit1;
static int hf_ieee80211_user_prio_bitmap_bit2;
static int hf_ieee80211_user_prio_bitmap_bit3;
static int hf_ieee80211_user_prio_bitmap_bit4;
static int hf_ieee80211_user_prio_bitmap_bit5;
static int hf_ieee80211_user_prio_bitmap_bit6;
static int hf_ieee80211_user_prio_bitmap_bit7;
static int hf_ieee80211_user_prio_limit;
static int hf_ieee80211_user_prio_reserved;
static int hf_ieee80211_stream_timeout_reserved;
static int hf_ieee80211_stream_timeout;
static int hf_ieee80211_mscs_subelement_id;
static int hf_ieee80211_mscs_subelement_len;
static int hf_ieee80211_mscs_subelement_data;

static int hf_ieee80211_intra_access_prio;
static int hf_ieee80211_intra_access_prio_user_prio;
static int hf_ieee80211_intra_access_prio_alt_queue;
static int hf_ieee80211_intra_access_prio_drop_elig;
static int hf_ieee80211_intra_access_prio_reserved;

static int hf_ieee80211_scs_descriptor_scsid;
static int hf_ieee80211_scs_descriptor_type;

static int hf_ieee80211_esp_access_category;
static int hf_ieee80211_esp_reserved;
static int hf_ieee80211_esp_data_format;
static int hf_ieee80211_esp_ba_windows_size;
static int hf_ieee80211_esp_est_air_time_frac;
static int hf_ieee80211_esp_data_ppdu_duration_target;
static int hf_ieee80211_estimated_service_params;

static int hf_ieee80211_fcg_new_channel_number;
static int hf_ieee80211_fcg_extra_info;
static int hf_ieee80211_sae_password_identifier;

static int hf_ieee80211_sae_anti_clogging_token;

static int hf_ieee80211_tag_fils_indication_info_nr_pk;
static int hf_ieee80211_tag_fils_indication_info_nr_realm;
static int hf_ieee80211_tag_fils_indication_info_ip_config;
static int hf_ieee80211_tag_fils_indication_info_cache_id_included;
static int hf_ieee80211_tag_fils_indication_info_hessid_included;
static int hf_ieee80211_tag_fils_indication_info_ska_without_pfs;
static int hf_ieee80211_tag_fils_indication_info_ska_with_pfs;
static int hf_ieee80211_tag_fils_indication_info_pka;
static int hf_ieee80211_tag_fils_indication_info_reserved;
static int hf_ieee80211_tag_fils_indication_cache_identifier;
static int hf_ieee80211_tag_fils_indication_hessid;
static int hf_ieee80211_tag_fils_indication_realm_list;
static int hf_ieee80211_tag_fils_indication_realm_identifier;
static int hf_ieee80211_tag_fils_indication_public_key_list;
static int hf_ieee80211_tag_fils_indication_public_key_type;
static int hf_ieee80211_tag_fils_indication_public_key_length;
static int hf_ieee80211_tag_fils_indication_public_key_indicator;

static int hf_ieee80211_qos_mgmt_attribute_id;
static int hf_ieee80211_qos_mgmt_attribute_len;
static int hf_ieee80211_qos_mgmt_start_port_range;
static int hf_ieee80211_qos_mgmt_end_port_range;
static int hf_ieee80211_qos_mgmt_dscp_pol_id;
static int hf_ieee80211_qos_mgmt_dscp_pol_req_type;
static int hf_ieee80211_qos_mgmt_dscp_pol_dscp;
static int hf_ieee80211_qos_mgmt_domain_name;
static int hf_ieee80211_qos_mgmt_unknown_attr;

static int hf_ieee80211_ext_tag;
static int hf_ieee80211_ext_tag_number;
static int hf_ieee80211_ext_tag_length;
static int hf_ieee80211_ext_tag_data;

static int hf_ieee80211_fils_req_params_parameter_control_bitmap;
static int hf_ieee80211_fils_req_params_fils_criteria_present;
static int hf_ieee80211_fils_req_params_max_delay_limit_present;
static int hf_ieee80211_fils_req_params_minimum_data_rate_present;
static int hf_ieee80211_fils_req_params_rcpi_limit_present;
static int hf_ieee80211_fils_req_params_oui_response_criteria_present;
static int hf_ieee80211_fils_req_params_reserved;
static int hf_ieee80211_fils_req_params_max_channel_time;
static int hf_ieee80211_fils_req_params_fils_criteria;
static int hf_ieee80211_fils_req_params_fils_criteria_bss_delay;
static int hf_ieee80211_fils_req_params_fils_criteria_phy_support;
static int hf_ieee80211_fils_req_params_fils_criteria_reserved;
static int hf_ieee80211_fils_req_params_max_delay_limit;
static int hf_ieee80211_fils_req_params_minimum_data_rate;
static int hf_ieee80211_fils_req_params_rcpi_limit;
static int hf_ieee80211_fils_req_params_oui_response_criteria;

static int hf_ieee80211_fils_session;
static int hf_ieee80211_fils_encrypted_data;
static int hf_ieee80211_fils_nonce;

/* wfa 60g ie tree */
static int hf_ieee80211_wfa_60g_attr;
static int hf_ieee80211_wfa_60g_attr_id;
static int hf_ieee80211_wfa_60g_attr_len;

static int hf_ieee80211_wfa_60g_attr_cap_sta_mac_addr;
static int hf_ieee80211_wfa_60g_attr_cap_recv_amsdu_frames;
static int hf_ieee80211_wfa_60g_attr_cap_reserved;

/* ************************************************************************* */
/*                              802.11AX fields                              */
/* ************************************************************************* */
static int hf_ieee80211_he_mac_capabilities;
static int hf_ieee80211_he_htc_he_support;
static int hf_ieee80211_he_twt_requester_support;
static int hf_ieee80211_he_twt_responder_support;
static int hf_ieee80211_he_dynamic_fragmentation_support;
static int hf_ieee80211_he_max_number_fragmented_msdus;
static int hf_ieee80211_he_min_fragment_size;
static int hf_ieee80211_he_trigger_frame_mac_padding_dur;
static int hf_ieee80211_he_multi_tid_aggregation_rx_support;
static int hf_ieee80211_he_he_link_adaptation_support;
static int hf_ieee80211_he_all_ack_support;
static int hf_ieee80211_he_trs_support;
static int hf_ieee80211_he_bsr_support;
static int hf_ieee80211_he_broadcast_twt_support;
static int hf_ieee80211_he_32_bit_ba_bitmap_support;
static int hf_ieee80211_he_mu_cascading_support;
static int hf_ieee80211_he_ack_enabled_aggregation_support;
static int hf_ieee80211_he_reserved_b24;
static int hf_ieee80211_he_om_control_support;
static int hf_ieee80211_he_ofdma_ra_support;
static int hf_ieee80211_he_max_a_mpdu_length_exponent_ext;
static int hf_ieee80211_he_a_msdu_fragmentation_support;
static int hf_ieee80211_he_flexible_twt_schedule_support;
static int hf_ieee80211_he_rx_control_frame_to_multibss;
static int hf_ieee80211_he_bsrp_bqrp_a_mpdu_aggregation;
static int hf_ieee80211_he_qtp_support;
static int hf_ieee80211_he_bqr_support;
static int hf_ieee80211_he_psr_responder;
static int hf_ieee80211_he_ndp_feedback_report_support;
static int hf_ieee80211_he_ops_support;
static int hf_ieee80211_he_a_msdu_in_a_mpdu_support;
static int hf_ieee80211_he_multi_tid_aggregation_tx_support;
static int hf_ieee80211_he_subchannel_selective_trans_support;
static int hf_ieee80211_he_2_996_tone_ru_support;
static int hf_ieee80211_he_om_control_ul_mu_data_disable_rx_support;
static int hf_ieee80211_he_dynamic_sm_power_save;
static int hf_ieee80211_he_punctured_sounding_support;
static int hf_ieee80211_he_ht_and_vht_trigger_frame_rx_support;
static int hf_ieee80211_he_reserved_bit_18;
static int hf_ieee80211_he_reserved_bit_19;
static int hf_ieee80211_he_reserved_bit_25;
static int hf_ieee80211_he_reserved_bit_29;
static int hf_ieee80211_he_reserved_bit_34;
static int hf_ieee80211_he_reserved_bits_5_7;
static int hf_ieee80211_he_reserved_bits_8_9;
static int hf_ieee80211_he_reserved_bits_15_16;
static int hf_ieee80211_he_phy_reserved_b0;
static int hf_ieee80211_he_phy_cap_reserved_b0;
static int hf_ieee80211_he_phy_chan_width_set;
static int hf_ieee80211_he_40mhz_channel_2_4ghz;
static int hf_ieee80211_he_40_and_80_mhz_5ghz;
static int hf_ieee80211_he_160_mhz_5ghz;
static int hf_ieee80211_he_160_80_plus_80_mhz_5ghz;
static int hf_ieee80211_he_242_tone_rus_in_2_4ghz;
static int hf_ieee80211_he_242_tone_rus_in_5ghz;
static int hf_ieee80211_he_5ghz_b0_reserved;
static int hf_ieee80211_he_5ghz_b4_reserved;
static int hf_ieee80211_he_24ghz_b1_reserved;
static int hf_ieee80211_he_24ghz_b2_reserved;
static int hf_ieee80211_he_24ghz_b3_reserved;
static int hf_ieee80211_he_24ghz_b5_reserved;
static int hf_ieee80211_he_chan_width_reserved;
static int hf_ieee80211_he_mcs_max_he_mcs_80_rx_1_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80_rx_2_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80_rx_3_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80_rx_4_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80_rx_5_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80_rx_6_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80_rx_7_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80_rx_8_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80_tx_1_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80_tx_2_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80_tx_3_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80_tx_4_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80_tx_5_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80_tx_6_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80_tx_7_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80_tx_8_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_1_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_2_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_3_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_4_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_5_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_6_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_7_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_8_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_1_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_2_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_3_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_4_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_5_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_6_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_7_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_8_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_160_rx_1_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_160_rx_2_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_160_rx_3_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_160_rx_4_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_160_rx_5_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_160_rx_6_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_160_rx_7_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_160_rx_8_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_160_tx_1_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_160_tx_2_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_160_tx_3_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_160_tx_4_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_160_tx_5_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_160_tx_6_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_160_tx_7_ss;
static int hf_ieee80211_he_mcs_max_he_mcs_160_tx_8_ss;
static int hf_ieee80211_he_rx_he_mcs_map_lte_80;
static int hf_ieee80211_he_tx_he_mcs_map_lte_80;
static int hf_ieee80211_he_rx_he_mcs_map_160;
static int hf_ieee80211_he_tx_he_mcs_map_160;
static int hf_ieee80211_he_rx_he_mcs_map_80_80;
static int hf_ieee80211_he_tx_he_mcs_map_80_80;
static int hf_ieee80211_he_ppe_thresholds_nss;
static int hf_ieee80211_he_ppe_thresholds_ru_index_bitmask;
static int hf_ieee80211_he_ppe_ppet16;
static int hf_ieee80211_he_ppe_ppet8;
static int hf_ieee80211_he_phy_b8_to_b23;
static int hf_ieee80211_he_phy_cap_punctured_preamble_rx;
static int hf_ieee80211_he_phy_cap_device_class;
static int hf_ieee80211_he_phy_cap_ldpc_coding_in_payload;
static int hf_ieee80211_he_phy_cap_he_su_ppdu_1x_he_ltf_08us;
static int hf_ieee80211_he_phy_cap_midamble_tx_rx_max_nsts;
static int hf_ieee80211_he_phy_cap_ndp_with_4x_he_ltf_32us;
static int hf_ieee80211_he_phy_cap_stbc_tx_lt_80mhz;
static int hf_ieee80211_he_phy_cap_stbc_rx_lt_80mhz;
static int hf_ieee80211_he_phy_cap_doppler_tx;
static int hf_ieee80211_he_phy_cap_doppler_rx;
static int hf_ieee80211_he_phy_cap_full_bw_ul_mu_mimo;
static int hf_ieee80211_he_phy_cap_partial_bw_ul_mu_mimo;
static int hf_ieee80211_he_phy_b24_to_b39;
static int hf_ieee80211_he_phy_cap_dcm_max_constellation_tx;
static int hf_ieee80211_he_phy_cap_dcm_max_nss_tx;
static int hf_ieee80211_he_phy_cap_dcm_max_constellation_rx;
static int hf_ieee80211_he_phy_cap_dcm_max_nss_rx;
static int hf_ieee80211_he_phy_cap_rx_partial_bw_su_20mhz_he_mu_ppdu;
static int hf_ieee80211_he_phy_cap_su_beamformer;
static int hf_ieee80211_he_phy_cap_su_beamformee;
static int hf_ieee80211_he_phy_cap_mu_beamformer;
static int hf_ieee80211_he_phy_cap_beamformee_sts_lte_80mhz;
static int hf_ieee80211_he_phy_cap_beamformee_sts_gt_80mhz;
static int hf_ieee80211_he_phy_b40_to_b55;
static int hf_ieee80211_he_phy_cap_number_of_sounding_dims_lte_80;
static int hf_ieee80211_he_phy_cap_number_of_sounding_dims_gt_80;
static int hf_ieee80211_he_phy_cap_ng_eq_16_su_fb;
static int hf_ieee80211_he_phy_cap_ng_eq_16_mu_fb;
static int hf_ieee80211_he_phy_cap_codebook_size_eq_4_2_fb;
static int hf_ieee80211_he_phy_cap_codebook_size_eq_7_5_fb;
static int hf_ieee80211_he_phy_cap_triggered_su_beamforming_fb;
static int hf_ieee80211_he_phy_cap_triggered_mu_beamforming_fb;
static int hf_ieee80211_he_phy_cap_triggered_cqi_fb;
static int hf_ieee80211_he_phy_cap_partial_bw_extended_range;
static int hf_ieee80211_he_phy_cap_partial_bw_dl_mu_mimo;
static int hf_ieee80211_he_phy_cap_ppe_threshold_present;
static int hf_ieee80211_he_phy_b56_to_b71;
static int hf_ieee80211_he_phy_cap_psr_based_sr_support;
static int hf_ieee80211_he_phy_cap_power_boost_factor_ar_support;
static int hf_ieee80211_he_phy_cap_he_su_ppdu_etc_gi;
static int hf_ieee80211_he_phy_cap_max_nc;
static int hf_ieee80211_he_phy_cap_stbc_tx_gt_80_mhz;
static int hf_ieee80211_he_phy_cap_stbc_rx_gt_80_mhz;
static int hf_ieee80211_he_phy_cap_he_er_su_ppdu_4xxx_gi;
static int hf_ieee80211_he_phy_cap_20mhz_in_40mhz_24ghz_band;
static int hf_ieee80211_he_phy_cap_20mhz_in_160_80p80_ppdu;
static int hf_ieee80211_he_phy_cap_80mgz_in_160_80p80_ppdu;
static int hf_ieee80211_he_phy_cap_he_er_su_ppdu_1xxx_gi;
static int hf_ieee80211_he_phy_cap_midamble_tx_rx_2x_xxx_ltf;
static int hf_ieee80211_he_phy_b72_to_b87;
static int hf_ieee80211_he_phy_cap_dcm_max_ru;
static int hf_ieee80211_he_phy_cap_longer_than_16_he_sigb_ofdm_symbol_support;
static int hf_ieee80211_he_phy_cap_non_triggered_cqi_feedback;
static int hf_ieee80211_he_phy_cap_tx_1024_qam_242_tone_ru_support;
static int hf_ieee80211_he_phy_cap_rx_1024_qam_242_tone_ru_support;
static int hf_ieee80211_he_phy_cap_rx_full_bw_su_using_he_muppdu_w_compressed_sigb;
static int hf_ieee80211_he_phy_cap_rx_full_bw_su_using_he_muppdu_w_non_compressed_sigb;
static int hf_ieee80211_he_phy_cap_nominal_packet_padding;
static int hf_ieee80211_he_phy_cap_he_mu_ppdu_ru_rx_max;
static int hf_ieee80211_he_phy_cap_b81_b87_reserved;
static int hf_ieee80211_he_operation_parameter;
static int hf_ieee80211_he_operation_default_pe_duration;
static int hf_ieee80211_he_operation_twt_required;
static int hf_ieee80211_he_operation_txop_duration_rts_threshold;
static int hf_ieee80211_he_operation_vht_operation_information_present;
static int hf_ieee80211_he_operation_co_hosted_bss;
static int hf_ieee80211_he_operation_er_su_disable;
static int hf_ieee80211_he_operation_6ghz_operation_information_present;
static int hf_ieee80211_he_operation_reserved_b16_b23;
static int hf_ieee80211_he_bss_color_information;
static int hf_ieee80211_he_bss_color_info_bss_color;
static int hf_ieee80211_he_bss_color_partial_bss_color;
static int hf_ieee80211_he_bss_color_bss_color_disabled;
static int hf_ieee80211_he_operation_basic_mcs;
static int hf_ieee80211_he_oper_max_he_mcs_for_1_ss;
static int hf_ieee80211_he_oper_max_he_mcs_for_2_ss;
static int hf_ieee80211_he_oper_max_he_mcs_for_3_ss;
static int hf_ieee80211_he_oper_max_he_mcs_for_4_ss;
static int hf_ieee80211_he_oper_max_he_mcs_for_5_ss;
static int hf_ieee80211_he_oper_max_he_mcs_for_6_ss;
static int hf_ieee80211_he_oper_max_he_mcs_for_7_ss;
static int hf_ieee80211_he_oper_max_he_mcs_for_8_ss;
static int hf_ieee80211_he_operation_channel_width;
static int hf_ieee80211_he_operation_channel_center_freq_0;
static int hf_ieee80211_he_operation_channel_center_freq_1;
static int hf_ieee80211_he_operation_max_co_hosted_bssid_indicator;
static int hf_ieee80211_he_operation_6ghz_primary_channel;
static int hf_ieee80211_he_operation_6ghz_control;
static int hf_ieee80211_he_operation_6ghz_control_channel_width;
static int hf_ieee80211_he_operation_6ghz_control_duplicate_beacon;
static int hf_ieee80211_he_operation_6ghz_control_regulatory_info;
static int hf_ieee80211_he_operation_6ghz_control_reserved;
static int hf_ieee80211_he_operation_6ghz_channel_center_freq_0;
static int hf_ieee80211_he_operation_6ghz_channel_center_freq_1;
static int hf_ieee80211_he_operation_6ghz_minimum_rate;
static int hf_ieee80211_he_muac_aci_aifsn;
static int hf_ieee80211_he_muac_aifsn;
static int hf_ieee80211_he_muac_acm;
static int hf_ieee80211_he_muac_aci;
static int hf_ieee80211_he_muac_reserved;
static int hf_ieee80211_he_mu_edca_timer;
static int hf_ieee80211_he_muac_ecwmin_ecwmax;
static int hf_ieee80211_he_srp_disallowed;
static int hf_ieee80211_he_non_srg_obss_pd_sr_disallowed;
static int hf_ieee80211_he_non_srg_offset_present;
static int hf_ieee80211_he_srg_information_present;
static int hf_ieee80211_he_hesiga_spatial_reuse_value15_allowed;
static int hf_ieee80211_he_sr_control_reserved;
static int hf_ieee80211_he_spatial_reuse_sr_control;
static int hf_ieee80211_he_spatial_non_srg_obss_pd_max_offset;
static int hf_ieee80211_he_spatial_srg_obss_pd_min_offset;
static int hf_ieee80211_he_spatial_srg_obss_pd_max_offset;
static int hf_ieee80211_he_spatial_srg_bss_color_bitmap;
static int hf_ieee80211_he_spatial_srg_partial_bssid_bitmap;
static int hf_ieee80211_he_ess_report_planned_ess;
static int hf_ieee80211_he_ess_report_edge_of_ess;
static int hf_ieee80211_he_resource_request_buffer_thresh;
static int hf_ieee80211_he_bss_color_change_new_color_info;
static int hf_ieee80211_he_new_bss_color_info_color;
static int hf_ieee80211_he_new_bss_color_info_reserved;
static int hf_ieee80211_he_bss_color_change_switch_countdown;
static int hf_ieee80211_he_ess_report_info_field;
static int hf_ieee80211_he_ess_report_recommend_transition_thresh;
static int hf_ieee80211_he_ops_duration;
static int hf_ieee80211_he_uora_field;
static int hf_ieee80211_he_uora_eocwmin;
static int hf_ieee80211_he_uora_owcwmax;
static int hf_ieee80211_he_uora_reserved;

static int hf_ieee80211_max_channel_switch_time;

static int hf_ieee80211_oci_operating_class;
static int hf_ieee80211_oci_primary_channel_number;
static int hf_ieee80211_oci_frequency_segment_1;
static int hf_ieee80211_oci_oct_operating_class;
static int hf_ieee80211_oci_oct_primary_channel_number;
static int hf_ieee80211_oci_oct_frequency_segment_1;

static int hf_ieee80211_multiple_bssid_configuration_bssid_count;
static int hf_ieee80211_multiple_bssid_configuration_full_set_rx_periodicity;
static int hf_ieee80211_known_bssid_bitmap;
static int hf_ieee80211_short_ssid;

static int hf_ieee80211_non_inheritance_element_id_list_length;
static int hf_ieee80211_non_inheritance_element_id_list_element_id;
static int hf_ieee80211_non_inheritance_element_id_ext_list_length;
static int hf_ieee80211_non_inheritance_element_id_ext_list_element_id_ext;

static int hf_ieee80211_rejected_groups_group;

static int hf_ieee80211_twt_bcast_flow;
static int hf_ieee80211_twt_individual_flow;
static int hf_ieee80211_twt_individual_flow_id;
static int hf_ieee80211_twt_individual_reserved;
static int hf_ieee80211_twt_bcast_id;
static int hf_ieee80211_twt_neg_type;
static int hf_ieee80211_twt_neg_type2_reserved1;
static int hf_ieee80211_twt_neg_type2_reserved2;
static int hf_ieee80211_twt_bcast_teardown_all;
static int hf_ieee80211_twt_bcast_teardown_all_twt;
static int hf_ieee80211_twt_bcast_twt_id_reserved;
static int hf_ieee80211_twt_bcast_neg_type_reserved;

static int hf_ieee80211_tag_twt_control_field;
static int hf_ieee80211_tag_twt_ndp_paging_indicator;
static int hf_ieee80211_tag_twt_responder_pm_mode;
static int hf_ieee80211_tag_twt_neg_type;
static int hf_ieee80211_tag_twt_info_frame_disabled;
static int hf_ieee80211_tag_twt_wake_duration_unit;
static int hf_ieee80211_tag_twt_link_id_bitmap_present;
static int hf_ieee80211_tag_twt_aligned_twt;

static int hf_ieee80211_tag_twt_req_type_field;
static int hf_ieee80211_tag_twt_req_type_req;
static int hf_ieee80211_tag_twt_req_type_setup_cmd;
static int hf_ieee80211_tag_twt_req_type_trigger;
static int hf_ieee80211_tag_twt_req_type_implicit;
static int hf_ieee80211_tag_twt_req_type_flow_type;
static int hf_ieee80211_tag_twt_req_type_flow_id;
static int hf_ieee80211_tag_twt_req_type_wake_int_exp;
static int hf_ieee80211_tag_twt_req_type_prot;
static int hf_ieee80211_tag_twt_req_type_last_bcst_parm_set;
static int hf_ieee80211_tag_twt_req_type_bcst_twt_recom;
static int hf_ieee80211_tag_twt_req_type_aligned;

static int hf_ieee80211_tag_twt_ndp_paging_field;
static int hf_ieee80211_tag_twt_ndp_paging_p_id;
static int hf_ieee80211_tag_twt_ndp_max_ndp_paging_period;
static int hf_ieee80211_tag_twt_ndp_partial_tsf_offset;
static int hf_ieee80211_tag_twt_ndp_action;
static int hf_ieee80211_tag_twt_ndp_min_sleep_duration;
static int hf_ieee80211_tag_twt_ndp_reserved;
static int hf_ieee80211_tag_twt_link_id_bitmap;
static int hf_ieee80211_tag_twt_aligned_twt_link_bitmap;
static int hf_ieee80211_tag_twt_broadcast_info;
static int hf_ieee80211_tag_twt_bcast_info_persistence;
static int hf_ieee80211_tag_twt_bcast_info_id;
static int hf_ieee80211_tag_twt_bcast_info_rtwt_traffic_present;
static int hf_ieee80211_tag_twt_bcast_info_rtwt_sche_info;
static int hf_ieee80211_tag_twt_traffic_info_control;
static int hf_ieee80211_tag_twt_traffic_info_dl_bitmap_valid;
static int hf_ieee80211_tag_twt_traffic_info_ul_bitmap_valid;
static int hf_ieee80211_tag_twt_traffic_info_reserved;
static int hf_ieee80211_tag_twt_traffic_info_rtwt_dl_bitmap;
static int hf_ieee80211_tag_twt_traffic_info_rtwt_ul_bitmap;

static int hf_ieee80211_tag_twt_target_wake_time;
static int hf_ieee80211_tag_twt_target_wake_time_short;
static int hf_ieee80211_tag_twt_nom_min_twt_wake_dur;
static int hf_ieee80211_tag_twt_wake_interval_mantissa;
static int hf_ieee80211_tag_twt_channel;

static int hf_ieee80211_tag_rsnx;
/* octet 1 */
static int hf_ieee80211_tag_rsnx_length;
static int hf_ieee80211_tag_rsnx_protected_twt_operations_support;
static int hf_ieee80211_tag_rsnx_sae_hash_to_element;
static int hf_ieee80211_tag_rsnx_sae_pk;
static int hf_ieee80211_tag_rsnx_protected_wur_frame_support;
/* octet 2 */
static int hf_ieee80211_tag_rsnx_secure_ltf_support;
static int hf_ieee80211_tag_rsnx_secure_rtt_supported;
static int hf_ieee80211_tag_rsnx_urnm_mfpr_x20;
static int hf_ieee80211_tag_rsnx_protected_announce_support;
static int hf_ieee80211_tag_rsnx_pbac;
static int hf_ieee80211_tag_rsnx_extended_s1g_action_protection;
static int hf_ieee80211_tag_rsnx_spp_amsdu_capable;
static int hf_ieee80211_tag_rsnx_urnm_mfpr;
static int hf_ieee80211_tag_rsnx_reserved;


/* ************************************************************************* */
/*                              RFC 8110 fields                              */
/* ************************************************************************* */
static int hf_ieee80211_owe_dh_parameter_group;
static int hf_ieee80211_owe_dh_parameter_public_key;

/* ************************************************************************* */
/*                               Protocol trees                              */
/* ************************************************************************* */
static int ett_80211;
static int ett_proto_flags;
static int ett_cap_tree;
static int ett_fc_tree;
static int ett_cntrl_wrapper_fc;
static int ett_cntrl_wrapper_payload;
static int ett_fragments;
static int ett_fragment;
static int ett_block_ack;
static int ett_block_ack_tid;
static int ett_block_ack_request_control;
static int ett_block_ack_bitmap;
static int ett_block_ack_request_multi_sta_aid_tid;
static int ett_multi_sta_block_ack;
static int ett_ath_cap_tree;
static int ett_extreme_mesh_services_tree;
static int ett_addr;

static int ett_80211_mgt;
static int ett_fixed_parameters;
static int ett_tagged_parameters;
static int ett_tag_bmapctl_tree;
static int ett_s1g_pvb_tree;
static int ett_s1g_pvb_eb_tree;
static int ett_s1g_pvb_block_control_byte;
static int ett_s1g_pvb_block_bitmap_tree;
static int ett_s1g_pvb_subblock_tree;
static int ett_s1g_pvb_olb_tree;
static int ett_s1g_pvb_olb_subblock;
static int ett_s1g_pvb_ade_tree;
static int ett_s1g_pvb_ade_control;
static int ett_tag_country_fnm_tree;
static int ett_tag_country_rcc_tree;
static int ett_qos_parameters;
static int ett_qos_ps_buf_state;
static int ett_wep_parameters;
static int ett_msh_control;
static int ett_hwmp_targ_flags_tree;
static int ett_mesh_chswitch_flag_tree;
static int ett_mesh_config_cap_tree;
static int ett_mesh_formation_info_tree;
static int ett_bcn_timing_rctrl_tree;
static int ett_bcn_timing_info_tree;
static int ett_gann_flags_tree;
static int ett_pxu_proxy_info_tree;
static int ett_pxu_proxy_info_flags_tree;

static int ett_rsn_gcs_tree;
static int ett_rsn_pcs_tree;
static int ett_rsn_sub_pcs_tree;
static int ett_rsn_akms_tree;
static int ett_rsn_sub_akms_tree;
static int ett_rsn_cap_tree;
static int ett_rsn_pmkid_tree;
static int ett_rsn_gmcs_tree;

static int ett_kde_mlo_link_info;

static int ett_wpa_mcs_tree;
static int ett_wpa_ucs_tree;
static int ett_wpa_sub_ucs_tree;
static int ett_wpa_akms_tree;
static int ett_wpa_sub_akms_tree;
static int ett_wme_ac;
static int ett_wme_aci_aifsn;
static int ett_wme_ecw;
static int ett_wme_qos_info;

static int ett_update_edca_info;

static int ett_ht_cap_tree;
static int ett_ampduparam_tree;
static int ett_mcsset_tree;
static int ett_mcsbit_tree;
static int ett_htex_cap_tree;
static int ett_txbf_tree;
static int ett_antsel_tree;
static int ett_hta_cap_tree;
static int ett_hta_cap1_tree;
static int ett_hta_cap2_tree;

static int ett_s1g_ndp;
static int ett_s1g_ndp_ack;
static int ett_s1g_ndp_cts;
static int ett_s1g_ndp_cf_end;
static int ett_s1g_ndp_ps_poll;
static int ett_s1g_ndp_ps_poll_ack;
static int ett_s1g_ndp_block_ack;
static int ett_s1g_ndp_beamforming_report_poll;
static int ett_s1g_ndp_paging;
static int ett_s1g_ndp_probe;
static int ett_pv1_sid;
static int ett_pv1_sid_field;
static int ett_pv1_seq_control;
static int ett_ieee80211_s1g_capabilities_info;
static int ett_ieee80211_s1g_capabilities;
static int ett_s1g_cap_byte1;
static int ett_s1g_cap_byte2;
static int ett_s1g_cap_byte3;
static int ett_s1g_cap_byte4;
static int ett_s1g_cap_byte5;
static int ett_s1g_cap_byte6;
static int ett_s1g_cap_byte7;
static int ett_s1g_cap_byte8;
static int ett_s1g_cap_byte9;
static int ett_s1g_cap_byte10;
static int ett_ieee80211_s1g_sup_mcs_and_nss_set;
static int ett_s1g_mcs_and_mcs_set;
static int ett_s1g_operation_info;
static int ett_s1g_channel_width;
static int ett_s1g_subchannel_selective_transmission;
static int ett_s1g_raw_assignment;
static int ett_s1g_raw_assn_tree;
static int ett_s1g_raw_control;
static int ett_s1g_raw_slot_def;
static int ett_s1g_raw_group_subfield;
static int ett_s1g_raw_channel_indication;
static int ett_s1g_page_slice_control;
static int ett_s1g_aid_request_mode;
static int ett_s1g_aid_characteristic;
static int ett_s1g_sector_operation;
static int ett_tack_info;
static int ett_ieee80211_s1g_auth_control;
static int ett_s1g_relay_control;
static int ett_s1g_relay_function;
static int ett_ieee80211_s1g_addr_list;
static int ett_ieee80211_s1g_reach_addr;
static int ett_s1g_relay_discovery_control;
static int ett_ieee80211_s1g_aid_entry;
static int ett_s1g_probe_resp_subfield_0;
static int ett_s1g_header_comp_control;
static int ett_pv1_mgmt_action;
static int ett_pv1_mgmt_action_no_ack;
static int ett_pv1_cntl_stack;
static int ett_pv1_cntl_bat;

static int ett_htc_tree;
static int ett_htc_he_a_control;
static int ett_mfb_subtree;
static int ett_lac_subtree;
static int ett_ieee80211_buffer_status_report;
static int ett_ieee80211_a_control_padding;
static int ett_ieee80211_a_control_ones;
static int ett_ieee80211_triggered_response_schedule;
static int ett_ieee80211_control_om;
static int ett_ieee80211_hla_control;
static int ett_ieee80211_control_uph;
static int ett_ieee80211_buffer_control_bqr;
static int ett_ieee80211_control_cci;
static int ett_ieee80211_control_eht_om;
static int ett_ieee80211_control_srs;
static int ett_ieee80211_control_aar;

static int ett_vht_cap_tree;
static int ett_vht_mcsset_tree;
static int ett_vht_rx_mcsbit_tree;
static int ett_vht_tx_mcsbit_tree;
static int ett_vht_basic_mcsbit_tree;
static int ett_vht_op_tree;
static int ett_vht_tpe_info_tree;
static int ett_tpe_psd;

static int ett_vht_ranging_annc;
static int ett_ndp_ranging_annc_sta_info;

static int ett_ff_he_action;
static int ett_ff_protected_he_action;
static int ett_ff_protected_eht_action;
static int ett_ff_he_mimo_control;
static int ett_ff_he_mimo_beamforming_report_snr;
static int ett_ff_he_mimo_feedback_matrices;

static int ett_ff_vhtmimo_cntrl;
static int ett_ff_vhtmimo_beamforming_report;
static int ett_ff_vhtmimo_beamforming_report_snr;
static int ett_ff_vhtmimo_beamforming_angle;
static int ett_ff_vhtmimo_beamforming_report_feedback_matrices;
static int ett_ff_vhtmu_exclusive_beamforming_report_matrices;

static int ett_vht_grpidmgmt;
static int ett_vht_msa;
static int ett_vht_upa;

static int ett_ht_info_delimiter1_tree;
static int ett_ht_info_delimiter2_tree;
static int ett_ht_info_delimiter3_tree;

static int ett_ff_ftm_param_delim1;
static int ett_ff_ftm_param_delim2;
static int ett_ff_ftm_param_delim3;
static int ett_ff_ftm_tod_err1;
static int ett_ff_ftm_toa_err1;
static int ett_tag_ranging;
static int ett_tag_ranging_ntb;

static int ett_ranging_subelement_tree;

static int ett_tag_direct_meas_results;

static int ett_rsta_avail_header;
static int ett_rsta_avail_tree;
static int ett_rsta_avail_subfield;

static int ett_pasn_parameters;
static int ett_pasn_comeback_tree;

static int ett_pasn_auth_frame;

/* 802.11be trees */
static int ett_eht_multi_link_control;
static int ett_eht_multi_link_common_info;
static int ett_eht_multi_link_common_info_link_id;
static int ett_eht_multi_link_common_info_medium_sync;
static int ett_eht_multi_link_common_info_eml_capa;
static int ett_eht_multi_link_common_info_mld_capa;
static int ett_eht_multi_link_common_info_ext_mld_capa;
static int ett_eht_multi_link_per_sta;
static int ett_eht_multi_link_subelt;
static int ett_eht_multi_link_sta_control;
static int ett_eht_multi_link_per_sta_info;
static int ett_eht_multi_link_sta_dtim;
static int ett_eht_multi_link_reconf_oper_param;
static int ett_eht_multi_link_reconfig_presence_indi;
static int ett_eht_multi_link_reconfig_operation_para_info;
static int ett_eht_operation_params;
static int ett_eht_operation_control;
static int ett_eht_mac_capa;
static int ett_eht_phy_capa;
static int ett_eht_phy_bits_0_15;
static int ett_eht_phy_bits_16_31;
static int ett_eht_phy_bits_32_39;
static int ett_eht_phy_bits_40_63;
static int ett_eht_phy_bits_64_71;
static int ett_eht_phy_mcs_nss;
static int ett_eht_phy_mcs_nss_set;
static int ett_eht_ttl_mapping;
static int ett_eht_ttl_mapping_link_mapping;
static int ett_eht_eht_multi_link_tc;
static int ett_eht_qos_characteristics;
static int ett_eht_aid_bmapctl_tree;
static int ett_eht_bw_indication_param;
static int ett_eht_eml_control;
static int ett_eht_eml_control_link_map;
static int ett_eht_eml_control_mcs_map_count;
static int ett_eht_emlsr_para_update;
static int ett_eht_mimo_ctrl;
static int ett_eht_beamforming_rpt_ru_index;
static int ett_eht_beamforming_feedback_tree;
static int ett_ff_eht_mimo_beamforming_report_snr;
static int ett_ff_eht_mimo_mu_exclusive_report;
static int ett_eht_mu_exclusive_beamforming_rpt_ru_index;

static int ett_tag_measure_request_mode_tree;
static int ett_tag_measure_request_type_tree;
static int ett_tag_measure_request_sub_element_tree;
static int ett_tag_measure_report_mode_tree;
static int ett_tag_measure_report_type_tree;
static int ett_tag_measure_report_basic_map_tree;
static int ett_tag_measure_report_rpi_tree;
static int ett_tag_measure_report_frame_tree;
static int ett_tag_measure_report_sub_element_tree;
static int ett_tag_measure_reported_frame_tree;
static int ett_tag_measure_reported_frame_frag_id_tree;
static int ett_tag_measure_reported_lci_z_tree;
static int ett_tag_measure_reported_lci_urp_tree;
static int ett_tag_bss_bitmask_tree;
static int ett_tag_dfs_map_tree;
static int ett_tag_dfs_map_flags_tree;
static int ett_tag_erp_info_tree;
static int ett_tag_ex_cap1;
static int ett_tag_ex_cap2;
static int ett_tag_ex_cap3;
static int ett_tag_ex_cap4;
static int ett_tag_ex_cap5;
static int ett_tag_ex_cap6;
static int ett_tag_ex_cap7;
static int ett_tag_ex_cap8;
static int ett_tag_ex_cap89;
static int ett_tag_ex_cap10;
static int ett_tag_ex_cap11;
static int ett_tag_ex_cap12;
static int ett_tag_ex_cap13;

static int ett_tag_rm_cap1;
static int ett_tag_rm_cap2;
static int ett_tag_rm_cap3;
static int ett_tag_rm_cap4;
static int ett_tag_rm_cap5;

static int ett_tag_rsnx_octet1;
static int ett_tag_rsnx_octet2;

static int ett_tag_multiple_bssid_subelem_tree;
static int ett_tag_20_40_bc;

static int ett_tag_intolerant_tree;

static int ett_tag_tclas_mask_tree;

static int ett_tag_supported_channels;

static int ett_tag_neighbor_report_bssid_info_tree;
static int ett_tag_neighbor_report_bssid_info_capability_tree;
static int ett_tag_neighbor_report_subelement_tree;
static int ett_tag_neighbor_report_sub_tag_tree;

static int ett_tag_wapi_param_set_akm_tree;
static int ett_tag_wapi_param_set_ucast_tree;
static int ett_tag_wapi_param_set_mcast_tree;
static int ett_tag_wapi_param_set_preauth_tree;

static int ett_max_idle_period_options;

static int ett_tag_time_adv_tree;

static int ett_tag_he_6ghz_cap_inf_tree;

static int ett_ff_ba_param_tree;
static int ett_ff_ba_ssc_tree;
static int ett_ff_delba_param_tree;
static int ett_ff_qos_info;
static int ett_ff_sm_pwr_save;
static int ett_ff_psmp_param_set;
static int ett_ff_mimo_cntrl;
static int ett_ff_ant_sel;
static int ett_mimo_report;
static int ett_ff_chan_switch_announce;
static int ett_ff_ht_info;
static int ett_ff_psmp_sta_info;

static int ett_tpc;

static int ett_msdu_aggregation_parent_tree;
static int ett_msdu_aggregation_subframe_tree;

static int ett_80211_mgt_ie;
static int ett_tsinfo_tree;
static int ett_sched_tree;

static int ett_fcs;

static int ett_hs20_osu_providers_list;
static int ett_hs20_osu_provider_tree;
static int ett_hs20_friendly_names_list;
static int ett_hs20_friendly_name_tree;
static int ett_hs20_osu_provider_method_list;
static int ett_osu_icons_avail_list;
static int ett_hs20_osu_icon_tree;
static int ett_hs20_osu_service_desc_list;
static int ett_hs20_osu_service_desc_tree;
static int ett_hs20_venue_url;
static int ett_hs20_advice_of_charge;
static int ett_hs20_aoc_plan;

static int ett_hs20_ofn_tree;

static int ett_adv_proto;
static int ett_adv_proto_tuple;
static int ett_gas_query;
static int ett_gas_anqp;
static int ett_nai_realm;
static int ett_nai_realm_eap;
static int ett_tag_ric_data_desc_ie;
static int ett_anqp_vendor_capab;

static int ett_osen_group_data_cipher_suite;
static int ett_osen_pairwise_cipher_suites;
static int ett_osen_pairwise_cipher_suite;
static int ett_osen_akm_cipher_suites;
static int ett_osen_akm_cipher_suite;
static int ett_osen_rsn_cap_tree;
static int ett_osen_pmkid_list;
static int ett_osen_pmkid_tree;
static int ett_osen_group_management_cipher_suite;

static int ett_hs20_cc_proto_port_tuple;

static int ett_tag_no_bssid_capability_dmg_bss_control_tree;
static int ett_ssid_list;

static int ett_sgdsn;
static int ett_nintendo;

static int ett_routerboard;

static int ett_meru;

static int ett_wisun_gtkl;
static int ett_wisun_lgtkl;

static int ett_qos_map_set_exception;
static int ett_qos_map_set_range;

static int ett_wnm_notif_subelt;

static int ett_ieee80211_3gpp_plmn;

static int ett_mbo_oce_attr;
static int ett_mbo_ap_cap;
static int ett_oce_cap;
static int ett_oce_metrics_cap;

static int ett_tag_mobility_domain_ft_capab_tree;

static int ett_tag_ft_mic_control_tree;
static int ett_tag_ft_subelem_tree;

static int ett_qos_mgmt_pol_capa;
static int ett_qos_mgmt_attributes;
static int ett_qos_mgmt_dscp_policy_capabilities;
static int ett_qos_mgmt_dscp_policy;
static int ett_qos_mgmt_tclas;
static int ett_qos_mgmt_domain_name;
static int ett_qos_mgmt_unknown_attribute;
static int ett_dscp_policy_status_list;
static int ett_pol_rqst_cont_tree;
static int ett_pol_resp_cont_tree;

static expert_field ei_ieee80211_bad_length;
static expert_field ei_ieee80211_inv_val;
static expert_field ei_ieee80211_vht_tpe_pwr_info_count;
static expert_field ei_ieee80211_ff_query_response_length;
static expert_field ei_ieee80211_ff_anqp_nai_realm_eap_len;
static expert_field ei_hs20_anqp_nai_hrq_length;
static expert_field ei_ieee80211_extra_data;
static expert_field ei_ieee80211_tag_data;
static expert_field ei_ieee80211_tdls_setup_confirm_malformed;
static expert_field ei_ieee80211_ff_anqp_nai_field_len;
static expert_field ei_ieee80211_rsn_pcs_count;
static expert_field ei_ieee80211_tag_measure_request_unknown;
static expert_field ei_ieee80211_tag_measure_request_beacon_unknown;
static expert_field ei_ieee80211_tag_measure_report_unknown;
static expert_field ei_ieee80211_tag_measure_report_beacon_unknown;
static expert_field ei_ieee80211_tag_measure_report_lci_unknown;
static expert_field ei_ieee80211_tag_number;
static expert_field ei_ieee80211_ff_anqp_info_length;
static expert_field ei_hs20_anqp_ofn_length;
static expert_field ei_ieee80211_tdls_setup_response_malformed;
static expert_field ei_ieee80211_ff_anqp_capability;
static expert_field ei_ieee80211_not_enough_room_for_anqp_header;
static expert_field ei_ieee80211_ff_query_request_length;
static expert_field ei_ieee80211_wfa_ie_wme_qos_info_bad_ftype;
static expert_field ei_ieee80211_qos_info_bad_ftype;
static expert_field ei_ieee80211_qos_bad_aifsn;
static expert_field ei_ieee80211_pmkid_count_too_large;
static expert_field ei_ieee80211_ff_anqp_venue_length;
static expert_field ei_ieee80211_ff_anqp_roaming_consortium_oi_len;
static expert_field ei_ieee80211_tag_length;
static expert_field ei_ieee80211_missing_data;
static expert_field ei_ieee80211_rsn_pmkid_count;
static expert_field ei_ieee80211_fc_retry;
static expert_field ei_ieee80211_tag_wnm_sleep_mode_no_key_data;
static expert_field ei_ieee80211_dmg_subtype;
static expert_field ei_ieee80211_vht_action;
static expert_field ei_ieee80211_mesh_peering_unexpected;
static expert_field ei_ieee80211_fcs;
static expert_field ei_ieee80211_mismatched_akm_suite;
static expert_field ei_ieee80211_vs_routerboard_unexpected_len;
static expert_field ei_ieee80211_vs_sgdsn_serialnumber_invalid_len_val;
static expert_field ei_ieee80211_vs_sgdsn_serialnumber_unexpected_len_val;
static expert_field ei_ieee80211_twt_tear_down_bad_neg_type;
static expert_field ei_ieee80211_twt_setup_bad_command;
static expert_field ei_ieee80211_twt_bcast_info_no_term;
static expert_field ei_ieee80211_invalid_control_word;
static expert_field ei_ieee80211_invalid_control_id;
static expert_field ei_ieee80211_invalid_control_length;
static expert_field ei_ieee80211_wfa_60g_attr_len_invalid;
static expert_field ei_ieee80211_wfa_60g_unknown_attribute;
static expert_field ei_ieee80211_htc_in_dmg_packet;
static expert_field ei_ieee80211_eht_invalid_subelement;
static expert_field ei_ieee80211_eht_invalid_action;
static expert_field ei_ieee80211_eht_invalid_multi_link;
static expert_field ei_ieee80211_eht_invalid_nc_nr;


/* 802.11ad trees */
static int ett_dynamic_alloc_tree;
static int ett_ssw_tree;
static int ett_bf_tree;
static int ett_sswf_tree;
static int ett_brp_tree;
static int ett_blm_tree;
static int ett_bic_tree;
static int ett_dmg_params_tree;
static int ett_cc_tree;
static int ett_rcsi_tree;
static int ett_80211_ext;
static int ett_allocation_tree;
static int ett_sta_info;

static int ett_ieee80211_esp;

static int ett_ieee80211_wfa_60g_attr;
static int ett_ieee80211_wfa_transition_disable_tree;

/* 802.11ah trees */
static int ett_s1g_sync_control_tree;
static int ett_s1g_sector_id_index;
static int ett_s1g_twt_information_control;
static int ett_twt_tear_down_tree;
static int ett_twt_control_field_tree;
static int ett_twt_req_type_tree;
static int ett_twt_ndp_paging_field_tree;
static int ett_twt_broadcast_info_tree;
static int ett_twt_traffic_info_tree;
static int ett_twt_traffic_info_control_tree;

/* 802.11ax trees */
static int ett_he_mac_capabilities;
static int ett_he_phy_capabilities;
static int ett_he_phy_cap_first_byte;
static int ett_he_phy_cap_chan_width_set;
static int ett_he_phy_cap_b8_to_b23;
static int ett_he_phy_cap_b24_to_b39;
static int ett_he_phy_cap_b40_to_b55;
static int ett_he_phy_cap_b56_to_b71;
static int ett_he_phy_cap_b72_to_b87;
static int ett_he_mcs_and_nss_set;
static int ett_he_rx_tx_he_mcs_map_lte_80;
static int ett_he_rx_mcs_map_lte_80;
static int ett_he_tx_mcs_map_lte_80;
static int ett_he_rx_tx_he_mcs_map_160;
static int ett_he_rx_mcs_map_160;
static int ett_he_tx_mcs_map_160;
static int ett_he_rx_tx_he_mcs_map_80_80;
static int ett_he_rx_mcs_map_80_80;
static int ett_he_tx_mcs_map_80_80;
static int ett_he_ppe_threshold;
static int ett_he_ppe_nss;
static int ett_he_ppe_ru_alloc;
static int ett_he_uora_tree;
static int ett_he_aic_aifsn;
static int ett_he_spatial_reuse_control;
static int ett_he_bss_new_color_info;
static int ett_he_ess_report_info_field;
static int ett_he_operation_params;
static int ett_he_bss_color_information;
static int ett_he_oper_basic_mcs;
static int ett_he_operation_vht_op_info;
static int ett_mscs_user_prio;
static int ett_ieee80211_user_prio_bitmap;
static int ett_ieee80211_intra_access_prio;
static int ett_he_operation_6ghz;
static int ett_he_operation_6ghz_control;
static int ett_he_mu_edca_param;
static int ett_he_trigger_common_info;
static int ett_he_trigger_ranging;
static int ett_he_trigger_ranging_poll;
static int ett_he_trigger_packet_extension;
static int ett_he_trigger_base_common_info;
static int ett_he_trigger_bar_ctrl;
static int ett_he_trigger_bar_info;
static int ett_he_trigger_user_info;
static int ett_he_trigger_base_user_info;
static int ett_he_trigger_dep_basic_user_info;
static int ett_he_trigger_dep_nfrp_user_info;
static int ett_ndp_annc;
static int ett_ndp_vht_annc_sta_list;
static int ett_ndp_vht_annc_sta_info_tree;
static int ett_ndp_he_annc_sta_list;
static int ett_ndp_he_annc_sta_item;
static int ett_ndp_he_annc_sta_info;
static int ett_ndp_ranging_annc_sta_list;
static int ett_ndp_eht_annc_sta_list;
static int ett_ndp_eht_annc_sta_info;
static int ett_non_inheritance_element_id_list;
static int ett_non_inheritance_element_id_ext_list;

/* 802.11ai trees */
static int ett_fils_indication_realm_list;
static int ett_fils_indication_public_key_list;
static int ett_ff_fils_discovery_frame_control;
static int ett_ff_fils_discovery_capability;
static int ett_neighbor_ap_info;
static int ett_tbtt_infos;
static int ett_rnr_bss_params_tree;
static int ett_rnr_mld_params_tree;

static int ett_ff_fils_req_params;
static int ett_ff_fils_req_params_fils_criteria;

/* Generic address HF list for proto_tree_add_mac48_detail() */
static const mac_hf_list_t mac_addr = {
  &hf_ieee80211_addr,
  &hf_ieee80211_addr_resolved,
  &hf_ieee80211_addr_oui,
  &hf_ieee80211_addr_oui_resolved,
  &hf_ieee80211_addr_lg,
  &hf_ieee80211_addr_ig,
};

/* Generic address HF list for proto_tree_add_mac48_detail() --
 * no LG/IG bits */
static const mac_hf_list_t mac_addr_hidden = {
  &hf_ieee80211_addr,
  &hf_ieee80211_addr_resolved,
  &hf_ieee80211_addr_oui,
  &hf_ieee80211_addr_oui_resolved,
  NULL,
  NULL,
};

/* Destination address HF list for proto_tree_add_mac48_detail() */
static const mac_hf_list_t mac_da = {
  &hf_ieee80211_addr_da,
  &hf_ieee80211_addr_da_resolved,
  &hf_ieee80211_addr_da_oui,
  &hf_ieee80211_addr_da_oui_resolved,
  &hf_ieee80211_addr_da_lg,
  &hf_ieee80211_addr_da_ig,
};

/* Source address HF list for proto_tree_add_mac48_detail() */
static const mac_hf_list_t mac_sa = {
  &hf_ieee80211_addr_sa,
  &hf_ieee80211_addr_sa_resolved,
  &hf_ieee80211_addr_sa_oui,
  &hf_ieee80211_addr_sa_oui_resolved,
  &hf_ieee80211_addr_sa_lg,
  &hf_ieee80211_addr_sa_ig,
};

/* Receiver address HF list for proto_tree_add_mac48_detail() */
static const mac_hf_list_t mac_ra = {
  &hf_ieee80211_addr_ra,
  &hf_ieee80211_addr_ra_resolved,
  &hf_ieee80211_addr_ra_oui,
  &hf_ieee80211_addr_ra_oui_resolved,
  &hf_ieee80211_addr_ra_lg,
  &hf_ieee80211_addr_ra_ig,
};

/* Transmitter address HF list for proto_tree_add_mac48_detail() */
static const mac_hf_list_t mac_ta = {
  &hf_ieee80211_addr_ta,
  &hf_ieee80211_addr_ta_resolved,
  &hf_ieee80211_addr_ta_oui,
  &hf_ieee80211_addr_ta_oui_resolved,
  &hf_ieee80211_addr_ta_lg,
  &hf_ieee80211_addr_ta_ig,
};

/* BSSID address HF list for proto_tree_add_mac48_detail() */
static const mac_hf_list_t mac_bssid = {
  &hf_ieee80211_addr_bssid,
  &hf_ieee80211_addr_bssid_resolved,
  &hf_ieee80211_addr_bssid_oui,
  &hf_ieee80211_addr_bssid_oui_resolved,
  &hf_ieee80211_addr_bssid_lg,
  &hf_ieee80211_addr_bssid_ig,
};

/* Station address HF list for proto_tree_add_mac48_detail() */
static const mac_hf_list_t mac_staa = {
  &hf_ieee80211_addr_staa,
  &hf_ieee80211_addr_staa_resolved,
  &hf_ieee80211_addr_staa_oui,
  &hf_ieee80211_addr_staa_oui_resolved,
  &hf_ieee80211_addr_staa_lg,
  &hf_ieee80211_addr_staa_ig,
};

static const fragment_items frag_items = {
  &ett_fragment,
  &ett_fragments,
  &hf_ieee80211_fragments,
  &hf_ieee80211_fragment,
  &hf_ieee80211_fragment_overlap,
  &hf_ieee80211_fragment_overlap_conflict,
  &hf_ieee80211_fragment_multiple_tails,
  &hf_ieee80211_fragment_too_long_fragment,
  &hf_ieee80211_fragment_error,
  &hf_ieee80211_fragment_count,
  &hf_ieee80211_reassembled_in,
  &hf_ieee80211_reassembled_length,
  /* Reassembled data field */
  NULL,
  "fragments"
};

static const enum_val_t wlan_ignore_prot_options[] = {
  { "no",         "No",               WLAN_IGNORE_PROT_NO    },
  { "without_iv", "Yes - without IV", WLAN_IGNORE_PROT_WO_IV },
  { "with_iv",    "Yes - with IV",    WLAN_IGNORE_PROT_W_IV  },
  { NULL,         NULL,               0                     }
};

static int wlan_address_type = -1;
static int wlan_bssid_address_type = -1;
static int wlan_ra_ta_address_type = -1;
static int wlan_aid_address_type = -1;

static int beacon_padding; /* beacon padding bug */

/*
 * Check if we have an S1G STA
 */
static bool
sta_is_s1g(packet_info *pinfo)
{
  void * data_p;

  if (treat_as_s1g)
    return true;

  data_p = p_get_proto_data(wmem_file_scope(), pinfo, proto_wlan, IS_S1G_KEY);
  return GPOINTER_TO_INT(data_p);
}

static const unsigned char bssid_broadcast_data[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
static address bssid_broadcast;
bool
is_broadcast_bssid(const address *bssid) {
  return addresses_equal(&bssid_broadcast, bssid);
}

static heur_dissector_list_t heur_subdissector_list;

static dissector_handle_t ieee80211_handle;
static dissector_handle_t wlan_withoutfcs_handle;
static dissector_handle_t llc_handle;
static dissector_handle_t epd_llc_handle;
static dissector_handle_t ipx_handle;
static dissector_handle_t eth_withoutfcs_handle;

static capture_dissector_handle_t llc_cap_handle;
static capture_dissector_handle_t ipx_cap_handle;

static dissector_table_t ethertype_subdissector_table;
static dissector_table_t tagged_field_table;
static dissector_table_t vendor_specific_action_table;
static dissector_table_t wifi_alliance_action_subtype_table;
static dissector_table_t vendor_specific_anqp_info_table;
static dissector_table_t wifi_alliance_anqp_info_table;
static dissector_table_t wifi_alliance_ie_table;
static dissector_table_t wifi_alliance_public_action_table;

static int wlan_tap;

static const value_string access_network_type_vals[] = {
  {  0, "Private network" },
  {  1, "Private network with guest access" },
  {  2, "Chargeable public network" },
  {  3, "Free public network" },
  {  4, "Personal device network" },
  {  5, "Emergency services only network" },
  { 14, "Test or experimental" },
  { 15, "Wildcard" },
  { 0, NULL }
};

static const value_string adv_proto_id_vals[] = {
  {  0, "Access Network Query Protocol"},
  {  1, "MIH Information Service"},
  {  2, "MIH Command and Event Services Capability Discovery"},
  {  3, "Emergency Alert System (EAS)"},
  {  4, "Location-to-Service Translation Protocol"},
  {221, "Vendor Specific"},
  {0, NULL}
};

static const value_string timeout_int_types[] = {
  {1, "Reassociation deadline interval (TUs)"},
  {2, "Key lifetime interval (seconds)"},
  {3, "Association Comeback time (TUs)"},
  {4, "Time to start (TUs)"},
  {0, NULL}
};

static const value_string tdls_action_codes[] = {
  {TDLS_SETUP_REQUEST,           "TDLS Setup Request"},
  {TDLS_SETUP_RESPONSE,          "TDLS Setup Response"},
  {TDLS_SETUP_CONFIRM,           "TDLS Setup Confirm"},
  {TDLS_TEARDOWN,                "TDLS Teardown"},
  {TDLS_PEER_TRAFFIC_INDICATION, "TDLS Peer Traffic Indication"},
  {TDLS_CHANNEL_SWITCH_REQUEST,  "TDLS Channel Switch Request"},
  {TDLS_CHANNEL_SWITCH_RESPONSE, "TDLS Channel Switch Response"},
  {TDLS_PEER_PSM_REQUEST,        "TDLS Peer PSM Request"},
  {TDLS_PEER_PSM_RESPONSE,       "TDLS Peer PSM Response"},
  {TDLS_PEER_TRAFFIC_RESPONSE,   "TDLS Peer Traffic Response"},
  {TDLS_DISCOVERY_REQUEST,       "TDLS Discovery Request"},
  {0, NULL}
};
static value_string_ext tdls_action_codes_ext = VALUE_STRING_EXT_INIT(tdls_action_codes);

static const value_string rm_action_codes[] = {
  {RM_ACTION_RADIO_MEASUREMENT_REQUEST,   "Radio Measurement Request"},
  {RM_ACTION_RADIO_MEASUREMENT_REPORT,    "Radio Measurement Report"},
  {RM_ACTION_LINK_MEASUREMENT_REQUEST,    "Link Measurement Request"},
  {RM_ACTION_LINK_MEASUREMENT_REPORT,     "Link Measurement Report"},
  {RM_ACTION_NEIGHBOR_REPORT_REQUEST,     "Neighbor Report Request"},
  {RM_ACTION_NEIGHBOR_REPORT_RESPONSE,    "Neighbor Report Response"},
  {0, NULL}
};
static value_string_ext rm_action_codes_ext = VALUE_STRING_EXT_INIT(rm_action_codes);

static const val64_string number_of_taps_values[] = {
  {0x0, "1 tap"},
  {0x1, "5 taps"},
  {0x2, "15 taps"},
  {0x3, "63 taps"},
  {0, NULL}
};

DOT11DECRYPT_CONTEXT dot11decrypt_ctx;

#define PSMP_STA_INFO_BROADCAST 0
#define PSMP_STA_INFO_MULTICAST 1
#define PSMP_STA_INFO_INDIVIDUALLY_ADDRESSED 2

#define PSMP_STA_INFO_FLAG_TYPE         0x00000003
#define PSMP_STA_INFO_FLAG_DTT_START    0x00001FFC
#define PSMP_STA_INFO_FLAG_DTT_DURATION 0x001FE000

#define PSMP_STA_INFO_FLAG_STA_ID       0x001FFFE0

#define PSMP_STA_INFO_FLAG_UTT_START    0x0000FFE0
#define PSMP_STA_INFO_FLAG_UTT_DURATION 0x03FF0000

#define PSMP_STA_INFO_FLAG_IA_RESERVED  0xFC000000

static const value_string ff_psmp_sta_info_flags[] = {
  { PSMP_STA_INFO_BROADCAST,              "Broadcast"},
  { PSMP_STA_INFO_MULTICAST,              "Multicast"},
  { PSMP_STA_INFO_INDIVIDUALLY_ADDRESSED, "Individually Addressed"},
  {0, NULL}
};

static const char*
wlan_conv_get_filter_type(conv_item_t* conv, conv_filter_type_e filter)
{
    if ((filter == CONV_FT_SRC_ADDRESS) && (conv->src_address.type == wlan_address_type))
        return "wlan.sa";

    if ((filter == CONV_FT_DST_ADDRESS) && (conv->dst_address.type == wlan_address_type))
        return "wlan.da";

    if ((filter == CONV_FT_ANY_ADDRESS) && (conv->src_address.type == wlan_address_type))
        return "wlan.addr";

    return CONV_FILTER_INVALID;
}

static ct_dissector_info_t wlan_ct_dissector_info = {&wlan_conv_get_filter_type};

static tap_packet_status
wlan_conversation_packet(void *pct, packet_info *pinfo, epan_dissect_t *edt _U_, const void *vip, tap_flags_t flags)
{
  conv_hash_t *hash = (conv_hash_t*) pct;
  hash->flags = flags;
  const wlan_hdr_t *whdr=(const wlan_hdr_t *)vip;
  tap_packet_status status = TAP_PACKET_DONT_REDRAW;

  if ((whdr->src.type != AT_NONE) && (whdr->dst.type != AT_NONE)) {
    add_conversation_table_data(hash, &whdr->src, &whdr->dst, 0, 0, 1, pinfo->fd->pkt_len, &pinfo->rel_ts, &pinfo->abs_ts, &wlan_ct_dissector_info, CONVERSATION_NONE);

    status = TAP_PACKET_REDRAW;
  }

  return status;
}

static const char*
wlan_endpoint_get_filter_type(endpoint_item_t* endpoint, conv_filter_type_e filter)
{
  if ((filter == CONV_FT_ANY_ADDRESS) && (endpoint->myaddress.type == wlan_address_type))
    return "wlan.addr";

  return CONV_FILTER_INVALID;
}

static et_dissector_info_t wlan_endpoint_dissector_info = {&wlan_endpoint_get_filter_type};

static tap_packet_status
wlan_endpoint_packet(void *pit, packet_info *pinfo, epan_dissect_t *edt _U_, const void *vip, tap_flags_t flags)
{
  conv_hash_t *hash = (conv_hash_t*) pit;
  hash->flags = flags;
  const wlan_hdr_t *whdr=(const wlan_hdr_t *)vip;
  tap_packet_status status = TAP_PACKET_DONT_REDRAW;

  /* Take two "add" passes per packet, adding for each direction, ensures that all
  packets are counted properly (even if address is sending to itself)
  XXX - this could probably be done more efficiently inside endpoint_table */
  if (whdr->src.type != AT_NONE) {
    add_endpoint_table_data(hash, &whdr->src, 0, true, 1, pinfo->fd->pkt_len, &wlan_endpoint_dissector_info, ENDPOINT_NONE);
    status = TAP_PACKET_REDRAW;
  }

  if (whdr->dst.type != AT_NONE) {
    add_endpoint_table_data(hash, &whdr->dst, 0, false, 1, pinfo->fd->pkt_len, &wlan_endpoint_dissector_info, ENDPOINT_NONE);
    status = TAP_PACKET_REDRAW;
  }

  return status;
}

static const char*
wlan_col_filter_str(const address* addr _U_, bool is_src)
{
  if (is_src)
    return "wlan.sa";

  return "wlan.da";
}

static const char*
wlan_bssid_col_filter_str(const address* addr _U_, bool is_src _U_)
{
  return "wlan.bssid";
}

static const char*
wlan_ra_ta_col_filter_str(const address* addr _U_, bool is_src)
{
  if (is_src)
    return "wlan.ta";

  return "wlan.ra";
}

static const char*
wlan_aid_col_filter_str(const address* addr _U_, bool is_src _U_)
{
  return "wlan.fc.sid.association_id";
}

static void
beacon_interval_base_custom(char *result, uint32_t beacon_interval)
{
  double temp_double;

  temp_double = (double)beacon_interval;
  snprintf(result, ITEM_LABEL_LENGTH, "%f [Seconds]", (temp_double * 1024 / 1000000));
}

static void
allocation_duration_base_custom(char *result, uint32_t allocation_duration)
{
  double temp_double;

  temp_double = (double)allocation_duration;
  snprintf(result, ITEM_LABEL_LENGTH, "%f [Seconds]", (temp_double / 1000000));
}

static void
extra_one_base_custom(char *result, uint32_t value)
{
  snprintf(result, ITEM_LABEL_LENGTH, "%d", value+1);
}

static void
extra_one_mul_two_base_custom(char *result, uint32_t value)
{
  snprintf(result, ITEM_LABEL_LENGTH, "%d", (value+1)*2);
}

static void
rcpi_and_power_level_custom(char *result, uint8_t value)
{
  /* 802.11-2016 section 9.4.2.38
     RCPI = |2 x (P + 110)| in steps of 0.5 dB */

  if (value == 0)
    snprintf(result, ITEM_LABEL_LENGTH, "%d (P < -109.5 dBm)", value);
  else if (value == 220)
    snprintf(result, ITEM_LABEL_LENGTH, "%d (P >= 0 dBm)", value);
  else if (value < 220)
    snprintf(result, ITEM_LABEL_LENGTH, "%d (P = %.1f dBm)", value, ((double)value) / 2 - 110);
  else if (value < 255)
    snprintf(result, ITEM_LABEL_LENGTH, "%d (Reserved)", value);
  else
    snprintf(result, ITEM_LABEL_LENGTH, "%d (Measurement not available)", value);
}

static void
sts_custom(char *result, uint32_t value)
{
  snprintf(result, ITEM_LABEL_LENGTH, "%d STS", value + 1);
}

static void
rep_custom(char *result, uint32_t value)
{
  snprintf(result, ITEM_LABEL_LENGTH, "%u repetition%s (%u)", value + 1, plurality(value + 1, "", "s"), value);
}

static void
hundred_us_base_custom(char *result, uint32_t value)
{
  snprintf(result, ITEM_LABEL_LENGTH, "%0.1f ms (%u)", ((double)value * 100 / 1000), value);
}

static void
partial_tsf_custom(char *result, uint32_t value)
{
  uint32_t shifted = value << 10;
  snprintf(result, ITEM_LABEL_LENGTH, "%u %s (%u)", shifted,
             unit_name_string_get_value(shifted, &units_microseconds), value);
}

/*
 * We use this is displaying the ru allocation region.
 */
static uint8_t global_he_trigger_bw;

static void
he_ru_allocation_base_custom(char *result, uint32_t ru_allocation)
{
  uint32_t tones = 0;

  switch (global_he_trigger_bw) {
  case 0:
    if (ru_allocation <= 8) {
      tones = 26;
      break;
    }
    if (ru_allocation >= 37 && ru_allocation <= 40) {
      tones = 52;
      break;
    }
    if (ru_allocation >= 53 && ru_allocation <= 54) {
      tones = 106;
      break;
    }
    if (ru_allocation == 61) {
      tones = 242;
      break;
    }
    // error
    break;
  case 1:
    if (ru_allocation <= 17) {
      tones = 26;
      break;
    }
    if (ru_allocation >= 37 && ru_allocation <= 44) {
      tones = 52;
      break;
    }
    if (ru_allocation >= 53 && ru_allocation <= 56) {
      tones = 106;
      break;
    }
    if (ru_allocation >= 61 && ru_allocation <= 62) {
      tones = 242;
      break;
    }
    if (ru_allocation == 65) {
      tones = 484;
      break;
    }
    // error
    break;
  case 2:
    /* fall-through */
  case 3:
    if (ru_allocation <= 36) {
      tones = 26;
      break;
    }
    if (ru_allocation >= 37 && ru_allocation <= 52) {
      tones = 52;
      break;
    }
    if (ru_allocation >= 53 && ru_allocation <= 60) {
      tones = 106;
      break;
    }
    if (ru_allocation >= 61 && ru_allocation <= 64) {
      tones = 242;
      break;
    }
    if (ru_allocation >= 65 && ru_allocation <= 66) {
      tones = 484;
      break;
    }
    if (ru_allocation == 67) {
      tones = 996;
      break;
    }
    if (ru_allocation == 68 && global_he_trigger_bw == 3) {
      tones = 2*996;
      break;
    }
    break;
  default:
    break;
  }

  if (tones)
    snprintf(result, ITEM_LABEL_LENGTH, "%d (%d tones)", ru_allocation, tones);
  else
    snprintf(result, ITEM_LABEL_LENGTH, "%d (bogus number of tones)", ru_allocation);
}

static void
eht_ru_allocation_base_custom(char *result, uint32_t ru_allocation)
{
  char *ru_str;

  /* TODO: check with PS160, B0 of RU allocation, BW */
  if (ru_allocation <= 36) {
    ru_str = "RU size: 26";
  } else if (ru_allocation >= 37 && ru_allocation <= 52) {
    ru_str = "RU size: 52";
  } else if (ru_allocation >= 53 && ru_allocation <= 60) {
    ru_str = "RU size: 106";
  } else if (ru_allocation >= 61 && ru_allocation <= 64) {
    ru_str = "RU size: 242";
  } else if (ru_allocation == 65 || ru_allocation == 66) {
    ru_str = "RU size: 484";
  } else if (ru_allocation == 67) {
    ru_str = "RU size: 996";
  } else if (ru_allocation == 68) {
    ru_str = "RU size: 2x996";
  } else if (ru_allocation == 69) {
    ru_str = "RU size: 4x996";
  } else if (ru_allocation >= 70 && ru_allocation <= 81) {
    ru_str = "MRU size: 52+26";
  } else if (ru_allocation >= 82 && ru_allocation <= 89) {
    ru_str = "MRU size: 106+26";
  } else if (ru_allocation >= 90 && ru_allocation <= 93) {
    ru_str = "MRU size: 484+242";
  } else if (ru_allocation >= 94 && ru_allocation <= 95) {
    ru_str = "MRU size: 996+484";
  } else if (ru_allocation >= 96 && ru_allocation <= 99) {
    ru_str = "MRU size: 996+484+242";
  } else if (ru_allocation >= 100 && ru_allocation <= 103) {
    ru_str = "MRU size: 2x996+484";
  } else if (ru_allocation == 104) {
    ru_str = "MRU size: 3x996";
  } else if (ru_allocation == 105 || ru_allocation == 106) {
    ru_str = "MRU size: 3x996+484";
  } else {
    ru_str = "Reserved";
  }

  snprintf(result, ITEM_LABEL_LENGTH, "%d (%s)", ru_allocation, ru_str);
}

/*
 * We use this to display the ANSI/CTA-2063 Serial number length
 */
static void
vs_sgdsn_serialnumber_len_custom(char *result, uint32_t val)
{
  if (val >= 0x30 && val <= 0x39) {
    snprintf(result, ITEM_LABEL_LENGTH, "%d byte(s)", val-0x30);
  } else if (val >= 0x41 && val <= 0x46) {
    snprintf(result, ITEM_LABEL_LENGTH, "%d byte(s)", val-0x37);
  } else {
    snprintf(result, ITEM_LABEL_LENGTH, "Invalid length: %u", val);
  }
}

/* ************************************************************************* */
/* Mesh Control field helper functions
 *
 * Per IEEE 802.11s Draft 12.0 section 7.2.2.1:
 *
 * The frame body consists of either:
 * The MSDU (or a fragment thereof), the Mesh Control field (if and only if the
 * frame is transmitted by a mesh STA and the Mesh Control Present subfield of
 * the QoS Control field is 1)...
 *
 * 8.2.4.5.1 "QoS Control field structure", table 8-4, in 802.11-2012,
 * seems to indicate that the bit that means "Mesh Control Present" in
 * frames sent by mesh STAs in a mesh BSS is part of the TXOP Limit field,
 * the AP PS Buffer State field, the TXOP Duration Requested field, or the
 * Queue Size field in some data frames in non-mesh BSSes.
 *
 * We need a statefull sniffer for that.  For now, use heuristics.
 *
 * Notably, only mesh data frames contain the Mesh Control field in the header.
 * Other frames that contain mesh control (i.e., multihop action frames) have
 * it deeper in the frame body where it can be definitively identified.
 * Further, mesh data frames always have to-ds and from-ds either 11 or 01.  We
 * use these facts to make our heuristics more reliable.
 * ************************************************************************* */
static int
has_mesh_control(uint16_t fcf, uint16_t qos_ctl, uint8_t mesh_flags)
{
  /* assume mesh control present if the QOS field's Mesh Control Present bit is
   * set, all reserved bits in the mesh_flags field are zero, and the address
   * extension mode is not a reserved value.
   */
  return (((FCF_ADDR_SELECTOR(fcf) == DATA_ADDR_T4) || (FCF_ADDR_SELECTOR(fcf) == DATA_ADDR_T2)) &&
          (QOS_MESH_CONTROL_PRESENT(qos_ctl)) &&
          ((mesh_flags & ~MESH_FLAGS_ADDRESS_EXTENSION) == 0) &&
          ((mesh_flags & MESH_FLAGS_ADDRESS_EXTENSION) != MESH_FLAGS_ADDRESS_EXTENSION));
}

/****************************************************************************** */
/*
 * locally originated mesh frames will have a mesh control field, but no QoS header
 * detect the presence of mesh control field by checking if mesh flags are legal
 * and confirming that the next header is an 802.2 LLC header
 *
 ****************************************************************************** */
static int
has_mesh_control_local(uint16_t fcf, uint8_t mesh_flags, uint16_t next_header)
{
  return (((FCF_ADDR_SELECTOR(fcf) == DATA_ADDR_T4) || (FCF_ADDR_SELECTOR(fcf) == DATA_ADDR_T2)) &&
          ((mesh_flags & ~MESH_FLAGS_ADDRESS_EXTENSION) == 0) &&
          ((mesh_flags & MESH_FLAGS_ADDRESS_EXTENSION) != MESH_FLAGS_ADDRESS_EXTENSION)) &&
          next_header == 0xaaaa;
}

static int
find_mesh_control_length(uint8_t mesh_flags)
{
  return 6 + 6*(mesh_flags & MESH_FLAGS_ADDRESS_EXTENSION);
}

static mimo_control_t
get_mimo_control(tvbuff_t *tvb, int offset)
{
  uint16_t       mimo;
  mimo_control_t output;

  mimo = tvb_get_letohs(tvb, offset);

  output.nc = (mimo & 0x0003) + 1;
  output.nr = ((mimo & 0x000C) >> 2) + 1;
  output.chan_width = (mimo & 0x0010) >> 4;
  output.coefficient_size = 4; /* XXX - Is this a good default? */

  switch ((mimo & 0x0060) >> 5)
    {
      case 0:
        output.grouping = 1;
        break;

      case 1:
        output.grouping = 2;
        break;

      case 2:
        output.grouping = 4;
        break;

      default:
        output.grouping = 1;
        break;
    }

  switch ((mimo & 0x0180) >> 7)
    {
      case 0:
        output.coefficient_size = 4;
        break;

      case 1:
        output.coefficient_size = 5;
        break;

      case 2:
        output.coefficient_size = 6;
        break;

      case 3:
        output.coefficient_size = 8;
        break;
    }

  output.codebook_info = (mimo & 0x0600) >> 9;
  output.remaining_matrix_segment = (mimo & 0x3800) >> 11;

  return output;
}

static int
get_mimo_na(uint8_t nr, uint8_t nc)
{
  if ((nr == 2) && (nc == 1)) {
    return 2;
  } else if ((nr == 2) && (nc == 2)) {
    return 2;
  } else if ((nr == 3) && (nc == 1)) {
    return 4;
  } else if ((nr == 3) && (nc == 2)) {
    return 6;
  } else if ((nr == 3) && (nc == 3)) {
    return 6;
  } else if ((nr == 4) && (nc == 1)) {
    return 6;
  } else if ((nr == 4) && (nc == 2)) {
    return 10;
  } else if ((nr == 4) && (nc == 3)) {
    return 12;
  } else if ((nr == 4) && (nc == 4)) {
    return 12;
  } else{
    return 0;
  }
}

static int
get_mimo_ns(bool chan_width, uint8_t output_grouping)
{
  int ns = 0;

  if (chan_width)
  {
    switch (output_grouping)
      {
        case 1:
          ns = 114;
          break;

          case 2:
            ns = 58;
            break;

          case 4:
            ns = 30;
            break;

          default:
            ns = 0;
      }
  } else {
    switch (output_grouping)
      {
        case 1:
          ns = 56;
          break;

        case 2:
          ns = 30;
          break;

        case 4:
          ns = 16;
          break;

        default:
          ns = 0;
      }
  }

  return ns;
}

static int
add_mimo_csi_matrices_report(proto_tree *tree, tvbuff_t *tvb, int offset, mimo_control_t mimo_cntrl)
{
  proto_tree *snr_tree;
  int         csi_matrix_size, start_offset;
  int         ns, i;

  start_offset = offset;
  snr_tree = proto_tree_add_subtree(tree, tvb, offset, mimo_cntrl.nc,
                        ett_mimo_report, NULL, "Signal to Noise Ratio");

  for (i = 1; i <= mimo_cntrl.nr; i++)
  {
    uint8_t snr;

    snr = tvb_get_uint8(tvb, offset);
    proto_tree_add_uint_format(snr_tree, hf_ieee80211_ff_mimo_csi_snr, tvb, offset, 1,
                               snr, "Channel %d - Signal to Noise Ratio: 0x%02X", i, snr);
    offset += 1;
  }

  ns = get_mimo_ns(mimo_cntrl.chan_width, mimo_cntrl.grouping);
  csi_matrix_size = ns*(3+(2*mimo_cntrl.nc*mimo_cntrl.nr*mimo_cntrl.coefficient_size));
  csi_matrix_size = WS_ROUNDUP_8(csi_matrix_size) / 8;
  proto_tree_add_item(snr_tree, hf_ieee80211_ff_mimo_csi_matrices, tvb, offset, csi_matrix_size, ENC_NA);
  offset += csi_matrix_size;
  return offset - start_offset;
}

static int
add_mimo_beamforming_feedback_report(proto_tree *tree, tvbuff_t *tvb, int offset, mimo_control_t mimo_cntrl)
{
  proto_tree *snr_tree;
  int         csi_matrix_size, start_offset;
  int         ns, i;

  start_offset = offset;
  snr_tree = proto_tree_add_subtree(tree, tvb, offset, mimo_cntrl.nc, ett_mimo_report, NULL, "Signal to Noise Ratio");

  for (i = 1; i <= mimo_cntrl.nc; i++)
  {
    uint8_t snr;

    snr = tvb_get_uint8(tvb, offset);
    proto_tree_add_uint_format(snr_tree, hf_ieee80211_ff_mimo_csi_snr, tvb, offset, 1,
                               snr, "Stream %d - Signal to Noise Ratio: 0x%02X", i, snr);
    offset += 1;
  }

  ns = get_mimo_ns(mimo_cntrl.chan_width, mimo_cntrl.grouping);
  csi_matrix_size = ns*(2*mimo_cntrl.nc*mimo_cntrl.nr*mimo_cntrl.coefficient_size);
  csi_matrix_size = WS_ROUNDUP_8(csi_matrix_size) / 8;
  proto_tree_add_item(snr_tree, hf_ieee80211_ff_mimo_csi_bf_matrices, tvb, offset, csi_matrix_size, ENC_NA);
  offset += csi_matrix_size;
  return offset - start_offset;
}

static int
add_mimo_compressed_beamforming_feedback_report(proto_tree *tree, tvbuff_t *tvb, int offset, mimo_control_t mimo_cntrl)
{
  proto_tree *snr_tree;
  int         csi_matrix_size, start_offset;
  int         ns, na, i;

  start_offset = offset;
  snr_tree = proto_tree_add_subtree(tree, tvb, offset, mimo_cntrl.nc,
                        ett_mimo_report, NULL, "Signal to Noise Ratio");

  for (i = 1; i <= mimo_cntrl.nc; i++)
  {
    int8_t snr;
    char edge_sign;

    snr = tvb_get_int8(tvb, offset);

    switch(snr) {
      case -128:
        edge_sign = '<';
        break;
      case 127:
        edge_sign = '>';
        break;
      default:
        edge_sign = ' ';
        break;
    }
    proto_tree_add_uint_format(snr_tree, hf_ieee80211_ff_mimo_csi_snr, tvb, offset, 1,
                               snr, "Stream %d - Signal to Noise Ratio: %c%3.2fdB", i, edge_sign,snr/4.0+22.0);
    offset += 1;
  }

  na = get_mimo_na(mimo_cntrl.nr, mimo_cntrl.nc);
  ns = get_mimo_ns(mimo_cntrl.chan_width, mimo_cntrl.grouping);
  csi_matrix_size = ns*(na*((mimo_cntrl.codebook_info+1)*2 + 2)/2);
  csi_matrix_size = WS_ROUNDUP_8(csi_matrix_size) / 8;
  proto_tree_add_item(snr_tree, hf_ieee80211_ff_mimo_csi_cbf_matrices, tvb, offset, csi_matrix_size, ENC_NA);
  offset += csi_matrix_size;
  return offset - start_offset;
}

static void
mesh_active_window_base_custom(char *result, uint32_t mesh_active_window)
{
  snprintf(result, ITEM_LABEL_LENGTH, "%f [Seconds]", (mesh_active_window * 1024.0 / 1000000));
}

/* ************************************************************************* */
/*          This is the capture function used to update packet counts        */
/* ************************************************************************* */
static bool
capture_ieee80211_common(const unsigned char * pd, int offset, int len,
                          capture_packet_info_t *cpinfo, const union wtap_pseudo_header *pseudo_header _U_, bool datapad)
{
  uint16_t fcf, hdr_length;

  if (!BYTES_ARE_IN_FRAME(offset, len, 2))
    return false;

  fcf = pletoh16(&pd[offset]);

  if (IS_PROTECTED(FCF_FLAGS(fcf)) && (wlan_ignore_prot == WLAN_IGNORE_PROT_NO))
    return false;

  switch (COMPOSE_FRAME_TYPE (fcf)) {

    case DATA:
    case DATA_CF_ACK:
    case DATA_CF_POLL:
    case DATA_CF_ACK_POLL:
    case DATA_QOS_DATA:
    case DATA_QOS_DATA_CF_ACK:
    case DATA_QOS_DATA_CF_POLL:
    case DATA_QOS_DATA_CF_ACK_POLL:
    {
      /* These are data frames that actually contain *data*. */
      hdr_length = (FCF_ADDR_SELECTOR(fcf) == DATA_ADDR_T4) ? DATA_LONG_HDR_LEN : DATA_SHORT_HDR_LEN;

      if (DATA_FRAME_IS_QOS(COMPOSE_FRAME_TYPE(fcf))) {
        /* QoS frame, so the header includes a QoS field */
        uint16_t qosoff;  /* Offset of the 2-byte QoS field */
        uint8_t mesh_flags;

        qosoff = hdr_length;
        hdr_length += 2; /* Include the QoS field in the header length */

        if (HAS_HT_CONTROL(FCF_FLAGS(fcf))) {
          /* Frame has a 4-byte HT Control field */
          hdr_length += 4;
        }

        if (datapad) {
          /*
           * Include the padding between the 802.11 header and the body,
           * as "helpfully" provided by some Atheros adapters.
           *
           * In the Atheros mesh capture sample we have, the padding
           * is before the mesh header, possibly because it doesn't
           * recognize the mesh header.
           */
          hdr_length = WS_ROUNDUP_4(hdr_length);
        }

        /*
         * Does it look as if we have a mesh header?
         * Look at the Mesh Control subfield of the QoS field and at the
         * purported mesh flag fields.
         */
        if (!BYTES_ARE_IN_FRAME(offset, hdr_length, 1))
          return false;

        mesh_flags = pd[hdr_length];
        if (has_mesh_control(fcf, pletoh16(&pd[qosoff]), mesh_flags)) {
          /* Yes, add the length of that in as well. */
          hdr_length += find_mesh_control_length(mesh_flags);
        }
      }
      /* I guess some bridges take Netware Ethernet_802_3 frames,
         which are 802.3 frames (with a length field rather than
         a type field, but with no 802.2 header in the payload),
         and just stick the payload into an 802.11 frame.  I've seen
         captures that show frames of that sort.

         We also handle some odd form of encapsulation in which a
         complete Ethernet frame is encapsulated within an 802.11
         data frame, with no 802.2 header.  This has been seen
         from some hardware.

         On top of that, at least at some point it appeared that
         the OLPC XO sent out frames with two bytes of 0 between
         the "end" of the 802.11 header and the beginning of
         the payload.

         So, if the packet doesn't start with 0xaa 0xaa:

           we first use the same scheme that linux-wlan-ng does to detect
           those encapsulated Ethernet frames, namely looking to see whether
           the frame either starts with 6 octets that match the destination
           address from the 802.11 header or has 6 octets that match the
           source address from the 802.11 header following the first 6 octets,
           and, if so, treat it as an encapsulated Ethernet frame;

           otherwise, we use the same scheme that we use in the Ethernet
           dissector to recognize Netware 802.3 frames, namely checking
           whether the packet starts with 0xff 0xff and, if so, treat it
           as an encapsulated IPX frame, and then check whether the
           packet starts with 0x00 0x00 and, if so, treat it as an OLPC
           frame. */
      if (!BYTES_ARE_IN_FRAME(offset+hdr_length, len, 2))
        return false;

      if ((pd[offset+hdr_length] != 0xaa) && (pd[offset+hdr_length+1] != 0xaa)) {
#if 0
        /* XXX - this requires us to parse the header to find the source
           and destination addresses. */
        if (BYTES_ARE_IN_FRAME(offset+hdr_length, len, 12)) {
          /* We have two MAC addresses after the header. */
          if ((memcmp(&pd[offset+hdr_length+6], pinfo->dl_src.data, 6) == 0) ||
              (memcmp(&pd[offset+hdr_length+6], pinfo->dl_dst.data, 6) == 0)) {
            return capture_eth (pd, offset + hdr_length, len, cpinfo, pseudo_header);
          }
        }
#endif
        if ((pd[offset+hdr_length] == 0xff) && (pd[offset+hdr_length+1] == 0xff))
          return call_capture_dissector (ipx_cap_handle, pd, offset+hdr_length, len, cpinfo, pseudo_header);
        else if ((pd[offset+hdr_length] == 0x00) && (pd[offset+hdr_length+1] == 0x00))
          return call_capture_dissector (llc_cap_handle, pd, offset + hdr_length + 2, len, cpinfo, pseudo_header);
      }
      else {
        return call_capture_dissector (llc_cap_handle, pd, offset + hdr_length, len, cpinfo, pseudo_header);
      }
      break;
    }
  }

  return false;
}

/*
 * Handle 802.11 with a variable-length link-layer header.
 */
static bool
capture_ieee80211(const unsigned char * pd, int offset, int len, capture_packet_info_t *cpinfo, const union wtap_pseudo_header *pseudo_header _U_)
{
  return capture_ieee80211_common (pd, offset, len, cpinfo, pseudo_header, false);
}

/*
 * Handle 802.11 with a variable-length link-layer header and data padding.
 */
static bool
capture_ieee80211_datapad(const unsigned char * pd, int offset, int len,
                           capture_packet_info_t *cpinfo, const union wtap_pseudo_header *pseudo_header _U_)
{
  return capture_ieee80211_common (pd, offset, len, cpinfo, pseudo_header, true);
}


/* ************************************************************************* */
/*          Add the subtree used to store the fixed parameters               */
/* ************************************************************************* */
static proto_tree *
get_fixed_parameter_tree(proto_tree * tree, tvbuff_t *tvb, int start, int size,
                         bool no_append)
{
  proto_item *fixed_fields;

  fixed_fields = proto_tree_add_item(tree, hf_ieee80211_fixed_parameters, tvb, start, size, ENC_NA);
  if (!no_append)
    proto_item_append_text(fixed_fields, " (%d bytes)", size);

  return proto_item_add_subtree(fixed_fields, ett_fixed_parameters);
}


/* ************************************************************************* */
/*            Add the subtree used to store tagged parameters                */
/* ************************************************************************* */
static proto_tree *
get_tagged_parameter_tree(proto_tree * tree, tvbuff_t *tvb, int start, int size)
{
  proto_item *tagged_fields;

  tagged_fields = proto_tree_add_item(tree, hf_ieee80211_tagged_parameters, tvb, start, -1, ENC_NA);
  proto_item_append_text(tagged_fields, " (%d bytes)", size);

  return proto_item_add_subtree(tagged_fields, ett_tagged_parameters);
}

static void
add_ptk_analysis(tvbuff_t *tvb, proto_tree *tree, DOT11DECRYPT_KEY_ITEM *used_key)
{
  if (!used_key) {
    return;
  }
  const uint8_t *key = NULL;
  proto_item *ti;
  char buf[SHORT_STR];
  int len = Dot11DecryptGetKCK(used_key, &key);
  bytes_to_hexstr(buf, key, len);
  buf[2 * len] = '\0';
  ti = proto_tree_add_string(tree, hf_ieee80211_fc_analysis_kck, tvb, 0, 0, buf);
  proto_item_set_generated(ti);

  len = Dot11DecryptGetKEK(used_key, &key);
  bytes_to_hexstr(buf, key, len);
  buf[2 * len] = '\0';
  ti = proto_tree_add_string(tree, hf_ieee80211_fc_analysis_kek, tvb, 0, 0, buf);
  proto_item_set_generated(ti);
}

static int
dissect_vendor_action_marvell(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void *data _U_)
{
  uint8_t octet;
  int offset = 0;

  octet = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_ff_marvell_action_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  switch (octet)
    {
      case MRVL_ACTION_MESH_MANAGEMENT:
        octet = tvb_get_uint8(tvb, offset);
        proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_action_code, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        offset += 1;
        switch (octet)
          {
            case MRVL_MESH_MGMT_ACTION_RREQ:
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_length, tvb, offset, 1, ENC_LITTLE_ENDIAN);
              offset += 1;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_mode, tvb, offset, 1, ENC_LITTLE_ENDIAN);
              offset += 1;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_hopcount, tvb, offset, 1, ENC_LITTLE_ENDIAN);
              offset += 1;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_ttl, tvb, offset, 1, ENC_LITTLE_ENDIAN);
              offset += 1;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_rreqid, tvb, offset, 4, ENC_LITTLE_ENDIAN);
              offset += 4;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_sa, tvb, offset, 6, ENC_NA);
              offset += 6;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_ssn, tvb, offset, 4, ENC_LITTLE_ENDIAN);
              offset += 4;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_lifetime, tvb, offset, 4, ENC_LITTLE_ENDIAN);
              offset += 4;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_metric, tvb, offset, 4, ENC_LITTLE_ENDIAN);
              offset += 4;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_dstcount, tvb, offset, 1, ENC_LITTLE_ENDIAN);
              offset += 1;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);
              offset += 1;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_da, tvb, offset, 6, ENC_NA);
              offset += 6;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_dsn, tvb, offset, 4, ENC_LITTLE_ENDIAN);
              offset += 4;
              break;
            case MRVL_MESH_MGMT_ACTION_RREP:
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_length, tvb, offset, 1, ENC_LITTLE_ENDIAN);
              offset += 1;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_mode, tvb, offset, 1, ENC_LITTLE_ENDIAN);
              offset += 1;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_hopcount, tvb, offset, 1, ENC_LITTLE_ENDIAN);
              offset += 1;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_ttl, tvb, offset, 1, ENC_LITTLE_ENDIAN);
              offset += 1;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_da, tvb, offset, 6, ENC_NA);
              offset += 6;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_dsn, tvb, offset, 4, ENC_LITTLE_ENDIAN);
              offset += 4;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_lifetime, tvb, offset, 4, ENC_LITTLE_ENDIAN);
              offset += 4;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_metric, tvb, offset, 4, ENC_LITTLE_ENDIAN);
              offset += 4;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_sa, tvb, offset, 6, ENC_NA);
              offset += 6;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_ssn, tvb, offset, 4, ENC_LITTLE_ENDIAN);
              offset += 4;
              break;
            case MRVL_MESH_MGMT_ACTION_RERR:
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_length, tvb, offset, 1, ENC_LITTLE_ENDIAN);
              offset += 1;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_mode, tvb, offset, 1, ENC_LITTLE_ENDIAN);
              offset += 1;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_dstcount, tvb, offset, 1, ENC_LITTLE_ENDIAN);
              offset += 1;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_da, tvb, offset, 6, ENC_NA);
              offset += 6;
              proto_tree_add_item(tree, hf_ieee80211_ff_marvell_mesh_mgt_dsn, tvb, offset, 4, ENC_LITTLE_ENDIAN);
              offset += 4;
              break;
            default:
              break;
          }
        break;
      default:
        break;
    }

  return offset;
}

static int
dissect_dscp_policy_query(tvbuff_t *tvb, packet_info *pinfo _U_,
                          proto_tree *tree, int offset)
{
  int start_offset = offset;

  while (tvb_captured_length_remaining(tvb, offset)) {
    offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
  }

  return offset - start_offset;
}

static int * const rqst_control_fields[] = {
  &hf_ieee80211_oui_qos_mgmt_rq_ctrl_more,
  &hf_ieee80211_oui_qos_mgmt_rq_ctrl_reset,
  &hf_ieee80211_oui_qos_mgmt_rq_reserved,
  NULL
};

static int
dissect_dscp_policy_request(tvbuff_t *tvb, packet_info *pinfo _U_,
                            proto_tree *tree, int offset)
{
  int start_offset = offset;

  proto_tree_add_bitmask(tree, tvb, offset,
                         hf_ieee80211_oui_qos_mgmt_rqst_control,
                         ett_pol_rqst_cont_tree, rqst_control_fields,
                         ENC_NA);
  offset += 1;

  while (tvb_reported_length_remaining(tvb, offset)) {
    offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
  }

  return offset - start_offset;
}

static int * const resp_control_fields[] = {
  &hf_ieee80211_oui_qos_mgmt_rsp_ctrl_more,
  &hf_ieee80211_oui_qos_mgmt_rsp_ctrl_reset,
  &hf_ieee80211_oui_qos_mgmt_rsp_reserved,
  NULL
};

static int
dissect_dscp_policy_response(tvbuff_t *tvb, packet_info *pinfo,
                             proto_tree *tree, int offset)
{
  int start_offset = offset;
  uint8_t count;
  wmem_strbuf_t *status_buf = wmem_strbuf_create(pinfo->pool);
  int i;

  proto_tree_add_bitmask(tree, tvb, offset,
                         hf_ieee80211_oui_qos_mgmt_resp_control,
                         ett_pol_resp_cont_tree, resp_control_fields,
                         ENC_NA);
  offset += 1;

  count = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_oui_qos_mgmt_count, tvb, offset,
                      1, ENC_NA);
  offset += 1;

  for (i = 0; i < count; i++) {
    proto_tree *status_tree = NULL;
    uint8_t scsid, status;

    scsid = tvb_get_uint8(tvb, offset);
    status_tree = proto_tree_add_subtree_format(tree, tvb, offset, 2,
                                                ett_dscp_policy_status_list,
                                                NULL, "Status list item %d",
                                                i);
    proto_tree_add_item(status_tree, hf_ieee80211_dscp_policy_id, tvb,
                        offset, 1, ENC_NA);
    if (wmem_strbuf_get_len(status_buf) == 0) {
      wmem_strbuf_append_printf(status_buf, "%u:", scsid);
    } else {
      wmem_strbuf_append_printf(status_buf, " %u:", scsid);
    }
    offset += 1;

    status = tvb_get_uint8(tvb, offset);
    proto_tree_add_item(status_tree, hf_ieee80211_dscp_policy_status, tvb,
                        offset, 1, ENC_NA);
    wmem_strbuf_append_printf(status_buf, "%u", status);
    offset += 1;
  }
  proto_tree_add_string(tree, hf_ieee80211_dscp_policy_scs_sts_list, tvb, 0, 1,
                        wmem_strbuf_finalize(status_buf));

  return offset - start_offset;
}

static int
dissect_vendor_action_wfa_qos_mgmt(tvbuff_t *tvb, packet_info *pinfo,
                                   proto_tree *tree, void *data _U_)
{
  int offset = 0;
  uint8_t subtype = tvb_get_uint8(tvb, offset);

  proto_tree_add_item(tree, hf_ieee80211_oui_qos_subtype, tvb, offset, 1,
                      ENC_NA);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_oui_qos_mgmt_dialog_token, tvb, offset,
                      1, ENC_NA);
  offset += 1;

  switch (subtype) {
  case 0:
    offset += dissect_dscp_policy_query(tvb, pinfo, tree, offset);
    break;
  case 1:
    offset += dissect_dscp_policy_request(tvb, pinfo, tree, offset);
    break;
  case 2:
    offset += dissect_dscp_policy_response(tvb, pinfo, tree, offset);
    break;
  }

  return offset;
}

static int
dissect_vendor_action_wifi_alliance(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
{
  uint8_t subtype;
  int offset = 0;
  int dissected;
  tvbuff_t *subtvb;

  subtype = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_tag_oui_wfa_action_type, tvb, offset,
                      1, ENC_NA);
  offset += 1;

  subtvb = tvb_new_subset_remaining(tvb, offset);
  dissected = dissector_try_uint_new(wifi_alliance_action_subtype_table, subtype, subtvb, pinfo, tree, false, NULL);
  if (dissected <= 0)
  {
      call_data_dissector(subtvb, pinfo, tree);
      dissected = tvb_reported_length(subtvb);
  }

  offset += dissected;

  return offset;
}

/*
 * This function is called from two different places. In one case it is called
 * without the tag and length. In other cases, it is called with those and
 * is asked to return the type and subtype. We know the difference because
 * type and subtype will be NULL in the first case.
 */
static unsigned
dissect_advertisement_protocol_common(packet_info *pinfo, proto_tree *tree,
                               tvbuff_t *tvb, int offset, unsigned *type,
                               unsigned *subtype)
{
  uint8_t     tag_no = 0, tag_len, left;
  proto_item *item = NULL, *adv_item;
  proto_tree *adv_tree, *adv_tuple_tree;

  if (type)
    *type = 0xff; // Last reserved value
  if (subtype)
    *subtype = 0xff;
  tag_no = tvb_get_uint8(tvb, offset);
  if (type)
    item = proto_tree_add_item(tree, hf_ieee80211_tag_number, tvb, offset, 1, ENC_LITTLE_ENDIAN);

  /*
   * If we have the tag and len, use the len in the tvb, otherwise ask
   * for the length of the tvb.
   */
  if (type)
    tag_len = tvb_get_uint8(tvb, offset + 1);
  else
    tag_len = tvb_reported_length_remaining(tvb, 0);

  if (type && tag_no != TAG_ADVERTISEMENT_PROTOCOL) {
    expert_add_info_format(pinfo, item, &ei_ieee80211_tag_number,
                           "Unexpected IE %d (expected Advertisement "
                           "Protocol)", tag_no);
    return 2 + tag_len;
  }
  if (type)
    item = proto_tree_add_uint(tree, hf_ieee80211_tag_length, tvb, offset + 1, 1, tag_len);
  if (tag_len < 2) {
    if (!type)
      item = proto_tree_add_uint(tree, hf_ieee80211_tag_length, tvb, offset + 1, 1, tag_len);
    expert_add_info_format(pinfo, item, &ei_ieee80211_tag_length,
                           "Advertisement Protocol: IE must be at least 2 "
                           "octets long");
    return 2 + tag_len;
  }

  left = tag_len;
  if (type) /* Skip past the header if there ... */
    offset += 2;
  adv_tree = proto_tree_add_subtree(tree, tvb, offset, left,
                                 ett_adv_proto, &adv_item, "Advertisement Protocol element");

  while (left >= 2) {
    uint8_t id;

    id = tvb_get_uint8(tvb, offset + 1);
    if (id == 0)
      proto_item_append_text(adv_item, ": ANQP");
    adv_tuple_tree = proto_tree_add_subtree_format(adv_tree, tvb, offset, 2, ett_adv_proto_tuple, &item,
                               "Advertisement Protocol Tuple: %s",
                               val_to_str(id, adv_proto_id_vals,
                                          "Unknown (%d)"));

    proto_tree_add_item(adv_tuple_tree,
                        hf_ieee80211_tag_adv_proto_resp_len_limit, tvb,
                        offset, 1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(adv_tuple_tree,
                        hf_ieee80211_tag_adv_proto_pame_bi, tvb,
                        offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    left--;
    proto_tree_add_item(adv_tuple_tree, hf_ieee80211_tag_adv_proto_id, tvb,
                        offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    left--;

    if ((id == 0) && type)
      *type = ADV_PROTO_ID_ANQP;

    if (id == 221) {
      /* Vendor specific */
      uint8_t len = tvb_get_uint8(tvb, offset);
      unsigned oui;
      uint8_t wfa_subtype;
      proto_tree_add_item(adv_tuple_tree, hf_ieee80211_tag_adv_vs_len, tvb, offset, 1, ENC_NA);
      offset += 1;
      left   -= 1;
      if (type)
        *type = ADV_PROTO_ID_VS;
      if (len > left) {
        expert_add_info_format(pinfo, item, &ei_ieee80211_tag_length,
                               "Vendor specific info length error");
        return 2 + tag_len;
      }
      proto_tree_add_item_ret_uint(adv_tuple_tree, hf_ieee80211_tag_oui, tvb, offset, 3, ENC_BIG_ENDIAN, &oui);
      offset += 3;
      left   -= 3;
      wfa_subtype = tvb_get_uint8(tvb, offset);
      proto_tree_add_item(adv_tuple_tree, hf_ieee80211_anqp_wfa_subtype, tvb,
                        offset, 1, ENC_NA);
      offset += 1;
      left   -= 1;
      if (oui == OUI_WFA) {
        proto_tree_add_item(adv_tuple_tree, hf_ieee80211_dpp_subtype, tvb, offset, 1, ENC_NA);
        if (subtype && wfa_subtype == WFA_SUBTYPE_DPP) {
          *subtype = WFA_SUBTYPE_DPP;
          *subtype |= (tvb_get_uint8(tvb, offset) << 8);
        }
        offset++;
        left--;
      }
    }
  }

  if (left) {
    expert_add_info_format(pinfo, item, &ei_ieee80211_extra_data,
                           "Unexpected extra data in the end");
  }

  return 2 + tag_len;
}

static int
dissect_advertisement_protocol(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
  return dissect_advertisement_protocol_common(pinfo, tree, tvb, 0, NULL, NULL);
}

static void
dissect_anqp_query_list(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset, int end)
{
  while (offset + 2 <= end) {
    proto_tree_add_item(tree, hf_ieee80211_ff_anqp_query_id,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }
  if (offset != end) {
    expert_add_info_format(pinfo, tree, &ei_ieee80211_ff_anqp_info_length,
                           "Unexpected ANQP Query list format");
  }
}

static void
dissect_hs20_anqp_hs_capability_list(proto_tree *tree, tvbuff_t *tvb, int offset, int end)
{
  while (offset < end) {
    proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_hs_capability_list,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;
  }
}

static void
dissect_anqp_capab_list(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset, int end)
{
  uint16_t    id, len;
  proto_item *item;
  proto_tree *vtree;
  uint32_t    oui;
  uint8_t     subtype;

  while (offset + 2 <= end) {
    id = tvb_get_letohs(tvb, offset);
    item = proto_tree_add_item(tree, hf_ieee80211_ff_anqp_capability,
                               tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    if (id == ANQP_INFO_ANQP_VENDOR_SPECIFIC_LIST) {
      vtree = proto_item_add_subtree(item, ett_anqp_vendor_capab);
      len = tvb_get_letohs(tvb, offset);
      proto_tree_add_item(vtree, hf_ieee80211_ff_anqp_capability_vlen,
                          tvb, offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
      if ((len < 3) || ((offset + len) > end)) {
        expert_add_info(pinfo, tree, &ei_ieee80211_ff_anqp_capability);
        return;
      }
      proto_tree_add_item_ret_uint(vtree, hf_ieee80211_tag_oui, tvb, offset, 3, ENC_BIG_ENDIAN, &oui);
      offset += 3;
      len    -= 3;

      switch (oui) {
      case OUI_WFA:
        if (len == 0)
          break;
        subtype = tvb_get_uint8(tvb, offset);
        proto_item_append_text(vtree, " - WFA - %s",
                               val_to_str(subtype, wfa_anqp_subtype_vals,
                                          "Unknown (%u)"));
        proto_tree_add_item(vtree, hf_ieee80211_anqp_wfa_subtype,
                            tvb, offset, 1, ENC_NA);
        offset++;
        len--;
        switch (subtype) {
        case WFA_ANQP_SUBTYPE_HS20:
          proto_tree_add_item(vtree, hf_ieee80211_hs20_anqp_subtype, tvb, offset, 1, ENC_NA);
          proto_tree_add_item(vtree, hf_ieee80211_hs20_anqp_reserved, tvb, offset + 1, 1, ENC_NA);
          offset += 2;
          len -= 2;
          dissect_hs20_anqp_hs_capability_list(vtree, tvb, offset, end);
          break;
        default:
          proto_tree_add_item(vtree, hf_ieee80211_ff_anqp_capability_vendor,
                              tvb, offset, len, ENC_NA);
          break;
        }
        break;
      default:
        proto_tree_add_item(vtree, hf_ieee80211_ff_anqp_capability_vendor,
                            tvb, offset, len, ENC_NA);
        break;
      }

      offset += len;
    }
  }
  if (offset != end) {
    expert_add_info_format(pinfo, tree, &ei_ieee80211_ff_anqp_info_length,
                           "Unexpected ANQP Capability list format");
  }
}

static const value_string venue_group_vals[] = {
  {  0, "Unspecified" },
  {  1, "Assembly" },
  {  2, "Business" },
  {  3, "Educational" },
  {  4, "Factory and Industrial" },
  {  5, "Institutional" },
  {  6, "Mercantile" },
  {  7, "Residential" },
  {  8, "Storage" },
  {  9, "Utility and Miscellaneous" },
  { 10, "Vehicular" },
  { 11, "Outdoor" },
  { 0, NULL }
};
static value_string_ext venue_group_vals_ext = VALUE_STRING_EXT_INIT(venue_group_vals);

static void
dissect_venue_info(proto_tree *tree, tvbuff_t *tvb, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_venue_info_group,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tree, hf_ieee80211_ff_venue_info_type,
                      tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);
}

static void
dissect_venue_name_info(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset, int end)
{
  proto_item *item;

  dissect_venue_info(tree, tvb, offset);
  offset += 2;
  while (offset + 4 <= end) {
    uint8_t vlen = tvb_get_uint8(tvb, offset);
    item = proto_tree_add_item(tree, hf_ieee80211_ff_anqp_venue_length,
                               tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    if ((vlen > (end - offset)) || (vlen < 3)) {
      expert_add_info(pinfo, item, &ei_ieee80211_ff_anqp_venue_length);
      break;
    }
    proto_tree_add_item(tree, hf_ieee80211_ff_anqp_venue_language,
                        tvb, offset, 3, ENC_ASCII);
    proto_tree_add_item(tree, hf_ieee80211_ff_anqp_venue_name,
                        tvb, offset + 3, vlen - 3, ENC_UTF_8);
    offset += vlen;
  }
}

static const value_string nw_auth_type_vals[] = {
  { 0, "Acceptance of terms and conditions" },
  { 1, "On-line enrollment supported" },
  { 2, "http/https redirection" },
  { 3, "DNS redirection" },
  { 0, NULL }
};

static void
dissect_network_auth_type(proto_tree *tree, tvbuff_t *tvb, int offset, int end)
{
  while (offset + 3 <= end) {
    uint16_t len;
    proto_tree_add_item(tree, hf_ieee80211_ff_anqp_nw_auth_type_indicator,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    len = tvb_get_letohs(tvb, offset);
    proto_tree_add_item(tree, hf_ieee80211_ff_anqp_nw_auth_type_url_len,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    if (len)
      proto_tree_add_item(tree, hf_ieee80211_ff_anqp_nw_auth_type_url,
                          tvb, offset, len, ENC_ASCII);
    offset += len;
  }
}

static void
dissect_anqp_network_auth_type_timestamp(proto_tree *tree, tvbuff_t *tvb, int offset, int end)
{
  while (offset + 2 <= end) {
    uint8_t len;
    proto_tree_add_item(tree, hf_ieee80211_ff_anqp_nw_auth_type_ts_indicator,
                        tvb, offset, 1, ENC_NA);
    len = tvb_get_uint8(tvb, offset + 1);
    proto_tree_add_item(tree, hf_ieee80211_ff_anqp_nw_auth_type_ts_url_len,
                        tvb, offset, 1, ENC_NA);
    offset += 2;
    if(len)
      proto_tree_add_item(tree, hf_ieee80211_ff_anqp_nw_auth_type_ts_url,
                          tvb, offset, len, ENC_ASCII);
    offset += len;
    /* Optional Time Value - Either 0 or 10 octets */
    /* Format: Octet 0-1: Year (0-65534)
               Octet 2: Month (0-12)
               Octet 3: Day of month (0-31)
               Octet 4: Hours (0-23)
               Octet 5: Minutes (0-59)
               Octet 6: Seconds (0-59)
               Octet 7-8: Milliseconds (0-999)
               Octet 9: Reserved */
    if ((offset + 10) < end) {
      /* Enough bytes to dissect a timestamp */
      proto_tree_add_item(tree, hf_ieee80211_ff_anqp_nw_auth_type_ts_year,
                          tvb, offset, 2, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(tree, hf_ieee80211_ff_anqp_nw_auth_type_ts_mon,
                          tvb, offset, 1, ENC_NA);
      proto_tree_add_item(tree, hf_ieee80211_ff_anqp_nw_auth_type_ts_day,
                          tvb, offset, 1, ENC_NA);
      proto_tree_add_item(tree, hf_ieee80211_ff_anqp_nw_auth_type_ts_hr,
                          tvb, offset, 1, ENC_NA);
      proto_tree_add_item(tree, hf_ieee80211_ff_anqp_nw_auth_type_ts_min,
                          tvb, offset, 1, ENC_NA);
      proto_tree_add_item(tree, hf_ieee80211_ff_anqp_nw_auth_type_ts_sec,
                          tvb, offset, 1, ENC_NA);
      proto_tree_add_item(tree, hf_ieee80211_ff_anqp_nw_auth_type_ts_msec,
                          tvb, offset, 2, ENC_NA);
      proto_tree_add_item(tree, hf_ieee80211_ff_anqp_nw_auth_type_ts_rsvd,
                          tvb, offset, 1, ENC_NA);
      offset += 10;
    } else {
      /* Not enough bytes to dissect a timestamp */
    }
  }
}

static void
add_manuf(proto_item *item, tvbuff_t *tvb, int offset)
{
  const char *manuf_name;

  manuf_name = tvb_get_manuf_name_if_known(tvb, offset);
  if (manuf_name == NULL)
    return;
  proto_item_append_text(item, " - %s", manuf_name);
}

static void
dissect_roaming_consortium_list(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset,
                                int end)
{
  proto_item *item;
  uint8_t     len;

  while (offset < end) {
    len = tvb_get_uint8(tvb, offset);
    item = proto_tree_add_item(tree,
                               hf_ieee80211_ff_anqp_roaming_consortium_oi_len,
                               tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    if ((len > (end - offset)) || (len < 3)) {
      expert_add_info(pinfo, item, &ei_ieee80211_ff_anqp_roaming_consortium_oi_len);
      break;
    }
    item = proto_tree_add_item(tree,
                               hf_ieee80211_ff_anqp_roaming_consortium_oi,
                               tvb, offset, len, ENC_NA);
    add_manuf(item, tvb, offset);
    offset += len;
  }
}

static const value_string ip_addr_avail_ipv6_vals[] = {
  { 0, "Address type not available" },
  { 1, "Address type available" },
  { 2, "Availability of the address type not known" },
  { 0, NULL }
};

static const value_string ip_addr_avail_ipv4_vals[] = {
  { 0, "Address type not available" },
  { 1, "Public IPv4 address available" },
  { 2, "Port-restricted IPv4 address available" },
  { 3, "Single NATed private IPv4 address available" },
  { 4, "Double NATed private IPv4 address available" },
  { 5, "Port-restricted IPv4 address and single NATed IPv4 address available" },
  { 6, "Port-restricted IPv4 address and double NATed IPv4 address available" },
  { 7, "Availability of the address type is not known" },
  { 0, NULL }
};

static void
dissect_ip_addr_type_availability_info(proto_tree *tree, tvbuff_t *tvb,
                                       int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_anqp_ip_addr_avail_ipv6,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tree, hf_ieee80211_ff_anqp_ip_addr_avail_ipv4,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
}

static const value_string nai_realm_encoding_vals[] = {
  { 0, "Formatted in accordance with RFC 4282" },
  { 1, "UTF-8 formatted that is not formatted in accordance with RFC 4282" },
  { 0, NULL }
};

static const range_string oper_class_rvals[] = {
  {   0,   0, "Unknown" }, /* 0 should not be used */
  {   1,  80, "Reserved" },
  {  81,  81, "2.407 GHz, Channels 1-13, 25 MHz Spacing" },
  {  82,  82, "2.414 GHz, Channel 14, 25 MHz Spacing" },
  {  83,  83, "2.407 GHz, Channels 1-9, 40 MHz Spacing" },
  {  84,  84, "2.407 GHz, Channels 5-13, 40 MHz Spacing" },
  {  85,  93, "Reserved" },
  {  94,  94, "3.0 GHz, Channels 133 and 137, 20 MHz Spacing" },
  {  95,  95, "3.0 GHz, Channels 132, 134, 136, and 138, 10 MHz Spacing" },
  {  96,  96, "3.0025 GHz, Channels 131-138, 5 MHz Spacing" },
  {  97, 100, "Reserved" },
  { 101, 101, "4.85 GHz, Channels 21 and 25, 20 MHz Spacing" },
  { 102, 102, "4.89 GHz, Channels 11, 13, 15, 17, and 19, 10 MHz Spacing" },
  { 103, 103, "4.9375 GHz, Channels 1-10, 5 MHz Spacing" },
  { 104, 104, "4.0 GHz, Channels 184 and 192, 40 MHz Spacing" },
  { 105, 105, "4.0 GHz, Channels 188 and 196, 40 MHz Spacing" },
  { 106, 106, "4.0 GHz, Channels 191 and 195, 20 MHz Spacing" },
  { 107, 107, "4.0 GHz, Channels 189, 191, 193, 195, and 197, 10 MHz Spacing" },
  { 108, 108, "4.0025 GHz, Channels 188-197, 5 MHz Spacing" },
  { 109, 109, "4.0 GHz, Channels 184, 188, 192, and 196, 20 MHz Spacing" },
  { 110, 110, "4.0 GHz, Channels 183-189, 10 MHz Spacing" },
  { 111, 111, "4.0025 GHz, Channels 182-189, 5 MHz Spacing" },
  { 112, 112, "5.0 GHz, Channels 8, 12, and 16, 20 MHz Spacing" },
  { 113, 113, "5.0 GHz, Channels 7-11, 10 MHz Spacing" },
  { 114, 114, "5.0 GHz, Channels 6-11, 5 MHz Spacing" },
  { 115, 115, "5.0 GHz, Channels 36, 40, 44, and 48, 20 MHz Spacing" },
  { 116, 116, "5.0 GHz, Channels 36 and 44, 40 MHz Spacing" },
  { 117, 117, "5.0 GHz, Channels 40 and 48, 40 MHz Spacing" },
  { 118, 118, "5.0 GHz, Channels 52, 56, 60, and 64, 20 MHz Spacing" },
  { 119, 119, "5.0 GHz, Channels 52 and 60, 40 MHz Spacing" },
  { 120, 120, "5.0 GHz, Channels 56 and 64, 40 MHz Spacing" },
  { 121, 121, "5.0 GHz, Channels 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, and 140, 20 MHz Spacing" },
  { 122, 122, "5.0 GHz, Channels 100, 108, 116, 124, and 132, 40 MHz Spacing" },
  { 123, 123, "5.0 GHz, Channels 104, 112, 120, 128, and 136, 40 MHz Spacing" },
  { 124, 124, "5.0 GHz, Channels 149, 153, 157, and 161, 20 MHz Spacing" },
  { 125, 125, "5.0 GHz, Channels 149, 153, 157, 161, 165, and 169, 20 MHz Spacing" },
  { 126, 126, "5.0 GHz, Channels 149 and 157, 40 MHz Spacing" },
  { 127, 127, "5.0 GHz, Channels 153 and 161, 40 MHz Spacing" },
  { 128, 191, "Reserved" },
  { 192, 254, "Vendor-Specific" },

  { 255, 255, "Reserved" },
  {   0,   0, NULL }
};

static const value_string nai_realm_auth_param_id_vals[] = {
  {   1, "Expanded EAP Method" },
  {   2, "Non-EAP Inner Authentication Type" },
  {   3, "Inner Authentication EAP Method Type" },
  {   4, "Expanded Inner EAP Method" },
  {   5, "Credential Type" },
  {   6, "Tunneled EAP Method Credential Type" },
  { 221, "Vendor Specific" },
  { 0, NULL }
};

static void
dissect_nai_realm_list(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset, int end)
{
  uint16_t      count, len;
  proto_item   *item, *r_item;
  int           f_end, eap_end;
  uint8_t       nai_len, eap_count, eap_len, auth_param_count, auth_param_len;
  uint8_t       auth_param_id;
  proto_tree   *realm_tree, *eap_tree;
  const uint8_t *realm;

  count = tvb_get_letohs(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_ff_anqp_nai_realm_count,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;
  while (count > 0) {
    len = tvb_get_letohs(tvb, offset);
    realm_tree = proto_tree_add_subtree(tree, tvb, offset, 2 + len, ett_nai_realm, &r_item, "NAI Realm Data");

    item = proto_tree_add_item(realm_tree, hf_ieee80211_ff_anqp_nai_field_len,
                               tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    if (offset + len > end) {
      expert_add_info_format(pinfo, item, &ei_ieee80211_ff_anqp_nai_field_len,
                             "Invalid NAI Realm List");
      break;
    }
    f_end = offset + len;
    proto_tree_add_item(realm_tree, hf_ieee80211_ff_anqp_nai_realm_encoding,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    nai_len = tvb_get_uint8(tvb, offset);
    proto_tree_add_item(realm_tree, hf_ieee80211_ff_anqp_nai_realm_length,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    if (offset + nai_len > f_end) {
      expert_add_info_format(pinfo, r_item, &ei_ieee80211_ff_anqp_nai_field_len,
                             "Invalid NAI Realm Data");
      break;
    }
    proto_tree_add_item_ret_string(realm_tree, hf_ieee80211_ff_anqp_nai_realm,
                        tvb, offset, nai_len, ENC_ASCII|ENC_NA, pinfo->pool, &realm);
    if (realm) {
      proto_item_append_text(r_item, " (%s)", realm);
    }
    offset += nai_len;
    eap_count = tvb_get_uint8(tvb, offset);
    proto_tree_add_item(realm_tree, hf_ieee80211_ff_anqp_nai_realm_eap_count,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    while (eap_count > 0) {
      eap_len = tvb_get_uint8(tvb, offset);
      eap_end = offset + 1 + eap_len;
      eap_tree = proto_tree_add_subtree(realm_tree, tvb, offset, 1 + eap_len,
                                 ett_nai_realm_eap, NULL, "EAP Method");

      item = proto_tree_add_item(eap_tree,
                                 hf_ieee80211_ff_anqp_nai_realm_eap_len,
                                 tvb, offset, 1, ENC_LITTLE_ENDIAN);
      offset += 1;
      if (offset + eap_len > f_end) {
        expert_add_info(pinfo, item, &ei_ieee80211_ff_anqp_nai_realm_eap_len);
        break;
      }

      proto_item_append_text(eap_tree, ": %s",
                             val_to_str_ext(tvb_get_uint8(tvb, offset),
                                            &eap_type_vals_ext, "Unknown (%d)"));
      proto_tree_add_item(eap_tree, hf_ieee80211_ff_anqp_nai_realm_eap_method,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      offset += 1;
      auth_param_count = tvb_get_uint8(tvb, offset);
      proto_tree_add_item(eap_tree,
                          hf_ieee80211_ff_anqp_nai_realm_auth_param_count,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      offset += 1;

      while (auth_param_count > 0) {
        auth_param_id = tvb_get_uint8(tvb, offset);
        proto_tree_add_item(eap_tree,
                            hf_ieee80211_ff_anqp_nai_realm_auth_param_id,
                            tvb, offset, 1, ENC_LITTLE_ENDIAN);
        offset += 1;
        auth_param_len = tvb_get_uint8(tvb, offset);
        proto_tree_add_item(eap_tree,
                            hf_ieee80211_ff_anqp_nai_realm_auth_param_len,
                            tvb, offset, 1, ENC_LITTLE_ENDIAN);
        offset += 1;
        item = proto_tree_add_item(
          eap_tree, hf_ieee80211_ff_anqp_nai_realm_auth_param_value,
          tvb, offset, auth_param_len, ENC_NA);
        if ((auth_param_id == 3) && (auth_param_len == 1)) {
          uint8_t inner_method = tvb_get_uint8(tvb, offset);
          const char *str;
          str = val_to_str_ext(inner_method, &eap_type_vals_ext, "Unknown (%d)");

          proto_item_append_text(eap_tree, " / %s", str);
          proto_item_append_text(item, " - %s", str);
        }
        offset += auth_param_len;

        auth_param_count--;
      }

      offset = eap_end;
      eap_count--;
    }

    offset = f_end;
    count--;
  }
}

static void
dissect_3gpp_cellular_network_info(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  uint8_t     iei, num, plmn_idx = 0;
  proto_item *item;

  /* See Annex A of 3GPP TS 24.234 v8.1.0 for description */
  proto_tree_add_item(tree, hf_ieee80211_3gpp_gc_gud, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_3gpp_gc_udhl, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  iei = tvb_get_uint8(tvb, offset);
  item = proto_tree_add_item(tree, hf_ieee80211_3gpp_gc_iei, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  if (iei == 0)
    proto_item_append_text(item, " (PLMN List)");
  else
    return;
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_3gpp_gc_plmn_len, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  num = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_3gpp_gc_num_plmns, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  while (num > 0) {
    proto_item *plmn_item = NULL;
    proto_tree *plmn_tree = NULL;
    unsigned plmn_val = 0;

    if (tvb_reported_length_remaining(tvb, offset) < 3)
      break;
    plmn_val = tvb_get_letoh24(tvb, offset);
    plmn_item = proto_tree_add_uint_format(tree, hf_ieee80211_3gpp_gc_plmn,
                                tvb, offset, 3, plmn_val, "PLMN %d (0x%x)",
                                plmn_idx++, plmn_val);
    plmn_tree = proto_item_add_subtree(plmn_item, ett_ieee80211_3gpp_plmn);
    dissect_e212_mcc_mnc_wmem_packet_str(tvb, pinfo, plmn_tree, offset, E212_NONE, true);
    num--;
    offset += 3;
  }
}

static void
dissect_domain_name_list(proto_tree *tree, tvbuff_t *tvb, int offset, int end)
{
  uint8_t len;

  while (offset < end) {
    len = tvb_get_uint8(tvb, offset);
    proto_tree_add_item(tree, hf_ieee80211_ff_anqp_domain_name_len,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ieee80211_ff_anqp_domain_name,
                        tvb, offset, len, ENC_ASCII);
    offset += len;
  }
}

static int
dissect_hs20_subscription_remediation(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, void *data _U_)
{
  int offset = 0;
  uint8_t url_len = tvb_get_uint8(tvb, offset);
  proto_item *pi = NULL;

  proto_tree_add_item(tree, hf_ieee80211_hs20_subscription_remediation_url_len, tvb, offset,
                        1, ENC_NA);
  offset++;
  if (tvb_reported_length_remaining(tvb, offset) >= url_len) {
    pi = proto_tree_add_item(tree, hf_ieee80211_hs20_subscription_remediation_server_url,
                        tvb, offset, url_len, ENC_ASCII);
    offset += url_len;
    proto_item_set_url(pi);
    proto_tree_add_item(tree, hf_ieee80211_hs20_subscription_remediation_server_method,
                        tvb, offset, 1, ENC_NA);
    offset++;
  }

  return offset;
}

static int
dissect_hs20_deauthentication_imminent(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, void *data _U_)
{
  int offset = 0;
  uint8_t url_len = 0;
  proto_item *pi = NULL;

  proto_tree_add_item(tree, hf_ieee80211_hs20_deauth_reason_code, tvb, offset, 1, ENC_NA);
  offset++;

  proto_tree_add_item(tree, hf_ieee80211_hs20_reauth_delay, tvb, offset, 2,
                        ENC_LITTLE_ENDIAN);
  offset += 2;

  url_len = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_hs20_deauth_reason_url_len, tvb, offset, 1,
                        ENC_NA);
  offset++;

  if (tvb_reported_length_remaining(tvb, offset) >= url_len) {
    pi = proto_tree_add_item(tree, hf_ieee80211_hs20_deauth_imminent_reason_url,
                        tvb, offset, url_len, ENC_ASCII);
    offset += url_len;
    proto_item_set_url(pi);
  }
  return offset;
}

#define HS20_ANQP_HS_QUERY_LIST              1
#define HS20_ANQP_HS_CAPABILITY_LIST         2
#define HS20_ANQP_OPERATOR_FRIENDLY_NAME     3
#define HS20_ANQP_WAN_METRICS                4
#define HS20_ANQP_CONNECTION_CAPABILITY      5
#define HS20_ANQP_NAI_HOME_REALM_QUERY       6
#define HS20_ANQP_OPERATING_CLASS_INDICATION 7
#define HS20_ANQP_OSU_PROVIDERS_LIST         8
/* 9 is reserved */
#define HS20_ANQP_ICON_REQUEST               10
#define HS20_ANQP_ICON_BINARY_FILE           11
#define HS20_ANQP_OPERATOR_ICON_METADATA     12
#define HS20_ANQP_ADVICE_OF_CHARGE           13

static const value_string hs20_anqp_subtype_vals[] = {
  { HS20_ANQP_HS_QUERY_LIST, "HS Query list" },
  { HS20_ANQP_HS_CAPABILITY_LIST, "HS Capability List" },
  { HS20_ANQP_OPERATOR_FRIENDLY_NAME, "Operator Friendly Name" },
  { HS20_ANQP_WAN_METRICS, "WAN Metrics" },
  { HS20_ANQP_CONNECTION_CAPABILITY, "Connection Capability" },
  { HS20_ANQP_NAI_HOME_REALM_QUERY, "NAI Home Realm Query" },
  { HS20_ANQP_OPERATING_CLASS_INDICATION, "Operating Class Indication" },
  { HS20_ANQP_OSU_PROVIDERS_LIST, "OSU Providers List" },
  { 9, "Reserved" },
  { HS20_ANQP_ICON_REQUEST, "Icon Request" },
  { HS20_ANQP_ICON_BINARY_FILE, "Icon Binary File" },
  { HS20_ANQP_OPERATOR_ICON_METADATA, "Operator Icon Metadata" },
  { HS20_ANQP_ADVICE_OF_CHARGE, "Advice of Charge" },
  { 0, NULL }
};

static void
dissect_hs20_anqp_hs_query_list(proto_tree *tree, tvbuff_t *tvb, int offset, int end)
{
  while (offset < end) {
    proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_hs_query_list,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;
  }
}

static void
dissect_hs20_anqp_operator_friendly_name(proto_tree *tree, tvbuff_t *tvb,
                                         packet_info *pinfo, int offset,
                                         int end, int hf_array[],
                                         int ett_val)
{
  int ofn_index = 0;

  while (offset + 4 <= end) {
    uint8_t vlen = tvb_get_uint8(tvb, offset);
    proto_tree *ofn_tree = NULL;
    proto_item *item = NULL, *pi = NULL;
    int start_offset = offset;

    ofn_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1, ett_val,
                                        &pi, "Friendly Name [%d]", ofn_index + 1);

    item = proto_tree_add_item(ofn_tree, hf_array[0],
                               tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;
    if (vlen > end - offset || vlen < 3) {
      expert_add_info(pinfo, item, &ei_hs20_anqp_ofn_length);
      break;
    }
    proto_tree_add_item(ofn_tree, hf_array[1],
                        tvb, offset, 3, ENC_ASCII|ENC_NA);
    proto_tree_add_item(ofn_tree, hf_array[2],
                        tvb, offset + 3, vlen - 3, ENC_UTF_8);
    offset += vlen;

    proto_item_set_len(pi, offset - start_offset);
    ofn_index++;
  }
}

static const value_string hs20_wm_link_status_vals[] = {
  { 0, "Reserved" },
  { 1, "Link up" },
  { 2, "Link down" },
  { 3, "Link in test state" },
  { 0, NULL }
};

static void
dissect_hs20_anqp_wan_metrics(proto_tree *tree, tvbuff_t *tvb, int offset, bool request)
{
  if (request)
    return;

  if(tvb_reported_length_remaining(tvb, offset) < 13)
    return;

  proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_wan_metrics_link_status,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_wan_metrics_symmetric_link,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_wan_metrics_at_capacity,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_wan_metrics_reserved,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset++;

  proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_wan_metrics_downlink_speed,
                      tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_wan_metrics_uplink_speed,
                      tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_wan_metrics_downlink_load,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset++;

  proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_wan_metrics_uplink_load,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset++;

  proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_wan_metrics_lmd,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
}

static const value_string hs20_cc_proto_vals[] = {
  {  1, "ICMP" },
  {  6, "TCP" },
  { 17, "UDP" },
  { 50, "ESP" },
  {  0, NULL }
};

static const value_string hs20_cc_port_vals[] = {
  {    0, "[Supported]" }, /* Used to indicate ICMP, ESP for IPSec VPN, or IKEv2 for IPSec VPN */
  {   20, "FTP" },
  {   22, "SSH" },
  {   80, "HTTP" },
  {  443, "HTTPS" },
  {  500, "IKEv2 for IPSec VPN" },
  { 1723, "PPTP for IPSec VPN" },
  { 4500, "[Optional] IKEv2 for IPSec VPN" },
  { 5060, "VOIP" },
  {    0, NULL },
};

static const value_string hs20_cc_status_vals[] = {
  { 0, "Closed" },
  { 1, "Open" },
  { 2, "Unknown" },
  { 0, NULL }
};

static void
dissect_hs20_anqp_connection_capability(proto_tree *tree, tvbuff_t *tvb,
                                        int offset, int end)
{
  proto_tree *tuple;
  while (offset + 4 <= end) {
    uint8_t ip_proto, status;
    uint16_t port_num;

    ip_proto = tvb_get_uint8(tvb, offset);
    port_num = tvb_get_letohs(tvb, offset + 1);
    status = tvb_get_uint8(tvb, offset + 3);

    tuple = proto_tree_add_subtree_format(tree, tvb, offset, 4, ett_hs20_cc_proto_port_tuple, NULL,
                               "ProtoPort Tuple - ip_proto=%s port_num=%s status=%s",
                               val_to_str(ip_proto, hs20_cc_proto_vals, "Unknown (%u)"),
                               val_to_str(port_num, hs20_cc_port_vals, "Unknown (%u)"),
                               val_to_str(status, hs20_cc_status_vals, "Reserved (%u)"));
    proto_tree_add_item(tuple, hf_ieee80211_hs20_anqp_cc_proto_ip_proto,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;
    proto_tree_add_item(tuple, hf_ieee80211_hs20_anqp_cc_proto_port_num,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    proto_tree_add_item(tuple, hf_ieee80211_hs20_anqp_cc_proto_status,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;
  }
}

static void
dissect_hs20_anqp_nai_home_realm_query(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,
                                       int offset, int end)
{
  uint8_t len;
  proto_item *item;

  proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_nai_hrq_count,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset++;

  while (offset + 2 <= end) {
    proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_nai_hrq_encoding_type,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;
    len = tvb_get_uint8(tvb, offset);
    item = proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_nai_hrq_length,
                               tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;
    if (offset + len > end) {
      expert_add_info(pinfo, item, &ei_hs20_anqp_nai_hrq_length);
      break;
    }
    proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_nai_hrq_realm_name,
                        tvb, offset, len, ENC_ASCII);
    offset += len;
  }
}

static void
dissect_hs20_anqp_oper_class_indic(proto_tree *tree, tvbuff_t *tvb, int offset, int end)
{
  while (offset < end) {
    proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_oper_class_indic,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;
  }
}

static int
dissect_hs20_osu_friendly_names(proto_tree *tree, tvbuff_t *tvb,
  packet_info *pinfo, int offset, int end _U_)
{
  int osu_fn_hf_array[3] = {hf_ieee80211_hs20_osu_friendly_name_length,
                            hf_ieee80211_hs20_osu_friendly_name_language,
                            hf_ieee80211_hs20_osu_friendly_name_name };
  uint16_t osu_fn_count = tvb_get_letohs(tvb, offset);
  proto_tree *fn_tree = NULL;

  proto_tree_add_item(tree, hf_ieee80211_hs20_osu_friendly_names_len, tvb, offset, 2,
                        ENC_LITTLE_ENDIAN);
  offset += 2;

  fn_tree = proto_tree_add_subtree(tree, tvb, offset, osu_fn_count,
                        ett_hs20_friendly_names_list, NULL,
                        "Friendly Names List");

  dissect_hs20_anqp_operator_friendly_name(fn_tree, tvb, pinfo, offset,
                        offset + osu_fn_count,
                        osu_fn_hf_array, ett_hs20_friendly_name_tree);

  return offset + osu_fn_count;
}

static int
dissect_hs20_osu_icon_available(proto_tree *tree, tvbuff_t *tvb,
  packet_info *pinfo _U_, int offset, int end _U_, uint16_t icon_index)
{
  proto_tree *icon_avail = NULL;
  proto_item *pi = NULL;
  int start_offset = offset;
  uint8_t icon_type_len = 0, icon_filename_len = 0;

  icon_avail = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                        ett_hs20_osu_icon_tree, &pi,
                        "Icon Available %d", icon_index);

  proto_tree_add_item(icon_avail, hf_ieee80211_osu_icon_avail_width, tvb, offset, 2,
                        ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(icon_avail, hf_ieee80211_osu_icon_avail_height, tvb, offset, 2,
                        ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(icon_avail, hf_ieee80211_osu_icon_avail_lang_code, tvb, offset, 3,
                        ENC_ASCII);
  offset += 3;

  icon_type_len = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(icon_avail, hf_ieee80211_osu_icon_avail_icon_type_len, tvb, offset,
                        1, ENC_NA);
  offset++;

  proto_tree_add_item(icon_avail, hf_ieee80211_osu_icon_avail_icon_type, tvb, offset,
                        icon_type_len, ENC_ASCII);
  offset += icon_type_len;

  icon_filename_len = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(icon_avail, hf_ieee80211_osu_icon_avail_filename_len, tvb, offset,
                        1, ENC_NA);
  offset++;

  proto_tree_add_item(icon_avail, hf_ieee80211_osu_icon_avail_filename, tvb, offset,
                        icon_filename_len, ENC_ASCII);
  offset += icon_filename_len;

  proto_item_set_len(pi, offset - start_offset);

  return offset;
}

static const value_string osu_method_vals[] = {
  { 0, "OMA DM" },
  { 1, "SOAP XML SPP" },
  { 0, NULL },
};

static int
dissect_hs20_osu_provider(proto_tree *tree, tvbuff_t *tvb,
  packet_info *pinfo, int offset, int end, uint8_t provider_index)
{
  proto_tree *prov_tree = NULL;
  proto_item *osupi = NULL, *uri_pi = NULL;
  int start_offset = offset;
  uint8_t osu_server_uri_len = 0;
  uint8_t osu_method_list_len = 0;
  uint16_t icons_avail = 0, icons_index = 0;
  uint8_t osu_nai_len = 0;
  uint16_t osu_service_desc_len = 0;

  prov_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                        ett_hs20_osu_provider_tree, &osupi,
                        "OSU Provider %d", provider_index);

  proto_tree_add_item(prov_tree, hf_ieee80211_hs20_osu_prov_length, tvb, offset, 2,
                        ENC_LITTLE_ENDIAN);
  offset += 2;

  offset = dissect_hs20_osu_friendly_names(prov_tree, tvb, pinfo, offset, end);

  proto_item_set_len(osupi, offset - start_offset);

  osu_server_uri_len = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(prov_tree, hf_ieee80211_hs20_osu_server_uri_len, tvb, offset, 1,
                        ENC_NA);
  offset++;

  uri_pi = proto_tree_add_item(prov_tree, hf_ieee80211_hs20_osu_server_uri, tvb, offset,
                        osu_server_uri_len, ENC_ASCII);
  offset += osu_server_uri_len;
  proto_item_set_url(uri_pi);

  osu_method_list_len = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(prov_tree, hf_ieee80211_hs20_osu_method_list_len, tvb, offset, 1,
                        ENC_NA);
  offset++;

  if (osu_method_list_len > 0) {
    proto_tree *osu_method_list = NULL;
    uint8_t osu_method_list_index = 0;

    osu_method_list = proto_tree_add_subtree(prov_tree, tvb, offset,
                                osu_method_list_len,
                                ett_hs20_osu_provider_method_list,
                                NULL, "OSU Method List");
    while (osu_method_list_len > osu_method_list_index) {
      proto_item *pi = NULL;
      uint8_t method = tvb_get_uint8(tvb, offset);

      pi = proto_tree_add_item(osu_method_list, hf_ieee80211_hs20_osu_method_val, tvb,
                        offset, 1, ENC_NA);
      proto_item_append_text(pi, ": %s",
                                val_to_str_const(method, osu_method_vals,
                                        "Reserved"));
      offset++;
      osu_method_list_index++;
    }
  }

  icons_avail = tvb_get_letohs(tvb, offset);
  proto_tree_add_item(prov_tree, hf_ieee80211_hs20_icons_avail_len, tvb, offset, 2,
                        ENC_LITTLE_ENDIAN);
  offset += 2;

  if (icons_avail > 0) {
    proto_tree *icon_list = NULL;
    proto_item *pi = NULL;

    start_offset = offset;

    icon_list = proto_tree_add_subtree(prov_tree, tvb, offset, -1,
                                ett_osu_icons_avail_list, &pi,
                                "Icons Available");

    while ((offset - start_offset) < icons_avail) {
      offset = dissect_hs20_osu_icon_available(icon_list, tvb, pinfo, offset,
                                end, icons_index);
      icons_index++;
    }

    proto_item_set_len(pi, offset - start_offset);
  }

  osu_nai_len = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(prov_tree, hf_ieee80211_hs20_osu_nai_len, tvb, offset, 1, ENC_NA);
  offset++;

  if (osu_nai_len > 0) {
    proto_tree_add_item(prov_tree, hf_ieee80211_hs20_osu_nai, tvb, offset,
                        osu_nai_len, ENC_ASCII);
    offset += osu_nai_len;
  }

  osu_service_desc_len = tvb_get_letohs(tvb, offset);
  proto_tree_add_item(prov_tree, hf_ieee80211_hs20_osu_service_desc_len, tvb, offset, 2,
                        ENC_LITTLE_ENDIAN);
  offset += 2;

  if (osu_service_desc_len > 0) {
    proto_tree *desc_tree = NULL;
    proto_item *pi = NULL;
    uint8_t service_desc_index = 0;

    start_offset = offset;
    desc_tree = proto_tree_add_subtree(prov_tree, tvb, offset, -1,
                                ett_hs20_osu_service_desc_list, &pi,
                                "OSU Service Description List");

    while ((offset - start_offset) < osu_service_desc_len) {
      proto_tree *desc_duple = NULL;
      uint8_t serv_desc_len = tvb_get_uint8(tvb, offset);

      desc_duple = proto_tree_add_subtree_format(desc_tree, tvb, offset,
                                1 + serv_desc_len,
                                ett_hs20_osu_service_desc_tree, NULL,
                                "OSU Service Description Duple %d",
                                service_desc_index);

      proto_tree_add_item(desc_duple, hf_ieee80211_hs20_osu_service_desc_duple_len, tvb,
                                offset, 1, ENC_NA);
      offset++;

      proto_tree_add_item(desc_duple, hf_ieee80211_hs20_osu_service_desc_lang, tvb, offset,
                                3, ENC_ASCII);
      offset += 3;

      proto_tree_add_item(desc_duple, hf_ieee80211_hs20_osu_service_desc, tvb, offset,
                                serv_desc_len - 3, ENC_ASCII);
      offset += serv_desc_len - 3;

      service_desc_index++;
    }

    proto_item_set_len(pi, offset - start_offset);
  }

  return offset;
}

static void
dissect_hs20_anqp_osu_providers_list(proto_tree *tree, tvbuff_t *tvb,
  packet_info *pinfo, int offset, int end)
{
  uint8_t ssid_len = tvb_get_uint8(tvb, offset);
  uint8_t osu_prov_count = 0, osu_prov_index = 0;

  proto_tree_add_item(tree, hf_ieee80211_hs20_osu_providers_list_ssid_len, tvb, offset, 1,
                        ENC_NA);
  offset++;

  proto_tree_add_item(tree, hf_ieee80211_hs20_osu_providers_ssid, tvb, offset, ssid_len,
                        ENC_UTF_8);
  offset += ssid_len;

  osu_prov_count = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_hs20_osu_providers_count, tvb, offset, 1,
                        ENC_NA);
  offset++;

  if (osu_prov_count > 0) {
    int start_offset = offset;
    proto_item *pi = NULL;
    proto_tree *osu_prov_list = NULL;

    osu_prov_list = proto_tree_add_subtree(tree, tvb, offset, -1,
                        ett_hs20_osu_providers_list, &pi,
                        "OSU Providers List");
    while (offset < end && osu_prov_count > osu_prov_index) {
      offset = dissect_hs20_osu_provider(osu_prov_list, tvb, pinfo, offset, end,
                        osu_prov_index);
      osu_prov_index++;
    }

    proto_item_set_len(pi, offset - start_offset);
  }
}

static void
dissect_hs20_anqp_icon_request(proto_tree *tree, tvbuff_t *tvb, int offset,
  int end)
{
  proto_tree_add_item(tree, hf_ieee80211_hs20_icon_request_filename, tvb, offset,
                        end - offset, ENC_UTF_8);
}

static const value_string hs20_icon_download_status_vals[] = {
  { 0, "Success" },
  { 1, "File not found" },
  { 2, "Unspecified file error" },
  { 0, NULL }
};

static void
dissect_hs20_anqp_icon_binary_file(proto_tree *tree, tvbuff_t *tvb, int offset,
  int end _U_)
{
  uint8_t icon_download_status = tvb_get_uint8(tvb, offset);
  proto_item *pi = NULL;
  uint8_t icon_type_len = 0;
  uint16_t icon_binary_data_len = 0;

  pi = proto_tree_add_item(tree, hf_ieee80211_hs20_icon_binary_file_status, tvb, offset, 1,
                        ENC_NA);
  offset++;
  proto_item_append_text(pi, ": %s",
                         val_to_str(icon_download_status,
                                    hs20_icon_download_status_vals,
                                    "Reserved (%u)"));

  icon_type_len = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_hs20_icon_type_length, tvb, offset, 1, ENC_NA);
  offset++;

  proto_tree_add_item(tree, hf_ieee80211_hs20_icon_type, tvb, offset, icon_type_len,
                        ENC_UTF_8);
  offset += icon_type_len;

  icon_binary_data_len = tvb_get_letohs(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_hs20_icon_binary_data_len, tvb, offset, 2,
                        ENC_BIG_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_hs20_icon_binary_data, tvb, offset,
                        icon_binary_data_len, ENC_NA);
}

static void
dissect_hs20_anqp_operator_icon_metadata(proto_tree *tree, tvbuff_t *tvb,
  int offset, int end _U_)
{
  proto_item *pi = NULL;
  int start_offset = offset;
  uint8_t icon_type_len = 0, icon_filename_len = 0;

  proto_tree_add_item(tree, hf_ieee80211_osu_icon_avail_width, tvb, offset, 2,
                        ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_osu_icon_avail_height, tvb, offset, 2,
                        ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_osu_icon_avail_lang_code, tvb, offset, 3,
                        ENC_ASCII);
  offset += 3;

  icon_type_len = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_osu_icon_avail_icon_type_len, tvb, offset,
                        1, ENC_NA);
  offset++;

  proto_tree_add_item(tree, hf_ieee80211_osu_icon_avail_icon_type, tvb, offset,
                        icon_type_len, ENC_ASCII);
  offset += icon_type_len;

  icon_filename_len = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_osu_icon_avail_filename_len, tvb, offset,
                        1, ENC_NA);
  offset++;

  proto_tree_add_item(tree, hf_ieee80211_osu_icon_avail_filename, tvb, offset,
                        icon_filename_len, ENC_ASCII);
  offset += icon_filename_len;

  proto_item_set_len(pi, offset - start_offset);
}

static void
dissect_anqp_venue_url(proto_tree *tree, tvbuff_t *tvb, int offset, int end)
{
  uint16_t url_duple_index = 0;

  while (offset < end) {
    proto_tree *venue_url = NULL;
    proto_item *url_pi = NULL;
    uint8_t url_duple_len = tvb_get_uint8(tvb, offset);

    venue_url = proto_tree_add_subtree_format(tree, tvb, offset,
                        url_duple_len + 1, ett_hs20_venue_url, NULL,
                        "Venue URL Duple %d", url_duple_index);

    proto_tree_add_item(venue_url, hf_ieee80211_hs20_anqp_venue_url_length, tvb, offset,
                        1, ENC_NA);
    offset++;

    proto_tree_add_item(venue_url, hf_ieee80211_hs20_anqp_venue_number, tvb, offset, 1,
                        ENC_NA);
    offset++;

    url_pi = proto_tree_add_item(venue_url, hf_ieee80211_hs20_anqp_venue_url, tvb, offset,
                        url_duple_len -1, ENC_ASCII);
    proto_item_set_url(url_pi);

    offset += (url_duple_len - 1);

    url_duple_index++;
  }
}

static const value_string advice_of_charge_type_vals[] = {
  { 0, "Time-based" },
  { 1, "Data-volume-based" },
  { 2, "Time-and-data-volume-based" },
  { 3, "Unlimited" },
  { 0, NULL }
};

static void
dissect_hs20_anqp_advice_of_charge(proto_tree *tree, tvbuff_t *tvb, int offset,
  int end _U_)
{
  uint16_t toc_index = 0;

  while (offset < end) {
    uint16_t adv_charge_len = tvb_get_letohs(tvb, offset);
    proto_tree *aoc_tree = NULL;
    proto_tree *plan_info_tree = NULL;
    proto_item *pi = NULL, *tpi = NULL;
    int start_offset = offset;
    uint8_t aoc_type = 0, nai_realm_len = 0;
    uint8_t plan_index = 0;
    uint16_t plan_tot_len = 0;
    int plan_offset = 0;

    aoc_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                        ett_hs20_advice_of_charge, &pi,
                        "Advice of Charge Duple %d", toc_index);
    proto_tree_add_item(aoc_tree, hf_ieee80211_hs20_anqp_advice_of_charge_length, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    aoc_type = tvb_get_uint8(tvb, offset);
    tpi = proto_tree_add_item(aoc_tree, hf_ieee80211_hs20_anqp_advice_of_charge_type, tvb,
                        offset, 1, ENC_NA);
    offset++;
    proto_item_append_text(tpi, ": %s",
                                val_to_str(aoc_type,
                                        advice_of_charge_type_vals,
                                        "Reserved (%u)"));

    proto_tree_add_item(aoc_tree, hf_ieee80211_hs20_anqp_aoc_nai_realm_encoding, tvb,
                        offset, 1, ENC_NA);
    offset++;

    nai_realm_len = tvb_get_uint8(tvb, offset);
    proto_tree_add_item(aoc_tree, hf_ieee80211_hs20_anqp_aoc_nai_realm_len, tvb, offset,
                        1, ENC_NA);
    offset++;

    proto_tree_add_item(aoc_tree, hf_ieee80211_hs20_anqp_aoc_nai_realm, tvb, offset,
                        nai_realm_len, ENC_UTF_8);
    offset += nai_realm_len;

    plan_tot_len = adv_charge_len - 3 - nai_realm_len;
    plan_offset = offset;

    while (offset < (plan_offset + plan_tot_len)) {
        uint16_t plan_len = tvb_get_letohs(tvb, offset);

        plan_info_tree = proto_tree_add_subtree_format(aoc_tree, tvb, offset,
                                plan_len + 2, ett_hs20_aoc_plan, NULL,
                                "Plan #%u", plan_index);

        proto_tree_add_item(plan_info_tree, hf_ieee80211_hs20_anqp_aoc_plan_len, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;

        proto_tree_add_item(plan_info_tree, hf_ieee80211_hs20_anqp_aoc_plan_lang, tvb,
                        offset, 3, ENC_ASCII);
        offset += 3;

        proto_tree_add_item(plan_info_tree, hf_ieee80211_hs20_anqp_aoc_plan_curcy, tvb,
                        offset, 3, ENC_ASCII);
        offset += 3;

        proto_tree_add_item(plan_info_tree, hf_ieee80211_hs20_anqp_aoc_plan_information,
                        tvb, offset, plan_len - 6, ENC_UTF_8);
        offset += plan_len - 6;

        plan_index++;
    }

    proto_item_set_len(pi, offset - start_offset);

    toc_index++;
  }
}

static int
dissect_hs20_anqp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
  uint8_t subtype;
  int ofn_hf_array[3] = {hf_ieee80211_hs20_anqp_ofn_length,
                         hf_ieee80211_hs20_anqp_ofn_language,
                         hf_ieee80211_hs20_anqp_ofn_name };

  int end = tvb_reported_length(tvb);
  int offset = 0;
  anqp_info_dissector_data_t* anqp_data = (anqp_info_dissector_data_t*)data;

  DISSECTOR_ASSERT(anqp_data);

  subtype = tvb_get_uint8(tvb, offset);
  proto_item_append_text(tree, " - HS 2.0 %s",
                         val_to_str(subtype, hs20_anqp_subtype_vals,
                                    "Reserved (%u)"));
  if (anqp_data->idx == 0) {
    col_append_fstr(pinfo->cinfo, COL_INFO, " HS 2.0 %s",
                    val_to_str(subtype, hs20_anqp_subtype_vals,
                               "Reserved (%u)"));
  } else if (anqp_data->idx == 1) {
    col_append_str(pinfo->cinfo, COL_INFO, ", ..");
  }
  proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_subtype, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  offset++;

  proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_reserved, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  offset++;

  switch (subtype) {
  case HS20_ANQP_HS_QUERY_LIST:
    dissect_hs20_anqp_hs_query_list(tree, tvb, offset, end);
    break;
  case HS20_ANQP_HS_CAPABILITY_LIST:
    dissect_hs20_anqp_hs_capability_list(tree, tvb, offset, end);
    break;
  case HS20_ANQP_OPERATOR_FRIENDLY_NAME:
    dissect_hs20_anqp_operator_friendly_name(tree, tvb, pinfo, offset, end,
                                ofn_hf_array, ett_hs20_ofn_tree);
    break;
  case HS20_ANQP_WAN_METRICS:
    dissect_hs20_anqp_wan_metrics(tree, tvb, offset, anqp_data->request);
    break;
  case HS20_ANQP_CONNECTION_CAPABILITY:
    dissect_hs20_anqp_connection_capability(tree, tvb, offset, end);
    break;
  case HS20_ANQP_NAI_HOME_REALM_QUERY:
    dissect_hs20_anqp_nai_home_realm_query(tree, tvb, pinfo, offset, end);
    break;
  case HS20_ANQP_OPERATING_CLASS_INDICATION:
    dissect_hs20_anqp_oper_class_indic(tree, tvb, offset, end);
    break;
  case HS20_ANQP_OSU_PROVIDERS_LIST:
    dissect_hs20_anqp_osu_providers_list(tree, tvb, pinfo, offset, end);
    break;
  case HS20_ANQP_ICON_REQUEST:
    dissect_hs20_anqp_icon_request(tree, tvb, offset, end);
    break;
  case HS20_ANQP_ICON_BINARY_FILE:
    dissect_hs20_anqp_icon_binary_file(tree, tvb, offset, end);
    break;
  case HS20_ANQP_OPERATOR_ICON_METADATA:
    dissect_hs20_anqp_operator_icon_metadata(tree, tvb, offset, end);
    break;
  case HS20_ANQP_ADVICE_OF_CHARGE:
    dissect_hs20_anqp_advice_of_charge(tree, tvb, offset, end);
    break;
  default:
    if (offset == end)
      break;
    proto_tree_add_item(tree, hf_ieee80211_hs20_anqp_payload, tvb, offset,
                        end - offset, ENC_NA);
    break;
  }

  return tvb_captured_length(tvb);
}

// MBO ANQP element subtypes
#define MBO_ANQP_QUERY_LIST               1
#define MBO_ANQP_CELLULAR_DATA_PREFERENCE 2

static const value_string mbo_anqp_subtype_vals[] = {
  { MBO_ANQP_QUERY_LIST, "MBO Query List" },
  { MBO_ANQP_CELLULAR_DATA_PREFERENCE, "Cellular Data Connection Preference" },
  { 0, NULL }
};

static int
dissect_mbo_anqp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
{
  uint8_t subtype;
  int len = tvb_reported_length(tvb);
  int offset = 0;

  if (len < 2) {
    expert_add_info(pinfo, tree, &ei_ieee80211_bad_length);
    return offset;
  }

  subtype = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_wfa_anqp_mbo_subtype, tvb, offset, 1, ENC_NA);
  offset++;
  len--;

  switch (subtype) {
  case MBO_ANQP_QUERY_LIST:
    while (len > 0) {
      proto_tree_add_item(tree, hf_ieee80211_wfa_anqp_mbo_query, tvb, offset, 1, ENC_NA);
      offset++;
      len--;
    }
    break;
  case MBO_ANQP_CELLULAR_DATA_PREFERENCE:
    proto_tree_add_item(tree, hf_ieee80211_wfa_anqp_mbo_cellular_pref, tvb, offset,
                        1, ENC_NA);
    offset++;
    len--;
    break;
  default:
    break;
  }

  return offset;
}

static int
dissect_vendor_wifi_alliance_anqp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
  uint8_t subtype;
  int offset = 0;
  tvbuff_t *subtvb;

  subtype = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_anqp_wfa_subtype, tvb, offset, 1, ENC_NA);
  offset += 1;

  subtvb = tvb_new_subset_remaining(tvb, offset);
  if (!dissector_try_uint_new(wifi_alliance_anqp_info_table, subtype, subtvb, pinfo, tree, false, data))
      call_data_dissector(subtvb, pinfo, tree);

  return tvb_captured_length(tvb);
}


static int
dissect_neighbor_report(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data);

static int
dissect_anqp_info(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset,
                  bool request, int idx)
{
  uint16_t    id, len;
  uint32_t    oui;
  proto_item *item, *item_len;
  tvbuff_t *vendor_tvb;
  anqp_info_dissector_data_t anqp_info;

  item = proto_tree_add_item(tree, hf_ieee80211_ff_anqp_info_id,
                             tvb, offset, 2, ENC_LITTLE_ENDIAN);
  id = tvb_get_letohs(tvb, offset);
  if (id != ANQP_INFO_ANQP_VENDOR_SPECIFIC_LIST) {
    if (idx == 0) {
      proto_item_append_text(tree, " - %s",
                             val_to_str_ext(id, &anqp_info_id_vals_ext, "Unknown (%u)"));
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s",
                      val_to_str_ext(id, &anqp_info_id_vals_ext, "Unknown (%u)"));
    } else if (idx == 1) {
      proto_item_append_text(tree, ", ..");
      col_append_str(pinfo->cinfo, COL_INFO, ", ..");
    }
  }
  tree = proto_item_add_subtree(item, ett_gas_anqp);
  offset += 2;
  item_len = proto_tree_add_item(tree, hf_ieee80211_ff_anqp_info_length,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  len = tvb_get_letohs(tvb, offset);
  offset += 2;
  if (tvb_reported_length_remaining(tvb, offset) < len) {
    expert_add_info(pinfo, tree, &ei_ieee80211_ff_anqp_info_length);
    return 4 + len;
  }
  switch (id)
  {
  case ANQP_INFO_ANQP_QUERY_LIST:
    dissect_anqp_query_list(tree, tvb, pinfo, offset, offset + len);
    break;
  case ANQP_INFO_ANQP_CAPAB_LIST:
    dissect_anqp_capab_list(tree, tvb, pinfo, offset, offset + len);
    break;
  case ANQP_INFO_VENUE_NAME_INFO:
    dissect_venue_name_info(tree, tvb, pinfo, offset, offset + len);
    break;
  case ANQP_INFO_NETWORK_AUTH_TYPE_INFO:
    dissect_network_auth_type(tree, tvb, offset, offset + len);
    break;
  case ANQP_INFO_ROAMING_CONSORTIUM_LIST:
    dissect_roaming_consortium_list(tree, tvb, pinfo, offset, offset + len);
    break;
  case ANQP_INFO_IP_ADDR_TYPE_AVAILABILITY_INFO:
    dissect_ip_addr_type_availability_info(tree, tvb, offset);
    break;
  case ANQP_INFO_NAI_REALM_LIST:
    dissect_nai_realm_list(tree, tvb, pinfo, offset, offset + len);
    break;
  case ANQP_INFO_3GPP_CELLULAR_NETWORK_INFO:
    dissect_3gpp_cellular_network_info(tree, tvb, pinfo, offset);
    break;
  case ANQP_INFO_DOMAIN_NAME_LIST:
    dissect_domain_name_list(tree, tvb, offset, offset + len);
    break;
  case ANQP_INFO_NEIGHBOR_REPORT:
    {
      tvbuff_t *report_tvb;
      ieee80211_tagged_field_data_t field_data;

      report_tvb = tvb_new_subset_length(tvb, offset, len);
      field_data.item_tag = item;
      field_data.item_tag_length = item_len;
      dissect_neighbor_report(report_tvb, pinfo, tree, &field_data);
    }
    break;
  case ANQP_INFO_ANQP_VENDOR_SPECIFIC_LIST:
    proto_tree_add_item_ret_uint(tree, hf_ieee80211_tag_oui, tvb, offset, 3, ENC_BIG_ENDIAN, &oui);
    offset += 3;
    vendor_tvb = tvb_new_subset_length(tvb, offset, len - 3);

    anqp_info.request = request;
    anqp_info.idx = idx;
    if (!dissector_try_uint_new(vendor_specific_anqp_info_table, oui, vendor_tvb, pinfo, tree, false, &anqp_info))
    {
      proto_tree_add_item(tree, hf_ieee80211_ff_anqp_info, tvb, offset, len, ENC_NA);
    }
    break;
  case ANQP_INFO_VENUE_URL:
    dissect_anqp_venue_url(tree, tvb, offset, offset + len);
    break;
  case ANQP_INFO_ADVICE_OF_CHARGE:
    dissect_hs20_anqp_advice_of_charge(tree, tvb, offset, offset + len);
    break;
  case ANQP_INFO_NETWORK_AUTH_TYPE_TIMESTAMP:
    dissect_anqp_network_auth_type_timestamp(tree, tvb, offset, offset + len);
    break;
  default:
    proto_tree_add_item(tree, hf_ieee80211_ff_anqp_info,
                        tvb, offset, len, ENC_NA);
    break;
  }

  return 4 + len;
}

static void
dissect_anqp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset, bool request)
{
  int idx = 0;

  proto_item_append_text(tree, ": ANQP ");
  proto_item_append_text(tree, request ? "Request" : "Response");
  if (tvb_reported_length_remaining(tvb, offset) < 4) {
    expert_add_info_format(pinfo, tree, &ei_ieee80211_not_enough_room_for_anqp_header,
                           "Not enough room for ANQP header");
    return;
  }
  col_append_fstr(pinfo->cinfo, COL_INFO, ", ANQP %s",
                  request ? "Req" : "Resp");
  while (tvb_reported_length_remaining(tvb, offset) > 0) {
    offset += dissect_anqp_info(tree, tvb, pinfo, offset, request, idx);
    idx += 1;
  }
}

static unsigned
dissect_gas_initial_request(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset,
                            unsigned type, unsigned subtype)
{
  uint16_t    req_len;
  int         start = offset;
  proto_item *item;
  proto_tree *query;

  /* Query Request Length (2 octets) */
  req_len = tvb_get_letohs(tvb, offset);

  query = proto_tree_add_subtree(tree, tvb, offset, 2 + req_len, ett_gas_query, &item, "Query Request");
  if (tvb_reported_length_remaining(tvb, offset) < 2 + req_len) {
    expert_add_info(pinfo, item, &ei_ieee80211_ff_query_request_length);
    return tvb_reported_length_remaining(tvb, offset);
  }

  proto_tree_add_item(query, hf_ieee80211_ff_query_request_length,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;
  /*
   * Query Request (GAS query; formatted per protocol specified in the
   * Advertisement Protocol IE)
   */
  switch (type) {
  case ADV_PROTO_ID_ANQP:
    dissect_anqp(query, tvb, pinfo, offset, true);
    break;
  case ADV_PROTO_ID_VS:
    if (subtype == ((DPP_CONFIGURATION_PROTOCOL << 8) | WFA_SUBTYPE_DPP)) {
       col_append_fstr(pinfo->cinfo, COL_INFO, ", DPP - %s",
                       val_to_str(subtype >> 8, dpp_subtype_vals, "Unknown (%u)"));
      dissect_wifi_dpp_config_proto(pinfo, query, tvb, offset);
    }
    break;
  default:
    proto_tree_add_item(query, hf_ieee80211_ff_query_request,
                        tvb, offset, req_len, ENC_NA);
  }
  offset += req_len;

  return offset - start;
}

static unsigned
dissect_gas_initial_response(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset,
                             unsigned type, unsigned subtype)
{
  uint16_t    resp_len;
  int         start = offset;
  proto_item *item;
  proto_tree *query;

  /* Query Response Length (2 octets) */
  resp_len = tvb_get_letohs(tvb, offset);

  query = proto_tree_add_subtree(tree, tvb, offset, 2 + resp_len,
                             ett_gas_query, &item, "Query Response");
  if (tvb_reported_length_remaining(tvb, offset) < 2 + resp_len) {
    expert_add_info(pinfo, item, &ei_ieee80211_ff_query_response_length);
    return tvb_reported_length_remaining(tvb, offset);
  }

  proto_tree_add_item(query, hf_ieee80211_ff_query_response_length,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;
  /* Query Response (optional) */
  if (resp_len) {
    switch (type) {
    case ADV_PROTO_ID_ANQP:
      dissect_anqp(query, tvb, pinfo, offset, false);
      break;
    case ADV_PROTO_ID_VS:
      if (subtype == ((DPP_CONFIGURATION_PROTOCOL << 8) | WFA_SUBTYPE_DPP)) {
         col_append_fstr(pinfo->cinfo, COL_INFO, ", DPP - %s",
                         val_to_str(subtype >> 8, dpp_subtype_vals, "Unknown (%u)"));
        dissect_wifi_dpp_config_proto(pinfo, query, tvb, offset);
      }
      break;
    default:
      proto_tree_add_item(query, hf_ieee80211_ff_query_response,
                          tvb, offset, resp_len, ENC_NA);
    }
    offset += resp_len;
  }

  return offset - start;
}

static reassembly_table gas_reassembly_table;

static int ett_gas_resp_fragment;
static int ett_gas_resp_fragments;

static int hf_ieee80211_gas_resp_fragments;
static int hf_ieee80211_gas_resp_fragment;
static int hf_ieee80211_gas_resp_fragment_overlap;
static int hf_ieee80211_gas_resp_fragment_overlap_conflict;
static int hf_ieee80211_gas_resp_fragment_multiple_tails;
static int hf_ieee80211_gas_resp_fragment_too_long_fragment;
static int hf_ieee80211_gas_resp_fragment_error;
static int hf_ieee80211_gas_resp_fragment_count;
static int hf_ieee80211_gas_resp_reassembled_in;
static int hf_ieee80211_gas_resp_reassembled_length;

static const fragment_items gas_resp_frag_items = {
  &ett_gas_resp_fragment,
  &ett_gas_resp_fragments,
  &hf_ieee80211_gas_resp_fragments,
  &hf_ieee80211_gas_resp_fragment,
  &hf_ieee80211_gas_resp_fragment_overlap,
  &hf_ieee80211_gas_resp_fragment_overlap_conflict,
  &hf_ieee80211_gas_resp_fragment_multiple_tails,
  &hf_ieee80211_gas_resp_fragment_too_long_fragment,
  &hf_ieee80211_gas_resp_fragment_error,
  &hf_ieee80211_gas_resp_fragment_count,
  &hf_ieee80211_gas_resp_reassembled_in,
  &hf_ieee80211_gas_resp_reassembled_length,
  /* Reassembled data field */
  NULL,
  "GAS Response fragments"
};

static unsigned
dissect_gas_comeback_response(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset,
                              unsigned type, unsigned subtype _U_, uint8_t frag, bool more,
                              uint8_t dialog_token)
{
  uint16_t    resp_len;
  int         start = offset;
  proto_item *item;
  proto_tree *query;

  /* Query Response Length (2 octets) */
  resp_len = tvb_get_letohs(tvb, offset);

  query = proto_tree_add_subtree(tree, tvb, offset, 2 + resp_len,
                             ett_gas_query, &item, "Query Response");
  if (tvb_reported_length_remaining(tvb, offset) < 2 + resp_len) {
    expert_add_info(pinfo, item, &ei_ieee80211_ff_query_response_length);
    return tvb_reported_length_remaining(tvb, offset);
  }

  proto_tree_add_item(query, hf_ieee80211_ff_query_response_length,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;
  /* Query Response (optional) */
  if (resp_len) {
    if (type == ADV_PROTO_ID_ANQP && (frag == 0) && !more)
      dissect_anqp(query, tvb, pinfo, offset, false);
    else {
      fragment_head *frag_msg;
      bool save_fragmented;
      tvbuff_t *new_tvb;

      save_fragmented = pinfo->fragmented;
      pinfo->fragmented = true;
      frag_msg = fragment_add_seq_check(&gas_reassembly_table, tvb, offset,
                                        pinfo, dialog_token, NULL,
                                        frag, resp_len, more);
      new_tvb = process_reassembled_data(tvb, offset, pinfo,
                                         "Reassembled GAS Query Response",
                                         frag_msg, &gas_resp_frag_items,
                                         NULL, tree);
      if (new_tvb) {
        switch (type) {
        case ADV_PROTO_ID_ANQP:
          dissect_anqp(query, new_tvb, pinfo, 0, false);
          break;
        case ADV_PROTO_ID_VS:
          if (subtype == ((DPP_CONFIGURATION_PROTOCOL << 8) |
                           WFA_SUBTYPE_DPP)) {
            col_append_fstr(pinfo->cinfo, COL_INFO, ", DPP - %s",
                            val_to_str(subtype >> 8, dpp_subtype_vals,
                                       "Unknown (%u)"));
            dissect_wifi_dpp_config_proto(pinfo, query, new_tvb, 0);
          } else {
            proto_tree_add_item(query, hf_ieee80211_ff_query_response,
                                new_tvb, 0,
                                tvb_reported_length_remaining(new_tvb, 0),
                                ENC_NA);
          }
          break;
        default:
          proto_tree_add_item(query, hf_ieee80211_ff_query_response,
                              new_tvb, 0,
                              tvb_reported_length_remaining(new_tvb, 0),
                              ENC_NA);
        }
      }

      /* The old tvb cannot be used anymore */
      ieee80211_tvb_invalid = true;

      pinfo->fragmented = save_fragmented;
    }
    offset += resp_len;
  }

  return offset - start;
}

/* ************************************************************************* */
/*              Dissect and add fixed mgmt fields to protocol tree           */
/* ************************************************************************* */

static uint64_t last_timestamp;

static unsigned
add_ff_timestamp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  last_timestamp = tvb_get_letoh64(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_ff_timestamp, tvb, offset, 8,
                      ENC_LITTLE_ENDIAN);
  return 8;
}

static unsigned
add_ff_beacon_interval(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_beacon_interval, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  col_append_fstr(pinfo->cinfo, COL_INFO, ", BI=%d",
                  tvb_get_letohs(tvb, offset));
  return 2;
}

static unsigned
add_ff_dmg_params(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset);

static unsigned
add_ff_cap_info(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  static int * const ieee80211_cap_info_fields[] = {
    &hf_ieee80211_ff_cf_ess,
    &hf_ieee80211_ff_cf_ibss,
    &hf_ieee80211_ff_cf_reserved1,
    &hf_ieee80211_ff_cf_reserved2,
    &hf_ieee80211_ff_cf_privacy,
    &hf_ieee80211_ff_cf_preamble,
    &hf_ieee80211_ff_cf_critical_update_flag,
    &hf_ieee80211_ff_cf_nontran_bss_critical_update_flag,
    &hf_ieee80211_ff_cf_spec_man,
    &hf_ieee80211_ff_cf_qos,
    &hf_ieee80211_ff_cf_short_slot_time,
    &hf_ieee80211_ff_cf_apsd,
    &hf_ieee80211_ff_cf_radio_measurement,
    &hf_ieee80211_ff_cf_epd,
    &hf_ieee80211_ff_cf_reserved5,
    &hf_ieee80211_ff_cf_reserved6,
    NULL
  };

  /* The capability information includes DMG parameters whenever it is transmitted by
     a DMG STA/AP (802.11ad-2012, 8.4.1.4) */

  bool isDMG = GPOINTER_TO_INT(p_get_proto_data(wmem_file_scope(), pinfo, proto_wlan, IS_DMG_KEY));

  if (isDMG) {
    proto_item *cap_item;
    proto_tree *cap_tree;
    cap_item = proto_tree_add_item(tree, hf_ieee80211_ff_capture, tvb, offset, 2,
                                   ENC_LITTLE_ENDIAN);
    cap_tree = proto_item_add_subtree(cap_item, ett_cap_tree);
    add_ff_dmg_params(cap_tree, tvb, pinfo, offset);
  } else {
    /*
     * We can only interpret the ESS and IBSS fields to be an AP if the
     * frame is a BEACON or PROBE_RESPONSE
     */
    uint32_t l_frame_type = GPOINTER_TO_UINT(p_get_proto_data(wmem_file_scope(),
                                                         pinfo, proto_wlan,
                                                         FRAME_TYPE_KEY));
    if (((tvb_get_letohs(tvb, offset) & 0x0003) == 0x1 &&
        (l_frame_type == MGT_BEACON || l_frame_type == MGT_PROBE_RESP)) ||
        l_frame_type == MGT_ASSOC_RESP || l_frame_type == MGT_REASSOC_RESP) {
      p_add_proto_data(wmem_file_scope(), pinfo, proto_wlan, IS_AP_KEY, GINT_TO_POINTER(true));
    }

    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                      hf_ieee80211_ff_capture,
                                      ett_cap_tree, ieee80211_cap_info_fields,
                                      ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  }
  return 2;
}

static unsigned
add_ff_auth_alg(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_auth_alg, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_auth_trans_seq(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_auth_seq, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_current_ap_addr(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_current_ap, tvb, offset, 6,
                      ENC_NA);
  return 6;
}

static unsigned
add_ff_listen_ival(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_listen_ival, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_reason_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_reason, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_assoc_id(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_assoc_id, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_status_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_status_code, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_category_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_category_code, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_action_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_action_code, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_trigger(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  uint8_t trigger = tvb_get_uint8(tvb, offset);
  col_append_fstr(pinfo->cinfo, COL_INFO, ", Trigger=%d (%s)", trigger,
                  val_to_str_const(trigger, ftm_trigger_vals, "Unknown"));
  proto_tree_add_item(tree, hf_ieee80211_ff_trigger, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_ftm_tod(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_ftm_tod, tvb, offset, 6,
                      ENC_LITTLE_ENDIAN);
  return 6;
}

static unsigned
add_ff_ftm_toa(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_ftm_toa, tvb, offset, 6,
                      ENC_LITTLE_ENDIAN);
  return 6;
}

static unsigned
add_ff_ftm_tod_err(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_ftm_tod_err, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_ftm_toa_err(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_ftm_toa_err, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_ftm_tod_err1(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  static int * const fields[] = {
    &hf_ieee80211_ff_ftm_max_tod_error_exponent,
    &hf_ieee80211_ff_ftm_tod_err_reserved,
    &hf_ieee80211_ff_ftm_tod_not_continuous,
    NULL
  };

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ff_ftm_tod_err1,
                                    ett_ff_ftm_tod_err1, fields,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  return 1;
}

static unsigned
add_ff_ftm_toa_err1(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  static int * const fields[] = {
    &hf_ieee80211_ff_ftm_max_toa_error_exponent,
    &hf_ieee80211_ff_ftm_toa_err_reserved,
    &hf_ieee80211_ff_ftm_invalid_measurement,
    &hf_ieee80211_ff_ftm_toa_type,
    NULL
  };

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ff_ftm_toa_err1,
                                    ett_ff_ftm_toa_err1, fields,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  return 1;
}

static unsigned
add_ff_ftm_cfo_parameter(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_ftm_cfo, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_ftm_r2i_ndp_tx_power(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_ftm_r2i_ndp_tx_power, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_ftm_i2r_ndp_target_rssi(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_ftm_i2r_ndp_target_rssi, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static int
dissect_ftm_params(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  int len = 0;
  proto_tree *ftm_param_tree = tree;
  static int * const ieee80211_ftm_params_fields1[] = {
    &hf_ieee80211_ff_ftm_param_status_indication,
    &hf_ieee80211_ff_ftm_param_value,
    &hf_ieee80211_ff_ftm_param_reserved1,
    &hf_ieee80211_ff_ftm_param_burst_exponent,
    &hf_ieee80211_ff_ftm_param_burst_duration,
    NULL};

  static int * const ieee80211_ftm_params_fields2[] = {
    &hf_ieee80211_ff_ftm_param_min_delta_ftm,
    &hf_ieee80211_ff_ftm_param_partial_tsf_timer,
    &hf_ieee80211_ff_ftm_param_partial_tsf_no_pref,
    &hf_ieee80211_ff_ftm_param_asap_capable,
    &hf_ieee80211_ff_ftm_param_asap,
    &hf_ieee80211_ff_ftm_param_ftm_per_burst,
    NULL};

  static int * const ieee80211_ftm_params_fields3[] = {
    &hf_ieee80211_ff_ftm_param_reserved2,
    &hf_ieee80211_ff_ftm_param_format_and_bw,
    &hf_ieee80211_ff_ftm_param_burst_period,
    NULL};

  len = tvb_captured_length(tvb);
  if (len != 9)
      return 0;

  proto_tree_add_bitmask_with_flags(ftm_param_tree, tvb, offset, hf_ieee80211_ff_ftm_param_delim1,
                                    ett_ff_ftm_param_delim1, ieee80211_ftm_params_fields1,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;
  proto_tree_add_bitmask_with_flags(ftm_param_tree, tvb, offset, hf_ieee80211_ff_ftm_param_delim2,
                                    ett_ff_ftm_param_delim2, ieee80211_ftm_params_fields2,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 4;
  proto_tree_add_bitmask_with_flags(ftm_param_tree, tvb, offset, hf_ieee80211_ff_ftm_param_delim3,
                                    ett_ff_ftm_param_delim3, ieee80211_ftm_params_fields3,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 3;

  return offset;
}

static unsigned
add_ff_dialog_token(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  uint8_t value = tvb_get_uint8(tvb, offset);
  col_append_fstr(pinfo->cinfo, COL_INFO, ", Dialog Token=%d", value);
  proto_tree_add_item(tree, hf_ieee80211_ff_dialog_token, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_followup_dialog_token(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_followup_dialog_token, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_wme_action_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_wme_action_code, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_wme_status_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_wme_status_code, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_qos_action_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_qos_action_code, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_block_ack_action_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_ba_action, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_block_ack_param(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_bitmask(tree, tvb, offset, hf_ieee80211_ff_block_ack_params,
                         ett_ff_ba_param_tree,
                         ieee80211_ff_block_ack_params_fields,
                         ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_block_ack_timeout(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_block_ack_timeout, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_block_ack_ssc(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_bitmask(tree, tvb, offset, hf_ieee80211_ff_block_ack_ssc,
                         ett_ff_ba_ssc_tree, ieee80211_ff_block_ack_ssc_fields,
                         ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_qos_ts_info(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_bitmask(tree, tvb, offset, hf_ieee80211_tsinfo,
                         ett_tsinfo_tree, ieee80211_tsinfo_fields,
                         ENC_LITTLE_ENDIAN);
  return 3;
}

static unsigned
add_ff_mesh_action(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_mesh_action, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_multihop_action(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_multihop_action, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_mesh_control(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  int    start = offset;
  uint8_t flags;

  proto_tree_add_item(tree, hf_ieee80211_ff_mesh_flags, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  flags = tvb_get_uint8(tvb, offset);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_ff_mesh_ttl, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_ff_mesh_sequence, tvb, offset, 4,
                      ENC_LITTLE_ENDIAN);
  offset += 4;

  switch (flags & 0x03) {
  case 1:
    proto_tree_add_item(tree, hf_ieee80211_ff_mesh_addr4, tvb, offset, 6,
                        ENC_NA);
    offset += 6;
    break;
  case 2:
    proto_tree_add_item(tree, hf_ieee80211_ff_mesh_addr5, tvb, offset, 6,
                        ENC_NA);
    offset += 6;
    proto_tree_add_item(tree, hf_ieee80211_ff_mesh_addr6, tvb, offset, 6,
                        ENC_NA);
    offset += 6;
    break;
  case 3:
    proto_item_append_text(tree, " Unknown Address Extension Mode");
    break;
  default:
    /* no default action */
    break;
  }

  return offset - start;
}

static unsigned
add_ff_selfprot_action(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_selfprot_action, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_dls_action_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_dls_action_code, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_dst_mac_addr(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_dst_mac_addr, tvb, offset, 6,
                      ENC_NA);
  return 6;
}

static unsigned
add_ff_src_mac_addr(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_src_mac_addr, tvb, offset, 6,
                      ENC_NA);
  return 6;
}

static unsigned
add_ff_req_ap_addr(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_req_ap_addr, tvb, offset, 6,
                      ENC_NA);
  return 6;
}

static unsigned
add_ff_res_ap_addr(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_res_ap_addr, tvb, offset, 6,
                      ENC_NA);
  return 6;
}

static unsigned
add_ff_check_beacon(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_check_beacon, tvb, offset, 1,
                      ENC_NA);
  return 1;
}

static unsigned
add_ff_tod(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_tod, tvb, offset, 4,
                     ENC_NA);
  return 4;
}

static unsigned
add_ff_toa(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_toa, tvb, offset, 4,
                      ENC_NA);
  return 4;
}

static unsigned
add_ff_max_tod_err(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_max_tod_err, tvb, offset, 1,
                      ENC_NA);
  return 1;
}

static unsigned
add_ff_max_toa_err(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_max_toa_err, tvb, offset, 1,
                      ENC_NA);
  return 1;
}

static unsigned
add_ff_dls_timeout(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_dls_timeout, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_delba_param_set(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_bitmask(tree, tvb, offset, hf_ieee80211_ff_delba_param,
                         ett_ff_ba_param_tree, ieee80211_ff_delba_param_fields,
                         ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_max_reg_pwr(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_max_reg_pwr, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_measurement_pilot_int(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_measurement_pilot_int, tvb, offset,
                      1, ENC_NA);
  return 1;
}

static unsigned
add_ff_country_str(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_country_str, tvb, offset, 3,
                      ENC_ASCII);
  return 3;
}

static unsigned
add_ff_max_tx_pwr(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_max_tx_pwr, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_tx_pwr_used(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_tx_pwr_used, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_transceiver_noise_floor(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_transceiver_noise_floor, tvb,
                      offset, 1, ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_channel_width(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_channel_width, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

/* QoS Info:  802.11-2012 8.4.1.17 */
static unsigned
add_ff_qos_info_ap(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  /* From AP so decode as AP: Figure 8-51-QoS Info field when sent by a AP */
  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ff_qos_info_ap,
                                    ett_ff_qos_info, ieee80211_ff_qos_info_ap_fields,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  return 1;
}


/* QoS Info:  802.11-2012 8.4.1.17 */
static unsigned
add_ff_qos_info_sta(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  /* To AP so decode as STA: Figure 8-52-QoS Info field when set by a non-AP STA */
  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ff_qos_info_sta,
                                    ett_ff_qos_info, ieee80211_ff_qos_info_sta_fields,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  return 1;
}

static unsigned
add_ff_sm_pwr_cntrl(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_bitmask(tree, tvb, offset, hf_ieee80211_ff_sm_pwr_save,
                         ett_ff_sm_pwr_save, ieee80211_ff_sw_pwr_save_fields,
                         ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_pco_phase_cntrl(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_pco_phase_cntrl, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_psmp_param_set(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_bitmask(tree, tvb, offset, hf_ieee80211_ff_psmp_param_set,
                         ett_ff_psmp_param_set,
                         ieee80211_ff_psmp_param_set_fields,
                         ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_mimo_cntrl(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_item *mimo_item;
  proto_tree *mimo_tree;
  static int * const ieee80211_mimo_fields[] = {
    &hf_ieee80211_ff_mimo_cntrl_nc_index,
    &hf_ieee80211_ff_mimo_cntrl_nr_index,
    &hf_ieee80211_ff_mimo_cntrl_channel_width,
    &hf_ieee80211_ff_mimo_cntrl_grouping,
    &hf_ieee80211_ff_mimo_cntrl_coefficient_size,
    &hf_ieee80211_ff_mimo_cntrl_codebook_info,
    &hf_ieee80211_ff_mimo_cntrl_remaining_matrix_segment,
    &hf_ieee80211_ff_mimo_cntrl_reserved,
    NULL
  };

  mimo_item = proto_tree_add_item(tree, hf_ieee80211_ff_mimo_cntrl, tvb,
                                  offset, 6, ENC_NA);
  mimo_tree = proto_item_add_subtree(mimo_item, ett_ff_mimo_cntrl);

  proto_tree_add_bitmask_list(mimo_tree, tvb, offset, 2, ieee80211_mimo_fields, ENC_LITTLE_ENDIAN);
  offset += 2;
  proto_tree_add_item(mimo_tree, hf_ieee80211_ff_mimo_cntrl_sounding_timestamp,
                      tvb, offset, 4, ENC_LITTLE_ENDIAN);

  return 6;
}

static unsigned
add_ff_ant_selection(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_bitmask(tree, tvb, offset, hf_ieee80211_ff_ant_selection,
                         ett_ff_ant_sel, ieee80211_ff_ant_selection_fields,
                         ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_extended_channel_switch_announcement(proto_tree *tree, tvbuff_t *tvb,
                                            packet_info *pinfo _U_, int offset)
{
  proto_tree_add_bitmask(tree, tvb, offset,
                         hf_ieee80211_ff_ext_channel_switch_announcement,
                         ett_ff_chan_switch_announce,
                         ieee80211_ff_ext_channel_switch_announcement_fields,
                         ENC_LITTLE_ENDIAN);
  return 4;
}

static unsigned
add_ff_ht_information(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_bitmask(tree, tvb, offset, hf_ieee80211_ff_ht_info,
                         ett_ff_ht_info, ieee80211_ff_ht_info_fields,
                         ENC_LITTLE_ENDIAN);
  return 1;
}
static unsigned
add_ff_lmr_report(proto_tree *tree, tvbuff_t *tvb,
                  packet_info *pinfo _U_, int offset)
{
  offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
  offset += add_ff_ftm_tod(tree, tvb, pinfo, offset);
  offset += add_ff_ftm_toa(tree, tvb, pinfo, offset);
  offset += add_ff_ftm_tod_err1(tree, tvb, pinfo, offset);
  offset += add_ff_ftm_toa_err1(tree, tvb, pinfo, offset);
  offset += add_ff_ftm_cfo_parameter(tree, tvb, pinfo, offset);
  offset += add_ff_ftm_r2i_ndp_tx_power(tree, tvb, pinfo, offset);
  offset += add_ff_ftm_i2r_ndp_target_rssi(tree, tvb, pinfo, offset);
  /* Secure LTF parameters (optional) */
  /* AOA feedback (optional) */
  return offset;
}

static unsigned
add_ff_ftm_request(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  return add_ff_trigger(tree, tvb, pinfo, offset);
}

static unsigned
add_ff_ftm(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  unsigned start = offset;
  uint8_t dialog_token = tvb_get_uint8(tvb, offset);
  offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
  if (dialog_token == 0) {
    col_append_str(pinfo->cinfo, COL_INFO, " (Termination)");
  }
  offset += add_ff_followup_dialog_token(tree, tvb, pinfo, offset);
  offset += add_ff_ftm_tod(tree, tvb, pinfo, offset);
  offset += add_ff_ftm_toa(tree, tvb, pinfo, offset);
  offset += add_ff_ftm_tod_err(tree, tvb, pinfo, offset);
  offset += add_ff_ftm_toa_err(tree, tvb, pinfo, offset);
  return offset - start;
}

static unsigned
add_ff_ht_action_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_ht_action, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_dmg_action_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_dmg_action_code, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_dmg_pwr_mgmt(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_dmg_pwr_mgmt, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_psmp_sta_info(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_item *psmp_item;
  proto_tree *psmp_tree;

  psmp_item = proto_tree_add_item(tree, hf_ieee80211_ff_psmp_sta_info, tvb,
                                  offset, 8, ENC_LITTLE_ENDIAN);
  psmp_tree = proto_item_add_subtree(psmp_item, ett_ff_psmp_sta_info);

  proto_tree_add_item(psmp_item, hf_ieee80211_ff_psmp_sta_info_type, tvb,
                      offset, 4, ENC_LITTLE_ENDIAN);

  switch (tvb_get_letohl(tvb, offset) & PSMP_STA_INFO_FLAG_TYPE) {
  case PSMP_STA_INFO_BROADCAST:
    proto_tree_add_item(psmp_tree,
                        hf_ieee80211_ff_psmp_sta_info_dtt_start_offset, tvb,
                        offset, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(psmp_tree, hf_ieee80211_ff_psmp_sta_info_dtt_duration,
                        tvb, offset, 4, ENC_LITTLE_ENDIAN);
    /* Missing 64 bit bitmask... */
    proto_tree_add_uint64(psmp_tree,
                          hf_ieee80211_ff_psmp_sta_info_reserved_large,
                          tvb, offset, 8,
                          (tvb_get_letoh64(tvb, offset) &
                           UINT64_C(0xFFFFFFFFFFE00000)) >> 21);
    break;
  case PSMP_STA_INFO_MULTICAST:
    proto_tree_add_item(psmp_tree,
                        hf_ieee80211_ff_psmp_sta_info_dtt_start_offset, tvb,
                        offset, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(psmp_tree, hf_ieee80211_ff_psmp_sta_info_dtt_duration,
                        tvb, offset, 4, ENC_LITTLE_ENDIAN);
    /* Missing 64 bit bitmask... */
    proto_tree_add_uint64(psmp_tree,
                          hf_ieee80211_ff_psmp_sta_info_psmp_multicast_id,
                          tvb, offset, 6,
                          (tvb_get_letoh64(tvb, offset) &
                           UINT64_C(0xFFFFFFFFFFE00000)) >> 21);
    break;
  case PSMP_STA_INFO_INDIVIDUALLY_ADDRESSED:
    proto_tree_add_item(psmp_tree,
                        hf_ieee80211_ff_psmp_sta_info_dtt_start_offset, tvb,
                        offset, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(psmp_tree, hf_ieee80211_ff_psmp_sta_info_dtt_duration,
                        tvb, offset, 4, ENC_LITTLE_ENDIAN);
    offset += 2;
    proto_tree_add_item(psmp_tree, hf_ieee80211_ff_psmp_sta_info_sta_id, tvb,
                        offset, 4, ENC_LITTLE_ENDIAN);
    offset += 2;

    proto_tree_add_item(psmp_tree,
                        hf_ieee80211_ff_psmp_sta_info_utt_start_offset,
                        tvb, offset, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(psmp_tree, hf_ieee80211_ff_psmp_sta_info_utt_duration,
                        tvb, offset, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(psmp_tree,
                        hf_ieee80211_ff_psmp_sta_info_reserved_small, tvb,
                        offset, 4, ENC_LITTLE_ENDIAN);
    break;
  }

  return 8;
}

static unsigned
add_ff_schedule_info(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  static int * const ieee80211_schedule_info_fields1[] = {
    &hf_ieee80211_sched_info_agg,
    NULL
  };
  static int * const ieee80211_schedule_info_fields2[] = {
    &hf_ieee80211_sched_info_agg,
    &hf_ieee80211_sched_info_tsid,
    &hf_ieee80211_sched_info_dir,
    NULL
  };

  if (tvb_get_letohs(tvb, offset) & 0x0001) {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_sched_info,
                                    ett_sched_tree, ieee80211_schedule_info_fields2,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  } else {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_sched_info,
                                    ett_sched_tree, ieee80211_schedule_info_fields1,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  }

  return 2;
}

static unsigned
add_ff_pa_action_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_public_action, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_ppa_action_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_protected_public_action, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_ft_action_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_ft_action_code, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_sta_address(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_sta_address, tvb, offset, 6,
                      ENC_NA);
  return 6;
}

static unsigned
add_ff_target_ap_address(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_target_ap_address, tvb, offset, 6,
                      ENC_NA);
  return 6;
}

static unsigned
add_ff_gas_comeback_delay(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_gas_comeback_delay, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_gas_fragment_id(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_gas_fragment_id, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tree, hf_ieee80211_ff_more_gas_fragments, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_sa_query_action_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_sa_query_action_code, tvb, offset,
                      1, ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_transaction_id(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_transaction_id, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_tdls_action_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  uint8_t code;
  code = tvb_get_uint8(tvb, offset);
  col_set_str(pinfo->cinfo, COL_INFO,
              val_to_str_ext_const(code, &tdls_action_codes_ext,
                                   "Unknown TDLS Action"));
  proto_tree_add_item(tree, hf_ieee80211_ff_tdls_action_code, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_target_channel(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_target_channel, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_operating_class(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_operating_class, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_wnm_action_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  uint8_t code;

  code = tvb_get_uint8(tvb, offset);
  col_set_str(pinfo->cinfo, COL_INFO,
              val_to_str_ext_const(code, &wnm_action_codes_ext, "Unknown WNM Action"));
  proto_tree_add_item(tree, hf_ieee80211_ff_wnm_action_code, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_unprotected_wnm_action_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  uint8_t code;

  code = tvb_get_uint8(tvb, offset);
  col_set_str(pinfo->cinfo, COL_INFO,
              val_to_str_ext_const(code, &unprotected_wnm_action_codes_ext, "Unknown Unprotected WNM Action"));
  proto_tree_add_item(tree, hf_ieee80211_ff_unprotected_wnm_action_code, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_unprotected_dmg_action_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_unprotected_dmg_action_code, tvb, offset, 1, ENC_NA);
  return 1;
}

static unsigned
add_ff_key_data_length(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_key_data_length, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_wnm_notification_type(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_wnm_notification_type,
                      tvb, offset, 1, ENC_NA);
  return 1;
}

/* Action frame: Radio Measurement actions */
static unsigned
add_ff_rm_action_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_rm_action_code, tvb, offset, 1, ENC_NA);
  return 1;
}

static unsigned
add_ff_rm_dialog_token(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_rm_dialog_token, tvb, offset, 1, ENC_NA);
  return 1;
}

/* Radio Measurement Request frame, Action fields */
static unsigned
add_ff_rm_repetitions(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  /* Note: 65535 means repeated until cancelled or superseded */
  proto_tree_add_item(tree, hf_ieee80211_ff_rm_repetitions, tvb, offset, 2,
                      ENC_BIG_ENDIAN);
  return 2;
}

/* Link Measurement Request frame, Action fields*/
static unsigned
add_ff_rm_tx_power(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  /* In dBm, see 8.4.1.20 */
  proto_tree_add_item(tree, hf_ieee80211_ff_rm_tx_power, tvb, offset, 1, ENC_NA);
  return 1;
}

static unsigned
add_ff_rm_max_tx_power(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  /* In dBm, see 8.4.1.19 */
  proto_tree_add_item(tree, hf_ieee80211_ff_rm_max_tx_power, tvb, offset, 1, ENC_NA);
  return 1;
}

/* Link Measurement Report frame, Action fields */
static unsigned
add_ff_rm_tpc_report(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree *tpc_tree;
  proto_item *tpc_item;

  /* 8.4.2.19 TPC Report element */
  /* XXX - The TPC Report element is exactly the same as that dissected
   * by ieee80211_tag_tpc_report(), so some of these fixed fields duplicate
   * tagged fields.
   */
  tpc_item = proto_tree_add_item(tree, hf_ieee80211_ff_tpc, tvb, offset, 4, ENC_NA);
  tpc_tree = proto_item_add_subtree(tpc_item, ett_tpc);
  proto_tree_add_item(tpc_tree, hf_ieee80211_ff_tpc_element_id, tvb, offset, 1, ENC_NA);
  proto_tree_add_item(tpc_tree, hf_ieee80211_ff_tpc_length, tvb, offset + 1, 1, ENC_NA);
  proto_tree_add_item(tpc_tree, hf_ieee80211_ff_tpc_tx_power, tvb, offset + 2, 1, ENC_NA);
  proto_tree_add_item(tpc_tree, hf_ieee80211_ff_tpc_link_margin, tvb, offset + 3, 1, ENC_NA);
  return 4;
}

static unsigned
add_ff_rm_rx_antenna_id(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  /* 8.4.2.42: 0 means unknown, 1-254 is valid, 255 means multiple antennas */
  proto_tree_add_item(tree, hf_ieee80211_ff_rm_rx_antenna_id, tvb, offset, 1, ENC_NA);
  return 1;
}

static unsigned
add_ff_rm_tx_antenna_id(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  /* 8.4.2.42: 0 means unknown, 1-254 is valid, 255 means multiple antennas */
  proto_tree_add_item(tree, hf_ieee80211_ff_rm_tx_antenna_id, tvb, offset, 1, ENC_NA);
  return 1;
}

static unsigned
add_ff_rm_rcpi(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  /* 8.4.2.40: RCPI as specified for certain PHYs */
  proto_tree_add_item(tree, hf_ieee80211_ff_rm_rcpi, tvb, offset, 1, ENC_NA);
  return 1;
}

static unsigned
add_ff_rm_rsni(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  /* 8.4.2.43: RSNI in steps of 0.5 dB, calculated as:
   * RSNI = (10 * log10((RCPI_{power} - ANPI_{power}) / ANPI_{power}) + 20)*2 */
  proto_tree_add_item(tree, hf_ieee80211_ff_rm_rsni, tvb, offset, 1, ENC_NA);
  return 1;
}

static unsigned
add_ff_bss_transition_status_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_bss_transition_status_code, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_bss_termination_delay(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_bss_termination_delay, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_fils_discovery(proto_tree *tree, tvbuff_t *tvb,
                                            packet_info *pinfo _U_, int offset)
{

  uint16_t fc, ssid_length;
  static int * const ieee80211_ff_fils_discovery_frame_control[] = {
    &hf_ieee80211_ff_fils_discovery_frame_control_ssid_length,
    &hf_ieee80211_ff_fils_discovery_frame_control_capability,
    &hf_ieee80211_ff_fils_discovery_frame_control_short_ssid,
    &hf_ieee80211_ff_fils_discovery_frame_control_ap_csn,
    &hf_ieee80211_ff_fils_discovery_frame_control_ano,
    &hf_ieee80211_ff_fils_discovery_frame_control_channel_center_frequency,
    &hf_ieee80211_ff_fils_discovery_frame_control_primary_channel,
    &hf_ieee80211_ff_fils_discovery_frame_control_rsn_info,
    &hf_ieee80211_ff_fils_discovery_frame_control_length,
    &hf_ieee80211_ff_fils_discovery_frame_control_md,
    &hf_ieee80211_ff_fils_discovery_frame_control_reserved,
    NULL
  };

  proto_tree_add_bitmask(tree, tvb, offset,
                         hf_ieee80211_ff_fils_discovery_frame_control,
                         ett_ff_fils_discovery_frame_control,
                         ieee80211_ff_fils_discovery_frame_control,
                         ENC_LITTLE_ENDIAN);
  fc = tvb_get_letohs(tvb, offset);
  offset += 2;

  offset += add_ff_timestamp(tree, tvb, pinfo, offset);

  offset += add_ff_beacon_interval(tree, tvb, pinfo, offset);

  if(fc & PA_FILS_FC_SHORT_SSID) {
     /* Always 4 bytes for Short SSID */
     /* TODO add check of SSID Length */
    proto_tree_add_item(tree, hf_ieee80211_ff_fils_discovery_short_ssid, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    offset += 4;
  } else {
    ssid_length = (fc & PA_FILS_FC_SSID_LENGTH) + 1;
    proto_tree_add_item(tree, hf_ieee80211_ff_fils_discovery_ssid, tvb, offset, ssid_length, ENC_ASCII);
    offset += ssid_length;
  }

  if(fc & PA_FILS_FC_LENGTH){
    proto_tree_add_item(tree, hf_ieee80211_ff_fils_discovery_length, tvb, offset, 1, ENC_NA);
    offset += 1;
  }

  if(fc & PA_FILS_FC_CAPABILITY) {
    proto_tree *fdc_tree;
    proto_item *fdc_item;
    uint32_t fdc;
    fdc_item = proto_tree_add_item_ret_uint(tree, hf_ieee80211_ff_fils_discovery_capability, tvb, offset, 2, ENC_LITTLE_ENDIAN, &fdc);
    fdc_tree = proto_item_add_subtree(fdc_item, ett_ff_fils_discovery_capability);
    proto_tree_add_item(fdc_tree, hf_ieee80211_ff_fils_discovery_capability_ess, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(fdc_tree, hf_ieee80211_ff_fils_discovery_capability_privacy, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(fdc_tree, hf_ieee80211_ff_fils_discovery_capability_bss_operating_channel_width, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(fdc_tree, hf_ieee80211_ff_fils_discovery_capability_max_number_of_spatial_streams, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(fdc_tree, hf_ieee80211_ff_fils_discovery_capability_reserved, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(fdc_tree, hf_ieee80211_ff_fils_discovery_capability_multiple_bssid, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(fdc_tree, hf_ieee80211_ff_fils_discovery_capability_phy_index, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    switch((fdc & 0x1C00) >> 10){
      case 0:
        proto_tree_add_item(fdc_tree, hf_ieee80211_ff_fils_discovery_capability_fils_minimum_rate_dsss, tvb, offset, 2, ENC_LITTLE_ENDIAN);
      break;
      case 1:
        proto_tree_add_item(fdc_tree, hf_ieee80211_ff_fils_discovery_capability_fils_minimum_rate_ofdm, tvb, offset, 2, ENC_LITTLE_ENDIAN);
      break;
      case 2:
      case 3:
        proto_tree_add_item(fdc_tree, hf_ieee80211_ff_fils_discovery_capability_fils_minimum_rate_ht_vht_tvht, tvb, offset, 2, ENC_LITTLE_ENDIAN);
      break;
      case 4:
        proto_tree_add_item(fdc_tree, hf_ieee80211_ff_fils_discovery_capability_fils_minimum_rate_he, tvb, offset, 2, ENC_LITTLE_ENDIAN);
      break;
      default:
        proto_tree_add_item(fdc_tree, hf_ieee80211_ff_fils_discovery_capability_fils_minimum_rate, tvb, offset, 2, ENC_LITTLE_ENDIAN);
      break;
    }
    offset += 2;
  }

  if(fc & PA_FILS_FC_PC) {
    proto_tree_add_item(tree, hf_ieee80211_ff_fils_discovery_operating_class, tvb, offset, 1, ENC_NA);
    offset += 1;
    proto_tree_add_item(tree, hf_ieee80211_ff_fils_discovery_primary_channel, tvb, offset, 1, ENC_NA);
    offset += 1;
  }

  if(fc & PA_FILS_FC_AP_CSN) {
    proto_tree_add_item(tree, hf_ieee80211_ff_fils_discovery_ap_csn, tvb, offset, 1, ENC_NA);
    offset += 1;
  }

  if(fc & PA_FILS_FC_ANO) {
    proto_tree_add_item(tree, hf_ieee80211_ff_fils_discovery_ano, tvb, offset, 1, ENC_NA);
    offset += 1;
  }

  if(fc & PA_FILS_FC_RSN_INFO) {
    /*TODO Dissect RSN info */
    proto_tree_add_item(tree, hf_ieee80211_ff_fils_discovery_rsn_info, tvb, offset, 5, ENC_NA);
    offset += 5;
  }

  if(fc & PA_FILS_FC_CCFS1){
    proto_tree_add_item(tree, hf_ieee80211_ff_fils_discovery_ccfs1, tvb, offset, 1, ENC_NA);
    offset += 1;
  }

  if(fc & PA_FILS_FC_MD) {
    /*TODO Dissect Mobility Domain */
    proto_tree_add_item(tree, hf_ieee80211_ff_fils_discovery_md, tvb, offset, 3, ENC_NA);
    offset += 3;
  }

  return offset;
}


static unsigned
add_ff_action_spectrum_mgmt(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
    switch (tvb_get_uint8(tvb, offset + 1)) {
    case SM_ACTION_MEASUREMENT_REQUEST:
    case SM_ACTION_MEASUREMENT_REPORT:
    case SM_ACTION_TPC_REQUEST:
    case SM_ACTION_TPC_REPORT:
      add_ff_category_code(tree, tvb, pinfo, offset);
      add_ff_action_code(tree, tvb, pinfo, offset + 1);
      add_ff_dialog_token(tree, tvb, pinfo, offset + 2);
      return 3;
    case SM_ACTION_CHAN_SWITCH_ANNC:
    case SM_ACTION_EXT_CHAN_SWITCH_ANNC:
      add_ff_category_code(tree, tvb, pinfo, offset);
      add_ff_action_code(tree, tvb, pinfo, offset + 1);
      return 2;
    default:
      add_ff_category_code(tree, tvb, pinfo, offset);
      add_ff_action_code(tree, tvb, pinfo, offset + 1);
      return 2;
    }
}

static unsigned
add_ff_action_qos(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  switch (tvb_get_uint8(tvb, offset + 1)) {
  case QOS_ACTION_ADDTS_REQUEST:
    add_ff_category_code(tree, tvb, pinfo, offset);
    add_ff_qos_action_code(tree, tvb, pinfo, offset + 1);
    add_ff_dialog_token(tree, tvb, pinfo, offset + 2);
    return 3;
  case QOS_ACTION_ADDTS_RESPONSE:
    add_ff_category_code(tree, tvb, pinfo, offset);
    add_ff_qos_action_code(tree, tvb, pinfo, offset + 1);
    add_ff_dialog_token(tree, tvb, pinfo, offset + 2);
    add_ff_status_code(tree, tvb, pinfo, offset + 3);
    return 5;
  case QOS_ACTION_DELTS:
    add_ff_category_code(tree, tvb, pinfo, offset);
    add_ff_qos_action_code(tree, tvb, pinfo, offset + 1);
    add_ff_qos_ts_info(tree, tvb, pinfo, offset + 2);
    add_ff_reason_code(tree, tvb, pinfo, offset + 5);
    return 7;
  case QOS_ACTION_SCHEDULE:
    add_ff_category_code(tree, tvb, pinfo, offset);
    add_ff_qos_action_code(tree, tvb, pinfo, offset + 1);
    return 2;
  case QOS_ACTION_MAP_CONFIGURE:
    add_ff_category_code(tree, tvb, pinfo, offset);
    add_ff_qos_action_code(tree, tvb, pinfo, offset + 1);
    return 2;
  default:
    add_ff_category_code(tree, tvb, pinfo, offset);
    return 2;
  }
}

static unsigned
add_ff_action_dls(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  switch (tvb_get_uint8(tvb, offset + 1)) {
  case DLS_ACTION_REQUEST:
    add_ff_category_code(tree, tvb, pinfo, offset);
    add_ff_dls_action_code(tree, tvb, pinfo, offset +  1);
    add_ff_dst_mac_addr(tree, tvb, pinfo, offset +  2);
    add_ff_src_mac_addr(tree, tvb, pinfo, offset +  8);
    add_ff_cap_info(tree, tvb, pinfo, offset + 14);
    add_ff_dls_timeout(tree, tvb, pinfo, offset + 16);
    return 18;
  case DLS_ACTION_RESPONSE:
    add_ff_category_code(tree, tvb, pinfo, offset);
    add_ff_dls_action_code(tree, tvb, pinfo, offset +  1);
    add_ff_status_code(tree, tvb, pinfo, offset +  2);
    add_ff_dst_mac_addr(tree, tvb, pinfo, offset +  4);
    add_ff_src_mac_addr(tree, tvb, pinfo, offset + 10);
    if (!hf_ieee80211_ff_status_code) {
      add_ff_cap_info(tree, tvb, pinfo, offset + 16);
    }
    return 16;
  case DLS_ACTION_TEARDOWN:
    add_ff_category_code(tree, tvb, pinfo, offset);
    add_ff_dls_action_code(tree, tvb, pinfo, offset +  1);
    add_ff_dst_mac_addr(tree, tvb, pinfo, offset +  2);
    add_ff_src_mac_addr(tree, tvb, pinfo, offset +  8);
    add_ff_reason_code(tree, tvb, pinfo, offset + 14);
    return 16;
  default:
    add_ff_category_code(tree, tvb, pinfo, offset);
    return 2;
  }
}

static unsigned
add_ff_action_block_ack(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  unsigned start = offset;

  switch (tvb_get_uint8(tvb, offset + 1)) {
  case BA_ADD_BLOCK_ACK_REQUEST:
  case BA_NDP_ADD_BLOCK_ACK_REQUEST:
  case BA_BAT_ADD_BLOCK_ACK_REQUEST:
    offset += add_ff_category_code(tree, tvb, pinfo, offset);
    offset += add_ff_block_ack_action_code(tree, tvb, pinfo, offset);
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    offset += add_ff_block_ack_param(tree, tvb, pinfo, offset);
    offset += add_ff_block_ack_timeout(tree, tvb, pinfo, offset);
    offset += add_ff_block_ack_ssc(tree, tvb, pinfo, offset);
    break;
  case BA_ADD_BLOCK_ACK_RESPONSE:
  case BA_NDP_ADD_BLOCK_ACK_RESPONSE:
  case BA_BAT_ADD_BLOCK_ACK_RESPONSE:
    offset += add_ff_category_code(tree, tvb, pinfo, offset);
    offset += add_ff_block_ack_action_code(tree, tvb, pinfo, offset);
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    offset += add_ff_status_code(tree, tvb, pinfo, offset);
    offset += add_ff_block_ack_param(tree, tvb, pinfo, offset);
    offset += add_ff_block_ack_timeout(tree, tvb, pinfo, offset);
    break;
  case BA_DELETE_BLOCK_ACK:
  case BA_NDP_DELETE_BLOCK_ACK:
  case BA_BAT_DELETE_BLOCK_ACK:
    offset += add_ff_category_code(tree, tvb, pinfo, offset);
    offset += add_ff_block_ack_action_code(tree, tvb, pinfo, offset);
    offset += add_ff_delba_param_set(tree, tvb, pinfo, offset);
    offset += add_ff_reason_code(tree, tvb, pinfo, offset);
    break;
  }

  return offset - start;  /* Size of fixed fields */
}

unsigned
add_ff_action_public_fields(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset, uint8_t code)
{
  uint32_t oui;
  unsigned type;
  unsigned subtype;
  uint8_t  dialog_token;
  uint8_t  frag;
  bool more;
  tvbuff_t *vendor_tvb;
  int dissected;

  unsigned start = offset;

  switch (code) {
  case PA_EXT_CHANNEL_SWITCH_ANNOUNCEMENT:
    offset += add_ff_extended_channel_switch_announcement(tree, tvb, pinfo, offset);
    break;
  case PA_VENDOR_SPECIFIC:
    proto_tree_add_item_ret_uint(tree, hf_ieee80211_tag_oui, tvb, offset, 3, ENC_BIG_ENDIAN, &oui);
    offset += 3;
    switch (oui) {
    case OUI_WFA:
      subtype = tvb_get_uint8(tvb, offset);
      proto_tree_add_item(tree, hf_ieee80211_tag_oui_wfa_subtype, tvb, offset, 1, ENC_NA);
      offset += 1;
      vendor_tvb = tvb_new_subset_remaining(tvb, offset);
      dissected = dissector_try_uint_new(wifi_alliance_public_action_table, subtype, vendor_tvb, pinfo, tree, false, NULL);
      offset += dissected;
      break;
    default:
      /* Don't know how to handle this vendor */
      break;
    }
    break;
  case PA_GAS_INITIAL_REQUEST:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    offset += dissect_advertisement_protocol_common(pinfo, tree, tvb, offset,
                                             &type, &subtype);
    offset += dissect_gas_initial_request(tree, tvb, pinfo, offset, type,
                                          subtype);
    break;
  case PA_GAS_INITIAL_RESPONSE:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    offset += add_ff_status_code(tree, tvb, pinfo, offset);
    offset += add_ff_gas_comeback_delay(tree, tvb, pinfo, offset);
    offset += dissect_advertisement_protocol_common(pinfo, tree, tvb, offset,
                                             &type, &subtype);
    offset += dissect_gas_initial_response(tree, tvb, pinfo, offset, type,
                                           subtype);
    break;
  case PA_GAS_COMEBACK_REQUEST:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    break;
  case PA_GAS_COMEBACK_RESPONSE:
    dialog_token = tvb_get_uint8(tvb, offset);
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    offset += add_ff_status_code(tree, tvb, pinfo, offset);
    frag = tvb_get_uint8(tvb, offset) & 0x7f;
    more = (tvb_get_uint8(tvb, offset) & 0x80) != 0;
    offset += add_ff_gas_fragment_id(tree, tvb, pinfo, offset);
    offset += add_ff_gas_comeback_delay(tree, tvb, pinfo, offset);
    offset += dissect_advertisement_protocol_common(pinfo, tree, tvb, offset,
                                             &type, &subtype);
    offset += dissect_gas_comeback_response(tree, tvb, pinfo, offset, type,
                                            subtype, frag, more, dialog_token);
    break;
  case PA_TDLS_DISCOVERY_RESPONSE:
    col_set_str(pinfo->cinfo, COL_PROTOCOL, "TDLS");
    col_set_str(pinfo->cinfo, COL_INFO, "TDLS Discovery Response");
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    offset += add_ff_cap_info(tree, tvb, pinfo, offset);
    break;
  case PA_QAB_REQUEST:
  case PA_QAB_RESPONSE:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    offset += add_ff_req_ap_addr(tree, tvb, pinfo, offset);
    offset += add_ff_res_ap_addr(tree, tvb, pinfo, offset);
    break;
  case PA_FTM_REQUEST:
    col_set_str(pinfo->cinfo, COL_INFO, "FTM Request");
    offset += add_ff_ftm_request(tree, tvb, pinfo, offset);
    break;
  case PA_FTM:
    col_set_str(pinfo->cinfo, COL_INFO, "FTM");
    offset += add_ff_ftm(tree, tvb, pinfo, offset);
    break;
  case PA_FILS_DISCOVERY:
    col_set_str(pinfo->cinfo, COL_INFO, "FILS Discovery");
    offset = add_ff_fils_discovery(tree, tvb, pinfo, offset);
    break;
  case PA_LOCATION_MEASUREMENT_REPORT:
    col_set_str(pinfo->cinfo, COL_INFO, "Location Measurement Report");
    offset = add_ff_lmr_report(tree, tvb, pinfo, offset);
    break;
  }

  return offset - start;  /* Size of fixed fields */
}

static unsigned
add_ff_action_public(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  uint8_t code;
  unsigned start = offset;
  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  code    = tvb_get_uint8(tvb, offset);
  offset += add_ff_pa_action_code(tree, tvb, pinfo, offset);
  offset += add_ff_action_public_fields(tree, tvb, pinfo, offset, code);
  return offset - start;
}

static unsigned
add_ff_action_protected_public(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  uint8_t code;
  unsigned start = offset;
  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  code    = tvb_get_uint8(tvb, offset);
  offset += add_ff_ppa_action_code(tree, tvb, pinfo, offset);
  offset += add_ff_action_public_fields(tree, tvb, pinfo, offset, code);
  return offset - start;
}

static unsigned
add_ff_action_radio_measurement(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  unsigned  start = offset;
  uint8_t code;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  code = tvb_get_uint8(tvb, offset);
  offset += add_ff_rm_action_code(tree, tvb, pinfo, offset);

  switch (code) {
  case RM_ACTION_RADIO_MEASUREMENT_REQUEST:
    offset += add_ff_rm_dialog_token(tree, tvb, pinfo, offset);
    offset += add_ff_rm_repetitions(tree, tvb, pinfo, offset);
    /* Followed by Measurement Request Elements */
    break;
  case RM_ACTION_RADIO_MEASUREMENT_REPORT:
    offset += add_ff_rm_dialog_token(tree, tvb, pinfo, offset);
    /* Followed by Measurement Report Elements */
    break;
  case RM_ACTION_LINK_MEASUREMENT_REQUEST:
    offset += add_ff_rm_dialog_token(tree, tvb, pinfo, offset);
    offset += add_ff_rm_tx_power(tree, tvb, pinfo, offset);
    offset += add_ff_rm_max_tx_power(tree, tvb, pinfo, offset);
    /* Followed by Optional Subelements */
    break;
  case RM_ACTION_LINK_MEASUREMENT_REPORT:
    offset += add_ff_rm_dialog_token(tree, tvb, pinfo, offset);
    offset += add_ff_rm_tpc_report(tree, tvb, pinfo, offset);
    offset += add_ff_rm_rx_antenna_id(tree, tvb, pinfo, offset);
    offset += add_ff_rm_tx_antenna_id(tree, tvb, pinfo, offset);
    offset += add_ff_rm_rcpi(tree, tvb, pinfo, offset);
    offset += add_ff_rm_rsni(tree, tvb, pinfo, offset);
    /* Followed by Optional Subelements */
    break;
  case RM_ACTION_NEIGHBOR_REPORT_REQUEST:
    offset += add_ff_rm_dialog_token(tree, tvb, pinfo, offset);
    /* Followed by Optional Subelements */
    break;
  case RM_ACTION_NEIGHBOR_REPORT_RESPONSE:
    offset += add_ff_rm_dialog_token(tree, tvb, pinfo, offset);
    /* Followed by Neighbor Report Elements */
    break;
  }

  return offset - start;  /* Size of fixed fields */
}

static unsigned
add_ff_action_fast_bss_transition(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  unsigned  start = offset;
  uint8_t code;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  code    = tvb_get_uint8(tvb, offset);
  offset += add_ff_ft_action_code(tree, tvb, pinfo, offset);

  switch (code) {
  case FT_ACTION_REQUEST:
    offset += add_ff_sta_address(tree, tvb, pinfo, offset);
    offset += add_ff_target_ap_address(tree, tvb, pinfo, offset);
    /* Followed by FT Request frame body (IEs) */
    break;
  case FT_ACTION_RESPONSE:
    offset += add_ff_sta_address(tree, tvb, pinfo, offset);
    offset += add_ff_target_ap_address(tree, tvb, pinfo, offset);
    offset += add_ff_status_code(tree, tvb, pinfo, offset);
    /* Followed by FT Response frame body (IEs) */
    break;
  case FT_ACTION_CONFIRM:
    offset += add_ff_sta_address(tree, tvb, pinfo, offset);
    offset += add_ff_target_ap_address(tree, tvb, pinfo, offset);
    /* Followed by FT Confirm frame body (IEs) */
    break;
  case FT_ACTION_ACK:
    offset += add_ff_sta_address(tree, tvb, pinfo, offset);
    offset += add_ff_target_ap_address(tree, tvb, pinfo, offset);
    offset += add_ff_status_code(tree, tvb, pinfo, offset);
    /* Followed by FT Ack frame body (IEs) */
    break;
  }

  return offset - start;  /* Size of fixed fields */
}

static unsigned
add_ff_action_sa_query(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  unsigned  start = offset;
  uint8_t code;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  code    = tvb_get_uint8(tvb, offset);
  offset += add_ff_sa_query_action_code(tree, tvb, pinfo, offset);

  switch (code) {
  case SA_QUERY_REQUEST:
    offset += add_ff_transaction_id(tree, tvb, pinfo, offset);
    break;
  case SA_QUERY_RESPONSE:
    offset += add_ff_transaction_id(tree, tvb, pinfo, offset);
    break;
  }

  return offset - start;  /* Size of fixed fields */
}

static unsigned
add_ff_action_mesh(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  unsigned length;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  offset += add_ff_mesh_action(tree, tvb, pinfo, offset);
  /* The only fixed fields are the category and mesh action.  The rest are IEs.
   */
  length = 2;
  if (tvb_get_uint8(tvb, 1) == MESH_ACTION_TBTT_ADJ_RESPONSE) {
    /* ..except for the TBTT Adjustment Response, which has a status code field
     */
    length += add_ff_status_code(tree, tvb, pinfo, offset);
  }
  return length;
}

static unsigned
add_ff_action_multihop(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  unsigned start = offset;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  offset += add_ff_multihop_action(tree, tvb, pinfo, offset);
  offset += add_ff_mesh_control(tree, tvb, pinfo, offset);
  return offset - start;
}

static unsigned
add_ff_action_self_protected(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset,
                             association_sanity_check_t *association_sanity_check)
{
  unsigned start = offset;
  uint8_t self_protected_action = tvb_get_uint8(tvb, start + 1);

  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  offset += add_ff_selfprot_action(tree, tvb, pinfo, offset);

  switch (self_protected_action) {
  case SELFPROT_ACTION_MESH_PEERING_OPEN:
    offset += add_ff_cap_info(tree, tvb, pinfo, offset);
    if (association_sanity_check)
      association_sanity_check->ampe_frame = self_protected_action;
    break;
  case SELFPROT_ACTION_MESH_PEERING_CONFIRM:
    offset += add_ff_cap_info(tree, tvb, pinfo, offset);
    offset += add_ff_assoc_id(tree, tvb, pinfo, offset);
    if (association_sanity_check)
      association_sanity_check->ampe_frame = self_protected_action;
    break;
  case SELFPROT_ACTION_MESH_PEERING_CLOSE:
    if (association_sanity_check)
      association_sanity_check->ampe_frame = self_protected_action;
    break;
  }

  return offset - start;
}

static unsigned
add_ff_vht_action(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_vht_action, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_s1g_timestamp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_s1g_timestamp, tvb, offset,
                      4, ENC_LITTLE_ENDIAN);
  return 4;
}

static unsigned
add_ff_change_sequence(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_s1g_change_sequence, tvb, offset,
                      1, ENC_NA);
  return 1;
}

static unsigned
add_ff_next_tbtt(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_s1g_next_tbtt, tvb, offset,
                      3, ENC_LITTLE_ENDIAN);
  return 3;
}

static unsigned
add_ff_compressed_ssid(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_s1g_compressed_ssid, tvb, offset,
                      4, ENC_LITTLE_ENDIAN);
  return 4;
}

/* This should not be S1G specific because 802.11-2016 defines it as well. */
static unsigned
add_ff_access_network_options(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_s1g_access_network_options, tvb,
                      offset, 1, ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_s1g_action(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_s1g_action, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned
add_ff_prot_s1g_action(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_prot_s1g_action, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  return 1;
}

static unsigned get_group_element_len(unsigned group) {
  switch (group) {
    /* Diffie-Hellman groups */
    case 1:
      return 96;
    case 2:
    case 22:
      return 128;
    case 5:
      return 192;
    case 14:
    case 23:
    case 24:
      return 256;
    case 15:
      return 384;
    case 16:
      return 512;
    case 17:
      return 768;
    case 18:
      return 1024;
    /* ECC groups */
    case 19:
    case 28:
      return 64;
    case 20:
    case 29:
      return 96;
    case 21:
      return 132;
    case 25:
      return 48;
    case 26:
      return 56;
    case 30:
      return 128;
    default:
      return 0;
  }
}

static unsigned get_scalar_len(unsigned group) {
  switch (group) {
    /* Diffie-Hellman groups */
    case 1:
      return 96;
    case 2:
      return 128;
    case 5:
      return 192;
    case 14:
      return 256;
    case 15:
      return 384;
    case 16:
      return 512;
    case 17:
      return 768;
    case 18:
      return 1024;
    case 22:
      return 20;
    case 23:
      return 28;
    case 24:
      return 32;
    /* ECC groups */
    case 19:
    case 28:
      return 32;
    case 20:
    case 29:
      return 48;
    case 21:
      return 66;
    case 25:
      return 24;
    case 26:
      return 28;
    case 30:
      return 64;
    default:
      return 0;
  }
}

static unsigned
find_fixed_field_len(tvbuff_t *tvb, unsigned offset)
{
  unsigned start_offset = offset;
  unsigned len = tvb_reported_length(tvb);

  if (offset >= len) {
    return 0;
  }

  while (offset < len) {
    if (tvb_get_uint8(tvb, offset) == 0xFF) {
      /*
       * Check if we have a len followed by either ETAG_REJECTED_GROUPS
       * or ETAG_PASSWORD_IDENTIFIER or ETAG_ANTI_CLOGGING_TOKEN
       */
      /* The length of SAE Confirm or Scalar Fixed parameter >= 32 */
      if ((offset < len - 3) && (offset - start_offset >= 32)) {
        uint8_t etag_len = tvb_get_uint8(tvb, offset + 1);
        uint8_t check_byte = tvb_get_uint8(tvb, offset + 2);
        if (check_byte == ETAG_REJECTED_GROUPS ||
            check_byte == ETAG_PASSWORD_IDENTIFIER ||
            check_byte == ETAG_ANTI_CLOGGING_TOKEN ||
            check_byte == ETAG_MULTI_LINK ||
            check_byte == ETAG_AKM_SUITE_SELECTOR) {
          /* Add length check to avoid false detection */
          if (offset + etag_len + 2 <= len) {
            break;
          }
        }
      }
    }
    offset++;
  }

  return offset - start_offset;
}

static const value_string ff_sae_message_type_vals[] = {
  {1, "Commit" },
  {2, "Confirm" },
  {0, NULL }
};

/*
 * We have to deal with the issue that an anti-clogging token may be in this
 * thing.
 */
static unsigned
add_ff_auth_sae(proto_tree *tree, tvbuff_t *tvb,
                         packet_info *pinfo _U_, unsigned offset)
{
  unsigned alg, seq, status_code, len;
  alg = tvb_get_letohs(tvb, 0);

  if (alg != AUTH_ALG_SAE)
    return offset;

  seq = tvb_get_letohs(tvb, 2);
  status_code = tvb_get_letohs(tvb, 4);

  proto_tree_add_uint(tree, hf_ieee80211_ff_sae_message_type, tvb, 2, 2, seq);

  if (seq == 1)
  {
    uint16_t group;
    unsigned sc_len, elt_len;

    /*
     * Order is: Status code,
     *           Finite Cyclic Group,
     *           Anti-Clogging Token in some cases
     *           Send-Confirm in some cases
     *           Scalar in some cases
     *           FFE in some cases
     *           Confirm in some cases
     *           Challenge Text in some cases
     *           RSNE in some cases.
     *           MDE in some cases.
     *           Fast BSS TRansition ... in some cases.
     */

    /* 76: Authentication is rejected because an Anti-Clogging Token is required (cf ieee80211_status_code) */
      /* These are present if status code is 0, 76, 77 or 126 */
    if (status_code == 0 || status_code == 76 || status_code == 77 ||
        status_code == 126)
    {
      group = tvb_get_letohs(tvb, offset);
      proto_tree_add_item(tree, hf_ieee80211_ff_finite_cyclic_group, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;


      /*
       * Now, get the fixed field length remaining. It will be divided up into
       * Anti-Clogging token, Scalar, FFE and some IEs.
       */
      len = find_fixed_field_len(tvb, offset);
      sc_len = get_scalar_len(group);
      elt_len = get_group_element_len(group);

      /*
       * The first conditional captures the case where we have an error and
       * an anti-clogging token with Scalar Field and FFE.
       * The second handles the case where we have an error with only an
       * anti-clogging token.
       * The third conditional below is a way to avoid keeping state about
       * what was in a previous response!
       */
      if (((status_code == 76 || status_code == 126) &&
           ((len > (sc_len + elt_len)))) ||
           ((status_code == 76) && (len > 0) && (len < (sc_len + elt_len))) ||
          ((status_code == 0) && (len > (sc_len + elt_len)))) {
        unsigned anti_clogging_len;
        /*
         * Handle the anti-clogging field. There is an anti-clogging token
         * before the other two.
         */
        if (len > (sc_len + elt_len))
          anti_clogging_len = len - (sc_len + elt_len);
        else
          anti_clogging_len = len;

        proto_tree_add_item(tree, hf_ieee80211_ff_sae_anti_clogging_token, tvb,
                            offset, anti_clogging_len, ENC_NA);
        offset += anti_clogging_len;
      }

      if (sc_len == 0) {
        /* assume no anti-clogging token */
        if (!(len % 3))
        {
          sc_len = len / 3;
        }
        else
        {
          sc_len = len / 2;
        }
        elt_len = len - sc_len;
      }

      /* Only present if status = 0 or 126 */
      if (status_code == 0 || status_code == 126) {
        proto_tree_add_item(tree, hf_ieee80211_ff_scalar, tvb, offset,
                            sc_len, ENC_NA);
        offset += sc_len;

        proto_tree_add_item(tree, hf_ieee80211_ff_finite_field_element, tvb,
                            offset, elt_len, ENC_NA);
        offset += elt_len;
      }
    }
  }
  else if ((seq == 2) && (status_code == 0))
  {
    proto_tree_add_item(tree, hf_ieee80211_ff_send_confirm, tvb, 6, 2,
                        ENC_LITTLE_ENDIAN);
    offset += 2;

    /* Check if there are additional elements */
    len = find_fixed_field_len(tvb, offset);
    proto_tree_add_item(tree, hf_ieee80211_ff_confirm, tvb, offset, len,
                        ENC_NA);
    offset += len;
  }

  return offset;
}

static unsigned
add_ff_auth_fils(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_,
                 unsigned offset)
{
  unsigned alg, seq, status_code;
  alg = tvb_get_letohs(tvb, 0);

  if ((alg != AUTH_ALG_FILS_SK_WITH_PFS) && (alg != AUTH_ALG_FILS_PK))
    return offset;

  seq = tvb_get_letohs(tvb, 2);
  status_code = tvb_get_letohs(tvb, 4);

  if ((seq == 1) || (seq == 2 && status_code == 0)) {
    unsigned group = tvb_get_letohs(tvb, 6);
    unsigned elt_len;
    proto_tree_add_item(tree, hf_ieee80211_ff_finite_cyclic_group, tvb, 6, 2,
                        ENC_LITTLE_ENDIAN);
    offset = 8;
    elt_len = get_group_element_len(group);

    proto_tree_add_item(tree, hf_ieee80211_ff_finite_field_element, tvb, offset,
                        elt_len, ENC_NA);

    offset += elt_len;
  }

  /* What about the other FILS case? */

  return offset;
}

/*
 * We handle different elements depending on whether the sequence number is
 * 1, 2 or 3.
 */
typedef struct ieee80211_pasn_data {
  unsigned pasn_seq;
  unsigned pasn_status_code;
} ieee80211_pasn_data_t;

static ieee80211_pasn_data_t*
create_pasn_data(packet_info *pinfo, unsigned seq, unsigned status)
{
  ieee80211_pasn_data_t *pasn_data = NULL;

  pasn_data = wmem_new(pinfo->pool, ieee80211_pasn_data_t);

  if(pasn_data) {
    p_add_proto_data(pinfo->pool, pinfo, proto_wlan, PASN_DATA_KEY, pasn_data);
    pasn_data->pasn_seq = seq;
    pasn_data->pasn_status_code = status;
  }

  return pasn_data;
}

static unsigned
add_ff_auth_pasn(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_,
                 unsigned offset)
{
  unsigned seq, status_code;
  ieee80211_pasn_data_t *pasn_data = NULL;

  seq = tvb_get_letohs(tvb, 2);
  status_code = tvb_get_letohs(tvb, 4);

  pasn_data = create_pasn_data(pinfo, seq, status_code);
  if (!pasn_data) {
    /* Leave it undissected if we cannot get memory. */
    return offset + tvb_captured_length_remaining(tvb, offset);
  }

  if (seq == 1) {
    /*
     * Contains RSN Info,
     * PASN field,
     * Wrapped Data may be present if the PASN element says so,
     * RSNXE may be present
     * Timeout Interval element may be present
     * Fragment element may be present if it was fragmented.
     */
    while (tvb_captured_length_remaining(tvb, offset)) {
      offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
    }
  } else if (seq == 2) {
    /* This test might not be needed */
    if (status_code != 0) {
      offset += tvb_captured_length_remaining(tvb, offset);
      return offset;
    }
    /*
     * RSN element is present.
     * PASN element is present if status == 0.
     * Wrapped Data element present if the PASN element says so.
     * ...
     */
    while (tvb_captured_length_remaining(tvb, offset)) {
      offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
    }
  } else if (seq == 3) {
    /*
     * Contains PASN element if status == 0
     * Contains Wrapped Data element if PASN element says so and status is 0.
     * Contains MC element
     * May contain fragment elements.
     */
    while (tvb_captured_length_remaining(tvb, offset)) {
      offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
    }
  }

  offset += tvb_captured_length_remaining(tvb, offset);

  return offset;
}

/*
 * Handle an Auth Frame. We need to be able to call this from several places.
 *
 * We should also handle the different auth types more correctly.
 */
static int
dissect_auth_frame(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb)
{
  int offset = 0;
  uint16_t auth_algorithm = tvb_get_letohs(tvb, offset);

  add_ff_auth_alg(tree, tvb, pinfo, offset);
  offset += 2;

  add_ff_auth_trans_seq(tree, tvb, pinfo, offset);
  offset += 2;

  add_ff_status_code(tree, tvb, pinfo, offset);
  offset += 2;

  switch (auth_algorithm) {
  case AUTH_ALG_SAE:
    offset = add_ff_auth_sae(tree, tvb, pinfo, offset);
    break;
  case AUTH_ALG_FILS_PK:
  case  AUTH_ALG_FILS_SK_WITH_PFS:
    offset = add_ff_auth_fils(tree, tvb, pinfo, offset);
    break;
  case AUTH_ALG_PASN:
    offset = add_ff_auth_pasn(tree, tvb, pinfo, offset);
    break;
  }

  return offset;
}

/*
 * If it is PASN wrapped data, handle it correctly, else defer to fils
 * wrapped data.
 */
static void
dissect_wrapped_data(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb,
                     int offset, uint8_t ext_tag_len _U_)
{
  ieee80211_pasn_data_t *pasn_data =
    (ieee80211_pasn_data_t*)p_get_proto_data(pinfo->pool, pinfo, proto_wlan,
                                             PASN_DATA_KEY);

  if (pasn_data) {
    proto_tree *auth_tree = NULL;
    proto_item *ai = NULL;
    uint16_t frame_len = 0;
    tvbuff_t *new_tvb = NULL;

    switch (pasn_data->pasn_seq) {
    case 1:
      auth_tree = proto_tree_add_subtree(tree, tvb, offset, -1,
                                         ett_pasn_auth_frame, &ai,
                                         "Authentication Frame");
      new_tvb = tvb_new_subset_remaining(tvb, offset);
      offset = dissect_auth_frame(auth_tree, pinfo, new_tvb);
      proto_item_set_len(ai, offset); /* This is correct */
      break;

    case 2:
      /* This has two auth frames in it. */
      frame_len = tvb_get_letohs(tvb, offset);
      proto_tree_add_item(tree, hf_ieee80211_pasn_auth1_frame_len, tvb, offset,
                          2, ENC_LITTLE_ENDIAN);
      offset += 2;
      auth_tree = proto_tree_add_subtree(tree, tvb, offset, frame_len,
                                         ett_pasn_auth_frame, NULL,
                                         "Authentication Frame 1");
      new_tvb = tvb_new_subset_length(tvb, offset, frame_len);
      offset += dissect_auth_frame(auth_tree, pinfo, new_tvb);

      /* Second frame */
      frame_len = tvb_get_letohs(tvb, offset);
      proto_tree_add_item(tree, hf_ieee80211_pasn_auth2_frame_len, tvb, offset,
                          2, ENC_LITTLE_ENDIAN);
      offset += 2;
      auth_tree = proto_tree_add_subtree(tree, tvb, offset, frame_len,
                                         ett_pasn_auth_frame, NULL,
                                         "Authentication Frame 2");
      new_tvb = tvb_new_subset_length(tvb, offset, frame_len);
      dissect_auth_frame(auth_tree, pinfo, new_tvb);
      break;

    case 3:
      auth_tree = proto_tree_add_subtree(tree, tvb, offset, -1,
                                         ett_pasn_auth_frame, &ai,
                                         "Authentication Frame");
      new_tvb = tvb_new_subset_remaining(tvb, offset);
      offset = dissect_auth_frame(auth_tree, pinfo, new_tvb);
      proto_item_set_len(ai, offset);
      break;
    }
  }
}

#define FILS_REQ_PARAMS_FILS_CRITERIA           0x01
#define FILS_REQ_PARAMS_MAX_DELAY_LIMIT         0x02
#define FILS_REQ_PARAMS_MINIMUM_DATA_RATE       0x04
#define FILS_REQ_PARAMS_RCPI_LIMIT              0x08
#define FILS_REQ_PARAMS_OUI_RESPONSE_CRITERIA   0x10
#define FILS_REQ_PARAMS_RESERVED                0xE0

#define FILS_REQ_PARAMS_FILS_CRITERIA_BSS_DELAY   0x07
#define FILS_REQ_PARAMS_FILS_CRITERIA_PHY_SUPPORT 0x38
#define FILS_REQ_PARAMS_FILS_CRITERIA_RESERVED    0xC0

static void
dissect_fils_req_params(proto_tree *tree, packet_info *pinfo _U_, tvbuff_t *tvb,
                     int offset, uint8_t ext_tag_len _U_)
{
  uint8_t bitmap;

  static int * const ieee80211_fils_req_params_paramter_control_bitmap[] = {
    &hf_ieee80211_fils_req_params_fils_criteria_present,
    &hf_ieee80211_fils_req_params_max_delay_limit_present,
    &hf_ieee80211_fils_req_params_minimum_data_rate_present,
    &hf_ieee80211_fils_req_params_rcpi_limit_present,
    &hf_ieee80211_fils_req_params_oui_response_criteria_present,
    &hf_ieee80211_fils_req_params_reserved,
    NULL
  };

  static int * const ieee80211_fils_req_params_fils_criteria[] = {
    &hf_ieee80211_fils_req_params_fils_criteria_bss_delay,
    &hf_ieee80211_fils_req_params_fils_criteria_phy_support,
    &hf_ieee80211_fils_req_params_fils_criteria_reserved,
    NULL
  };

  bitmap = tvb_get_uint8(tvb, offset);
  proto_tree_add_bitmask(tree, tvb, offset, hf_ieee80211_fils_req_params_parameter_control_bitmap,
                         ett_ff_fils_req_params, ieee80211_fils_req_params_paramter_control_bitmap, ENC_LITTLE_ENDIAN);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_fils_req_params_max_channel_time,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset +=1;

  if(bitmap & FILS_REQ_PARAMS_FILS_CRITERIA) {
    proto_tree_add_bitmask(tree, tvb, offset, hf_ieee80211_fils_req_params_fils_criteria,
                         ett_ff_fils_req_params_fils_criteria, ieee80211_fils_req_params_fils_criteria, ENC_LITTLE_ENDIAN);
    offset += 1;
  }

  if(bitmap & FILS_REQ_PARAMS_MAX_DELAY_LIMIT) {
    proto_tree_add_item(tree, hf_ieee80211_fils_req_params_max_delay_limit,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
  }

  if(bitmap & FILS_REQ_PARAMS_MINIMUM_DATA_RATE) {
    proto_tree_add_item(tree, hf_ieee80211_fils_req_params_minimum_data_rate,
                        tvb, offset, 3, ENC_LITTLE_ENDIAN);
    offset += 3;
  }

  if(bitmap & FILS_REQ_PARAMS_RCPI_LIMIT) {
    proto_tree_add_item(tree, hf_ieee80211_fils_req_params_rcpi_limit,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
  }

  if(bitmap & FILS_REQ_PARAMS_OUI_RESPONSE_CRITERIA) {
    proto_tree_add_item(tree, hf_ieee80211_fils_req_params_oui_response_criteria,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    //offset += 2;
  }

}

static unsigned
wnm_bss_trans_mgmt_query(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  int    start = offset;
  int    left;
  int tmp_sublen;
  const uint8_t ids[] = { TAG_NEIGHBOR_REPORT };


  offset += add_ff_dialog_token(tree, tvb, pinfo, offset);

  proto_tree_add_item(tree, hf_ieee80211_ff_bss_transition_query_reason, tvb, offset, 1,
                      ENC_NA);
  offset += 1;

  left = tvb_reported_length_remaining(tvb, offset);
  if (left > 0) {
    proto_tree_add_item(tree, hf_ieee80211_ff_bss_transition_candidate_list_entries,
                        tvb, offset, left, ENC_NA);

    while (left > 0){
      tmp_sublen = tvb_get_uint8(tvb, offset + 1);
      if(add_tagged_field(pinfo, tree, tvb, offset, 0, ids, G_N_ELEMENTS(ids), NULL) == 0){
        break;
      }
      left -= (tmp_sublen + 2);
      offset += (tmp_sublen + 2);
    }
  }

  return offset - start;
}


static unsigned
wnm_bss_trans_mgmt_req(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  int    start = offset;
  uint8_t mode;
  int    left = tvb_reported_length_remaining(tvb, offset);
  int tmp_sublen;
  const uint8_t ids[] = { TAG_NEIGHBOR_REPORT, TAG_VENDOR_SPECIFIC_IE};

  static int * const ieee80211_ff_request_flags[] = {
    &hf_ieee80211_ff_request_mode_pref_cand,
    &hf_ieee80211_ff_request_mode_abridged,
    &hf_ieee80211_ff_request_mode_disassoc_imminent,
    &hf_ieee80211_ff_request_mode_bss_term_included,
    &hf_ieee80211_ff_request_mode_ess_disassoc_imminent,
    &hf_ieee80211_ff_request_mode_link_removal_imminent,
    &hf_ieee80211_ff_request_mode_reserved,
    NULL
  };

  if (left < 5) {
    expert_add_info(pinfo, tree, &ei_ieee80211_bad_length);
    return offset - start;
  }

  offset += add_ff_dialog_token(tree, tvb, pinfo, offset);

  mode = tvb_get_uint8(tvb, offset);
  proto_tree_add_bitmask_list(tree, tvb, offset, 1, ieee80211_ff_request_flags, ENC_LITTLE_ENDIAN);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_ff_disassoc_timer, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_ff_validity_interval, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  offset += 1;
  left -= 5;

  if (mode & 0x08) {
    proto_item *item;
    proto_tree  *sub_tree;
    uint8_t sub_id, sub_len;

    // BSS termination Duration sub element is the same as the neighbor report sub element
    if (left < 12) {
      expert_add_info(pinfo, tree, &ei_ieee80211_bad_length);
      return offset - start;
    }

    sub_tree = proto_tree_add_subtree(tree, tvb, offset, 12, ett_tag_neighbor_report_subelement_tree,
                                      NULL, "BSS Termination Duration");

    sub_id = tvb_get_uint8(tvb, offset);
    item = proto_tree_add_item(sub_tree, hf_ieee80211_tag_neighbor_report_subelement_id,
                               tvb, offset, 1, ENC_NA);
    offset += 1;
    if (sub_id != NR_SUB_ID_BSS_TER_DUR) {
      expert_add_info_format(pinfo, item, &ei_ieee80211_inv_val,
                             "Incorrect BSS Termination Duration subelement ID");
    }

    sub_len = tvb_get_uint8(tvb, offset);
    item = proto_tree_add_item(sub_tree, hf_ieee80211_tag_neighbor_report_subelement_length,
                               tvb, offset, 1, ENC_NA);
    offset += 1;
    if (sub_len != 10) {
       expert_add_info_format(pinfo, item, &ei_ieee80211_inv_val,
                              "Incorrect BSS Termination Duration subelement length");
    }

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_neighbor_report_subelement_bss_ter_tsf,
                        tvb, offset, 8, ENC_LITTLE_ENDIAN);
    offset += 8;
    proto_tree_add_item(sub_tree, hf_ieee80211_tag_neighbor_report_subelement_bss_dur,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    left -= 12;
  }

  if (mode & 0x10) {
    uint8_t url_len;

    url_len = tvb_get_uint8(tvb, offset);
    if (left < url_len) {
      expert_add_info(pinfo, tree, &ei_ieee80211_bad_length);
      return offset - start;
    }

    proto_tree_add_item(tree, hf_ieee80211_ff_url_len, tvb, offset, 1,
                        ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ieee80211_ff_url, tvb, offset, url_len,
                        ENC_ASCII);
    offset += url_len;
    left -= url_len + 1;
  }

  if (left > 0) {
    proto_tree_add_item(tree, hf_ieee80211_ff_bss_transition_candidate_list_entries,
                        tvb, offset, left, ENC_NA);

    while (left > 0){
      tmp_sublen = tvb_get_uint8(tvb, offset + 1);
      if(add_tagged_field(pinfo, tree, tvb, offset, 0, ids, G_N_ELEMENTS(ids), NULL) == 0){
        break;
      }
      left -= (tmp_sublen + 2);
      offset += (tmp_sublen + 2);
    }
  }

  return offset - start;
}


static unsigned
wnm_bss_trans_mgmt_resp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  int    start = offset;
  uint8_t code;
  int    left;
  int tmp_sublen;
  const uint8_t ids[] = { TAG_NEIGHBOR_REPORT, TAG_VENDOR_SPECIFIC_IE };

  offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
  code = tvb_get_uint8(tvb, offset);
  offset += add_ff_bss_transition_status_code(tree, tvb, pinfo, offset);
  offset += add_ff_bss_termination_delay(tree, tvb, pinfo, offset);
  if (!code) {
    proto_tree_add_item(tree, hf_ieee80211_ff_target_bss,
                        tvb, offset, 6, ENC_NA);
    offset += 6;
  }
  left = tvb_reported_length_remaining(tvb, offset);
  if (left > 0) {
    proto_tree_add_item(tree, hf_ieee80211_ff_bss_transition_candidate_list_entries,
                        tvb, offset, left, ENC_NA);
    while (left > 0){
      tmp_sublen = tvb_get_uint8(tvb, offset + 1);
      if(add_tagged_field(pinfo, tree, tvb, offset, 0, ids, G_N_ELEMENTS(ids), NULL) == 0){
        break;
      }
      left -= (tmp_sublen + 2);
      offset += (tmp_sublen + 2);
    }
  }

  return offset - start;
}

static unsigned
wnm_sleep_mode_req(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  int start = offset;
  offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
  return offset - start;
}

static unsigned
wnm_sleep_mode_resp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  int start = offset;
  uint16_t key_data_len;
  int left;

  offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
  key_data_len = tvb_get_letohs(tvb, offset);
  offset += add_ff_key_data_length(tree, tvb, pinfo, offset);
  left = tvb_reported_length_remaining(tvb, offset);
  if (left < key_data_len) {
    expert_add_info(pinfo, tree, &ei_ieee80211_tag_wnm_sleep_mode_no_key_data);
    return offset - start;
  }
  proto_tree_add_item(tree, hf_ieee80211_ff_key_data, tvb, offset,
                      key_data_len, ENC_NA);
  offset += key_data_len;
  return offset - start;
}

static unsigned
wnm_tfs_req(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  int start = offset;
  offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
  return offset - start;
}

static unsigned
wnm_tfs_resp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  int start = offset;
  offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
  return offset - start;
}

#define AP_DESCRIPTOR            0
#define FIRMWARE_VERSION_CURRENT 1
#define FIRMWARE_VERSION_NEW     2

static unsigned
dissect_wnm_subelements(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_,
  int offset) {
  unsigned sub_elt_id = tvb_get_uint8(tvb, offset);
  unsigned sub_elt_len = tvb_get_uint8(tvb, offset + 1);

  proto_tree_add_item(tree, hf_ieee80211_wnm_sub_elt_id, tvb, offset, 1, ENC_NA);
  offset++;

  proto_tree_add_item(tree, hf_ieee80211_wnm_sub_elt_len, tvb, offset, 1, ENC_NA);
  offset++;

  switch (sub_elt_id) {
  case AP_DESCRIPTOR:

    break;

  case FIRMWARE_VERSION_CURRENT:

    break;

  case FIRMWARE_VERSION_NEW:

    break;
  }

  offset += sub_elt_len;
  return offset;
}

static unsigned
wnm_notification_req(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  int start = offset;
  int len = 0;
  uint8_t wnm_type = 0;
  uint8_t wnm_sub_elt = 0;

  offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
  wnm_type = tvb_get_uint8(tvb, offset);
  offset += add_ff_wnm_notification_type(tree, tvb, pinfo, offset);
  len = tvb_reported_length_remaining(tvb, offset);

  if (wnm_type == 0) {
    int offset_end = offset + len;
    while (offset < offset_end) {
      int start_offset = offset;
      proto_tree *wnm_list = NULL;
      proto_item *wnm_item = NULL;
      wnm_list = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                        ett_wnm_notif_subelt,
                        &wnm_item, "WNM Subelement %d", wnm_sub_elt);
      offset = dissect_wnm_subelements(wnm_list, tvb, pinfo, offset);
      proto_item_set_len(wnm_item, offset - start_offset);
    }
  }
  return offset - start;
}

static unsigned
wnm_notification_resp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  int start = offset;

  offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
  proto_tree_add_item(tree, hf_ieee80211_ff_wnm_notification_response_status,
                      tvb, offset, 1, ENC_NA);
  offset += 1;

  return offset - start;
}

static unsigned
add_ff_action_wnm(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  uint8_t code;
  unsigned  start = offset;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  code    = tvb_get_uint8(tvb, offset);
  offset += add_ff_wnm_action_code(tree, tvb, pinfo, offset);
  switch (code) {
  case WNM_EVENT_REQ:
  case WNM_EVENT_REPORT:
  case WNM_DIAGNOSTIC_REQ:
  case WNM_DIAGNOSTIC_REPORT:
  case WNM_LOCATION_CFG_REQ:
  case WNM_LOCATION_CFG_RESP:
  case WNM_FMS_REQ:
  case WNM_FMS_RESP:
  case WNM_DMS_REQ:
  case WNM_DMS_RESP:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    break;
  case WNM_BSS_TRANS_MGMT_QUERY:
    offset += wnm_bss_trans_mgmt_query(tree, tvb, pinfo, offset);
    break;
  case WNM_BSS_TRANS_MGMT_REQ:
    offset += wnm_bss_trans_mgmt_req(tree, tvb, pinfo, offset);
    break;
  case WNM_BSS_TRANS_MGMT_RESP:
    offset += wnm_bss_trans_mgmt_resp(tree, tvb, pinfo, offset);
    break;
  case WNM_TFS_REQ:
    offset += wnm_tfs_req(tree, tvb, pinfo, offset);
    break;
  case WNM_TFS_RESP:
    offset += wnm_tfs_resp(tree, tvb, pinfo, offset);
    break;
  case WNM_SLEEP_MODE_REQ:
    offset += wnm_sleep_mode_req(tree, tvb, pinfo, offset);
    break;
  case WNM_SLEEP_MODE_RESP:
    offset += wnm_sleep_mode_resp(tree, tvb, pinfo, offset);
    break;
  case WNM_NOTIFICATION_REQ:
    offset += wnm_notification_req(tree, tvb, pinfo, offset);
    break;
  case WNM_NOTIFICATION_RESP:
    offset += wnm_notification_resp(tree, tvb, pinfo, offset);
    break;
  }

  return offset - start;  /* Size of fixed fields */
}

static unsigned
add_ff_action_unprotected_wnm(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  uint8_t code;
  unsigned  start = offset;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  code    = tvb_get_uint8(tvb, offset);
  offset += add_ff_unprotected_wnm_action_code(tree, tvb, pinfo, offset);

  switch (code) {
  case UNPROTECTED_WNM_TIM:
    offset += add_ff_check_beacon(tree, tvb, pinfo, offset);
    offset += add_ff_timestamp(tree, tvb, pinfo, offset);
    offset += add_ff_tod(tree, tvb, pinfo, offset);
    offset += add_ff_toa(tree, tvb, pinfo, offset);
    offset += add_ff_max_tod_err(tree, tvb, pinfo, offset);
    offset += add_ff_max_toa_err(tree, tvb, pinfo, offset);
    break;
  case UNPROTECTED_WNM_TIMING_MEASUREMENT:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    offset += add_ff_followup_dialog_token(tree, tvb, pinfo, offset);
    break;
  }

  return offset - start;  /* Size of fixed fields */
}

static unsigned
add_ff_action_tdls(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  uint8_t code;
  uint16_t status;
  unsigned   start = offset;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  code = tvb_get_uint8(tvb, offset);

  /* Extract keys for dot11decrypt engine */
  try_scan_tdls_keys(tvb, pinfo, offset);

  offset += add_ff_tdls_action_code(tree, tvb, pinfo, offset);
  switch (code) {
  case TDLS_SETUP_REQUEST:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    offset += add_ff_cap_info(tree, tvb, pinfo, offset);
    break;
  case TDLS_SETUP_RESPONSE:
    status = tvb_get_letohs(tvb, offset);
    offset += add_ff_status_code(tree, tvb, pinfo, offset);
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    if (tvb_reported_length_remaining(tvb, offset) < 2) {
      if (status == 0) {
        expert_add_info(pinfo, tree, &ei_ieee80211_tdls_setup_response_malformed);
      }
      break;
    }
    offset += add_ff_cap_info(tree, tvb, pinfo, offset);
    break;
  case TDLS_SETUP_CONFIRM:
    status = tvb_get_letohs(tvb, offset);
    offset += add_ff_status_code(tree, tvb, pinfo, offset);
    if (tvb_reported_length_remaining(tvb, offset) < 1) {
      if (status == 0) {
        expert_add_info(pinfo, tree, &ei_ieee80211_tdls_setup_confirm_malformed);
      }
      break;
    }
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    break;
  case TDLS_TEARDOWN:
    offset += add_ff_reason_code(tree, tvb, pinfo, offset);
    break;
  case TDLS_PEER_TRAFFIC_INDICATION:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    break;
  case TDLS_CHANNEL_SWITCH_REQUEST:
    offset += add_ff_target_channel(tree, tvb, pinfo, offset);
    offset += add_ff_operating_class(tree, tvb, pinfo, offset);
    break;
  case TDLS_CHANNEL_SWITCH_RESPONSE:
    offset += add_ff_status_code(tree, tvb, pinfo, offset);
    break;
  case TDLS_PEER_PSM_REQUEST:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    break;
  case TDLS_PEER_PSM_RESPONSE:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    offset += add_ff_status_code(tree, tvb, pinfo, offset);
    break;
  case TDLS_PEER_TRAFFIC_RESPONSE:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    break;
  case TDLS_DISCOVERY_REQUEST:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    break;
  }

  return offset - start;  /* Size of fixed fields */
}

static unsigned
add_ff_action_mgmt_notification(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  unsigned start = offset;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  offset += add_ff_wme_action_code(tree, tvb, pinfo, offset);
  offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
  offset += add_ff_wme_status_code(tree, tvb, pinfo, offset);

  return offset - start;  /* Size of fixed fields */
}

static unsigned
add_ff_action_vendor_specific(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  unsigned   start = offset;
  uint32_t oui;
  tvbuff_t *vendor_tvb;
  int dissected;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  proto_tree_add_item_ret_uint(tree, hf_ieee80211_tag_oui, tvb, offset, 3, ENC_BIG_ENDIAN, &oui);
  offset += 3;

  vendor_tvb = tvb_new_subset_remaining(tvb, offset);
  dissected = dissector_try_uint_new(vendor_specific_action_table, oui, vendor_tvb, pinfo, tree, false, NULL);
  if (dissected <= 0)
  {
      call_data_dissector(vendor_tvb, pinfo, tree);
      /* Skip the whole TVB because we don't know its format */
      dissected = tvb_reported_length_remaining(vendor_tvb, 0);
  }

  offset += dissected;

  return offset - start;  /* Size of fixed fields */
}

static unsigned
add_ff_action_ht(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  unsigned  start = offset;
  uint8_t n_sta, i;
  mimo_control_t mimo_cntrl;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  offset += add_ff_ht_action_code(tree, tvb, pinfo, offset);

  switch (tvb_get_uint8(tvb, offset - 1)) {
  case HT_ACTION_NOTIFY_CHAN_WIDTH:
    offset += add_ff_channel_width(tree, tvb, pinfo, offset);
    break;
  case HT_ACTION_SM_PWR_SAVE:
    offset += add_ff_sm_pwr_cntrl(tree, tvb, pinfo, offset);
    break;
  case HT_ACTION_PSMP_ACTION:
    n_sta = tvb_get_uint8(tvb, offset);
    offset += add_ff_psmp_param_set(tree, tvb, pinfo, offset);
    for (i = 0; i < (n_sta & 0x0F); i++) {
      offset += add_ff_psmp_sta_info(tree, tvb, pinfo, offset);
    }
    break;
  case HT_ACTION_SET_PCO_PHASE:
    offset += add_ff_pco_phase_cntrl(tree, tvb, pinfo, offset);
    break;
  case HT_ACTION_MIMO_CSI:
    mimo_cntrl = get_mimo_control(tvb, offset);
    offset += add_ff_mimo_cntrl(tree, tvb, pinfo, offset);
    offset += add_mimo_csi_matrices_report(tree, tvb, offset, mimo_cntrl);
    break;
  case HT_ACTION_MIMO_BEAMFORMING:
    mimo_cntrl = get_mimo_control(tvb, offset);
    offset += add_ff_mimo_cntrl(tree, tvb, pinfo, offset);
    offset += add_mimo_beamforming_feedback_report(tree, tvb, offset,
                                                   mimo_cntrl);
    break;
  case HT_ACTION_MIMO_COMPRESSED_BEAMFORMING:
    mimo_cntrl = get_mimo_control(tvb, offset);
    offset += add_ff_mimo_cntrl(tree, tvb, pinfo, offset);
    offset += add_mimo_compressed_beamforming_feedback_report(tree, tvb,
                                                              offset,
                                                              mimo_cntrl);
    break;
  case HT_ACTION_ANT_SEL_FEEDBACK:
    offset += add_ff_ant_selection(tree, tvb, pinfo, offset);
    break;
  case HT_ACTION_HT_INFO_EXCHANGE:
    offset += add_ff_ht_information(tree, tvb, pinfo, offset);
    break;
  }

  return offset - start;
}

static unsigned
add_ff_beacon_interval_ctrl(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ff_bic,
                                    ett_bic_tree, ieee80211_ff_bic_fields,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);

  return 6;
}

static unsigned
add_ff_beamforming_ctrl(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset, bool isGrant)
{
  uint16_t bf_field = tvb_get_letohs(tvb, offset);
  bool isInit = (bf_field & 0x2) >> 1;
  bool isResp = (bf_field & 0x4) >> 2;
  static int * const ieee80211_ff_beamforming_ctrl[] = {
    &hf_ieee80211_ff_bf_train,
    &hf_ieee80211_ff_bf_is_init,
    &hf_ieee80211_ff_bf_is_resp,
    &hf_ieee80211_ff_bf_rxss_len,
    &hf_ieee80211_ff_bf_rxss_rate,
    &hf_ieee80211_ff_bf_b10b15,
    NULL
  };

  static int * const ieee80211_ff_beamforming_ctrl_grant[] = {
    &hf_ieee80211_ff_bf_train,
    &hf_ieee80211_ff_bf_is_init,
    &hf_ieee80211_ff_bf_is_resp,
    &hf_ieee80211_ff_bf_num_sectors,
    &hf_ieee80211_ff_bf_num_rx_dmg_ants,
    &hf_ieee80211_ff_bf_b12b15,
    NULL
  };

  if((isInit==true) && (isResp==true) && isGrant) {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ff_bf,
                                    ett_bf_tree, ieee80211_ff_beamforming_ctrl_grant,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  } else {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ff_bf,
                                    ett_bf_tree, ieee80211_ff_beamforming_ctrl,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  }
  return 2;
}

static unsigned
add_ff_dynamic_allocation(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  static int * const ieee80211_ff_dynamic_allocation[] = {
    &hf_ieee80211_ff_TID,
    &hf_ieee80211_ff_alloc_type,
    &hf_ieee80211_ff_src_aid,
    &hf_ieee80211_ff_dest_aid,
    &hf_ieee80211_ff_alloc_duration,
    &hf_ieee80211_ff_b39,
    NULL
  };

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ff_dynamic_allocation,
                                    ett_dynamic_alloc_tree, ieee80211_ff_dynamic_allocation,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);

  return 5;
}

static unsigned
add_ff_beamformed_link(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  static int * const ieee80211_ff_beamformed_link[] = {
    &hf_ieee80211_ff_blm_unit_index,
    &hf_ieee80211_ff_blm_maint_value,
    &hf_ieee80211_ff_blm_is_master,
    NULL
  };

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ff_blm,
                                    ett_blm_tree, ieee80211_ff_beamformed_link,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  return 1;
}

static unsigned
add_ff_BRP_request(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  static int * const ieee80211_ff_BRP_request[] = {
    &hf_ieee80211_ff_brp_L_RX,
    &hf_ieee80211_ff_brp_TX_TRN_REQ,
    &hf_ieee80211_ff_brp_MID_REQ,
    &hf_ieee80211_ff_brp_BC_REQ,
    &hf_ieee80211_ff_brp_MID_GRANT,
    &hf_ieee80211_ff_brp_BC_GRANT,
    &hf_ieee80211_ff_brp_chan_FBCK_CAP,
    &hf_ieee80211_ff_brp_tx_sector,
    &hf_ieee80211_ff_brp_other_aid,
    &hf_ieee80211_ff_brp_tx_antenna,
    &hf_ieee80211_ff_brp_reserved,
    NULL
  };

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ff_brp,
                                    ett_brp_tree, ieee80211_ff_BRP_request,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  return 4;
}

static unsigned
add_ff_sector_sweep_feedback_from_iss(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  static int * const ieee80211_ff_sector_sweep_feedback_from_iss[] = {
    &hf_ieee80211_ff_sswf_total_sectors,
    &hf_ieee80211_ff_sswf_num_rx_dmg_ants,
    &hf_ieee80211_ff_sswf_reserved1,
    &hf_ieee80211_ff_sswf_poll_required,
    &hf_ieee80211_ff_sswf_reserved2,
    NULL
  };

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ff_sswf,
                                    ett_sswf_tree, ieee80211_ff_sector_sweep_feedback_from_iss,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  return 3;
}

static unsigned
add_ff_sector_sweep_feedback_to_iss(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  static int * const ieee80211_ff_sector_sweep_feedback_to_iss[] = {
    &hf_ieee80211_ff_sswf_sector_select,
    &hf_ieee80211_ff_sswf_dmg_antenna_select,
    &hf_ieee80211_ff_sswf_snr_report,
    &hf_ieee80211_ff_sswf_poll_required,
    &hf_ieee80211_ff_sswf_reserved2,
    NULL
  };

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ff_sswf,
                                    ett_sswf_tree, ieee80211_ff_sector_sweep_feedback_to_iss,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  return 3;
}

static unsigned
add_ff_sector_sweep(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  static int * const ieee80211_ff_sector_sweep[] = {
    &hf_ieee80211_ff_ssw_direction,
    &hf_ieee80211_ff_ssw_cdown,
    &hf_ieee80211_ff_ssw_sector_id,
    &hf_ieee80211_ff_ssw_dmg_ant_id,
    &hf_ieee80211_ff_ssw_rxss_len,
    NULL
  };

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ff_ssw,
                                    ett_ssw_tree, ieee80211_ff_sector_sweep,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  return 3;
}

static unsigned
add_ff_dmg_params(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  static int * const ieee80211_ff_dmg_params[] = {
    &hf_ieee80211_ff_dmg_params_bss,
    &hf_ieee80211_ff_dmg_params_cbap_only,
    &hf_ieee80211_ff_dmg_params_cbap_src,
    &hf_ieee80211_ff_dmg_params_privacy,
    &hf_ieee80211_ff_dmg_params_policy,
    &hf_ieee80211_ff_dmg_params_spec_mgmt,
    &hf_ieee80211_ff_dmg_params_radio_measure,
    NULL
  };

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ff_dmg_params,
                                    ett_dmg_params_tree, ieee80211_ff_dmg_params,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  return 1;
}

static unsigned
add_ff_cc_field(proto_tree *tree, tvbuff_t *tvb, int offset, bool dis)
{
  proto_item *cc_item = proto_tree_add_item(tree, hf_ieee80211_ff_cc, tvb, offset, 8, ENC_LITTLE_ENDIAN);
  proto_tree *cc_tree = proto_item_add_subtree(cc_item, ett_cc_tree);
  uint64_t cc_field;
  if(dis) {
    proto_tree_add_item(cc_tree, hf_ieee80211_ff_cc_abft_resp_addr, tvb, offset, 6, ENC_NA);
  } else {
    cc_field = tvb_get_letoh64(tvb, offset);
    /*TODO : Add support of bitmask for FT_(U)INT64 */
    proto_tree_add_uint(cc_tree, hf_ieee80211_ff_cc_sp_duration, tvb, offset, 1, (uint32_t)(cc_field & 0xff));
    proto_tree_add_uint64(cc_tree, hf_ieee80211_ff_cc_cluster_id, tvb, offset+1, 6, (uint64_t)((cc_field & UINT64_C(0x00ffffffffffff00)) >> 8));
    proto_tree_add_uint(cc_tree, hf_ieee80211_ff_cc_role, tvb, offset+7, 1, (uint32_t)((cc_field & UINT64_C(0x0300000000000000)) >> 56));
    proto_tree_add_uint(cc_tree, hf_ieee80211_ff_cc_max_mem, tvb, offset+7, 1, (uint32_t)((cc_field & UINT64_C(0x7c00000000000000)) >> 58));
  }
  return 8;
}


static unsigned
add_ff_band_id(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_band_id, tvb, offset, 1, ENC_NA);
  return 1;
}

static unsigned
add_ff_subject_address(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_subject_address, tvb, offset, 6, ENC_NA);
  return 6;
}

static unsigned
add_ff_handover_reason(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_handover_reason, tvb, offset, 1, ENC_NA);
  return 1;
}

static unsigned
add_ff_handover_remaining_bi(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_handover_remaining_bi, tvb, offset, 1, ENC_NA);
  return 1;
}

static unsigned
add_ff_handover_result(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_handover_result, tvb, offset, 1, ENC_NA);
  return 1;
}

static unsigned
add_ff_handover_reject_reason(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_handover_reject_reason, tvb, offset, 1, ENC_NA);
  return 1;
}

static unsigned
add_ff_destination_reds_aid(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_destination_reds_aid, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_destination_aid(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_destination_aid, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_relay_aid(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_relay_aid, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_source_aid(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_source_aid, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_timing_offset(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_timing_offset, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_sampling_frequency_offset(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_sampling_frequency_offset, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  return 2;
}

static unsigned
add_ff_relay_operation_type(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_relay_operation_type, tvb, offset, 1, ENC_NA);
  return 1;
}

static unsigned
add_ff_fst_action_code(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_fst_action_code, tvb, offset, 1, ENC_NA);
  return 1;
}

static unsigned
add_ff_robust_av_streaming_action_code(proto_tree *tree, tvbuff_t *tvb,
                                       packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_robust_av_streaming_action_code,
                      tvb, offset, 1, ENC_NA);
  return 1;
}

static unsigned
add_ff_llt(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_llt, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  return 4;
}

static unsigned
add_ff_fsts_id(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_fsts_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  return 4;
}

static unsigned
add_ff_oct_mmpdu(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  unsigned start = offset;
  unsigned len = tvb_get_letohs(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_ff_mmpdu_len, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;
  proto_tree_add_item(tree, hf_ieee80211_ff_mmpdu_ctrl, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;
  proto_tree_add_item(tree, hf_ieee80211_ff_oct_mmpdu, tvb, offset, len, ENC_NA);
  offset += len;
  return offset - start;
}

static int * const eht_eml_control_field_mode_headers[] = {
  &hf_ieee80211_eht_eml_control_emlsr_mode,
  &hf_ieee80211_eht_eml_control_emlmr_mode,
  &hf_ieee80211_eht_eml_control_emlsr_para_update_control,
  &hf_ieee80211_eht_eml_control_device_coexist_activities,
  &hf_ieee80211_eht_eml_control_reserved,
  NULL
};

static int * const eht_emlsr_para_update_headers[] = {
  &hf_ieee80211_eht_emlsr_para_update_padding_delay,
  &hf_ieee80211_eht_emlsr_para_update_tran_delay,
  &hf_ieee80211_eht_emlsr_para_update_reserved,
  NULL
};

static int * const eht_eml_control_mcs_map_count_headers[] = {
  &hf_ieee80211_eht_eml_control_mcs_map_count_bw,
  &hf_ieee80211_eht_eml_control_mcs_map_count_reserved,
  NULL
};

static const value_string eht_eml_control_mcs_map_count_bw[] = {
  {0x00, "80 MHz"},
  {0x01, "160 MHz"},
  {0x02, "320 MHz"},
  {0, NULL}
};

static int * const eht_le_80_mcs_map_hdrs[] = {
  &hf_ieee80211_eht_le_80_rx_max_nss_0_9,
  &hf_ieee80211_eht_le_80_tx_max_nss_0_9,
  &hf_ieee80211_eht_le_80_rx_max_nss_10_11,
  &hf_ieee80211_eht_le_80_tx_max_nss_10_11,
  &hf_ieee80211_eht_le_80_rx_max_nss_12_13,
  &hf_ieee80211_eht_le_80_tx_max_nss_12_13,
  NULL
};

static int * const eht_160_mcs_map_hdrs[] = {
  &hf_ieee80211_eht_160_rx_max_nss_0_9,
  &hf_ieee80211_eht_160_tx_max_nss_0_9,
  &hf_ieee80211_eht_160_rx_max_nss_10_11,
  &hf_ieee80211_eht_160_tx_max_nss_10_11,
  &hf_ieee80211_eht_160_rx_max_nss_12_13,
  &hf_ieee80211_eht_160_tx_max_nss_12_13,
  NULL
};

static int * const eht_320_mcs_map_hdrs[] = {
  &hf_ieee80211_eht_320_rx_max_nss_0_9,
  &hf_ieee80211_eht_320_tx_max_nss_0_9,
  &hf_ieee80211_eht_320_rx_max_nss_10_11,
  &hf_ieee80211_eht_320_tx_max_nss_10_11,
  &hf_ieee80211_eht_320_rx_max_nss_12_13,
  &hf_ieee80211_eht_320_tx_max_nss_12_13,
  NULL
};

static unsigned
dissect_eht_eml_control_field(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  unsigned start = offset;
  unsigned len = tvb_captured_length_remaining(tvb, offset);
  uint8_t mode = tvb_get_uint8(tvb, offset);
  uint8_t mcs_map_count;
  proto_item *link_map_item;
  proto_tree *link_map_tree;
  uint16_t bmap, f;

  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_eht_eml_control_field,
                                    ett_eht_eml_control,
                                    eht_eml_control_field_mode_headers,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  if (mode & 0x03) { /* EMLSR or EMLMR*/
    if (len < 3) {
      expert_add_info_format(pinfo, tree, &ei_ieee80211_eht_invalid_action, "EMLSR or EMLMR length %u is wrong", len);
      return len;
    }
    link_map_item = proto_tree_add_item(tree,
                      hf_ieee80211_eht_eml_control_link_bitmap,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
    link_map_tree = proto_item_add_subtree(link_map_item,
                     ett_eht_eml_control_link_map);
    bmap = tvb_get_letohs(tvb, offset);
    for (f = 0; f < 16; f++) {
      if (bmap & (1 << f)) {
        proto_tree_add_uint_format_value(link_map_tree,
          hf_ieee80211_eht_eml_control_link_enable_id,
          tvb, offset + (f/8), 1, f, "%u", f);
      }
    }
    offset += 2;
  }
  if (mode & 0x02) { /* EMLMR */
    if (len < 7) {
      expert_add_info_format(pinfo, tree, &ei_ieee80211_eht_invalid_action, "EMLMR length %u is wrong", len);
      return len;
    }
    mcs_map_count = tvb_get_uint8(tvb, offset) & 0x03;
    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
        hf_ieee80211_eht_eml_control_mcs_map_count,
        ett_eht_eml_control_mcs_map_count,
        eht_eml_control_mcs_map_count_headers, ENC_LITTLE_ENDIAN,
        BMT_NO_APPEND);
    offset++;

    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
      hf_ieee80211_eht_mcs_and_nss_le_80mhz,
      ett_eht_phy_mcs_nss_set,
      eht_le_80_mcs_map_hdrs,
      ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 3;
    if (mcs_map_count >= 1) {
      proto_tree_add_bitmask_with_flags(tree, tvb, offset,
        hf_ieee80211_eht_mcs_and_nss_eq_160mhz,
        ett_eht_phy_mcs_nss_set,
        eht_160_mcs_map_hdrs,
        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
      offset += 3;
    }
    if (mcs_map_count >= 2) {
      proto_tree_add_bitmask_with_flags(tree, tvb, offset,
        hf_ieee80211_eht_mcs_and_nss_eq_320mhz,
        ett_eht_phy_mcs_nss_set,
        eht_320_mcs_map_hdrs,
        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
      offset += 3;
    }
  }

  if (mode & 0x04) { /* EMLSR Parameter Update */
    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
      hf_ieee80211_eht_emlsr_para_update, ett_eht_emlsr_para_update,
      eht_emlsr_para_update_headers, ENC_LITTLE_ENDIAN,
      BMT_NO_APPEND);
    offset++;
  }

  return offset - start;
}

static int
add_tag_relay_capabilities(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  static int * const ieee80211_tag_relay_capabilities[] = {
    &hf_ieee80211_tag_relay_support,
    &hf_ieee80211_tag_relay_use,
    &hf_ieee80211_tag_relay_permission,
    &hf_ieee80211_tag_AC_power,
    &hf_ieee80211_tag_relay_prefer,
    &hf_ieee80211_tag_duplex,
    &hf_ieee80211_tag_cooperation,
    NULL
  };

  if (tag_len < 2) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag length must be 2");
    return 1;
  }

  proto_tree_add_bitmask_list(tree, tvb, offset, 1, ieee80211_tag_relay_capabilities, ENC_NA);
  return tvb_captured_length(tvb);
}

#if 0
static unsigned
add_ff_relay_capable_sta_info(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  proto_item *rcsi_item = proto_tree_add_item(tree, hf_ieee80211_ff_rcsi, tvb, offset, 3, ENC_LITTLE_ENDIAN);
  proto_tree *rcsi_tree = proto_item_add_subtree(rcsi_item, ett_rcsi_tree);
  proto_tree_add_item(rcsi_tree, hf_ieee80211_ff_rcsi_aid, tvb, offset, 1, ENC_NA);
  offset += 1;
  add_tag_relay_capabilities(pinfo, rcsi_item, 2, rcsi_tree, tvb, &offset);
  return 3;
}
#endif

#define NEXT_TBTT_PRESENT       0x01
#define COMPRESSED_SSID_PRESENT 0x02
#define ANO_PRESENT             0x04

static void
dissect_ieee80211_extension(uint16_t fcf, tvbuff_t *tvb, packet_info *pinfo,
                            proto_tree *tree, uint16_t flags)
{
  proto_item *ti;
  proto_tree *ext_tree;
  proto_tree *fixed_tree;
  proto_tree *tagged_tree;

  int offset = 0;
  int tagged_parameter_tree_len;

  ti = proto_tree_add_item(tree, proto_wlan_ext, tvb, offset, -1, ENC_NA);
  ext_tree = proto_item_add_subtree(ti, ett_80211_ext);

  switch (COMPOSE_FRAME_TYPE(fcf))
  {
    case EXTENSION_DMG_BEACON:
    {
      bool cc, dis;
      uint16_t bic_field;
      fixed_tree = get_fixed_parameter_tree(ext_tree, tvb, offset, 20, false);
      offset += add_ff_timestamp(fixed_tree, tvb, pinfo, offset);
      offset += add_ff_sector_sweep(fixed_tree, tvb, pinfo, offset);
      offset += add_ff_beacon_interval(fixed_tree, tvb, pinfo, offset);
      bic_field = tvb_get_letohs(tvb, offset);
      cc = (bic_field & 0x1);
      dis  = (bic_field & 0x2) >> 1;
      offset += add_ff_beacon_interval_ctrl(fixed_tree, tvb, pinfo, offset);
      offset += add_ff_dmg_params(fixed_tree, tvb, pinfo, offset);
      if(cc) {
        offset += add_ff_cc_field(fixed_tree, tvb, offset, dis);
      }
      tagged_parameter_tree_len = tvb_reported_length_remaining(tvb, offset);

      /*
       * The tagged params are optional here. See Table 8.33a of the 2012
       * version of the standard.
       */
      if (tagged_parameter_tree_len) {
        tagged_tree = get_tagged_parameter_tree(ext_tree, tvb, offset, tagged_parameter_tree_len);
        ieee_80211_add_tagged_parameters(tvb, offset, pinfo, tagged_tree, tagged_parameter_tree_len, EXTENSION_DMG_BEACON, NULL);
      }
      break;
    }
    case EXTENSION_S1G_BEACON:
    {
        int params_size = 5;

        if (flags & NEXT_TBTT_PRESENT) params_size += 3;
        if (flags & COMPRESSED_SSID_PRESENT) params_size += 4;
        if (flags & ANO_PRESENT) params_size += 1;

        fixed_tree = get_fixed_parameter_tree( ext_tree, tvb, offset, params_size, false);
        offset += add_ff_s1g_timestamp(fixed_tree, tvb, pinfo, offset);
        offset += add_ff_change_sequence(fixed_tree, tvb, pinfo, offset);
        if (flags & NEXT_TBTT_PRESENT)
          offset += add_ff_next_tbtt(fixed_tree, tvb, pinfo, offset);
        if (flags & COMPRESSED_SSID_PRESENT)
          offset += add_ff_compressed_ssid(fixed_tree, tvb, pinfo, offset);
        if (flags & ANO_PRESENT)
          offset += add_ff_access_network_options(fixed_tree, tvb, pinfo, offset);

        tagged_parameter_tree_len = tvb_reported_length_remaining(tvb, offset);

        if (tagged_parameter_tree_len) {
          tagged_tree = get_tagged_parameter_tree(ext_tree, tvb, offset, tagged_parameter_tree_len);
          ieee_80211_add_tagged_parameters(tvb, offset, pinfo, tagged_tree, tagged_parameter_tree_len, EXTENSION_S1G_BEACON, NULL);
        }
    }
  }
}

static unsigned
add_ff_action_unprotected_dmg(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  uint8_t code;
  unsigned  start = offset;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  code    = tvb_get_uint8(tvb, offset);
  offset += add_ff_unprotected_dmg_action_code(tree, tvb, pinfo, offset);
  switch (code) {
    case UNPROTECTED_DMG_ANNOUNCE:
      offset += add_ff_timestamp(tree, tvb, pinfo, offset);
      offset += add_ff_beacon_interval(tree, tvb, pinfo, offset);
      break;
    case UNPROTECTED_DMG_BRP:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_BRP_request(tree, tvb, pinfo, offset);
      break;
  }
  return offset - start;
}

/* There is no easy way to skip all these subcarrier indices that must not
 * be displayed when showing compressed beamforming feedback matrices
 * Table 8-53g IEEE Std 802.11ac-2013 amendment.
 *
 * The irregular use of case statements in this function is to improve
 * readability in what is otherwise a large function that does very little.
 */
static inline int
vht_compressed_skip_scidx(uint8_t nchan_width, uint8_t ng, int scidx)
{
  switch(nchan_width) {
    /* 20 MHz */
    case 0:
      /* No Grouping */
      if (ng == 0)
        switch (scidx) {
          /* Pilot subcarriers */
          case -21: case -7: case 7: case 21:
          /* DC subcarrier */
          case 0:
            scidx++;
          default:
            break;
        }
      break;
    /* 40 MHz */
    case 1:
      /* No Grouping */
      if (ng == 0)
        switch (scidx) {
          /* Pilot subcarriers */
          case -53: case -25: case -11: case 11: case 25: case 53:
            scidx++;
            break;
          /* DC subcarriers */
          case -1: case 0: case 1:
            scidx = 2;
          default:
            break;
        }
      break;
    /* 80 MHz */
    case 2:
      /* No Grouping */
      if (ng == 0)
        switch (scidx) {
          /* Pilot subcarriers */
          case -103: case -75: case -39: case -11: case 11: case 39: case 75: case 103:
            scidx++;
            break;
          /* DC subcarriers, skip -1, 0, 1 */
          case -1:
            scidx = 2;
          default:
            break;
        }
      break;
    /* 160 MHz / 80+80 Mhz
     * Skip values here assume 160 MHz, as vht_mimo_control does not let us differentiate
     * between 160 MHz & 80-80MHz */
    case 3:
      switch (ng) {
        /* No Grouping */
        case 0:
          /* DC subcarriers, skip -5 to 5*/
          if (scidx == -5) {
            scidx = 6;
            break;
          }
          switch (scidx) {
            /* Pilot subcarriers */
            case -231: case -203: case -167: case -139: case -117: case -89: case -53: case -25:
            case 25: case 53: case 89: case 117: case 139: case 167: case 203: case 231:
              scidx++;
              break;
            /* Other subcarriers, skip -129 to -127, 127 to 129 */
            case -129:
              scidx = -126;
              break;
            case 127:
              scidx = 130;
              break;
            default:
              break;
          }
          break;
        /* Grouping of 2 */
        case 1:
          switch (scidx) {
            /* DC subcarriers */
            case -128: case -4: case -2: case 0: case 2: case 4: case 128:
              scidx++;
            default:
              break;
          }
          break;
        /* Grouping of 4 */
        case 2:
          if (scidx == -2 || scidx == 2)
            scidx++;
          break;
      }
      break;
    default:
      break;
  }

  return scidx;
}

static inline int vht_exclusive_skip_scidx(uint8_t nchan_width, uint8_t ng, int scidx)
{
  switch (nchan_width) {
    /* 20 MHz */
    case 0:
      switch (ng) {
        /* No Grouping */
        case 0:
          if (scidx == -2 || scidx == 1)
              scidx++;
          else
              scidx = scidx + 2;
          break;
        case 1:
          switch (scidx) {
            case -4: case 1:
              scidx = scidx + 3;
              break;
            case -1:
              scidx = 1;
              break;
            default:
              scidx = scidx + 4;
              break;
          }
          break;
        default:
          switch (scidx) {
            case -4: case 1:
              scidx = scidx + 3;
              break;
            case -1:
              scidx = 1;
              break;
            default:
              scidx = scidx + 8;
              break;
          }
          break;
      }
      break;
    /* 40 MHz */
    case 1:
    /* 80 MHz */
    case 2:
      switch (ng) {
        /* No Grouping */
        case 0:
          if (scidx == -2)
            scidx = 2;
          else
            scidx = scidx + 2;
          break;
        case 1:
          scidx = scidx + 4;
          break;
        default:
          if (scidx == -2)
            scidx = 2;
          else
            scidx = scidx + 8;
          break;
      }
      break;
    /* 160 MHz / 80+80 Mhz */
    case 3:
      switch (ng) {
        /* No Grouping */
        case 0:
          switch (scidx) {
            /* DC subcarriers, skip -4 to 4*/
            case -6:
              scidx = 6;
              break;
            /* Other subcarriers, skip -128, 128 */
            case -130:
              scidx = -126;
              break;
            case 126:
              scidx = 130;
              break;
            default:
              scidx = scidx + 2;
              break;
          }
          break;
        case 1:
          switch (scidx) {
            /* DC subcarriers, skip -4 to 4*/
            case -6:
              scidx = 6;
              break;
            default:
              scidx = scidx + 4;
              break;
          }
          break;
        default:
          switch (scidx) {
            case -6:
              scidx = 6;
              break;
            case -130:
              scidx = -126;
              break;
            case 126:
              scidx = 130;
              break;
            default:
              scidx = scidx + 8;
              break;
          }
        break;
      }
      break;
    default:
      break;
  }
  return scidx;
}

static int
dissect_he_feedback_matrix(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,
                           int offset, int bit_offset, int scidx,
                           int nr, int nc,
                           int phi_bits, int psi_bits,
                           int hf);

static unsigned
add_ff_vht_compressed_beamforming_report(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  uint32_t vht_mimo;
  uint8_t nc;
  uint8_t nr;
  uint8_t chan_width;
  uint8_t grouping;
  bool codebook_info;
  bool feedback_type;
  proto_item *vht_beam_item, *vht_excl_beam_item;
  proto_tree *vht_beam_tree, *subtree, *vht_excl_beam_tree;
  int i, len, pos, ns, scidx = 0;
  uint8_t phi, psi, carry;
  int j, ic, off_len = 0, sscidx = 0, xnsc;
  int bit_offset = 0;
  int start_offset = 0;
  /* Table 8-53g Subcarriers for which a Compressed Beamforming Feedback Matrix
   * subfield is sent back. IEEE Std 802.11ac-2013 amendment */
  static const int ns_arr[4][3] = { {  52,  30,  16 },
                                    { 108,  58,  30 },
                                    { 234, 122,  62 },
                                    { 468, 244, 124 }
                                  };

  /* Table 8-53j, no of Subcarriers for which the Delta SNR subfield is sent back to the beamformer.
   * IEEE Std 802.11ac-2013 amendment */
  static const int delta_ns_arr[4][3] = { {  30,  16,  10 },
                                          {  58,  30,  16 },
                                          { 122,  62,  32 },
                                          { 244, 124,  64 }
                                        };

  vht_mimo = tvb_get_letoh24(tvb, offset);
  proto_tree_add_bitmask(tree, tvb, offset, hf_ieee80211_ff_vht_mimo_cntrl,
                        ett_ff_vhtmimo_cntrl, hf_ieee80211_ff_vht_mimo_cntrl_fields, ENC_LITTLE_ENDIAN);
  offset += 3;

  /* Extract values for beamforming use */
  nc = (vht_mimo & 0x7) + 1;
  nr = ((vht_mimo & 0x38) >> 3) + 1;
  chan_width = (vht_mimo & 0xC0) >> 6;
  grouping = ((vht_mimo & 0x300) >> 8);
  codebook_info = (vht_mimo & 0x400) >> 10;
  feedback_type = (vht_mimo & 0x800) >> 11;

  if (feedback_type) {
    if (codebook_info) {
      psi = 7; phi = 9;
    } else {
      psi = 5; phi = 7;
    }
  } else {
    if (codebook_info) {
      psi = 4; phi = 6;
    } else {
      psi = 2; phi = 4;
    }
  }

  vht_beam_item = proto_tree_add_item(tree, hf_ieee80211_vht_compressed_beamforming_report, tvb,
                                  offset, -1, ENC_NA);
  vht_beam_tree = proto_item_add_subtree(vht_beam_item, ett_ff_vhtmimo_beamforming_report);

  subtree = proto_tree_add_subtree(vht_beam_tree, tvb, offset, nc,
                        ett_ff_vhtmimo_beamforming_report_snr, NULL, "Average Signal to Noise Ratio");

  for (i = 1; i <= nc; i++)
  {
    int8_t snr;
    char edge_sign;

    snr = tvb_get_int8(tvb, offset);

    switch(snr) {
      case -128:
        edge_sign = '<';
        break;
      case 127:
        edge_sign = '>';
        break;
      default:
        edge_sign = ' ';
        break;
    }

    proto_tree_add_int_format(subtree, hf_ieee80211_vht_compressed_beamforming_report_snr, tvb, offset, 1,
                               snr, "Stream %d - Signal to Noise Ratio: %c%3.2fdB", i, edge_sign,snr/4.0+22.0);

    offset += 1;
  }

  /* Table 8-53c Subfields of the VHT MIMO Control field (802.11ac-2013)
   * reserves value 3 of the Grouping subfield. */
  if (grouping == 3) {
    expert_add_info_format(pinfo, vht_beam_item, &ei_ieee80211_inv_val,
                           "Grouping subfield value 3 is reserved");
    return offset;
  }

  start_offset = offset;
  subtree = proto_tree_add_subtree(vht_beam_tree, tvb, offset, -1,
                        ett_ff_vhtmimo_beamforming_report_feedback_matrices,
                        NULL, "Feedback Matrices");

  ns = ns_arr[chan_width][grouping];
  switch(chan_width) {
    case 0:
      scidx = -28;
      break;
    case 1:
      scidx = -58;
      break;
    case 2:
      scidx = -122;
      break;
    case 3:
      /* This is -122 for 80+80MHz Channel Width but vht_mimo_control does not allow us
       * to differentiate between 160MHz and 80+80Mhz */
      scidx = -250;
      break;
  }

  bit_offset = offset * 8;
  for (i = 0; i < ns; i++) {

    scidx = vht_compressed_skip_scidx(chan_width, grouping, scidx);

    bit_offset = dissect_he_feedback_matrix(subtree, tvb, pinfo, offset,
                                    bit_offset, scidx++, nr, nc, phi, psi,
                                    hf_ieee80211_vht_compressed_beamform_scidx);
    offset = bit_offset / 8;
  }

  proto_item_set_len(subtree, offset - start_offset);

  if (feedback_type) {
    xnsc = delta_ns_arr[chan_width][grouping];
    if ((nc * xnsc *4) % 8)
        off_len = (nc * xnsc *4) / 8 + 1;
    else
        off_len = (nc * xnsc *4) / 8;
    switch(chan_width) {
      case 0:
        sscidx = -28;
        break;
      case 1:
        sscidx = -58;
        break;
      case 2:
        sscidx = -122;
        break;
      case 3:
        sscidx = -250;
        break;
    }
    vht_excl_beam_item = proto_tree_add_item(tree, hf_ieee80211_vht_mu_exclusive_beamforming_report, tvb, offset, off_len, ENC_NA);
    vht_excl_beam_tree = proto_item_add_subtree(vht_excl_beam_item, ett_ff_vhtmu_exclusive_beamforming_report_matrices);

    carry = 1;
    for (j = 1; j <= xnsc; j++) {
      for (ic = 1; ic <= nc; ic++) {
        if (carry % 2){
          pos = 0;
          len = 1;
        }
        else
        {
          pos = 1;
          len = 0;
        }
        proto_tree_add_none_format(vht_excl_beam_tree, hf_ieee80211_vht_mu_exclusive_beamforming_delta_snr, tvb,
                                      offset - pos, 1, "Delta SNR for space-time stream %d for subcarrier %d", ic, sscidx);
        offset += len;
        carry ++;
      }
      sscidx = vht_exclusive_skip_scidx(chan_width, grouping, sscidx);
    }
  }

  return offset;
}

static unsigned
add_ff_action_vht(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  unsigned start = offset;
  uint8_t vht_action, field_val;
  uint64_t msa_value;
  uint64_t upa_value;
  int m;
  proto_item *ti;
  proto_tree *ti_tree;
  proto_item *msa, *upa;
  proto_tree *msa_tree, *upa_tree;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);

  vht_action = tvb_get_uint8(tvb, offset);
  offset += add_ff_vht_action(tree, tvb, pinfo, offset);

  switch(vht_action){
    case VHT_ACT_VHT_COMPRESSED_BEAMFORMING:{
      offset = add_ff_vht_compressed_beamforming_report(tree, tvb, pinfo, offset);
      offset += tvb_reported_length_remaining(tvb, offset);
    }
    break;
    case VHT_ACT_GROUP_ID_MANAGEMENT:{
      ti = proto_tree_add_item(tree, hf_ieee80211_vht_group_id_management, tvb,
                          offset, -1, ENC_NA);
      ti_tree = proto_item_add_subtree(ti, ett_vht_grpidmgmt);

      msa_value = tvb_get_letoh64(tvb, offset);
      msa = proto_tree_add_item(ti_tree, hf_ieee80211_vht_membership_status_array, tvb,
                                offset, 8, ENC_NA);
      msa_tree = proto_item_add_subtree(msa, ett_vht_msa);
      for (m = 0; m < 64; m++) {
          if (msa_value & (INT64_C(1) << m))
              proto_tree_add_uint_format(msa_tree, hf_ieee80211_vht_membership_status_field,
                                               tvb, offset + (m/8), 1, 1, "Membership Status in Group ID %d: 1", m);
      }
      offset += 8;

      upa = proto_tree_add_item(ti_tree, hf_ieee80211_vht_user_position_array, tvb,
                                      offset, 16, ENC_NA);
      upa_tree = proto_item_add_subtree(upa, ett_vht_upa);

      upa_value = tvb_get_letoh64(tvb, offset);
      for (m = 0; m < 32; m++) {
          if (msa_value & (INT64_C(1) << m)) {
              field_val = (uint8_t) ((upa_value >> m*2) & 0x3);
              proto_tree_add_uint_format(upa_tree, hf_ieee80211_vht_user_position_field,
                                               tvb, offset + (m/4), 1, field_val, "User Position in Group ID %d: %u", m, field_val);
          }
      }
      upa_value = tvb_get_letoh64(tvb, offset+8);
      for (m = 0; m < 32; m++) {
          if (msa_value & (INT64_C(1) << (32+m))) {
              field_val = (uint8_t) ((upa_value >> m*2) & 0x3);
              proto_tree_add_uint_format(upa_tree, hf_ieee80211_vht_user_position_field,
                                               tvb, (offset + 8) + (m/4), 1, field_val, "User Position in Group ID %d: %u", m, field_val);
          }
      }
      offset += tvb_reported_length_remaining(tvb, offset);
    }
    break;
    case VHT_ACT_OPERATION_MODE_NOTIFICATION:{
      ti = proto_tree_add_item(tree, hf_ieee80211_vht_operation_mode_notification, tvb,
                          offset, -1, ENC_NA);
      expert_add_info(pinfo, ti, &ei_ieee80211_vht_action);
      offset += tvb_reported_length_remaining(tvb, offset);
    }
    break;
    default:
    break;
  }


  return offset - start;
}

static int * const s1g_sync_control_headers[] = {
  &hf_ieee80211_s1g_sync_control_uplink_sync_request,
  &hf_ieee80211_s1g_sync_control_time_slot_protection_request,
  &hf_ieee80211_s1g_sync_control_reserved,
  NULL
};

static int
add_ff_sync_control(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  int start = offset;

  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_s1g_sync_control,
                                    ett_s1g_sync_control_tree,
                                    s1g_sync_control_headers,
                                    ENC_LITTLE_ENDIAN, BMT_NO_FLAGS);
  offset += 1;

  return offset - start;
}

static int * const s1g_sector_id_index_headers[] = {
  &hf_ieee80211_s1g_sector_id_preferred_sector_id,
  &hf_ieee80211_s1g_sector_id_snr,
  &hf_ieee80211_s1g_sector_id_receive_sector_bitmap,
  NULL
};

static void
s1g_sector_id_index_snr_custom(char *result, uint16_t snr)
{
  switch (snr) {
  case 0:
    snprintf(result, ITEM_LABEL_LENGTH, "%s", "Less than or equal to -3dB");
    break;
  case 30:
    snprintf(result, ITEM_LABEL_LENGTH, "%s", "Greater than or equal to 27dB");
    break;
  case 31:
    snprintf(result, ITEM_LABEL_LENGTH, "%s", "No Feedback");
    break;
  default:
    snprintf(result, ITEM_LABEL_LENGTH, "%ddB", snr - 3);
  }
}

static int
add_ff_sector_id_index(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  int start = offset;

  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_s1g_sector_id_index,
                                    ett_s1g_sector_id_index,
                                    s1g_sector_id_index_headers,
                                    ENC_LITTLE_ENDIAN, BMT_NO_FLAGS);
  offset += 2;

  return offset - start;
}

static int * const s1g_twt_information_control_headers[] = {
  &hf_ieee80211_s1g_twt_flow_identifier,
  &hf_ieee80211_s1g_twt_response_required,
  &hf_ieee80211_s1g_twt_next_twt_request,
  &hf_ieee80211_s1g_twt_next_twt_subfield_size,
  &hf_ieee80211_s1g_twt_reserved,
  NULL
};

static int
add_ff_twt_information(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  int start = offset;
  uint8_t control = tvb_get_uint8(tvb, offset);

  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_s1g_twt_information_control,
                                    ett_s1g_twt_information_control,
                                    s1g_twt_information_control_headers,
                                    ENC_LITTLE_ENDIAN, BMT_NO_FLAGS);
  offset += 1;

  if (control & 0x60) {
    int len_bits = ((control >> 5) & 0x03);
    int len = 0;

    switch (len_bits) {
    case 0:
      len = 0; /* Should not happen! */
      break;
    case 1:
      len = 4;
      proto_tree_add_item(tree, hf_ieee80211_s1g_twt_next_twt_32, tvb, offset,
                          len, ENC_LITTLE_ENDIAN);
      break;
    case 2:
      len = 6;
      proto_tree_add_item(tree, hf_ieee80211_s1g_twt_next_twt_48, tvb, offset,
                          len, ENC_LITTLE_ENDIAN);
      break;
    case 3:
      len = 8;
      proto_tree_add_item(tree, hf_ieee80211_s1g_twt_next_twt_64, tvb, offset,
                          len, ENC_LITTLE_ENDIAN);
      break;
    }

    offset += len;
  }

  return offset - start;
}

static unsigned
add_ff_s1g_twt_setup(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  const uint8_t ids[] = { TAG_TWT };
  unsigned start = offset;

  offset += add_tagged_field(pinfo, tree, tvb, offset, 0, ids, G_N_ELEMENTS(ids), NULL);

  return offset - start;
}

static int * const ieee80211_twt_individual_flow[] = {
  &hf_ieee80211_twt_individual_flow_id,
  &hf_ieee80211_twt_individual_reserved,
  &hf_ieee80211_twt_neg_type,
  &hf_ieee80211_twt_bcast_teardown_all_twt,
  NULL,
};
static int * const ieee80211_twt_bcast_flow[] = {
  &hf_ieee80211_twt_bcast_id,
  &hf_ieee80211_twt_neg_type,
  &hf_ieee80211_twt_bcast_teardown_all_twt,
  NULL,
};
static int * const ieee80211_twt_neg_type2[] = {
  &hf_ieee80211_twt_neg_type2_reserved1,
  &hf_ieee80211_twt_neg_type,
  &hf_ieee80211_twt_neg_type2_reserved2,
  NULL,
};
static int * const ieee80211_twt_teardown_all[] = {
  &hf_ieee80211_twt_bcast_twt_id_reserved,
  &hf_ieee80211_twt_bcast_neg_type_reserved,
  &hf_ieee80211_twt_bcast_teardown_all_twt,
  NULL,
};

static unsigned
add_ff_s1g_twt_teardown(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  uint8_t twt_flow_id = tvb_get_uint8(tvb, offset);

  // Bit 7 is means Teardown All TWT, and the other fields are reserved
  if (twt_flow_id & 0x80) {
    proto_tree_add_bitmask(tree, tvb, offset,
                           hf_ieee80211_twt_bcast_teardown_all,
                           ett_twt_tear_down_tree,
                           ieee80211_twt_teardown_all,
                           ENC_NA);
    return 1;
  }

  // Bits 5 and 6 are the negotiation type - See ieee80211.ax/D3.0 9.6.25.9
  switch ((twt_flow_id & 0x60) >> 5) {
    case 2:
      proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                        hf_ieee80211_twt_bcast_flow,
                                        ett_twt_tear_down_tree, ieee80211_twt_neg_type2,
                                        ENC_LITTLE_ENDIAN, BMT_NO_FLAGS);
      break;

    case 3:
      // According to 11ax, first 5 bits are the BCAST TWT flow ID
      proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                        hf_ieee80211_twt_bcast_flow,
                                        ett_twt_tear_down_tree, ieee80211_twt_bcast_flow,
                                        ENC_LITTLE_ENDIAN, BMT_NO_FLAGS);
    break;
    case 0:
    case 1:
      // According to 11ah / 11ax, first 3 bits are the UCAST TWT flow ID
      proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                        hf_ieee80211_twt_individual_flow,
                                        ett_twt_tear_down_tree, ieee80211_twt_individual_flow,
                                        ENC_LITTLE_ENDIAN, BMT_NO_FLAGS);
      break;
    default:
      proto_tree_add_expert(tree, pinfo, &ei_ieee80211_twt_tear_down_bad_neg_type,
                            tvb, offset, tvb_reported_length_remaining(tvb, offset));
  }

  // The TWT Flow ID size
  return 1;
}

static unsigned
add_ff_action_s1g(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  unsigned start = offset;
  uint8_t s1g_action;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);

  s1g_action = tvb_get_uint8(tvb, offset);
  offset += add_ff_s1g_action(tree, tvb, pinfo, offset);

  switch(s1g_action) {
  case S1G_ACT_AID_SWITCH_REQUEST:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
    break;
  case S1G_ACT_AID_SWITCH_RESPONSE:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
    break;
  case S1G_ACT_SYNC_CONTROL:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    offset += add_ff_sync_control(tree, tvb, pinfo, offset);
    break;
  case S1G_ACT_STA_INFO_ANNOUNCE:
    offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
     break;
  case S1G_ACT_EDCA_PARAM_SET:
    offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
    break;
  case S1G_ACT_EL_OPERATION:
    offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
    break;
  case S1G_ACT_TWT_SETUP:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    offset += add_ff_s1g_twt_setup(tree, tvb, pinfo, offset);
    break;
  case S1G_ACT_TWT_TEARDOWN:
    offset += add_ff_s1g_twt_teardown(tree, tvb, pinfo, offset);
    break;
  case S1G_ACT_SECT_GROUP_ID_LIST:
    offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
    break;
  case S1G_ACT_SECT_ID_FEEDBACK:
    offset += add_ff_sector_id_index(tree, tvb, pinfo, offset);
    break;
  case S1G_ACT_TWT_INFORMATION:
    offset += add_ff_twt_information(tree, tvb, pinfo, offset);
    break;
  default:
    break;
  }

  return offset - start;
}

static unsigned
add_ff_action_protected_s1g(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  unsigned start = offset;
  uint8_t s1g_action;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);

  s1g_action = tvb_get_uint8(tvb, offset);
  offset += add_ff_prot_s1g_action(tree, tvb, pinfo, offset);

  switch(s1g_action) {
    case PROT_S1G_ACT_REACH_ADDR_UPDATE:
    case PROT_S1G_ACT_RELAY_ACTIVATE_REQ:
    case PROT_S1G_ACT_RELAY_ACTIVATE_RESP:
    case PROT_S1G_ACT_HEADER_COMPRESSION:
      // TODO
      break;
    case PROT_S1G_ACT_TWT_SETUP:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_s1g_twt_setup(tree, tvb, pinfo, offset);
      break;
    case PROT_S1G_ACT_TWT_TEARDOWN:
      offset += add_ff_s1g_twt_teardown(tree, tvb, pinfo, offset);
      break;
    case PROT_S1G_ACT_TWT_INFORMATION:
      offset += add_ff_twt_information(tree, tvb, pinfo, offset);
      break;
    case PROT_S1G_ACT_AID_SWITCH_REQUEST:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
      break;
    case PROT_S1G_ACT_AID_SWITCH_RESPONSE:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
      break;
    case PROT_S1G_ACT_SYNC_CONTROL:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_sync_control(tree, tvb, pinfo, offset);
      break;
    case PROT_S1G_ACT_STA_INFO_ANNOUNCE:
      offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
      break;
    case PROT_S1G_ACT_EDCA_PARAM_SET:
      offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
      break;
    case PROT_S1G_ACT_EL_OPERATION:
      offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
      break;
    case PROT_S1G_ACT_SECT_GROUP_ID_LIST:
      offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
      break;
    case PROT_S1G_ACT_SECT_ID_FEEDBACK:
      offset += add_ff_sector_id_index(tree, tvb, pinfo, offset);
      break;
    default:
      break;
  }

  return offset - start;
}

#define HE_COMPRESSED_BEAMFORMING_AND_CQI 0
#define HE_QUIET_TIME_PERIOD              1

static const range_string he_action_rvals[] = {
  { HE_COMPRESSED_BEAMFORMING_AND_CQI, HE_COMPRESSED_BEAMFORMING_AND_CQI,
        "HE Compressed Beamforming And CQI" },
  { HE_QUIET_TIME_PERIOD, HE_QUIET_TIME_PERIOD,
        "Quiet Time Period" },
  { HE_QUIET_TIME_PERIOD + 1, 255, "Reserved" },
  { 0, 0, NULL }
};

#define HE_BSS_COLOR_CHANGE_ANNOUNCEMENT  0

static const range_string protected_he_action_rvals[] = {
  { HE_BSS_COLOR_CHANGE_ANNOUNCEMENT, HE_BSS_COLOR_CHANGE_ANNOUNCEMENT,
        "HE BSS Color Change Announcement" },
  { HE_BSS_COLOR_CHANGE_ANNOUNCEMENT + 1, 255, "Reserved" },
  { 0, 0, NULL }
};

#define EHT_TID_LINK_MAP_REQ            0
#define EHT_TID_LINK_MAP_RESP           1
#define EHT_TID_LINK_MAP_TEAR_DOWN      2
#define EHT_EPCS_PRIO_ACCESS_REQ        3
#define EHT_EPCS_PRIO_ACCESS_RESP       4
#define EHT_EPCS_PRIO_ACCESS_TEAR_DOWN  5
#define EHT_EML_OP_MODE_NOTIFICATION    6
#define EHT_LINK_RECOMMENDATION         7
#define EHT_MULTI_LINK_OP_UPDATE_REQ    8
#define EHT_MULTI_LINK_OP_UPDATE_RESP   9

static const range_string protected_eht_action_rvals[] = {
  { EHT_TID_LINK_MAP_REQ, EHT_TID_LINK_MAP_REQ,
        "EHT TID-to-Link Mapping Request" },
  { EHT_TID_LINK_MAP_RESP, EHT_TID_LINK_MAP_RESP,
        "EHT TID-to-Link Mapping Response" },
  { EHT_TID_LINK_MAP_TEAR_DOWN, EHT_TID_LINK_MAP_TEAR_DOWN,
        "EHT TID-to-Link Mapping Teardown" },
  { EHT_EPCS_PRIO_ACCESS_REQ, EHT_EPCS_PRIO_ACCESS_REQ,
        "EHT EPCS Priority Access Request" },
  { EHT_EPCS_PRIO_ACCESS_RESP, EHT_EPCS_PRIO_ACCESS_RESP,
        "EHT EPCS Priority Access Response" },
  { EHT_EPCS_PRIO_ACCESS_TEAR_DOWN, EHT_EPCS_PRIO_ACCESS_TEAR_DOWN,
        "EHT EPCS Priority Access Teardown" },
  { EHT_EML_OP_MODE_NOTIFICATION, EHT_EML_OP_MODE_NOTIFICATION,
        "EHT EML Operating Mode Notification" },
  { EHT_LINK_RECOMMENDATION, EHT_LINK_RECOMMENDATION,
        "EHT Link Recommendation" },
  { EHT_MULTI_LINK_OP_UPDATE_REQ, EHT_MULTI_LINK_OP_UPDATE_REQ,
        "EHT Multi-Link Operation Update Request" },
  { EHT_MULTI_LINK_OP_UPDATE_RESP, EHT_MULTI_LINK_OP_UPDATE_RESP,
        "EHT Multi-Link Operation Update Response" },
  { EHT_MULTI_LINK_OP_UPDATE_RESP + 1, 255, "Reserved" },
  { 0, 0, NULL }
};

/*
 * This currently only works for SU, 20MHz, 40MHz and 80MHz and grouping 4 and 16.
 */
struct scidx_start_end {
  int start;
  int end;
};

#define N_SCIDX_20MHZ_NG4 9
static const struct scidx_start_end scidx_20MHz_Ng4[N_SCIDX_20MHZ_NG4] = {
  { -122, -96 },
  { -96, -68 },
  { -68, -40 },
  { -44, -16 },
  { -16, 16 },
  { 16, 44 },
  { 40, 68 },
  { 68, 96 },
  { 96, 122 }
};

#define N_SCIDX_20MHZ_NG16 9
static const struct scidx_start_end scidx_20MHz_Ng16[9] = {
  { -122, -84 },
  { -96, -64 },
  { -80, -32 },
  { -52, -4 },
  { -20, 20 },
  { 4, 52 },
  { 32, 80 },
  { 64, 96 },
  { 84, 122 }
};

#define N_SCIDX_40MHZ_NG4 18
static const struct scidx_start_end scidx_40MHz_Ng4[N_SCIDX_40MHZ_NG4] = {
  { -500 + 256, -472 + 256 },
  { -476 + 256, -448 + 256 },
  { -488 + 256, -420 + 256 },
  { -420 + 256, -392 + 256 },
  { -392 + 256, -364 + 256 },
  { -368 + 256, -340 + 256 },
  { -340 + 256, -312 + 256 },
  { -312 + 256, -284 + 256 },
  { -288 + 256, -260 + 256 },
  {  260 - 256,  288 - 256 },
  {  284 - 256,  312 - 256 },
  {  312 - 256,  340 - 256 },
  {  340 - 256,  368 - 256 },
  {  364 - 256,  392 - 256 },
  {  392 - 256,  420 - 256 },
  {  420 - 256,  448 - 256 },
  {  448 - 256,  476 - 256 },
  {  472 - 256,  500 - 256 }
};

#define N_SCIDX_40MHZ_NG16 18
static const struct scidx_start_end scidx_40MHz_Ng16[N_SCIDX_40MHZ_NG16] = {
  { -500 + 256, -468 + 256 },
  { -484 + 256, -436 + 256 },
  { -452 + 256, -420 + 256 },
  { -420 + 256, -388 + 256 },
  { -404 + 256, -356 + 256 },
  { -372 + 256, -340 + 256 },
  { -340 + 256, -308 + 256 },
  { -324 + 256, -276 + 256 },
  { -292 + 256, -260 + 245 },
  {  260 - 256,  292 - 256 },
  {  276 - 256,  324 - 256 },
  {  308 - 256,  340 - 256 },
  {  340 - 256,  322 - 256 },
  {  356 - 256,  404 - 256 },
  {  388 - 256,  420 - 256 },
  {  420 - 256,  452 - 256 },
  {  436 - 256,  484 - 256 },
  {  468 - 256,  500 - 256 }
};

#define N_SCIDX_80MHZ_NG4 37
static const struct scidx_start_end scidx_80MHz_Ng4[N_SCIDX_80MHZ_NG4] = {
  { -500, -472 },
  { -476, -448 },
  { -448, -420 },
  { -420, -392 },
  { -392, -364 },
  { -368, -340 },
  { -340, -312 },
  { -312, -284 },
  { -288, -260 },
  { -260, -232 },
  { -232, -204 },
  { -204, -176 },
  { -180, -152 },
  { -152, -124 },
  { -124,  -96 },
  { -100,  -72 },
  {  -72,  -44 },
  {  -44,  -16 },
  {  -16,   16 },
  {   16,   44 },
  {   44,   72 },
  {   72,  100 },
  {   96,  124 },
  {  124,  152 },
  {  152,  180 },
  {  176,  204 },
  {  204,  232 },
  {  232,  260 },
  {  260,  288 },
  {  284,  312 },
  {  312,  340 },
  {  340,  368 },
  {  364,  392 },
  {  392,  420 },
  {  420,  448 },
  {  448,  476 },
  {  472,  500 }
};

#define N_SCIDX_80MHZ_NG16 37
static const struct scidx_start_end scidx_80MHz_Ng16[N_SCIDX_80MHZ_NG16] = {
  { -500, -468 },
  { -484, -436 },
  { -452, -420 },
  { -420, -388 },
  { -404, -356 },
  { -372, -340 },
  { -340, -308 },
  { -324, -276 },
  { -292, -260 },
  { -260, -228 },
  { -244, -196 },
  { -212, -164 },
  { -180, -148 },
  { -164, -116 },
  { -132,  -84 },
  { -100,  -68 },
  {  -84,  -36 },
  {  -52,   -4 },
  {  -20,   20 },
  {    4,   52 },
  {   36,   84 },
  {   68,  100 },
  {   84,  132 },
  {  116,  164 },
  {  148,  180 },
  {  164,  212 },
  {  196,  244 },
  {  228,  260 },
  {  260,  292 },
  {  276,  324 },
  {  308,  340 },
  {  340,  372 },
  {  356,  404 },
  {  388,  420 },
  {  420,  452 },
  {  436,  484 },
  {  468,  500 },
};

#define SU_FEEDBACK (0)
#define MU_FEEDBACK (1)
#define CQI_FEEDBACK (2)
#define RESERVED_FEEDBACK (3)

#define BW_20MHz (0)
#define BW_40MHz (1)
#define BW_80MHz (2)
#define BW_160MHz (3)

#define SCIDX_END_SENTINAL (0x80000000)

static int
next_he_scidx(int scidx, int bw _U_, int grouping _U_, int feedback _U_,
              int ru_start_index, int ru_end_index)
{
  int incr = 4;

  /*
   * We need to check the correct bw value to determine if we have hit
   * the end of the range of SCIDXes.
   */
  switch (bw) {
  case BW_20MHz:
    if (grouping == 0) {
      if (ru_end_index >= N_SCIDX_20MHZ_NG4 ||
          scidx == scidx_20MHz_Ng4[ru_end_index].end)  /* we returned the max */
        return SCIDX_END_SENTINAL;
    } else {
      if (ru_end_index >= N_SCIDX_20MHZ_NG16 ||
          scidx == scidx_20MHz_Ng16[ru_end_index].end)
        return SCIDX_END_SENTINAL;
    }
    break;
  case BW_40MHz:
    if (grouping == 0) {
      if (ru_end_index >= N_SCIDX_40MHZ_NG4 ||
          scidx == scidx_40MHz_Ng4[ru_end_index].end)
        return SCIDX_END_SENTINAL;
    } else {
      if (ru_end_index >= N_SCIDX_40MHZ_NG16 ||
          scidx == scidx_40MHz_Ng16[ru_end_index].end)
        return SCIDX_END_SENTINAL;
    }
    break;
  case BW_80MHz:
    if (grouping == 0) {
      if (ru_end_index >= N_SCIDX_80MHZ_NG4 ||
          scidx == scidx_80MHz_Ng4[ru_end_index].end)
        return SCIDX_END_SENTINAL;
    } else {
      if (ru_end_index >= N_SCIDX_80MHZ_NG16 ||
          scidx == scidx_80MHz_Ng16[ru_end_index].end)
        return SCIDX_END_SENTINAL;
    }
    break;
  case BW_160MHz:
    return SCIDX_END_SENTINAL;
  }

  /*
   * Check if this is the first time though and figure out the starting
   * SCIDX.
   */
  if (scidx == (int)SCIDX_END_SENTINAL)
    switch (bw) {
    case BW_20MHz:
      if (grouping == 0) {
        if (ru_start_index >= N_SCIDX_20MHZ_NG4)
          return SCIDX_END_SENTINAL;
        else
          return scidx_20MHz_Ng4[ru_start_index].start;
      } else {
        if (ru_start_index >= N_SCIDX_20MHZ_NG16)
          return SCIDX_END_SENTINAL;
        else
          return scidx_20MHz_Ng16[ru_start_index].start;
      }
    case BW_40MHz:
      if (grouping == 0) {
        if (ru_start_index >= N_SCIDX_40MHZ_NG4)
          return SCIDX_END_SENTINAL;
        else
          return scidx_40MHz_Ng4[ru_start_index].start;
      } else {
        if (ru_start_index >= N_SCIDX_40MHZ_NG16)
          return SCIDX_END_SENTINAL;
        else
          return scidx_40MHz_Ng16[ru_start_index].start;
      }
    case BW_80MHz:
      if (grouping == 0) {
        if (ru_start_index >= N_SCIDX_80MHZ_NG4)
          return SCIDX_END_SENTINAL;
        else
          return scidx_80MHz_Ng4[ru_start_index].start;
      } else {
        if (ru_start_index >= N_SCIDX_80MHZ_NG16)
          return SCIDX_END_SENTINAL;
        else
          return scidx_80MHz_Ng16[ru_start_index].start;
      }
    case BW_160MHz:
      return SCIDX_END_SENTINAL;
  }

  /*
   * for BW_20MHz it is more complex, and the start and end sets have an
   * increment of 2, and around zero they go -4, -2, 2, 4 as well.
   */
  if (bw == BW_20MHz) {
    if (grouping == 0) {
      if (scidx == -122)
        return -120;
      if (scidx == -4)
        return -2;
      if (scidx == 2)
        return 4;
      if (scidx == 120)
        return 122;
    } else {
      if (scidx == -122)
        return -116;
      if (scidx == -4)
        return -2;
      if (scidx == -2)
        return 2;
      if (scidx == 2)
        return 4;
      if (scidx == 116)
        return 122;
    }
  }

  if (grouping == 1)
    incr = 16;

  scidx += incr;

  if (scidx == 0)  /* Not sure if this is needed */
    scidx += incr;

  return scidx;
}

/*
 * This might have a problem if there are not enough bits in the TVB.
 * Will only handle a limited number of bits.
 */
static uint16_t
he_get_bits(tvbuff_t *tvb, int bit_offset, int bit_len)
{
  uint32_t bits;
  int byte_offset = bit_offset / 8;
  int bit_start = bit_offset % 8;
  int bit_mask = (1 << bit_len) - 1;  /* Select that many bits */
  int remaining_length = tvb_reported_length_remaining(tvb, byte_offset);

  if (remaining_length >= 3)
    bits = tvb_get_letoh24(tvb, byte_offset);
  else if (remaining_length == 2)
    bits = tvb_get_letohs(tvb, byte_offset);
  else
    bits = tvb_get_uint8(tvb, byte_offset);

  bits = bits >> bit_start;

  return bits & bit_mask;
}

static int
dissect_he_feedback_matrix(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,
                           int offset, int bit_offset, int scidx,
                           int nr, int nc, int phi_bits, int psi_bits,
                           int hf)
{
  int ri, ci;
  int start_bit_offset = bit_offset;
  int start_offset = offset;
  wmem_strbuf_t *angles = wmem_strbuf_new(pinfo->pool, NULL);

  if (nc == nr)  /* If they are the same, reduce Nc by one */
    nc -= 1;

  wmem_strbuf_append_printf(angles, "%d", scidx);
  /* Reset to the start bit offset */
  bit_offset = start_bit_offset;

  for (ci = 1; ci <= nc; ci++) {
    for (ri = ci; ri < nr; ri++) {
      int angle = he_get_bits(tvb, bit_offset, phi_bits);
      wmem_strbuf_append_printf(angles, ", φ%d%d:%d", ri, ci, angle);
      bit_offset += phi_bits;
    }
    for (ri = ci + 1; ri <= nr; ri++) {
      int angle = he_get_bits(tvb, bit_offset, psi_bits);
      wmem_strbuf_append_printf(angles, ", ψ%d%d:%d", ri, ci, angle);
      bit_offset += psi_bits;
    }
  }

  /* Update this */
  proto_tree_add_string(tree, hf, tvb, offset,
                        ((start_bit_offset + 7) / 8) - start_offset,
                        wmem_strbuf_get_str(angles));

  return bit_offset;
}

static int * const he_mimo_control_headers[] = {
  &hf_ieee80211_he_mimo_control_nc_index,
  &hf_ieee80211_he_mimo_control_nr_index,
  &hf_ieee80211_he_mimo_control_bw,
  &hf_ieee80211_he_mimo_control_grouping,
  &hf_ieee80211_he_mimo_control_codebook_info,
  &hf_ieee80211_he_mimo_control_feedback_type,
  &hf_ieee80211_he_mimo_control_remaining_feedback_segs,
  &hf_ieee80211_he_mimo_control_first_feedback_seg,
  &hf_ieee80211_he_mimo_control_ru_start_index,
  &hf_ieee80211_he_mimo_control_ru_end_index,
  &hf_ieee80211_he_mimo_control_sounding_dialog_token_num,
  &hf_ieee80211_he_mimo_control_reserved,
  NULL
};

/*
 * Handle compressed beamforming matrices and CQI
 */
static unsigned
dissect_compressed_beamforming_and_cqi(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  int byte_count = 0;
  uint64_t mimo_cntl = tvb_get_letoh40(tvb, offset);
  int nc = 0, nr = 0, i;
  int bw, grouping, codebook, feedback, bit_offset, scidx;
  int phi_bits = 0, psi_bits = 0;
  proto_tree *snr_tree = NULL, *feedback_tree = NULL;
  int start_offset;
  int ru_start_index, ru_end_index;

  nc = (int)((mimo_cntl & 0x07) + 1);
  nr = (int)(((mimo_cntl >> 3) & 0x07) + 1);
  bw = (int)((mimo_cntl >> 6) & 0x03);
  grouping = (int)((mimo_cntl >> 8) & 0x01);
  codebook = (int)((mimo_cntl >> 9) & 0x01);
  feedback = (int)((mimo_cntl >> 10) & 0x03);
  ru_start_index = (int)((mimo_cntl >> 16) & 0x7F);
  ru_end_index = (int)((mimo_cntl >> 23) & 0x7F);

  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
    hf_ieee80211_he_mimo_control_field, ett_ff_he_mimo_control,
    he_mimo_control_headers, ENC_LITTLE_ENDIAN,
    BMT_NO_APPEND);
  offset += 5;

  snr_tree = proto_tree_add_subtree(tree, tvb, offset, nc,
                ett_ff_he_mimo_beamforming_report_snr, NULL,
                "Average Signal to Noise Ratio");

  for (i = 0; i < nc; i++) {
    int8_t snr = tvb_get_int8(tvb, offset);

    proto_tree_add_int_format(snr_tree,
        hf_ieee80211_he_compressed_beamforming_report_snr, tvb, offset, 1,
        snr, "Stream %d: %s%0.2fdB (0x%02x)", i, (snr == 127 ? ">=" :
                                                  (snr == -128 ? "<=" : "")),
                                             (float)((float)88 + snr)/4,
                                             (uint8_t)snr);
    offset++;
  }

  /*
   * The rest of the data consists of the compressed beamforming matrices, one
   * for each SCIDX per group. Each matrix consists of phi and psi angles
   * encoded using the number of bits specified using the codebook field.
   *
   * The matrices contain a number entries related to Nr -1 & Nc except when
   * Nr == Nc, and then it is Nr -1 x Nc -1, with Nr - 1 phi angles, Nc - 1
   * psi angles, Nr - 2 phi angles, Nc - 2 psi angles ...
   */
  if (feedback == 0) {  /* SU */
    if (codebook == 0) {
      psi_bits = 2; phi_bits = 4;
    } else {
      psi_bits = 4; phi_bits = 6;
    }
  } else if (feedback == 1) { /* MU */
    if (grouping == 1) {
      psi_bits = 9; phi_bits = 7;
    } else {
      if (codebook == 0) {
        psi_bits = 5; phi_bits = 7;
      } else {
        psi_bits = 7; phi_bits = 9;
      }
    }
  }  /* DO something about CQI etc. */

  feedback_tree = proto_tree_add_subtree(tree, tvb, offset, -1,
                        ett_ff_he_mimo_feedback_matrices, NULL,
                        "Feedback Matrices");

  start_offset = offset;
  bit_offset = offset * 8;
  scidx = SCIDX_END_SENTINAL;
  while ((scidx = next_he_scidx(scidx, bw, grouping, feedback,
          ru_start_index, ru_end_index)) != (int)SCIDX_END_SENTINAL) {
    int prev_bit_offset = bit_offset;
    bit_offset = dissect_he_feedback_matrix(feedback_tree, tvb, pinfo, offset,
                        bit_offset, scidx, nr, nc, phi_bits, psi_bits,
                        hf_ieee80211_he_compressed_beamform_scidx);
    if (bit_offset <= prev_bit_offset) {
      expert_add_info(pinfo, tree, &ei_ieee80211_bad_length);
      break;
    }

    offset = bit_offset / 8;
  }

  offset = (bit_offset + 7) / 8;
  proto_item_set_len(feedback_tree, offset - start_offset);

  /* Sometimes the FCS is in the buffer as well ... */
  byte_count = tvb_reported_length_remaining(tvb, offset);
  if (byte_count > 0)
    offset += byte_count; /* Should fix the real problem */

  return offset;
}

enum quiet_time_period_control {
  QTP_CONTROL_SETUP = 0,
  QTP_CONTROL_REQUEST = 1,
  QTP_CONTROL_RESPONSE = 2,
};

static const range_string quiet_time_period_control_rvals[] = {
  { QTP_CONTROL_SETUP,    QTP_CONTROL_SETUP,    "Quiet Time Period Setup" },
  { QTP_CONTROL_REQUEST,  QTP_CONTROL_REQUEST,  "Quiet Time Period Request" },
  { QTP_CONTROL_RESPONSE, QTP_CONTROL_RESPONSE, "Quiet Time Period Response" },
  { QTP_CONTROL_RESPONSE +1 , 255, "Reserved" },
  { 0, 0, NULL }
};

static void
dissect_bss_color_change(tvbuff_t *tvb, packet_info *pinfo _U_,
proto_tree *tree, int offset, int len _U_);

static unsigned
dissect_quiet_time_period(tvbuff_t *tvb, packet_info *pinfo _U_,
proto_tree *tree, int offset, int len _U_)
{
  uint8_t control = tvb_get_uint8(tvb, offset);

  proto_tree_add_item(tree, hf_ieee80211_he_qtp_control, tvb, offset, 1, ENC_NA);
  offset += 1;

  switch (control)
  {
  case QTP_CONTROL_SETUP:
    proto_tree_add_item(tree, hf_ieee80211_he_qtp_setup_quiet_period_duration, tvb, offset,
                1, ENC_NA);
    offset += 1;
    proto_tree_add_item(tree, hf_ieee80211_he_qtp_setup_srv_specific_identif, tvb, offset,
                2, ENC_LITTLE_ENDIAN);
    offset += 2;
    break;

  case QTP_CONTROL_REQUEST:
    proto_tree_add_item(tree, hf_ieee80211_he_qtp_request_dialog_token, tvb, offset, 2,
                ENC_LITTLE_ENDIAN);
    offset += 2;
    proto_tree_add_item(tree, hf_ieee80211_he_qtp_request_quiet_period_offset, tvb, offset,
                1, ENC_NA);
    offset += 1;
    proto_tree_add_item(tree, hf_ieee80211_he_qtp_request_quiet_period_duration, tvb, offset,
                2, ENC_LITTLE_ENDIAN);
    offset += 2;
    proto_tree_add_item(tree, hf_ieee80211_he_qtp_request_quiet_period_interval, tvb, offset,
                1, ENC_NA);
    offset += 1;
    proto_tree_add_item(tree, hf_ieee80211_he_qtp_request_repetition_count, tvb, offset, 1,
                ENC_NA);
    offset += 1;
    proto_tree_add_item(tree, hf_ieee80211_he_qtp_request_srv_specific_identif, tvb, offset,
                2, ENC_LITTLE_ENDIAN);
    offset += 2;
    break;

  case QTP_CONTROL_RESPONSE:
    proto_tree_add_item(tree, hf_ieee80211_he_qtp_response_dialog_token, tvb, offset, 2,
                ENC_LITTLE_ENDIAN);
    offset += 2;
    proto_tree_add_item(tree, hf_ieee80211_he_qtp_response_status_code, tvb, offset, 1,
                ENC_NA);
    offset += 1;
    proto_tree_add_item(tree, hf_ieee80211_he_qtp_response_quiet_period_offset, tvb, offset,
                1, ENC_NA);
    offset += 1;
    proto_tree_add_item(tree, hf_ieee80211_he_qtp_response_quiet_period_duration, tvb, offset,
                2, ENC_LITTLE_ENDIAN);
    offset += 2;
    proto_tree_add_item(tree, hf_ieee80211_he_qtp_response_quiet_period_interval, tvb, offset,
                1, ENC_NA);
    offset += 1;
    proto_tree_add_item(tree, hf_ieee80211_he_qtp_response_repetition_count, tvb, offset,
                1, ENC_NA);
    offset += 1;
    proto_tree_add_item(tree, hf_ieee80211_he_qtp_response_srv_specific_identif, tvb, offset,
                2, ENC_LITTLE_ENDIAN);
    offset += 2;
    break;

  default:
    /* Reserved */
    break;
  }

  return offset;
}

static unsigned
add_ff_action_he(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  unsigned start = offset;
  uint8_t he_action;
  uint8_t length;
  //uint8_t elem_id, elem_id_extension;
  proto_item *item;
  proto_tree *subtree;
  unsigned int len = tvb_reported_length_remaining(tvb, offset);

  offset += add_ff_category_code(tree, tvb, pinfo, offset);

  he_action = tvb_get_uint8(tvb, offset);

  item = proto_tree_add_item(tree, hf_ieee80211_ff_he_action, tvb, offset, 1, ENC_NA);
  offset += 1;

  subtree = proto_item_add_subtree(item, ett_ff_he_action);


  switch (he_action) {
  case HE_COMPRESSED_BEAMFORMING_AND_CQI:
    proto_tree_add_uint_format(subtree, hf_ieee80211_he_beamforming_report_len,
        tvb, offset, 0, len, "Total length: %u", len);
    offset = dissect_compressed_beamforming_and_cqi(subtree, tvb, pinfo, offset);
    break;

  case HE_QUIET_TIME_PERIOD:
    //elem_id = tvb_get_uint8(tvb, offset);
    length = tvb_get_uint8(tvb, offset + 1);
    //elem_id_extension = tvb_get_uint8(tvb, offset + 2);
    /* Should check following condition?
     * elem_id == TAG_ELEMENT_ID_EXTENSION && elem_id_extension == ETAG_QUIET_TIME_PERIOD
     */
    offset = dissect_quiet_time_period(tvb, pinfo, subtree, offset + 3, length);
    break;

  default:
    break;
  }
  return offset - start;
}

static unsigned
add_ff_action_protected_he(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  unsigned start = offset;
  uint8_t protected_he_action;
  uint8_t length;
  //uint8_t elem_id, elem_id_extension;
  proto_item *item;
  proto_tree *subtree;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);

  protected_he_action = tvb_get_uint8(tvb, offset);

  item = proto_tree_add_item(tree, hf_ieee80211_ff_protected_he_action, tvb, offset,
        1, ENC_NA);
  offset += 1;

  subtree = proto_item_add_subtree(item, ett_ff_protected_he_action);


  switch (protected_he_action) {
  case HE_BSS_COLOR_CHANGE_ANNOUNCEMENT:
    //elem_id = tvb_get_uint8(tvb, offset);
    length = tvb_get_uint8(tvb, offset + 1);
    //elem_id_extension = tvb_get_uint8(tvb, offset + 2);
    /* Should check following condition?
     * elem_id == TAG_ELEMENT_ID_EXTENSION && elem_id_extension == ETAG_BSS_COLOR_CHANGE_ANNOUNCEMENT
     */
    dissect_bss_color_change(tvb, pinfo, subtree, offset + 3, length);
    offset += 5;
    break;

  default:
    break;
  }

  return offset - start;
}

static unsigned
add_ff_action_protected_ftm(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  unsigned start = offset;
  uint8_t action;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  action = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_ff_protected_ftm_action, tvb, offset, 1, ENC_NA);
  offset += 1;

  col_set_str(pinfo->cinfo, COL_INFO, val_to_str_const(action, protected_ftm_action_vals, "Unknown"));

  switch (action) {
    case 1:
      offset += add_ff_ftm_request(tree, tvb, pinfo, offset);
      break;
    case 2:
      offset += add_ff_ftm(tree, tvb, pinfo, offset);
      break;
    case 3:
      offset += add_ff_lmr_report(tree, tvb, pinfo, offset);
      break;
    default:  /* reserved */
      break;
  }

  return offset - start;
}

static unsigned
add_ff_action_protected_eht(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  unsigned start = offset;
  uint8_t protected_eht_action;
  proto_item *item;
  int len = 0;
  uint16_t status;
  bool invalid = false;
  /* Default Extension Element is Multi-Link */
  uint8_t ext_ids[1] = {ETAG_MULTI_LINK};

  offset += add_ff_category_code(tree, tvb, pinfo, offset);

  protected_eht_action = tvb_get_uint8(tvb, offset);

  item = proto_tree_add_item(tree, hf_ieee80211_ff_protected_eht_action, tvb,
                             offset, 1, ENC_NA);
  offset += 1;

  switch (protected_eht_action) {
  case EHT_TID_LINK_MAP_REQ:
    ext_ids[0] = ETAG_TID_TO_LINK_MAPPING;
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);

    /*
     * Next contains one or two TID-To-Link mappings. We have to look into
     * the elements to verify them because we don't have the length of this
     * element and there might be other IEs after us.
     */
    if (tvb_captured_length_remaining(tvb, offset) >= 2) {
      len = tvb_get_uint8(tvb, offset + 1);
    } else {
      invalid = true;
    }
    if (!invalid && (len >= 1) &&
        (add_tagged_field_with_validation(pinfo, tree, tvb, offset, 0, NULL,
         0, false, ext_ids, G_N_ELEMENTS(ext_ids), false, NULL) > 0)) {
      offset += len + 2;
    } else {
      invalid = true;
    }
    if (invalid) {
      expert_add_info_format(pinfo, item, &ei_ieee80211_eht_invalid_action,
                             "Invalid TID_TO_LINK_MAPPING_REQUEST. "
                             "There should be one or two Tid-To-Link IEs "
                             "but none found");
      break;
    }

    len = 0;
    if (tvb_captured_length_remaining(tvb, offset) >= 2) {
      len = tvb_get_uint8(tvb, offset + 1);
    }
    if ((len >= 1) &&
        (add_tagged_field_with_validation(pinfo, tree, tvb, offset, 0, NULL,
         0, false, ext_ids, G_N_ELEMENTS(ext_ids), false, NULL) > 0)) {
      offset += len + 2;
    }
    break;
  case EHT_TID_LINK_MAP_RESP:
    ext_ids[0] = ETAG_TID_TO_LINK_MAPPING;
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);

    status = tvb_get_ntohs(tvb, offset);
    offset += add_ff_status_code(tree, tvb, pinfo, offset);
    if (status == 134) {
      /* There should be one or two TID-To-Link mappings. */
      if (tvb_captured_length_remaining(tvb, offset) >= 2) {
        len = tvb_get_uint8(tvb, offset + 1);
      } else {
        invalid = true;
      }
      if (!invalid && (len >= 1) &&
          (add_tagged_field_with_validation(pinfo, tree, tvb, offset, 0, NULL,
           0, false, ext_ids, G_N_ELEMENTS(ext_ids), false, NULL) > 0)) {
        offset += len + 2;
      } else {
        invalid = true;
      }
      if (invalid) {
        expert_add_info_format(pinfo, item, &ei_ieee80211_eht_invalid_action,
                               "Invalid TID_TO_LINK_MAPPING_RESPONSE. "
                               "There should be one or two Tid-To-Link IEs "
                               "but none found");
        break;
      }

      len = 0;
      if (tvb_captured_length_remaining(tvb, offset) >= 2) {
        len = tvb_get_uint8(tvb, offset + 1);
      }
      if ((len >= 1) &&
          (add_tagged_field_with_validation(pinfo, tree, tvb, offset, 0, NULL,
           0, false, ext_ids, G_N_ELEMENTS(ext_ids), false, NULL) > 0)) {
        offset += len + 2;
      }
    }
    break;
  case EHT_TID_LINK_MAP_TEAR_DOWN:
    /* Seems to be nothing to do here */
    break;
  case EHT_EPCS_PRIO_ACCESS_REQ:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    if (tvb_captured_length_remaining(tvb, offset) >= 2) {
      len = tvb_get_uint8(tvb, offset + 1);
      if (add_tagged_field_with_validation(pinfo, tree, tvb, offset, 0, NULL,
          0, false, ext_ids, G_N_ELEMENTS(ext_ids), false, NULL) > 0) {
        offset += len + 2;
      }
    }
    break;
  case EHT_EPCS_PRIO_ACCESS_RESP:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    offset += add_ff_status_code(tree, tvb, pinfo, offset);
    if (tvb_captured_length_remaining(tvb, offset) >= 2) {
      len = tvb_get_uint8(tvb, offset + 1);
      if (add_tagged_field_with_validation(pinfo, tree, tvb, offset, 0, NULL,
          0, false, ext_ids, G_N_ELEMENTS(ext_ids), false, NULL) > 0) {
        offset += len + 2;
      }
    }
    break;
  case EHT_EPCS_PRIO_ACCESS_TEAR_DOWN:
    break;
  case EHT_EML_OP_MODE_NOTIFICATION:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    offset += dissect_eht_eml_control_field(tree, tvb, pinfo, offset);
    break;
  case EHT_LINK_RECOMMENDATION:
    offset += add_ff_reason_code(tree, tvb, pinfo, offset);
    if (tvb_captured_length_remaining(tvb, offset) >= 2) {
      len = tvb_get_uint8(tvb, offset + 1);
    } else {
      invalid = true;
    }
    ext_ids[0] = ETAG_AID_BITMAP;
    if (!invalid && (len >= 1) &&
        (add_tagged_field_with_validation(pinfo, tree, tvb, offset, 0, NULL,
         0, false, ext_ids, G_N_ELEMENTS(ext_ids), false, NULL) > 0)) {
      offset += len + 2;
    } else {
      invalid = true;
    }
    if (invalid) {
      expert_add_info_format(pinfo, item, &ei_ieee80211_eht_invalid_action,
                             "Invalid LINK_RECOMMENDATION. "
                             "There should be AID_BITMAP element"
                             "but none found");
      break;
    }

    invalid = false;
    if (tvb_captured_length_remaining(tvb, offset) >= 2) {
      len = tvb_get_uint8(tvb, offset + 1);
    } else {
      invalid = true;
    }
    ext_ids[0] = ETAG_MULTI_LINK_TRAFFIC;
    if (!invalid && (len >= 1) &&
        (add_tagged_field_with_validation(pinfo, tree, tvb, offset, 0, NULL,
         0, false, ext_ids, G_N_ELEMENTS(ext_ids), false, NULL) > 0)) {
      offset += len + 2;
    } else {
      invalid = true;
    }
    if (invalid) {
      expert_add_info_format(pinfo, item, &ei_ieee80211_eht_invalid_action,
                             "Invalid LINK_RECOMMENDATION. "
                             "There should be MULTI_LINK_TRAFFIC element"
                             "but none found");
      break;
    }
    break;
  case EHT_MULTI_LINK_OP_UPDATE_REQ:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    if (tvb_captured_length_remaining(tvb, offset) >= 2) {
      len = tvb_get_uint8(tvb, offset + 1);
    } else {
      invalid = true;
    }
    if (!invalid && (len >= 1) &&
        (add_tagged_field_with_validation(pinfo, tree, tvb, offset, 0, NULL,
         0, false, ext_ids, G_N_ELEMENTS(ext_ids), false, NULL) > 0)) {
      offset += len + 2;
    } else {
      invalid = true;
    }
    if (invalid) {
      expert_add_info_format(pinfo, item, &ei_ieee80211_eht_invalid_action,
                             "Invalid Multi-Link Operation Update Request. "
                             "There should be Reconf Multi-Link element"
                             "but none found");
      break;
    }
    break;
  case EHT_MULTI_LINK_OP_UPDATE_RESP:
    offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
    offset += add_ff_status_code(tree, tvb, pinfo, offset);
    break;
  default:
    expert_add_info_format(pinfo, item, &ei_ieee80211_eht_invalid_action,
                           "Reserved Protected EHT Action %u",
                           protected_eht_action);

    break;
  }

  return offset - start;
}

/*
 * Structure for handling the EHT scidx info. Allows for a compact
 * representation.
 */
struct scidx_part {
  unsigned start_val;      /* What we start at                 */
  bool use_ng;      /* Should we use Ng or the inc next */
  unsigned inc;            /* The increment when not using Ng  */
  unsigned stop_val;       /* When we should stop              */
  bool last_ent;    /* This is the last one in the list */
};

struct scidx_ctx {
  uint8_t ru_index;
  struct scidx_part *scidx_array;
  uint8_t ng;
  bool just_inited;
  unsigned last_val;
};

static struct scidx_part ru_242_tone_1_20MHz_ng4[] = {
  { -122, false, 2, -120, false },
  { -120, true,  0,   -4, false },
  {   -2, false, 4,    2, false },
  {    4, true,  0,  120, false },
  {  120, false, 2,  122, true  }
};

static struct scidx_part ru_242_tone_1_20MHz_ng16[] = {
  { -122, false,  6, -116, false },
  { -116, true,   0,   -4, false },
  {   -2, false,  4,    2, false },
  {    4, true,   0,  116, false },
  {  116, false,  6,  122, true  }
};

/* Here, there is one per RU index */
/*Start, UseNg, Inc,End, last */
static struct scidx_part ru_242_tone_40MHz[] = {
  { -244, true, 0,   -4, true },
  {    4, true, 0,  244, true }
};

static struct scidx_part ru_242_tone_80MHz[] = {
  { -500, true, 0, -260, true },
  { -252, true, 0,  -12, true },
  {   12, true, 0,  252, true },
  {  260, true, 0,  500, true }
};

static struct scidx_part ru_242_tone_160MHz[] = {
  { -1012, true, 0, -772, true },
  {  -764, true, 0, -524, true },
  {  -500, true, 0, -260, true },
  {  -252, true, 0,  -12, true },
  {    12, true, 0,  252, true },
  {   260, true, 0,  500, true },
  {   524, true, 0,  764, true },
  {   772, true, 0, 1012, true }
};

static struct scidx_part ru_242_tone_320MHz[] = {
  { -2036, true, 0, -1796, true },
  { -1788, true, 0, -1548, true },
  { -1524, true, 0, -1284, true },
  { -1276, true, 0, -1036, true },
  { -1012, true, 0,  -772, true },
  {  -764, true, 0,  -524, true },
  {  -500, true, 0,  -260, true },
  {  -252, true, 0,   -12, true },
  {    12, true, 0,   252, true },
  {   260, true, 0,   500, true },
  {   524, true, 0,   764, true },
  {   772, true, 0,  1012, true },
  {  1036, true, 0,  1276, true },
  {  1284, true, 0,  1524, true },
  {  1548, true, 0,  1788, true },
  {  1796, true, 0,  2036, true }
};

/* All these ru_96 tone sets for NG=4 go in pairs. */
static struct scidx_part ru_996_tone_80MHz_ng4[] = {
  { -500, false, 4,  -4, false },
  {    4, false, 4, 500, true }
};

static struct scidx_part ru_996_tone_80MHz_ng16[] = {
  { -500,  true, 0, -260, false },
  { -252,  true, 0,  -12, false },
  {   -4, false, 8,    4, false },
  {   12,  true, 0,  252, false },
  {  260,  true, 0,  500,  true }
};

static struct scidx_part ru_996_tone_160MHz_ng4[] = {
  { -1012, true, 0, -516, false },
  {  -508, true, 0,  -12,  true },

  {    12, true, 0,  508, false },
  {   516, true, 0, 1012,  true }
};

static struct scidx_part ru_996_tone_160MHz_ng16[] = {
  { -1012,  true, 0, -772, false },
  {  -764,  true, 0, -524, false },
  {  -516, false, 8, -508, false },
  {  -500,  true, 0, -260, false },
  {  -252,  true, 0, -12 ,  true },

  {    12,  true, 0,  252, false },
  {   260,  true, 0,  500, false },
  {   508, false, 8,  516, false },
  {   524,  true, 0,  764, false },
  {   772,  true, 0, 1012,  true }
};

static struct scidx_part ru_996_tone_320MHz_ng4[] = {
  { -2036,  true, 0, -1540, false },
  { -1532,  true, 0, -1036,  true },

  { -1012,  true, 0,  -516, false },
  {  -508,  true, 0,   -12,  true },

  {    12,  true, 0,   508, false },
  {   516,  true, 0,  1012,  true },

  {  1036,  true, 0,  1532, false },
  {  1540,  true, 0,  2036,  true }
};

static struct scidx_part ru_996_tone_320MHz_ng16[] = {
  { -2036,  true, 0, -1796, false },
  { -1788,  true, 0, -1548, false },
  { -1540, false, 8, -1532, false },
  { -1524,  true, 0, -1284, false },
  { -1276,  true, 0, -1036,  true },

  { -1012,  true, 0,  -772, false },
  {  -764,  true, 0,  -524, false },
  {  -516, false, 8,  -508, false },
  {  -500,  true, 0,  -260, false },
  {  -252,  true, 0,   -12,  true },

  {    12,  true, 0,   252, false },
  {   260,  true, 0,   500, false },
  {   508, false, 8,   516, false },
  {   524,  true, 0,   764, false },
  {   772,  true, 0,  1012,  true },

  {  1036,  true, 0,  1276, false },
  {  1284,  true, 0,  1524, false },
  {  1532, false, 8,  1540, false },
  {  1548,  true, 0,  1788, false },
  {  1796,  true, 0,  2036,  true }
};


static void
init_eht_scidx(struct scidx_ctx *ctx, uint8_t ru_index,
               struct scidx_part *scidx_array, uint8_t ng)
{
  ctx->ru_index = ru_index;
  ctx->scidx_array = scidx_array;
  ctx->ng = ng;
  ctx->just_inited = true;
}

/* What about the special 20MHz ones? */
/* Figure out the next SCIDX */
static bool
next_eht_scidx(struct scidx_ctx *ctx, int *scidx)
{
  if (ctx->just_inited) {
    ctx->last_val = ctx->scidx_array->start_val;
    ctx->just_inited = false;
    *scidx = ctx->last_val;
    return true;
  }

  /* Move to the next val ... but check if it is a short seg first */
  if (ctx->last_val == ctx->scidx_array->stop_val) {
    if (ctx->scidx_array->last_ent) {
        return false;
    } else {
        /* Pretend like we just started again */
        /* Also, note that the arrays need to be set up correctly */
        ctx->scidx_array++;
        if (ctx->last_val == ctx->scidx_array->start_val) {
          if (ctx->scidx_array->use_ng) {
            ctx->last_val += ctx->ng;
          } else {
            ctx->last_val += ctx->scidx_array->inc;
          }
        } else {
          ctx->last_val = ctx->scidx_array->start_val;
        }
        *scidx = ctx->last_val;
        return true;
    }
  }

  /*
   * If the increment is not ng, then handle that.
   */
  if (ctx->scidx_array->use_ng) {
    ctx->last_val += ctx->ng;
  } else {
    ctx->last_val += ctx->scidx_array->inc;
  }
  *scidx = ctx->last_val;

  return true;
}

static int
add_ff_eht_mu_exclusive_20MHz_rpt(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_,
                                  int offset, uint8_t nc_index,
                                  uint8_t grouping, uint16_t partial_bw_info _U_)
{
  int start_offset = offset;
  unsigned scidx;
  struct scidx_ctx scidx_ctx;
  uint8_t ng = grouping == 0 ? 4 : 16;
  proto_tree *ru_index_tree = NULL;
  proto_item *ruii = NULL;
  unsigned ss = 0, get_snr = 1;
  int8_t snr = 0, value;

  if (ng == 4) {
    init_eht_scidx(&scidx_ctx, 1, &ru_242_tone_1_20MHz_ng4[0], ng);
  } else {
    init_eht_scidx(&scidx_ctx, 1, &ru_242_tone_1_20MHz_ng16[0], ng);
  }

  ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                                ett_eht_mu_exclusive_beamforming_rpt_ru_index,
                                                &ruii,
                                                "RU Index %d for 20MHz, Partial BW "
                                                "not all one.", 1);
  while (next_eht_scidx(&scidx_ctx, &scidx)) {
    for (ss = 1; ss <= nc_index; ss++) {
      if (get_snr) {
        snr = tvb_get_int8(tvb, offset);
        offset += 1;
        value = snr & 0x0f;
        get_snr = 0;
      } else {
        value = snr >> 4;
        get_snr = 1;
      }
      proto_tree_add_int_format(ru_index_tree, hf_ieee80211_eht_mu_exclusive_beamforming_report_delta_snr,
                                tvb, offset, 1, value, "Delta SNR for Stream %d for subcarrier %u: %d dB",
                                ss, scidx, value);
    }
  }
  proto_item_set_len(ruii, offset - start_offset);
  return offset - start_offset;
}

static int
add_ff_eht_mu_exclusive_40MHz_rpt(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_,
                                  int offset, uint8_t nc_index,
                                  uint8_t grouping, uint16_t partial_bw_info)
{
  int start_offset = offset;
  int i = 0;
  struct scidx_ctx scidx_ctx;
  unsigned scidx;
  uint8_t ng = grouping == 0 ? 4 : 16;
  proto_tree *ru_index_tree = NULL;
  proto_item *ruii = NULL;
  unsigned ss = 0, get_snr = 1;
  int8_t snr = 0, value;

  /* Add each of the RU index groups set */
  for (i = 1; i <= 2; i++) {
    int tree_offset = offset;
    if ((partial_bw_info & (1 << i)) == 0x0) {
      continue;  /* Only dissect those with the bit set */
    }

    init_eht_scidx(&scidx_ctx, i, &ru_242_tone_40MHz[i - 1], ng);
    ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                                  ett_eht_mu_exclusive_beamforming_rpt_ru_index,
                                                  &ruii,
                                                  "RU Index %d for 40MHz, Partial BW "
                                                  "not all one.", i);
    while (next_eht_scidx(&scidx_ctx, &scidx)) {
      for (ss = 1; ss <= nc_index; ss++) {
        if (get_snr) {
          snr = tvb_get_int8(tvb, offset);
          offset += 1;
          value = snr & 0x0f;
          get_snr = 0;
        } else {
          value = snr >> 4;
          get_snr = 1;
        }
        proto_tree_add_int_format(ru_index_tree, hf_ieee80211_eht_mu_exclusive_beamforming_report_delta_snr,
                                  tvb, offset, 1, value, "Delta SNR for Stream %d for subcarrier %u: %d dB",
                                  ss, scidx, value);
      }
    }
    proto_item_set_len(ruii, offset - tree_offset);
  }

  return offset - start_offset;
}

static int
add_ff_eht_mu_exclusive_80MHz_rpt(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_,
                                  int offset, uint8_t nc_index,
                                  uint8_t grouping, uint16_t partial_bw_info)
{
  int start_offset = offset;
  int i = 0;
  struct scidx_ctx scidx_ctx;
  unsigned scidx;
  uint8_t ng = grouping == 0 ? 4 : 16;
  proto_tree *ru_index_tree = NULL;
  proto_item *ruii = NULL;
  unsigned ss = 0, get_snr = 1;
  int8_t snr = 0, value;

  if (partial_bw_info == 0x1E) { /* Uses 996-tone RU indices */
    if (ng == 4) {
      init_eht_scidx(&scidx_ctx, i, &ru_996_tone_80MHz_ng4[0], ng);
    } else {
      init_eht_scidx(&scidx_ctx, i, &ru_996_tone_80MHz_ng16[0], ng);
    }
    ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                                  ett_eht_mu_exclusive_beamforming_rpt_ru_index,
                                                  &ruii,
                                                  "996-tone RU Index %d for 80MHz", 1);
    while (next_eht_scidx(&scidx_ctx, &scidx)) {
      for (ss = 1; ss <= nc_index; ss++) {
        if (get_snr) {
          snr = tvb_get_int8(tvb, offset);
          offset += 1;
          value = snr & 0x0f;
          get_snr = 0;
        } else {
          value = snr >> 4;
          get_snr = 1;
        }
        proto_tree_add_int_format(ru_index_tree, hf_ieee80211_eht_mu_exclusive_beamforming_report_delta_snr,
                                  tvb, offset, 1, value, "Delta SNR for Stream %d for subcarrier %u: %d dB",
                                  ss, scidx, value);
      }
    }
    proto_item_set_len(ruii, offset - start_offset);

    return offset - start_offset;
  }

  /* Add each of the RU index groups */
  for (i = 1; i <= 4; i++) {
    int tree_offset = offset;
    if ((partial_bw_info & (1 << i)) == 0x0) {
      continue;  /* Only dissect those with the bit set */
    }

    init_eht_scidx(&scidx_ctx, i, &ru_242_tone_80MHz[i - 1], ng);
    ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                                  ett_eht_mu_exclusive_beamforming_rpt_ru_index,
                                                  &ruii,
                                                  "RU Index %d for 80MHz, Partial BW "
                                                  "not all one.", i);
    while (next_eht_scidx(&scidx_ctx, &scidx)) {
      for (ss = 1; ss <= nc_index; ss++) {
        if (get_snr) {
          snr = tvb_get_int8(tvb, offset);
          offset += 1;
          value = snr & 0x0f;
          get_snr = 0;
        } else {
          value = snr >> 4;
          get_snr = 1;
        }
        proto_tree_add_int_format(ru_index_tree, hf_ieee80211_eht_mu_exclusive_beamforming_report_delta_snr,
                                  tvb, offset, 1, value, "Delta SNR for Stream %d for subcarrier %u: %d dB",
                                  ss, scidx, value);
      }
    }
    proto_item_set_len(ruii, offset - tree_offset);
  }

  return offset - start_offset;
}

static int
add_ff_eht_mu_exclusive_160MHz_rpt(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_,
                                   int offset, uint8_t nc_index,
                                   uint8_t grouping, uint16_t partial_bw_info)
{
  int start_offset = offset;
  int tree_offset;
  int i = 0;
  struct scidx_ctx scidx_ctx;
  unsigned scidx;
  uint8_t ng = grouping == 0 ? 4 : 16;
  proto_tree *ru_index_tree = NULL;
  proto_item *ruii = NULL;
  unsigned ss = 0, get_snr = 1;
  int8_t snr = 0, value;

  /* Is the first lot a 996-tone RU? */
  if ((partial_bw_info & 0x1E) == 0x1E) { /* Uses 996-tone RU indices */
    tree_offset = offset;
    if (ng == 4) {
      init_eht_scidx(&scidx_ctx, i, &ru_996_tone_160MHz_ng4[0], ng);
    } else {
      init_eht_scidx(&scidx_ctx, i, &ru_996_tone_160MHz_ng16[0], ng);
    }
    ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                                  ett_eht_mu_exclusive_beamforming_rpt_ru_index,
                                                  &ruii,
                                                  "996-tone RU Index %d for 160MHz", 1);
    while (next_eht_scidx(&scidx_ctx, &scidx)) {
      for (ss = 1; ss <= nc_index; ss++) {
        if (get_snr) {
          snr = tvb_get_int8(tvb, offset);
          offset += 1;
          value = snr & 0x0f;
          get_snr = 0;
        } else {
          value = snr >> 4;
          get_snr = 1;
        }
        proto_tree_add_int_format(ru_index_tree, hf_ieee80211_eht_mu_exclusive_beamforming_report_delta_snr,
                                  tvb, offset, 1, value, "Delta SNR for Stream %d for subcarrier %u: %d dB",
                                  ss, scidx, value);
      }
    }
    proto_item_set_len(ruii, offset - tree_offset);
  } else {
    /* Add each of the RU index groups for the lower 80MHz */
    for (i = 1; i <= 4; i++) {
      if ((partial_bw_info & (1 << i)) == 0x0) {
        continue;  /* Only dissect those with the bit set */
      }

      tree_offset = offset;
      init_eht_scidx(&scidx_ctx, i, &ru_242_tone_160MHz[i - 1], ng);
      ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                                    ett_eht_mu_exclusive_beamforming_rpt_ru_index,
                                                    &ruii,
                                                    "RU Index %d for 160MHz, Partial BW "
                                                    "not all one, lower 80MHz.", i);
      while (next_eht_scidx(&scidx_ctx, &scidx)) {
        for (ss = 1; ss <= nc_index; ss++) {
          if (get_snr) {
            snr = tvb_get_int8(tvb, offset);
            offset += 1;
            value = snr & 0x0f;
            get_snr = 0;
          } else {
            value = snr >> 4;
            get_snr = 1;
          }
          proto_tree_add_int_format(ru_index_tree, hf_ieee80211_eht_mu_exclusive_beamforming_report_delta_snr,
                                    tvb, offset, 1, value, "Delta SNR for Stream %d for subcarrier %u: %d dB",
                                    ss, scidx, value);
        }
      }
      proto_item_set_len(ruii, offset - tree_offset);
    }
  }

  /* Is the second lot a 996-tone RU? */
  get_snr = 1;
  if ((partial_bw_info & 0x1E0) == 0x1E0) { /* Uses 996-tone RU indices */
    tree_offset = offset;
    if (ng == 4) {
      init_eht_scidx(&scidx_ctx, i, &ru_996_tone_160MHz_ng4[2], ng);
    } else {
      init_eht_scidx(&scidx_ctx, i, &ru_996_tone_160MHz_ng16[5], ng);
    }
    ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                                  ett_eht_mu_exclusive_beamforming_rpt_ru_index,
                                                  &ruii,
                                                  "996-tone RU Index %d for 160MHz", 2);
    while (next_eht_scidx(&scidx_ctx, &scidx)) {
      for (ss = 1; ss <= nc_index; ss++) {
        if (get_snr) {
          snr = tvb_get_int8(tvb, offset);
          offset += 1;
          value = snr & 0x0f;
          get_snr = 0;
        } else {
          value = snr >> 4;
          get_snr = 1;
        }
        proto_tree_add_int_format(ru_index_tree, hf_ieee80211_eht_mu_exclusive_beamforming_report_delta_snr,
                                  tvb, offset, 1, value, "Delta SNR for Stream %d for subcarrier %u: %d dB",
                                  ss, scidx, value);
      }
    }
    proto_item_set_len(ruii, offset - tree_offset);
  } else {
    /* Add each of the RU index groups for the lower 80MHz */
    for (i = 5; i <= 8; i++) {
      if ((partial_bw_info & (1 << i)) == 0x0) {
        continue;  /* Only dissect those with the bit set */
      }

      tree_offset = offset;
      init_eht_scidx(&scidx_ctx, i, &ru_242_tone_160MHz[i - 1], ng);
      ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                                    ett_eht_mu_exclusive_beamforming_rpt_ru_index,
                                                    &ruii,
                                                    "RU Index %d for 160MHz, Partial BW "
                                                    "not all one, upper 80MHz.", i);
      while (next_eht_scidx(&scidx_ctx, &scidx)) {
        for (ss = 1; ss <= nc_index; ss++) {
          if (get_snr) {
            snr = tvb_get_int8(tvb, offset);
            offset += 1;
            value = snr & 0x0f;
            get_snr = 0;
          } else {
            value = snr >> 4;
            get_snr = 1;
          }
          proto_tree_add_int_format(ru_index_tree, hf_ieee80211_eht_mu_exclusive_beamforming_report_delta_snr,
                                    tvb, offset, 1, value, "Delta SNR for Stream %d for subcarrier %u: %d dB",
                                    ss, scidx, value);
        }
      }
      proto_item_set_len(ruii, offset - tree_offset);
    }
  }

  return offset - start_offset;
}

static int
add_ff_eht_mu_exclusive_320MHz_rpt(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_,
                                   int offset, uint8_t nc_index,
                                   uint8_t grouping, uint16_t partial_bw_info)
{
  int start_offset = offset;
  int tree_offset = offset;
  int i = 0, j = 0, k = 0;
  struct scidx_ctx scidx_ctx;
  unsigned scidx;
  uint8_t ng = grouping == 0 ? 4 : 16;
  proto_tree *ru_index_tree = NULL;
  proto_item *ruii = NULL;
  unsigned ss = 0, get_snr = 1;
  int8_t snr = 0, value;

  for ( i = 0; i < 4; i++) {
    if (((partial_bw_info >> (2*i+1)) & 0x03) == 0x03) { /* Uses 996-tone RU indices */
      if (ng == 4) {
        init_eht_scidx(&scidx_ctx, i+1, &ru_996_tone_320MHz_ng4[i * 2], ng);
      } else {
        init_eht_scidx(&scidx_ctx, i+1, &ru_996_tone_320MHz_ng16[i * 5], ng);
      }
      ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                                    ett_eht_mu_exclusive_beamforming_rpt_ru_index,
                                                    &ruii,
                                                    "996-tone RU Index %d for 320MHz",
                                                    i+1);
      tree_offset = offset;
      while (next_eht_scidx(&scidx_ctx, &scidx)) {
        for (ss = 1; ss <= nc_index; ss++) {
          if (get_snr) {
            snr = tvb_get_int8(tvb, offset);
            offset += 1;
            value = snr & 0x0f;
            get_snr = 0;
          } else {
            value = snr >> 4;
            get_snr = 1;
          }
          proto_tree_add_int_format(ru_index_tree, hf_ieee80211_eht_mu_exclusive_beamforming_report_delta_snr,
                                    tvb, offset, 1, value, "Delta SNR for Stream %d for subcarrier %u: %d dB",
                                    ss, scidx, value);
        }
      }
      proto_item_set_len(ruii, offset - tree_offset);
    } else {
      for (j = 2*i; j <= 2*i+1; j++) {
        if ((partial_bw_info & (1 << (j+1))) == 0x0) {
          continue;  /* Only dissect those with the bit set */
        }
        /* Each 484-tone RU contains two 242-tone RUs */
        for (k = 2*j;k <= 2*j+1;k++) {
          init_eht_scidx(&scidx_ctx, k+1, &ru_242_tone_320MHz[k], ng);
          ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                            ett_eht_mu_exclusive_beamforming_rpt_ru_index,
                            &ruii,
                            "RU Index %d for 320MHz, Partial BW "
                            "not all one.", k+1);
          tree_offset = offset;
          while (next_eht_scidx(&scidx_ctx, &scidx)) {
            for (ss = 1; ss <= nc_index; ss++) {
              if (get_snr) {
                snr = tvb_get_int8(tvb, offset);
                offset += 1;
                value = snr & 0x0f;
                get_snr = 0;
              } else {
                value = snr >> 4;
                get_snr = 1;
              }
              proto_tree_add_int_format(ru_index_tree, hf_ieee80211_eht_mu_exclusive_beamforming_report_delta_snr,
                                        tvb, offset, 1, value, "Delta SNR for Stream %d for subcarrier %u: %d dB",
                                        ss, scidx, value);
            }
          }
          proto_item_set_len(ruii, offset - tree_offset);
        }
      }
    }
  }

  return offset - start_offset;
}

static unsigned
add_ff_eht_mu_exclusive_beamforming_rpt(proto_tree *tree, tvbuff_t *tvb,
                                        packet_info *pinfo, int offset,
                                        uint64_t mimo_control)
{
  uint8_t nc_index = mimo_control & 0x0F;
  uint8_t bw = (mimo_control >> 8) & 0x07;
  uint8_t grouping = (mimo_control >> 11) & 0x01;
  uint16_t partial_bw_info = (mimo_control >> 21) & 0x01FF;
  proto_tree *exclusive_tree = NULL;
  proto_item *fti = NULL;
  unsigned start_offset = offset;
  unsigned tree_len = 0, byte_count = 0;

  exclusive_tree = proto_tree_add_subtree(tree, tvb, offset, -1,
                     ett_ff_eht_mimo_mu_exclusive_report, &fti,
                     "EHT MU Exclusive Beamforming Report");

  switch (bw) {
  case 0: /*  20 MHz */
    tree_len = add_ff_eht_mu_exclusive_20MHz_rpt(exclusive_tree, tvb, pinfo, offset,
                                                 nc_index, grouping, partial_bw_info);
    proto_item_set_len(fti, tree_len);
    offset += tree_len;
    break;
  case 1: /*  40 MHz */
    tree_len = add_ff_eht_mu_exclusive_40MHz_rpt(exclusive_tree, tvb, pinfo, offset,
                                                 nc_index, grouping, partial_bw_info);
    proto_item_set_len(fti, tree_len);
    offset += tree_len;
    break;
  case 2: /*  80 MHz */
    tree_len = add_ff_eht_mu_exclusive_80MHz_rpt(exclusive_tree, tvb, pinfo, offset,
                                                 nc_index, grouping, partial_bw_info);
    proto_item_set_len(fti, tree_len);
    offset += tree_len;
    break;
  case 3: /* 160 MHz */
    tree_len = add_ff_eht_mu_exclusive_160MHz_rpt(exclusive_tree, tvb, pinfo, offset,
                                                  nc_index, grouping, partial_bw_info);
    proto_item_set_len(fti, tree_len);
    offset += tree_len;
    break;
  case 4: /* 320 MHz */
    tree_len = add_ff_eht_mu_exclusive_320MHz_rpt(exclusive_tree, tvb, pinfo, offset,
                                                  nc_index, grouping, partial_bw_info);
    proto_item_set_len(fti, tree_len);
    offset += tree_len;
    break;
  default:
    /* Add EI about invalid BW setting */
    break;
  }

  byte_count = tvb_reported_length_remaining(tvb, offset);
  if (byte_count > 0)
    offset += byte_count; /* Should fix the real problem. */

  return offset - start_offset;
}

static int
add_ff_eht_su_20MHz_rpt(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,
                        int offset, uint8_t nc_index, uint8_t nr_index,
                        uint8_t grouping, uint16_t partial_bw_info _U_,
                        uint8_t phi_bits, uint8_t psi_bits)
{
  int start_offset = offset;
  unsigned scidx;
  struct scidx_ctx scidx_ctx;
  uint8_t ng = grouping == 0 ? 4 : 16;
  unsigned bit_offset = offset * 8;
  proto_tree *ru_index_tree = NULL;
  proto_item *ruii = NULL;

  if (ng == 4) {
    init_eht_scidx(&scidx_ctx, 1, &ru_242_tone_1_20MHz_ng4[0], ng);
  } else {
    init_eht_scidx(&scidx_ctx, 1, &ru_242_tone_1_20MHz_ng16[0], ng);
  }

  ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                                ett_eht_beamforming_rpt_ru_index,
                                                &ruii,
                                                "RU Index %d for 20MHz, Partial BW "
                                                "not all one.", 1);
  while (next_eht_scidx(&scidx_ctx, &scidx)) {
    bit_offset = dissect_he_feedback_matrix(ru_index_tree, tvb, pinfo, offset,
                                            bit_offset, scidx, nr_index + 1,
                                            nc_index + 1, phi_bits, psi_bits,
                                            hf_ieee80211_eht_compressed_beamform_scidx);
    offset = bit_offset / 8;
  }
  proto_item_set_len(ruii, offset - start_offset);

  return offset - start_offset;
}

static int
add_ff_eht_su_40MHz_rpt(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,
                        int offset, uint8_t nc_index, uint8_t nr_index,
                        uint8_t grouping, uint16_t partial_bw_info,
                        uint8_t phi_bits, uint8_t psi_bits)
{
  int start_offset = offset;
  int i = 0;
  struct scidx_ctx scidx_ctx;
  unsigned scidx;
  uint8_t ng = grouping == 0 ? 4 : 16;
  unsigned bit_offset = offset * 8;
  proto_tree *ru_index_tree = NULL;
  proto_item *ruii = NULL;

  /* Add each of the RU index groups set */
  for (i = 1; i <= 2; i++) {
    int tree_offset = offset;
    if ((partial_bw_info & (1 << i)) == 0x0) {
      continue;  /* Only dissect those with the bit set */
    }

    init_eht_scidx(&scidx_ctx, i, &ru_242_tone_40MHz[i - 1], ng);
    ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                                  ett_eht_beamforming_rpt_ru_index,
                                                  &ruii,
                                                  "RU Index %d for 40MHz, Partial BW "
                                                  "not all one.", i);
    while (next_eht_scidx(&scidx_ctx, &scidx)) {
      bit_offset = dissect_he_feedback_matrix(ru_index_tree, tvb, pinfo, offset,
                                              bit_offset, scidx, nr_index + 1,
                                              nc_index + 1, phi_bits, psi_bits,
                                              hf_ieee80211_eht_compressed_beamform_scidx);
      offset = bit_offset / 8;
    }
    proto_item_set_len(ruii, offset - tree_offset);
  }

  return offset - start_offset;
}

static int
add_ff_eht_su_80MHz_rpt(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,
                        int offset, uint8_t nc_index, uint8_t nr_index,
                        uint8_t grouping, uint16_t partial_bw_info,
                        uint8_t phi_bits, uint8_t psi_bits)
{
  int start_offset = offset;
  int i = 0;
  struct scidx_ctx scidx_ctx;
  unsigned scidx;
  uint8_t ng = grouping == 0 ? 4 : 16;
  unsigned bit_offset = offset * 8;
  proto_tree *ru_index_tree = NULL;
  proto_item *ruii = NULL;

  if (partial_bw_info == 0x1E) { /* Uses 996-tone RU indices */
    if (ng == 4) {
      init_eht_scidx(&scidx_ctx, i, &ru_996_tone_80MHz_ng4[0], ng);
    } else {
      init_eht_scidx(&scidx_ctx, i, &ru_996_tone_80MHz_ng16[0], ng);
    }
    ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                                  ett_eht_beamforming_rpt_ru_index,
                                                  &ruii,
                                                  "996-tone RU Index %d for 80MHz", 1);
    while (next_eht_scidx(&scidx_ctx, &scidx)) {
      bit_offset = dissect_he_feedback_matrix(ru_index_tree, tvb, pinfo, offset,
                                              bit_offset, scidx, nr_index + 1,
                                              nc_index + 1, phi_bits, psi_bits,
                                              hf_ieee80211_eht_compressed_beamform_scidx);
      offset = bit_offset / 8;
    }
    proto_item_set_len(ruii, offset - start_offset);

    return offset - start_offset;
  }

  /* Add each of the RU index groups */
  for (i = 1; i <= 4; i++) {
    int tree_offset = offset;
    if ((partial_bw_info & (1 << i)) == 0x0) {
      continue;  /* Only dissect those with the bit set */
    }

    init_eht_scidx(&scidx_ctx, i, &ru_242_tone_80MHz[i - 1], ng);
    ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                                  ett_eht_beamforming_rpt_ru_index,
                                                  &ruii,
                                                  "RU Index %d for 80MHz, Partial BW "
                                                  "not all one.", i);
    while (next_eht_scidx(&scidx_ctx, &scidx)) {
      bit_offset = dissect_he_feedback_matrix(ru_index_tree, tvb, pinfo, offset,
                                              bit_offset, scidx, nr_index + 1,
                                              nc_index + 1, phi_bits, psi_bits,
                                              hf_ieee80211_eht_compressed_beamform_scidx);
      offset = bit_offset / 8;
    }
    proto_item_set_len(ruii, offset - tree_offset);
  }

  return offset - start_offset;
}

static int
add_ff_eht_su_160MHz_rpt(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,
                         int offset, uint8_t nc_index, uint8_t nr_index,
                         uint8_t grouping, uint16_t partial_bw_info,
                         uint8_t phi_bits, uint8_t psi_bits)
{
  int start_offset = offset;
  int tree_offset;
  int i = 0;
  struct scidx_ctx scidx_ctx;
  unsigned scidx;
  uint8_t ng = grouping == 0 ? 4 : 16;
  unsigned bit_offset = offset * 8;
  proto_tree *ru_index_tree = NULL;
  proto_item *ruii = NULL;

  /* Is the first lot a 996-tone RU? */
  if ((partial_bw_info & 0x1E) == 0x1E) { /* Uses 996-tone RU indices */
    tree_offset = offset;
    if (ng == 4) {
      init_eht_scidx(&scidx_ctx, i, &ru_996_tone_160MHz_ng4[0], ng);
    } else {
      init_eht_scidx(&scidx_ctx, i, &ru_996_tone_160MHz_ng16[0], ng);
    }
    ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                                  ett_eht_beamforming_rpt_ru_index,
                                                  &ruii,
                                                  "996-tone RU Index %d for 160MHz", 1);
    while (next_eht_scidx(&scidx_ctx, &scidx)) {
      bit_offset = dissect_he_feedback_matrix(ru_index_tree, tvb, pinfo, offset,
                                              bit_offset, scidx, nr_index + 1,
                                              nc_index + 1, phi_bits, psi_bits,
                                              hf_ieee80211_eht_compressed_beamform_scidx);
      offset = bit_offset / 8;
    }
    proto_item_set_len(ruii, offset - tree_offset);
  } else {
    /* Add each of the RU index groups for the lower 80MHz */
    for (i = 1; i <= 4; i++) {
      if ((partial_bw_info & (1 << i)) == 0x0) {
        continue;  /* Only dissect those with the bit set */
      }

      tree_offset = offset;
      init_eht_scidx(&scidx_ctx, i, &ru_242_tone_160MHz[i - 1], ng);
      ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                                    ett_eht_beamforming_rpt_ru_index,
                                                    &ruii,
                                                    "RU Index %d for 160MHz, Partial BW "
                                                    "not all one, lower 80MHz.", i);
      while (next_eht_scidx(&scidx_ctx, &scidx)) {
        bit_offset = dissect_he_feedback_matrix(ru_index_tree, tvb, pinfo,
                                                offset, bit_offset, scidx,
                                                nr_index + 1, nc_index + 1,
                                                phi_bits, psi_bits,
                                                hf_ieee80211_eht_compressed_beamform_scidx);
        offset = bit_offset / 8;
      }
      proto_item_set_len(ruii, offset - tree_offset);
    }
  }

  /* Is the second lot a 996-tone RU? */
  if ((partial_bw_info & 0x1E0) == 0x1E0) { /* Uses 996-tone RU indices */
    tree_offset = offset;
    if (ng == 4) {
      init_eht_scidx(&scidx_ctx, i, &ru_996_tone_160MHz_ng4[2], ng);
    } else {
      init_eht_scidx(&scidx_ctx, i, &ru_996_tone_160MHz_ng16[5], ng);
    }
    ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                                  ett_eht_beamforming_rpt_ru_index,
                                                  &ruii,
                                                  "996-tone RU Index %d for 160MHz", 2);
    while (next_eht_scidx(&scidx_ctx, &scidx)) {
      bit_offset = dissect_he_feedback_matrix(ru_index_tree, tvb, pinfo, offset,
                                              bit_offset, scidx, nr_index + 1,
                                              nc_index + 1, phi_bits, psi_bits,
                                              hf_ieee80211_eht_compressed_beamform_scidx);
      offset = bit_offset / 8;
    }
    proto_item_set_len(ruii, offset - tree_offset);
  } else {
    /* Add each of the RU index groups for the lower 80MHz */
    for (i = 5; i <= 8; i++) {
      if ((partial_bw_info & (1 << i)) == 0x0) {
        continue;  /* Only dissect those with the bit set */
      }

      tree_offset = offset;
      init_eht_scidx(&scidx_ctx, i, &ru_242_tone_160MHz[i - 1], ng);
      ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                                    ett_eht_beamforming_rpt_ru_index,
                                                    &ruii,
                                                    "RU Index %d for 160MHz, Partial BW "
                                                    "not all one, upper 80MHz.", i);
      while (next_eht_scidx(&scidx_ctx, &scidx)) {
        bit_offset = dissect_he_feedback_matrix(ru_index_tree, tvb, pinfo,
                                                offset, bit_offset, scidx,
                                                nr_index + 1, nc_index + 1,
                                                phi_bits, psi_bits,
                                                hf_ieee80211_eht_compressed_beamform_scidx);
        offset = bit_offset / 8;
      }
      proto_item_set_len(ruii, offset - tree_offset);
    }
  }

  return offset - start_offset;
}

static int
add_ff_eht_su_320MHz_rpt(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,
                         int offset, uint8_t nc_index, uint8_t nr_index,
                         uint8_t grouping, uint16_t partial_bw_info,
                         uint8_t phi_bits, uint8_t psi_bits)
{
  int start_offset = offset;
  int tree_offset = offset;
  int i = 0, j = 0, k = 0;
  struct scidx_ctx scidx_ctx;
  unsigned scidx;
  uint8_t ng = grouping == 0 ? 4 : 16;
  unsigned bit_offset = offset * 8;
  proto_tree *ru_index_tree = NULL;
  proto_item *ruii = NULL;

  /* Resolution is 40 MHz */
  for (i = 0; i < 4; i++) {
    if (((partial_bw_info >> (2*i+1)) & 0x03) == 0x03) { /* Uses 996-tone RU indices */
      if (ng == 4) {
        init_eht_scidx(&scidx_ctx, i+1, &ru_996_tone_320MHz_ng4[i * 2], ng);
      } else {
        init_eht_scidx(&scidx_ctx, i+1, &ru_996_tone_320MHz_ng16[i * 5], ng);
      }
      ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                                    ett_eht_beamforming_rpt_ru_index,
                                                    &ruii,
                                                    "996-tone RU Index %d for 320MHz",
                                                    i+1);
      tree_offset = offset;
      while (next_eht_scidx(&scidx_ctx, &scidx)) {
        bit_offset = dissect_he_feedback_matrix(ru_index_tree, tvb, pinfo,
                                                offset, bit_offset, scidx,
                                                nr_index + 1, nc_index + 1,
                                                phi_bits, psi_bits,
                                                hf_ieee80211_eht_compressed_beamform_scidx);
        offset = bit_offset / 8;
      }
      proto_item_set_len(ruii, offset - tree_offset);
    } else {
      for (j = 2*i; j <= 2*i+1; j++) {
        if ((partial_bw_info & (1 << (j+1))) == 0x0) {
          continue;  /* Only dissect those with the bit set */
        }
        /* Each 484-tone RU contains two 242-tone RUs */
        for (k = 2*j;k <= 2*j+1;k++) {
          init_eht_scidx(&scidx_ctx, k+1, &ru_242_tone_320MHz[k], ng);
          ru_index_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                            ett_eht_beamforming_rpt_ru_index,
                            &ruii,
                            "RU Index %d for 320MHz, Partial BW "
                            "not all one.", k+1);
          tree_offset = offset;
          while (next_eht_scidx(&scidx_ctx, &scidx)) {
            bit_offset = dissect_he_feedback_matrix(ru_index_tree, tvb, pinfo, offset,
                           bit_offset, scidx, nr_index + 1,
                           nc_index + 1, phi_bits, psi_bits,
                           hf_ieee80211_eht_compressed_beamform_scidx);
            offset = bit_offset / 8;
          }
          proto_item_set_len(ruii, offset - tree_offset);
        }
      }
    }
  }

  return offset - start_offset;
}

static unsigned
add_ff_eht_su_beamforming_rpt(proto_tree *tree, tvbuff_t *tvb,
                              packet_info *pinfo, int offset,
                              uint64_t mimo_control)
{
  uint8_t nc_index = mimo_control & 0x0F;
  uint8_t nr_index = (mimo_control >> 4) & 0x0F;
  uint8_t bw = (mimo_control >> 8) & 0x07;
  uint8_t grouping = (mimo_control >> 11) & 0x01;
  uint16_t partial_bw_info = (mimo_control >> 21) & 0x01FF;
  uint8_t codebook_info = (mimo_control >> 36) & 0x01;
  proto_tree *snr_tree = NULL, *feedback_tree = NULL;
  proto_item *fti = NULL;
  uint8_t i = 0, phi_bits, psi_bits;
  unsigned start_offset = offset;
  unsigned tree_len = 0, byte_count = 0;

  snr_tree = proto_tree_add_subtree(tree, tvb, offset, nc_index + 1,
               ett_ff_eht_mimo_beamforming_report_snr, NULL,
               "Average Signal to Noise Ratio");

  for (i = 0; i < nc_index + 1; i++) {
    int8_t snr = tvb_get_int8(tvb, offset);

    proto_tree_add_int_format(snr_tree,
      hf_ieee80211_eht_compressed_beamforming_report_snr, tvb, offset, 1,
      snr, "Stream %d: %s%0.2fdB (0x%02x)", i,
      (snr == 127 ? ">=" : (snr == -128 ? "<=" : "")),
      (float)((float)88 + snr)/4, (uint8_t)snr);
    offset++;
  }

  if (codebook_info == 0) {
    phi_bits = 4;
    psi_bits = 2;
  } else {
    phi_bits = 6;
    psi_bits = 4;
  }

  feedback_tree = proto_tree_add_subtree(tree, tvb, offset, -1,
                                         ett_eht_beamforming_feedback_tree,
                                         &fti, "Feedback Matrices");
  switch (bw) {
  case 0: /*  20 MHz */
    tree_len = add_ff_eht_su_20MHz_rpt(feedback_tree, tvb, pinfo, offset,
                                       nc_index, nr_index, grouping,
                                       partial_bw_info, phi_bits, psi_bits);
    proto_item_set_len(fti, tree_len);
    offset += tree_len;
    break;
  case 1: /*  40 MHz */
    tree_len = add_ff_eht_su_40MHz_rpt(feedback_tree, tvb, pinfo, offset,
                                       nc_index, nr_index, grouping,
                                       partial_bw_info, phi_bits, psi_bits);
    proto_item_set_len(fti, tree_len);
    offset += tree_len;
    break;
  case 2: /*  80 MHz */
    tree_len = add_ff_eht_su_80MHz_rpt(feedback_tree, tvb, pinfo, offset,
                                       nc_index, nr_index, grouping,
                                       partial_bw_info, phi_bits, psi_bits);
    proto_item_set_len(fti, tree_len);
    offset += tree_len;
    break;
  case 3: /* 160 MHz */
    tree_len = add_ff_eht_su_160MHz_rpt(feedback_tree, tvb, pinfo, offset,
                                        nc_index, nr_index, grouping,
                                        partial_bw_info, phi_bits, psi_bits);
    proto_item_set_len(fti, tree_len);
    offset += tree_len;
    break;
  case 4: /* 320 MHz */
    tree_len = add_ff_eht_su_320MHz_rpt(feedback_tree, tvb, pinfo, offset,
                                        nc_index, nr_index, grouping,
                                        partial_bw_info, phi_bits, psi_bits);
    proto_item_set_len(fti, tree_len);
    offset += tree_len;
    break;
  default:
    /* Add EI about invalid BW setting */
    break;
  }

  byte_count = tvb_reported_length_remaining(tvb, offset);
  if (byte_count > 0)
    offset += byte_count; /* Should fix the real problem. */

  return offset - start_offset;
}

static const val64_string eht_mimo_bw_vals[] = {
  { 0, "20 MHz" },
  { 1, "40 MHz" },
  { 2, "80 MHz" },
  { 3, "160 MHz" },
  { 4, "320 MHz" },
  { 5, "Reserved" },
  { 6, "Reserved" },
  { 7, "Reserved" },
  { 0, NULL }
};

static const val64_string eht_mimo_grouping_vals[] = {
  { 0, "Ng = 4" },
  { 1, "Ng = 16" },
  { 0, NULL }
};

static const val64_string eht_feedback_type_vals[] = {
  { 0, "SU" },
  { 1, "MU" },
  { 2, "CQI" },
  { 3, "Reserved" },
  { 0, NULL }
};

static int * const eht_mimo_ctrl_hdrs[] = {
  &hf_ieee80211_eht_mimo_ctrl_nc_index,
  &hf_ieee80211_eht_mimo_ctrl_nr_index,
  &hf_ieee80211_eht_mimo_ctrl_bw,
  &hf_ieee80211_eht_mimo_ctrl_grouping,
  &hf_ieee80211_eht_mimo_ctrl_feedback_type,
  &hf_ieee80211_eht_mimo_ctrl_reserved1,
  &hf_ieee80211_eht_mimo_ctrl_remaining_feedback_segments,
  &hf_ieee80211_eht_mimo_ctrl_first_feedback_segment,
  &hf_ieee80211_eht_mimo_ctrl_partial_bw_info,
  &hf_ieee80211_eht_mimo_ctrl_sounding_dialog_token_number,
  &hf_ieee80211_eht_mimo_ctrl_codebook_info,
  &hf_ieee80211_eht_mimo_ctrl_reserved2,
  NULL
};

static unsigned
add_ff_eht_mimo_control_etc(proto_tree *tree _U_, tvbuff_t *tvb _U_,
                            packet_info *pinfo _U_,
                            int offset _U_)
{
  unsigned start = offset;
  uint64_t mimo_control = tvb_get_uint40(tvb, offset, ENC_LITTLE_ENDIAN);
  uint8_t feedback_type = (mimo_control >> 12) & 0x03;
  uint8_t nc_index = mimo_control & 0x0F;
  uint8_t nr_index = (mimo_control >> 4) & 0x0F;
  proto_item *mci = NULL;

  mci = proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                          hf_ieee80211_eht_mimo_ctrl_field,
                                          ett_eht_mimo_ctrl, eht_mimo_ctrl_hdrs,
                                          ENC_LITTLE_ENDIAN, BMT_NO_APPEND);

  /*
   * Validate nc_index and nr_index and go no further if they exceed the
   * limits.
   *
   * 802.11be D3.0
   */
  if (nc_index > 7) {
    expert_add_info_format(pinfo, mci, &ei_ieee80211_eht_invalid_nc_nr,
                           "Nc indices (%d) > 7 are reserved", nc_index);
    return offset;
  }
  if (nr_index == 0 || nr_index > 7) {
    expert_add_info_format(pinfo, mci, &ei_ieee80211_eht_invalid_nc_nr,
                           "Nr indices (%d) 0 and > 7 are reserved", nr_index);
    return offset;
  }
  offset += 5;

  switch (feedback_type) {
  case SU_FEEDBACK:
    offset += add_ff_eht_su_beamforming_rpt(tree, tvb, pinfo, offset,
                                            mimo_control);
    break;
  case MU_FEEDBACK:
    offset += add_ff_eht_su_beamforming_rpt(tree, tvb, pinfo, offset,
                                            mimo_control);
    offset += add_ff_eht_mu_exclusive_beamforming_rpt(tree, tvb, pinfo, offset,
                                                      mimo_control);
    break;
  case CQI_FEEDBACK:
    /* TODO */
    break;
  default:
    break;
  }

  return offset - start;
}

static const range_string eht_action_rvals[] = {
  { 0, 0, "EHT Compressed Beamforming/CQI" },
  { 1, 255, "Reserved" },
  { 0, 0, NULL }
};

static unsigned
add_ff_action_eht(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,
                  int offset)
{
  unsigned start = offset;
  uint8_t eht_action;
  proto_item *item = NULL;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);

  eht_action = tvb_get_uint8(tvb, offset);

  item = proto_tree_add_item(tree, hf_ieee80211_ff_eht_action, tvb, offset, 1,
                             ENC_NA);
  offset += 1;

  switch (eht_action) {
  case 0:
    offset += add_ff_eht_mimo_control_etc(tree, tvb, pinfo, offset);
    break;
  default:
    expert_add_info_format(pinfo, item, &ei_ieee80211_eht_invalid_action,
                           "Reserved EHT Action %u", eht_action);
  }

  return offset - start;
}

static unsigned
add_ff_action_fst(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  uint8_t code;
  unsigned  start = offset;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  code    = tvb_get_uint8(tvb, offset);
  offset += add_ff_fst_action_code(tree, tvb, pinfo, offset);
  switch (code) {
    case FST_SETUP_REQUEST:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_llt(tree, tvb, pinfo, offset);
      break;
    case FST_SETUP_RESPONSE:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_status_code(tree, tvb, pinfo, offset);
      break;
    case FST_TEAR_DOWN:
      offset += add_ff_fsts_id(tree, tvb, pinfo, offset);
      break;
    case FST_ACK_REQUEST:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_fsts_id(tree, tvb, pinfo, offset);
      break;
    case FST_ACK_RESPONSE:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_fsts_id(tree, tvb, pinfo, offset);
      break;
    case FST_ON_CHANNEL_TUNNEL_REQUEST:
      offset += add_ff_oct_mmpdu(tree, tvb, pinfo, offset);
      break;
  }
  return offset - start;
}

static int
add_ff_scs_descriptor_list(proto_tree *tree, tvbuff_t *tvb,
                           packet_info *pinfo _U_, int offset)
{
  unsigned start = offset;

  /*
   * This is could be a list, so it needs change.
   */
  offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
  return offset - start;
}

static int
add_ff_scs_response_count(proto_tree *tree, tvbuff_t *tvb,
                          packet_info *pinfo _U_, int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_ff_scs_response_count, tvb, offset, 1,
                      ENC_NA);

  return 1;
}

static int
add_ff_scs_status_list(proto_tree *tree, tvbuff_t *tvb,
                       packet_info *pinfo _U_, int offset, uint8_t count)
{
  unsigned start = offset;

  while (count > 0) {
    if (tvb_reported_length_remaining(tvb, offset) >= 3) {
      proto_tree_add_item(tree, hf_ieee80211_ff_scs_scsid, tvb, offset, 1,
                          ENC_NA);
      offset += 1;

      proto_tree_add_item(tree, hf_ieee80211_ff_scs_status, tvb, offset, 2,
                          ENC_LITTLE_ENDIAN);
      offset += 2;
    }
    count--;
  }

  return offset - start;
}

static int
add_ff_mscs_descriptor_elt(proto_tree *tree, tvbuff_t *tvb,
                           packet_info *pinfo _U_, int offset)
{
  unsigned start = offset;

  offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
  return offset - start;
}

static unsigned
add_ff_action_robust_av_streaming(proto_tree *tree, tvbuff_t *tvb,
                                  packet_info *pinfo, int offset)
{
  uint8_t code, count;
  unsigned  start = offset;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  code    = tvb_get_uint8(tvb, offset);
  offset += add_ff_robust_av_streaming_action_code(tree, tvb, pinfo, offset);

  switch (code) {
    case ROBUST_AV_STREAMING_SCS_REQUEST:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_scs_descriptor_list(tree, tvb, pinfo, offset);
      break;
    case ROBUST_AV_STREAMING_SCS_RESPONSE:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      count = tvb_get_uint8(tvb, offset);
      offset += add_ff_scs_response_count(tree, tvb, pinfo, offset);
      offset += add_ff_scs_status_list(tree, tvb, pinfo, offset, count);
      break;
    case ROBUST_AV_STREAMING_MSCS_REQUEST:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_mscs_descriptor_elt(tree, tvb, pinfo, offset);
    break;
    case ROBUST_AV_STREAMING_MSCS_RESPONSE:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_status_code(tree, tvb, pinfo, offset);
      /* If there is any more data it is probably an mscs descriptor */
      if (tvb_reported_length_remaining(tvb, offset) > 0)
        offset += add_ff_mscs_descriptor_elt(tree, tvb, pinfo, offset);
    break;
  }
  return offset - start;
}

static unsigned
add_ff_action_dmg(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  uint8_t code;
  unsigned  start = offset;
  int left_offset;

  offset += add_ff_category_code(tree, tvb, pinfo, offset);
  code    = tvb_get_uint8(tvb, offset);
  offset += add_ff_dmg_action_code(tree, tvb, pinfo, offset);
  switch (code) {
    case DMG_ACTION_PWR_SAVE_CONFIG_REQ:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_dmg_pwr_mgmt(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_PWR_SAVE_CONFIG_RES:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_status_code(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_INFO_REQ:
      offset += add_ff_subject_address(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_INFO_RES:
      offset += add_ff_subject_address(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_HANDOVER_REQ:
      offset += add_ff_handover_reason(tree, tvb, pinfo, offset);
      offset += add_ff_handover_remaining_bi(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_HANDOVER_RES:
      offset += add_ff_handover_result(tree, tvb, pinfo, offset);
      offset += add_ff_handover_reject_reason(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_DTP_REQ:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_DTP_RES:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_RELAY_SEARCH_REQ:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_destination_reds_aid(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_RELAY_SEARCH_RES:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_status_code(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_MUL_RELAY_CHANNEL_MEASURE_REQ:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_MUL_RELAY_CHANNEL_MEASURE_RES:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      left_offset =
          tvb_reported_length_remaining(tvb, offset);
      while(left_offset > 0) {
        proto_tree_add_item(tree, hf_ieee80211_ff_peer_sta_aid, tvb, offset, 1, ENC_NA);
        proto_tree_add_item(tree, hf_ieee80211_ff_snr, tvb, offset+1, 1, ENC_NA);
        proto_tree_add_item(tree, hf_ieee80211_ff_internal_angle, tvb, offset+2, 1, ENC_NA);
        proto_tree_add_item(tree, hf_ieee80211_ff_recommend, tvb, offset+2, 1, ENC_NA);
        /* another reserved byte */
        offset += 4;
        left_offset -= 4;
      }
      break;
    case DMG_ACTION_RLS_REQ:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_destination_aid(tree, tvb, pinfo, offset);
      offset += add_ff_relay_aid(tree, tvb, pinfo, offset);
      offset += add_ff_source_aid(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_RLS_RES:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_RLS_ANNOUNCE:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_status_code(tree, tvb, pinfo, offset);
      offset += add_ff_destination_aid(tree, tvb, pinfo, offset);
      offset += add_ff_relay_aid(tree, tvb, pinfo, offset);
      offset += add_ff_source_aid(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_RLS_TEARDOWN:
      offset += add_ff_destination_aid(tree, tvb, pinfo, offset);
      offset += add_ff_relay_aid(tree, tvb, pinfo, offset);
      offset += add_ff_source_aid(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_RELAY_ACK_REQ:
    case DMG_ACTION_RELAY_ACK_RES:
      break;
    case DMG_ACTION_TPA_REQ:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_timing_offset(tree, tvb, pinfo, offset);
      offset += add_ff_sampling_frequency_offset(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_TPA_RES:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_TPA_REP:
      offset += add_ff_status_code(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_ROC_REQ:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_relay_operation_type(tree, tvb, pinfo, offset);
      break;
    case DMG_ACTION_ROC_RES:
      offset += add_ff_dialog_token(tree, tvb, pinfo, offset);
      offset += add_ff_status_code(tree, tvb, pinfo, offset);
      break;
  }
  return offset - start;
}

unsigned
add_ff_action(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset,
              association_sanity_check_t *association_sanity_check)
{
  switch (tvb_get_uint8(tvb, offset) & 0x7f) {
  case CAT_SPECTRUM_MGMT: /* 0 */
    return add_ff_action_spectrum_mgmt(tree, tvb, pinfo, offset);
  case CAT_QOS: /* 1 */
    return add_ff_action_qos(tree, tvb, pinfo, offset);
  case CAT_DLS: /* 2 */
    return add_ff_action_dls(tree, tvb, pinfo, offset);
  case CAT_BLOCK_ACK: /* 3 */
    return add_ff_action_block_ack(tree, tvb, pinfo, offset);
  case CAT_PUBLIC: /* 4 */
    return add_ff_action_public(tree, tvb, pinfo, offset);
  case CAT_RADIO_MEASUREMENT: /* 5 */
    return add_ff_action_radio_measurement(tree, tvb, pinfo, offset);
  case CAT_FAST_BSS_TRANSITION: /* 6 */
    return add_ff_action_fast_bss_transition(tree, tvb, pinfo, offset);
  case CAT_HT: /* 7 */
    return add_ff_action_ht(tree, tvb, pinfo, offset);
  case CAT_SA_QUERY: /* 8 */
    return add_ff_action_sa_query(tree, tvb, pinfo, offset);
  case CAT_PUBLIC_PROTECTED: /* 9 */
    return add_ff_action_protected_public(tree, tvb, pinfo, offset);
  case CAT_WNM: /* 10 */
    return add_ff_action_wnm(tree, tvb, pinfo, offset);
  case CAT_UNPROTECTED_WNM: /* 11 */
    return add_ff_action_unprotected_wnm(tree, tvb, pinfo, offset);
  case CAT_TDLS: /* 12 */
    return add_ff_action_tdls(tree, tvb, pinfo, offset);
  case CAT_MESH: /* 13 */
    return add_ff_action_mesh(tree, tvb, pinfo, offset);
  case CAT_MULTIHOP: /* 14 */
    return add_ff_action_multihop(tree, tvb, pinfo, offset);
  case CAT_SELF_PROTECTED: /* 15 */
    return add_ff_action_self_protected(tree, tvb, pinfo, offset, association_sanity_check);
  case CAT_DMG: /* 16 */
    return add_ff_action_dmg(tree, tvb, pinfo, offset);
  case CAT_MGMT_NOTIFICATION:  /* Management notification frame - 17 */
    return add_ff_action_mgmt_notification(tree, tvb, pinfo, offset);
  case CAT_FAST_SESSION_TRANSFER: /* 18 */
    return add_ff_action_fst(tree, tvb, pinfo, offset);
  case CAT_ROBUST_AV_STREAMING: /* 19 */
    return add_ff_action_robust_av_streaming(tree, tvb, pinfo, offset);
  case CAT_UNPROTECTED_DMG: /* 20 */
    return add_ff_action_unprotected_dmg(tree, tvb, pinfo, offset);
  case CAT_VHT: /* 21 */
    return add_ff_action_vht(tree, tvb, pinfo, offset);
  case CAT_S1G: /* 22 */
    return add_ff_action_s1g(tree, tvb, pinfo, offset);
  case CAT_PROTECTED_S1G: /* 23 */
    return add_ff_action_protected_s1g(tree, tvb, pinfo, offset);
  case CAT_HE:
    return add_ff_action_he(tree, tvb, pinfo, offset);
  case CAT_PROTECTED_HE:
    return add_ff_action_protected_he(tree, tvb, pinfo, offset);
  case CAT_PROTECTED_EHT:
    return add_ff_action_protected_eht(tree, tvb, pinfo, offset);
  case CAT_PROTECTED_FTM:
    return add_ff_action_protected_ftm(tree, tvb, pinfo, offset);
  case CAT_EHT:
    return add_ff_action_eht(tree, tvb, pinfo, offset);
  case CAT_VENDOR_SPECIFIC_PROTECTED: /* Same as below for now */
  case CAT_VENDOR_SPECIFIC:  /* Vendor Specific Protected Category - 127 */
    return add_ff_action_vendor_specific(tree, tvb, pinfo, offset);
  default:
    add_ff_category_code(tree, tvb, pinfo, offset);
    return 1;
  }
}

static const value_string ieee80211_rsn_cipher_vals[] = {
  {0, "NONE"},
  {1, "WEP (40-bit)"},
  {2, "TKIP"},
  {3, "AES (OCB)"},
  {4, "AES (CCM)"},
  {5, "WEP (104-bit)"},
  {6, "BIP (128)"},
  {7, "Group addressed traffic not allowed"},
  {8, "GCMP (128)" },
  {9, "GCMP (256)" },
  {10, "CCMP (256)" },
  {11, "BIP (GMAC-128)" },
  {12, "BIP (GMAC-256)" },
  {13, "BIP (CMAC-256)" },
  {0, NULL}
};

#define AKMS_NONE                 0x000FAC00
#define AKMS_WPA                  0x000FAC01
#define AKMS_PSK                  0x000FAC02
#define AKMS_FT_IEEE802_1X        0x000FAC03
#define AKMS_FT_PSK               0x000FAC04
#define AKMS_WPA_SHA256           0x000FAC05
#define AKMS_PSK_SHA256           0x000FAC06
#define AKMS_TDLS                 0x000FAC07
#define AKMS_SAE                  0x000FAC08
#define AKMS_FT_SAE               0x000FAC09
#define AKMS_AP_PEER_KEY          0x000FAC0A
#define AKMS_WPA_SHA256_SUITEB    0x000FAC0B
#define AKMS_WPA_SHA384_SUITEB    0x000FAC0C
#define AKMS_FT_IEEE802_1X_SHA384 0x000FAC0D
#define AKMS_FILS_SHA256          0x000FAC0E
#define AKMS_FILS_SHA384          0x000FAC0F
#define AKMS_FT_FILS_SHA256       0x000FAC10
#define AKMS_FT_FILS_SHA384       0x000FAC11
#define AKMS_OWE                  0x000FAC12
#define AKMS_SAE_GROUP_DEPEND     0x000FAC18
#define AKMS_FT_SAE_GROUP_DEPEND  0x000FAC19

static const value_string ieee80211_rsn_keymgmt_vals[] = {
  {0, "NONE"},
  {1, "WPA"},
  {2, "PSK"},
  {3, "FT over IEEE 802.1X"},
  {4, "FT using PSK"},
  {5, "WPA (SHA256)"},
  {6, "PSK (SHA256)"},
  {7, "TDLS / TPK Handshake (SHA256)"},
  {8, "SAE (SHA256)" },
  {9, "FT using SAE (SHA256)" },
  {10, "APPeerKey (SHA256)" },
  {11, "WPA (SHA256-SuiteB)" },
  {12, "WPA (SHA384-SuiteB)" },
  {13, "FT over IEEE 802.1X (SHA384)" },
  {14, "FILS (SHA256 and AES-SIV-256)" },
  {15, "FILS (SHA384 and AES-SIV-512)" },
  {16, "FT over FILS (SHA256 and AES-SIV-256)" },
  {17, "FT over FILS (SHA384 and AES-SIV-512)" },
  {18, "Opportunistic Wireless Encryption"},
  {19, "FT using PSK (SHA384)"},
  {20, "PSK (SHA384)"},
  {21, "PASN"},
  {24, "SAE (GROUP-DEPEND)"},
  {25, "FT using SAE (GROUP-DEPEND)"},
  {0, NULL}
};

static void
oui_base_custom(char *result, uint32_t oui)
{
  uint8_t      p_oui[3];
  const char *manuf_name;

  p_oui[0] = oui >> 16 & 0xFF;
  p_oui[1] = oui >> 8 & 0xFF;
  p_oui[2] = oui & 0xFF;

  /* Attempt an OUI lookup. */
  manuf_name = uint_get_manuf_name_if_known(oui);
  if (manuf_name == NULL) {
    /* Could not find an OUI. */
    snprintf(result, ITEM_LABEL_LENGTH, "%02x:%02x:%02x", p_oui[0], p_oui[1], p_oui[2]);
  }
  else {
   /* Found an address string. */
    snprintf(result, ITEM_LABEL_LENGTH, "%02x:%02x:%02x (%s)", p_oui[0], p_oui[1], p_oui[2], manuf_name);
  }
}

static void
rsn_gcs_base_custom(char *result, uint32_t gcs)
{
  char oui_result[SHORT_STR];
  char *tmp_str;

  oui_result[0] = '\0';
  oui_base_custom(oui_result, gcs >> 8);
  tmp_str = val_to_str_wmem(NULL, gcs & 0xFF, ieee80211_rsn_cipher_vals, "Unknown %d");
  snprintf(result, ITEM_LABEL_LENGTH, "%s %s", oui_result, tmp_str);
  wmem_free(NULL, tmp_str);
}

static void
rsn_pcs_base_custom(char *result, uint32_t pcs)
{
  char oui_result[SHORT_STR];
  char *tmp_str;

  oui_result[0] = '\0';
  oui_base_custom(oui_result, pcs >> 8);
  tmp_str = val_to_str_wmem(NULL, pcs & 0xFF, ieee80211_rsn_cipher_vals, "Unknown %d");
  snprintf(result, ITEM_LABEL_LENGTH, "%s %s", oui_result, tmp_str);
  wmem_free(NULL, tmp_str);

}
static void
rsn_akms_base_custom(char *result, uint32_t akms)
{
  char oui_result[SHORT_STR];
  char *tmp_str;

  oui_result[0] = '\0';
  oui_base_custom(oui_result, akms >> 8);
  tmp_str = val_to_str_wmem(NULL, akms & 0xFF, ieee80211_rsn_keymgmt_vals, "Unknown %d");
  snprintf(result, ITEM_LABEL_LENGTH, "%s %s", oui_result, tmp_str);
  wmem_free(NULL, tmp_str);
}

static char *
rsn_pcs_return(wmem_allocator_t *scope, uint32_t pcs)
{
  char *result;

  result = (char *)wmem_alloc(scope, SHORT_STR);
  result[0] = '\0';
  rsn_pcs_base_custom(result, pcs);

  return result;
}

static char *
rsn_akms_return(wmem_allocator_t *scope, uint32_t akms)
{
  char *result;

  result = (char *)wmem_alloc(scope, SHORT_STR);
  result[0] = '\0';
  rsn_akms_base_custom(result, akms);

  return result;
}

static void
rsn_gmcs_base_custom(char *result, uint32_t gmcs)
{
  char oui_result[SHORT_STR];
  char *tmp_str;

  oui_result[0] = '\0';
  oui_base_custom(oui_result, gmcs >> 8);
  tmp_str = val_to_str_wmem(NULL, gmcs & 0xFF, ieee80211_rsn_cipher_vals, "Unknown %d");
  snprintf(result, ITEM_LABEL_LENGTH, "%s %s", oui_result, tmp_str);
  wmem_free(NULL, tmp_str);
}

static void
rsni_base_custom(char *result, uint8_t rsni)
{
  double temp_double;

  if (rsni < 255) {
    temp_double = (double)rsni - 20;
    snprintf(result, ITEM_LABEL_LENGTH, "%.1f dB", (temp_double / 2));
  } else
    snprintf(result, ITEM_LABEL_LENGTH, "%d (Measurement not available)", rsni);
}

static void
vht_tpe_custom(char *result, uint8_t txpwr)
{
  int8_t txpwr_db;

  txpwr_db = (int8_t)(txpwr);
  snprintf(result, ITEM_LABEL_LENGTH, "%3.1f dBm", (txpwr_db/2.0));
}

static void
tpe_psd_custom(char *result, uint8_t txpwr)
{
  int8_t txpwr_db;

  txpwr_db = (int8_t)(txpwr);
  if (txpwr_db == -128) {
    snprintf(result, ITEM_LABEL_LENGTH, "Channel cannot be used for transmission");
  } else if (txpwr_db == 127) {
    snprintf(result, ITEM_LABEL_LENGTH, "No maximum PSD is specified for channel");
  } else {
    snprintf(result, ITEM_LABEL_LENGTH, "%3.1f dBm/MHz", (txpwr_db/2.0));
  }
}

static void
channel_number_custom(char *result, uint8_t channel_number)
{
  switch(channel_number){
    case 0:
      snprintf(result, ITEM_LABEL_LENGTH, "%u (iterative measurements on all supported channels in the specified Operating Class)", channel_number);
    break;
    case 255:
      snprintf(result, ITEM_LABEL_LENGTH, "%u (iterative measurements on all supported channels listed in the AP Channel Report)", channel_number);
    break;
    default :
      snprintf(result, ITEM_LABEL_LENGTH, "%u (iterative measurements on that Channel Number)", channel_number);
    break;
  }
}

/* WPA / WME */
static const value_string ieee802111_wfa_ie_type_vals[] = {
  { 1, "WPA Information Element" },
  { 2, "WMM/WME" },
  { 4, "WPS" },
  { 0, NULL }
};

static const value_string ieee80211_wfa_ie_wpa_cipher_vals[] = {
  { 0, "NONE" },
  { 1, "WEP (40-bit)" },
  { 2, "TKIP" },
  { 3, "AES (OCB)" },
  { 4, "AES (CCM)" },
  { 5, "WEP (104-bit)" },
  { 6, "BIP" },
  { 7, "Group addressed traffic not allowed" },
  { 0, NULL }
};

static const value_string ieee80211_wfa_ie_wpa_keymgmt_vals[] = {
  { 0, "NONE" },
  { 1, "WPA" },
  { 2, "PSK" },
  { 3, "FT over IEEE 802.1X" },
  { 4, "FT using PSK" },
  { 5, "WPA (SHA256)" },
  { 6, "PSK (SHA256)" },
  { 7, "TDLS / TPK Handshake" },
  { 0, NULL }
};

static const value_string ieee80211_wfa_ie_wme_acs_vals[] = {
  { 0, "Best Effort" },
  { 1, "Background" },
  { 2, "Video" },
  { 3, "Voice" },
  { 0, NULL }
};

static const value_string ieee80211_wfa_ie_wme_tspec_tsinfo_direction_vals[] = {
  { 0, "Uplink" },
  { 1, "Downlink" },
  { 2, "Direct link" },
  { 3, "Bidirectional link" },
  { 0, NULL }
};

static const value_string ieee80211_wfa_ie_wme_tspec_tsinfo_psb_vals[] = {
  { 0, "Legacy" },
  { 1, "U-APSD" },
  { 0, NULL }
};

static const value_string ieee80211_wfa_ie_wme_tspec_tsinfo_up_vals[] = {
  { 0, "Best Effort" },
  { 1, "Background" },
  { 2, "Spare" },
  { 3, "Excellent Effort" },
  { 4, "Controlled Load" },
  { 5, "Video" },
  { 6, "Voice" },
  { 7, "Network Control" },
  { 0, NULL }
};

static const value_string ieee802111_wfa_ie_wme_qos_info_sta_max_sp_length_vals[] = {
  { 0, "WMM AP may deliver all buffered frames (MSDUs and MMPDUs)" },
  { 1, "WMM AP may deliver a maximum of 2 buffered frames (MSDUs and MMPDUs) per USP" },
  { 2, "WMM AP may deliver a maximum of 4 buffered frames (MSDUs and MMPDUs) per USP" },
  { 3, "WMM AP may deliver a maximum of 6 buffered frames (MSDUs and MMPDUs) per USP" },
  { 0, NULL}
};
static const true_false_string ieee802111_wfa_ie_wme_qos_info_sta_ac_tfs = {
  "WMM delivery and trigger enabled",
  "non-WMM PS"
};

/* az: Ranging Parameters */
static const val64_string ieee80211_ranging_status_vals[] = {
  { 0, "Reserved" },
  { 1, "Successful; measurement exchanges are about to begin" },
  { 2, "Request incapable; do not send same request again; FTM session ends" },
  { 3, "Request failed; do not send new request for Value seconds; FTM session ends" },
  { 0, NULL }
};

static const val64_string ieee80211_ranging_fmt_bw_vals[] = {
  { 0, "HE 20 MHz" },
  { 1, "HE 40 MHz" },
  { 2, "HE 80 MHz" },
  { 3, "HE 80+80 MHz" },
  { 4, "HE 160 MHz (two separate RF LOs)" },
  { 5, "HE 160 MHz (single RF LO)" },
  /* values 6-63 reserved */
  { 0, NULL }
};

static const val64_string ieee80211_ranging_ltf_total_vals[] = {
  { 0, "4 LTFs" },
  { 1, "8 LTFs" },
  { 2, "16 LTFs" },
  { 3, "No max LTFs specified" },
  { 0, NULL }
};

static void
wpa_mcs_base_custom(char *result, uint32_t mcs)
{
  char oui_result[SHORT_STR];
  char *tmp_str;

  oui_result[0] = '\0';
  oui_base_custom(oui_result, mcs >> 8);
  tmp_str = val_to_str_wmem(NULL, mcs & 0xFF, ieee80211_wfa_ie_wpa_cipher_vals, "Unknown %d");
  snprintf(result, ITEM_LABEL_LENGTH, "%s %s", oui_result, tmp_str);
  wmem_free(NULL, tmp_str);
}

static void
wpa_ucs_base_custom(char *result, uint32_t ucs)
{
  char oui_result[SHORT_STR];
  char *tmp_str;

  oui_result[0] = '\0';
  oui_base_custom(oui_result, ucs >> 8);
  tmp_str = val_to_str_wmem(NULL, ucs & 0xFF, ieee80211_wfa_ie_wpa_cipher_vals, "Unknown %d");
  snprintf(result, ITEM_LABEL_LENGTH, "%s %s", oui_result, tmp_str);
  wmem_free(NULL, tmp_str);
}
static void
wpa_akms_base_custom(char *result, uint32_t akms)
{
  char oui_result[SHORT_STR];
  char *tmp_str;

  oui_result[0] = '\0';
  oui_base_custom(oui_result, akms >> 8);
  tmp_str = val_to_str_wmem(NULL, akms & 0xFF, ieee80211_wfa_ie_wpa_keymgmt_vals, "Unknown %d");
  snprintf(result, ITEM_LABEL_LENGTH, "%s %s", oui_result, tmp_str);
  wmem_free(NULL, tmp_str);
}

static char *
wpa_ucs_return(wmem_allocator_t *scope, uint32_t ucs)
{
  char *result;

  result = (char *)wmem_alloc(scope, SHORT_STR);
  result[0] = '\0';
  wpa_ucs_base_custom(result, ucs);

  return result;
}

static char *
wpa_akms_return(wmem_allocator_t *scope, uint32_t akms)
{
  char *result;

  result = (char *)wmem_alloc(scope, SHORT_STR);
  result[0] = '\0';
  wpa_akms_base_custom(result, akms);

  return result;
}

/* For each Field */
static const value_string ieee80211_wapi_suite_type[] = {
  {0, "Reserved"},
  {1, "WAI Certificate Authentication and Key Management"},
  {2, "WAI Preshared Key Authentication and Key Management"},
  {0, NULL},
};
/* For Summary Tag Information */
static const value_string ieee80211_wapi_suite_type_short[] = {
  {0, "Reserved"},
  {1, "WAI-CERT"},
  {2, "WAI-PSK"},
  {0, NULL},
};

static const value_string ieee80211_wapi_cipher_type[] = {
  {0, "Reserved"},
  {1, "WPI-SMS4"},
  {0, NULL},
};

static const value_string ieee802111_wfa_ie_wme_type[] = {
  { 0, "Information Element" },
  { 1, "Parameter Element" },
  { 2, "TSPEC Element" },
  { 0, NULL}
};

static const value_string ft_subelem_id_vals[] = {
  {0, "Reserved"},
  {1, "PMK-R1 key holder identifier (R1KH-ID)"},
  {2, "GTK subelement"},
  {3, "PMK-R0 key holder identifier (R0KH-ID)"},
  {4, "IGTK"},
  {5, "Operating Channel Information (OCI)"},
  {6, "BIGTK"},
  {7, "WIGTK"},
  {8, "MLO GTK"},
  {9, "MLO IGTK"},
  {10, "MLO BIGTK"},
  {0, NULL}
};

static int
dissect_wme_qos_info(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset, int ftype)
{
  proto_item *wme_qos_info_item;

  static int * const ieee80211_mgt_req[] = {
    &hf_ieee80211_wfa_ie_wme_qos_info_sta_max_sp_length,
    &hf_ieee80211_wfa_ie_wme_qos_info_sta_ac_be,
    &hf_ieee80211_wfa_ie_wme_qos_info_sta_ac_bk,
    &hf_ieee80211_wfa_ie_wme_qos_info_sta_ac_vi,
    &hf_ieee80211_wfa_ie_wme_qos_info_sta_ac_vo,
    &hf_ieee80211_wfa_ie_wme_qos_info_sta_reserved,
    NULL
  };

  static int * const ieee80211_mgt_resp[] = {
    &hf_ieee80211_wfa_ie_wme_qos_info_ap_u_apsd,
    &hf_ieee80211_wfa_ie_wme_qos_info_ap_parameter_set_count,
    &hf_ieee80211_wfa_ie_wme_qos_info_ap_reserved,
    NULL
  };

  switch (ftype) {
    case MGT_ASSOC_REQ:
    case MGT_PROBE_REQ:
    case MGT_REASSOC_REQ:
    {
      /* To AP so decode as per WMM standard Figure 7 QoS Info field when sent from WMM STA*/
      proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_wfa_ie_wme_qos_info,
                                    ett_wme_qos_info, ieee80211_mgt_req,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
      break;
    }
    case MGT_BEACON:
    case MGT_PROBE_RESP:
    case MGT_ASSOC_RESP:
    case MGT_REASSOC_RESP:
    case MGT_ACTION:
    {
      /* From AP so decode as per WMM standard Figure 6 QoS Info field when sent from WMM AP */
      proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_wfa_ie_wme_qos_info,
                                    ett_wme_qos_info, ieee80211_mgt_resp,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
      break;
    }
    default:
        wme_qos_info_item = proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_qos_info, tvb, offset, 1, ENC_NA);
        expert_add_info_format(pinfo, wme_qos_info_item, &ei_ieee80211_wfa_ie_wme_qos_info_bad_ftype, "Could not deduce direction to decode correctly, ftype %u", ftype);
      break;
    }

  offset += 1;
  return offset;
}

static int * const update_edca_info_headers[] = {
  &hf_ieee80211_s1g_update_edca_override,
  &hf_ieee80211_s1g_update_edca_ps_poll_aci,
  &hf_ieee80211_s1g_update_edca_raw_aci,
  &hf_ieee80211_s1g_update_edca_sta_type,
  &hf_ieee80211_s1g_update_edca_reserved,
  NULL
};

static const value_string sta_field_type_vals[] = {
  { 0, "Valid for both sensor and non-sensor STAs" },
  { 1, "Valid for sensor STAs" },
  { 2, "Valid for non-sensor STAs" },
  { 3, "Reserved" },
  { 0, NULL }
};

static int
decode_qos_parameter_set(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset, int ftype)
{
  int i;
  bool is_s1g = sta_is_s1g(pinfo);
  /* WME QoS Info Field */
  offset = dissect_wme_qos_info(tree, tvb, pinfo, offset, ftype);
  /* WME Reserved Field or EDCA Update */
  if (is_s1g) {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                            hf_ieee80211_s1g_update_edca_info,
                            ett_update_edca_info, update_edca_info_headers,
                            ENC_LITTLE_ENDIAN, BMT_NO_APPEND);

  } else {
    proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_reserved, tvb, offset, 1, ENC_NA);
  }

  offset += 1;
  /* AC Parameters */
  for (i = 0; i < 4; i++)
  {
    proto_item *ac_item, *aci_aifsn_item, *ecw_item, *cw_item;
    proto_tree *ac_tree, *ecw_tree;
    uint8_t aci_aifsn, ecw, ecwmin, ecwmax;
    uint16_t cwmin, cwmax;
    static int * const ieee80211_wfa_ie_wme_be[] = {
        &hf_ieee80211_wfa_ie_wme_acp_aci_be,
        &hf_ieee80211_wfa_ie_wme_acp_acm_be,
        &hf_ieee80211_wfa_ie_wme_acp_aifsn_be,
        &hf_ieee80211_wfa_ie_wme_acp_reserved_be,
        NULL
    };

    static int * const ieee80211_wfa_ie_wme_bk[] = {
        &hf_ieee80211_wfa_ie_wme_acp_aci_bk,
        &hf_ieee80211_wfa_ie_wme_acp_acm_bk,
        &hf_ieee80211_wfa_ie_wme_acp_aifsn_bk,
        &hf_ieee80211_wfa_ie_wme_acp_reserved_bk,
        NULL
    };

    static int * const ieee80211_wfa_ie_wme_vi[] = {
        &hf_ieee80211_wfa_ie_wme_acp_aci_vi,
        &hf_ieee80211_wfa_ie_wme_acp_acm_vi,
        &hf_ieee80211_wfa_ie_wme_acp_aifsn_vi,
        &hf_ieee80211_wfa_ie_wme_acp_reserved_vi,
        NULL
    };

    static int * const ieee80211_wfa_ie_wme_vo[] = {
        &hf_ieee80211_wfa_ie_wme_acp_aci_vo,
        &hf_ieee80211_wfa_ie_wme_acp_acm_vo,
        &hf_ieee80211_wfa_ie_wme_acp_aifsn_vo,
        &hf_ieee80211_wfa_ie_wme_acp_reserved_vo,
        NULL
    };

    static int * const * ie_wme_hdrs[] = {
       ieee80211_wfa_ie_wme_be,
       ieee80211_wfa_ie_wme_bk,
       ieee80211_wfa_ie_wme_vi,
       ieee80211_wfa_ie_wme_vo
    };

    static int * const ecw_max_hf[] = {
      &hf_ieee80211_wfa_ie_wme_acp_ecw_max_be,
      &hf_ieee80211_wfa_ie_wme_acp_ecw_max_bk,
      &hf_ieee80211_wfa_ie_wme_acp_ecw_max_vi,
      &hf_ieee80211_wfa_ie_wme_acp_ecw_max_vo
    };

    static int * const ecw_min_hf[] = {
      &hf_ieee80211_wfa_ie_wme_acp_ecw_min_be,
      &hf_ieee80211_wfa_ie_wme_acp_ecw_min_bk,
      &hf_ieee80211_wfa_ie_wme_acp_ecw_min_vi,
      &hf_ieee80211_wfa_ie_wme_acp_ecw_min_vo
    };

    static int * const txop_limit_hf[] = {
      &hf_ieee80211_wfa_ie_wme_acp_txop_limit_be,
      &hf_ieee80211_wfa_ie_wme_acp_txop_limit_bk,
      &hf_ieee80211_wfa_ie_wme_acp_txop_limit_vi,
      &hf_ieee80211_wfa_ie_wme_acp_txop_limit_vo
    };

    ac_item = proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_ac_parameters, tvb, offset, 4, ENC_NA);
    ac_tree = proto_item_add_subtree(ac_item, ett_wme_ac);

    /* ACI/AIFSN Field */
    aci_aifsn_item = proto_tree_add_bitmask_with_flags(ac_tree, tvb, offset, hf_ieee80211_wfa_ie_wme_acp_aci_aifsn,
                            ett_wme_aci_aifsn, ie_wme_hdrs[i],
                            ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    aci_aifsn = tvb_get_uint8(tvb, offset);
    /* 802.11-2012, 8.4.2.31 EDCA Parameter Set element */
    if (aci_aifsn < 2) {
       expert_add_info_format(pinfo, aci_aifsn_item, &ei_ieee80211_qos_bad_aifsn,
         "The minimum value for the AIFSN subfield is 2 (found %u).", aci_aifsn);
    }
    proto_item_append_text(ac_item, " ACI %u (%s), ACM %s, AIFSN %u",
      (aci_aifsn & 0x60) >> 5, try_val_to_str((aci_aifsn & 0x60) >> 5, ieee80211_wfa_ie_wme_acs_vals),
      (aci_aifsn & 0x10) ? "yes" : "no", aci_aifsn & 0x0f);
    offset += 1;

    /* ECWmin/ECWmax field */
    ecw_item = proto_tree_add_item(ac_tree, hf_ieee80211_wfa_ie_wme_acp_ecw, tvb, offset, 1, ENC_NA);
    ecw_tree = proto_item_add_subtree(ecw_item, ett_wme_ecw);
    ecw = tvb_get_uint8(tvb, offset);
    ecwmin = ecw & 0x0f;
    ecwmax = (ecw & 0xf0) >> 4;
    cwmin= (1 << ecwmin) - 1;
    cwmax= (1 << ecwmax) - 1;
    cw_item = proto_tree_add_item(ecw_tree, *ecw_max_hf[i], tvb, offset, 1, ENC_NA);
    proto_item_append_text(cw_item, " (CW Max: %u)", cwmax);
    cw_item = proto_tree_add_item(ecw_tree, *ecw_min_hf[i], tvb, offset, 1, ENC_NA);
    proto_item_append_text(cw_item, " (CW Min: %u)", cwmin);
    proto_item_append_text(ac_item, ", ECWmin/max %u/%u (CWmin/max %u/%u)", ecwmin, ecwmax, cwmin, cwmax);
    offset += 1;

    /* TXOP Limit */
    proto_tree_add_item(ac_tree, *txop_limit_hf[i], tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_item_append_text(ac_item, ", TXOP %u", tvb_get_letohs(tvb, offset));
    offset += 2;
  }

  return offset;
}

static int
dissect_vendor_ie_wpawme(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset, uint32_t tag_len, int ftype)
{
  uint8_t type;

  proto_tree_add_item(tree, hf_ieee80211_wfa_ie_type, tvb, offset, 1, ENC_NA);
  type = tvb_get_uint8(tvb, offset);
  proto_item_append_text(tree, ": %s", val_to_str(type, ieee802111_wfa_ie_type_vals, "Unknown %d"));
  offset += 1;

  switch (type) {
    case 1:   /* Wi-Fi Protected Access (WPA) */
    {
      proto_item *wpa_mcs_item, *wpa_ucs_item, *wpa_akms_item;
      proto_item *wpa_sub_ucs_item, *wpa_sub_akms_item;
      proto_tree *wpa_mcs_tree, *wpa_ucs_tree, *wpa_akms_tree;
      proto_tree *wpa_sub_ucs_tree, *wpa_sub_akms_tree;
      uint16_t ucs_count, akms_count;
      unsigned ii;

      proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wpa_version, tvb, offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;

      /* Multicast Cipher Suite */
      wpa_mcs_item = proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wpa_mcs, tvb, offset, 4, ENC_BIG_ENDIAN);
      wpa_mcs_tree = proto_item_add_subtree(wpa_mcs_item, ett_wpa_mcs_tree);
      proto_tree_add_item(wpa_mcs_tree, hf_ieee80211_wfa_ie_wpa_mcs_oui, tvb, offset, 3, ENC_BIG_ENDIAN);

      /* Check if OUI is 00:50:F2 (WFA) */
      if (tvb_get_ntoh24(tvb, offset) == OUI_WPAWME)
      {
        proto_tree_add_item(wpa_mcs_tree, hf_ieee80211_wfa_ie_wpa_mcs_wfa_type, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);
        save_proto_data_value(pinfo, tvb_get_uint8(tvb, offset + 3), GROUP_CIPHER_KEY);
      } else {
        proto_tree_add_item(wpa_mcs_tree, hf_ieee80211_wfa_ie_wpa_mcs_type, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);
      }
      offset += 4;

      /* Unicast Cipher Suites */
      proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wpa_ucs_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
      ucs_count = tvb_get_letohs(tvb, offset);
      offset += 2;

      wpa_ucs_item = proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wpa_ucs_list, tvb, offset, ucs_count * 4, ENC_NA);
      wpa_ucs_tree = proto_item_add_subtree(wpa_ucs_item, ett_wpa_ucs_tree);
      for (ii = 0; ii < ucs_count; ii++)
      {
        wpa_sub_ucs_item = proto_tree_add_item(wpa_ucs_tree, hf_ieee80211_wfa_ie_wpa_ucs, tvb, offset, 4, ENC_BIG_ENDIAN);
        wpa_sub_ucs_tree = proto_item_add_subtree(wpa_sub_ucs_item, ett_wpa_sub_ucs_tree);
        proto_tree_add_item(wpa_sub_ucs_tree, hf_ieee80211_wfa_ie_wpa_ucs_oui, tvb, offset, 3, ENC_BIG_ENDIAN);

        /* Check if OUI is 00:50:F2 (WFA) */
        if (tvb_get_ntoh24(tvb, offset) == OUI_WPAWME)
        {
          proto_tree_add_item(wpa_sub_ucs_tree, hf_ieee80211_wfa_ie_wpa_ucs_wfa_type, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);
          proto_item_append_text(wpa_ucs_item, " %s", wpa_ucs_return(pinfo->pool, tvb_get_ntohl(tvb, offset)));
          save_proto_data_value(pinfo, tvb_get_uint8(tvb, offset + 3), CIPHER_KEY);
        } else {
          proto_tree_add_item(wpa_sub_ucs_tree, hf_ieee80211_wfa_ie_wpa_ucs_type, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);
        }
        offset += 4;
      }

      /* Authenticated Key Management Suites */
      proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wpa_akms_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
      akms_count = tvb_get_letohs(tvb, offset);
      offset += 2;

      wpa_akms_item = proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wpa_akms_list, tvb, offset, akms_count * 4, ENC_NA);
      wpa_akms_tree = proto_item_add_subtree(wpa_akms_item, ett_wpa_akms_tree);
      for (ii = 0; ii < akms_count; ii++)
      {
        wpa_sub_akms_item = proto_tree_add_item(wpa_akms_tree, hf_ieee80211_wfa_ie_wpa_akms, tvb, offset, 4, ENC_BIG_ENDIAN);
        wpa_sub_akms_tree = proto_item_add_subtree(wpa_sub_akms_item, ett_wpa_sub_akms_tree);
        proto_tree_add_item(wpa_sub_akms_tree, hf_ieee80211_wfa_ie_wpa_akms_oui, tvb, offset, 3, ENC_BIG_ENDIAN);

        /* Check if OUI is 00:50:F2 (WFA) */
        if (tvb_get_ntoh24(tvb, offset) == OUI_WPAWME)
        {
          proto_tree_add_item(wpa_sub_akms_tree, hf_ieee80211_wfa_ie_wpa_akms_wfa_type, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);
          proto_item_append_text(wpa_akms_item, " %s", wpa_akms_return(pinfo->pool, tvb_get_ntohl(tvb, offset)));
          save_proto_data_value(pinfo, tvb_get_uint8(tvb, offset + 3), AKM_KEY);
        } else {
          proto_tree_add_item(wpa_sub_akms_tree, hf_ieee80211_wfa_ie_wpa_akms_type, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);
        }
        offset += 4;
      }
      break;
    }
    case 2:   /* Wireless Multimedia Enhancements (WME) */
    {
      uint8_t subtype;

      proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_subtype, tvb, offset, 1, ENC_NA);
      subtype = tvb_get_uint8(tvb, offset);
      proto_item_append_text(tree, ": %s", val_to_str(subtype, ieee802111_wfa_ie_wme_type, "Unknown %d"));
      offset += 1;
      proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_version, tvb, offset, 1, ENC_NA);
      offset += 1;
      switch (subtype) {
        case 0: /* WME Information Element */
        {
          /* WME QoS Info Field */
          offset = dissect_wme_qos_info(tree, tvb, pinfo, offset, ftype);
          break;
        }
        case 1: /* WME Parameter Element */
        {
          offset = decode_qos_parameter_set(tree, tvb, pinfo, offset, ftype);
          break;
        }
        case 2:   /* WME TSPEC Element */
        {
            static int * const ieee80211_wfa_ie_wme_tspec_tsinfo[] = {
              &hf_ieee80211_wfa_ie_wme_tspec_tsinfo_tid,
              &hf_ieee80211_wfa_ie_wme_tspec_tsinfo_direction,
              &hf_ieee80211_wfa_ie_wme_tspec_tsinfo_psb,
              &hf_ieee80211_wfa_ie_wme_tspec_tsinfo_up,
              &hf_ieee80211_wfa_ie_wme_tspec_tsinfo_reserved,
              NULL
            };

            proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_wfa_ie_wme_tspec_tsinfo,
                                    ett_tsinfo_tree, ieee80211_wfa_ie_wme_tspec_tsinfo,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
            offset += 3;

            proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_tspec_nor_msdu, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            offset += 2;

            proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_tspec_max_msdu, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            offset += 2;

            proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_tspec_min_srv, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_tspec_max_srv, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_tspec_inact_int, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_tspec_susp_int, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_tspec_srv_start, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_tspec_min_data, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_tspec_mean_data, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_tspec_peak_data, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_tspec_burst_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_tspec_delay_bound, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_tspec_min_phy, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_tspec_surplus, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            offset += 2;

            proto_tree_add_item(tree, hf_ieee80211_wfa_ie_wme_tspec_medium, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            offset += 2;

          break;
        }
        default:
          /* No default Action */
        break;
      } /* End switch (subtype) */
      break;
    }
    case 4: /* WPS: Wifi Protected Setup */
    {
      dissect_wps_tlvs(tree, tvb, offset, tag_len-1, NULL);
    }
    break;
    default:
      /* No default Action...*/
    break;
  } /* End switch (type) */

  return offset;
}

/*
 * Dissect a group data cipher suite which consists of an OUI and a one-byte
 * selector: IEEE802.11 2012 Figure 9-256.
 *
 * Accepts a two entry array of header fields so we can use this elsewhere.
 */
static int dissect_group_data_cipher_suite(tvbuff_t *tvb, packet_info *pinfo _U_,
    proto_tree *tree, int offset, int *hf_array, int ett_val, char *label)
{
  proto_tree *gdcs_tree = NULL;

  gdcs_tree = proto_tree_add_subtree(tree, tvb, offset, 4, ett_val, NULL,
                         label);
  proto_tree_add_item(gdcs_tree, hf_array[0], tvb, offset, 3, ENC_BIG_ENDIAN);
  offset += 3;
  proto_tree_add_item(gdcs_tree, hf_array[1], tvb, offset, 1, ENC_NA);
  offset += 1;

  return offset;
}

static const range_string qos_mgmt_attributes[] = {
  { 0, 0, "Reserved" },
  { 1, 1, "Port Range" },
  { 2, 2, "DSCP Policy" },
  { 3, 3, "TCLAS" },
  { 4, 4, "Domain Name" },
  { 5, 255, "Reserved" },
  { 0, 0, NULL }
};

static int
ieee80211_frame_classifier(tvbuff_t *tvb, packet_info *pinfo _U_,
                           proto_tree *tree, int offset, int tag_len);

static int
dissect_qos_mgmt(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  uint8_t attr_id;
  uint8_t attr_len;
  uint8_t attr_num = 0;
  proto_tree *sub_tree = NULL;

  while (tvb_captured_length_remaining(tvb, offset)) {
    attr_id = tvb_get_uint8(tvb, offset);
    attr_len = tvb_get_uint8(tvb, offset + 1);
    proto_tree *attr = NULL;

    attr = proto_tree_add_subtree_format(tree, tvb, offset, attr_len + 2,
                                  ett_qos_mgmt_attributes, NULL,
                                  "QoS Management Attribute %d", attr_num++);
    proto_tree_add_item(attr, hf_ieee80211_qos_mgmt_attribute_id, tvb, offset,
                        1, ENC_NA);
    offset += 1;

    proto_tree_add_item(attr, hf_ieee80211_qos_mgmt_attribute_len, tvb, offset,
                        1, ENC_NA);
    offset += 1;

    switch (attr_id) {
    case 1:
      sub_tree = proto_tree_add_subtree(attr, tvb, offset, 1,
                          ett_qos_mgmt_dscp_policy_capabilities, NULL,
                          "Port Range");
      proto_tree_add_item(sub_tree, hf_ieee80211_qos_mgmt_start_port_range,
                          tvb, offset, 2, ENC_BIG_ENDIAN);
      offset += 2;

      proto_tree_add_item(sub_tree, hf_ieee80211_qos_mgmt_end_port_range, tvb,
                          offset, 2, ENC_BIG_ENDIAN);
      offset += 2;
      break;
    case 2:
      sub_tree = proto_tree_add_subtree(attr, tvb, offset, attr_len,
                          ett_qos_mgmt_dscp_policy, NULL,
                          "DSCP Policy");

      proto_tree_add_item(sub_tree, hf_ieee80211_qos_mgmt_dscp_pol_id, tvb,
                          offset, 1, ENC_NA);
      offset += 1;

      proto_tree_add_item(sub_tree, hf_ieee80211_qos_mgmt_dscp_pol_req_type,
                          tvb, offset, 1, ENC_NA);
      offset += 1;

      proto_tree_add_item(sub_tree, hf_ieee80211_qos_mgmt_dscp_pol_dscp, tvb,
                          offset, 1, ENC_NA);
      offset += 1;
      break;
    case 3:
      sub_tree = proto_tree_add_subtree(attr, tvb, offset, attr_len,
                          ett_qos_mgmt_tclas, NULL,
                          "TCLAS");

      ieee80211_frame_classifier(tvb, pinfo, sub_tree, offset, attr_len);
      offset += attr_len;
      break;
    case 4:
      sub_tree = proto_tree_add_subtree(attr, tvb, offset, attr_len,
                          ett_qos_mgmt_domain_name, NULL,
                          "Domain Name");
      proto_tree_add_item(sub_tree, hf_ieee80211_qos_mgmt_domain_name, tvb,
                          offset, attr_len, ENC_ASCII);
      offset += attr_len;
      break;
    default:
      sub_tree = proto_tree_add_subtree(attr, tvb, offset, attr_len,
                          ett_qos_mgmt_unknown_attribute, NULL,
                          "Unknown attribute");
      proto_tree_add_item(sub_tree, hf_ieee80211_qos_mgmt_unknown_attr, tvb,
                          offset, attr_len, ENC_NA);
      offset += attr_len;
      break;
    }
  }

  return offset;
}

/*
 * Handle the HS 2.0 rev 2 OSU Server-only authenticated layer 2 Encryption
 * Network element. This is almost the same format as the RSNE so maybe some
 * common code can be used.
 */
static int
dissect_hs20_osen(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  int hf_array[2] = { hf_ieee80211_group_data_cipher_suite_oui,
                       hf_ieee80211_group_data_cipher_suite_type };
  proto_tree *pwc_list = NULL;
  proto_item *pwcsi = NULL;
  uint16_t pwc_count = 0, pwc_index = 0;
  uint16_t akms_count = 0, akms_index = 0;
  static int * const osen_rsn_cap[] = {
    &hf_ieee80211_osen_rsn_cap_preauth,
    &hf_ieee80211_osen_rsn_cap_no_pairwise,
    &hf_ieee80211_osen_rsn_cap_ptksa_replay_counter,
    &hf_ieee80211_osen_rsn_cap_gtksa_replay_counter,
    &hf_ieee80211_osen_rsn_cap_mfpr,
    &hf_ieee80211_osen_rsn_cap_mfpc,
    &hf_ieee80211_osen_rsn_cap_jmr,
    &hf_ieee80211_osen_rsn_cap_peerkey,
    &hf_ieee80211_osen_rsn_spp_a_msdu_capable,
    &hf_ieee80211_osen_rsn_spp_a_msdu_required,
    &hf_ieee80211_osen_rsn_pbac,
    &hf_ieee80211_osen_extended_key_id_iaf,
    &hf_ieee80211_osen_reserved,
    NULL
  };
  uint16_t pmkid_count = 0, pmkid_index = 0;
  int gmcs_array[2] = { hf_ieee80211_osen_group_management_cipher_suite_oui,
                        hf_ieee80211_osen_group_management_cipher_suite_type };

  offset = dissect_group_data_cipher_suite(tvb, pinfo, tree, offset, hf_array,
                        ett_osen_group_data_cipher_suite,
                        "OSEN Group Data Cipher Suite");

  pwc_count = tvb_get_letohs(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_osen_pcs_count, tvb, offset,
                      2, ENC_LITTLE_ENDIAN);
  offset += 2;

  if (pwc_count > 0) {
    int start_offset = offset;
    pwc_list = proto_tree_add_subtree(tree, tvb, offset, -1,
                        ett_osen_pairwise_cipher_suites, &pwcsi,
                        "OSEN Pairwise Cipher Suite List");

    while (pwc_count > 0) {
      if (tvb_reported_length_remaining(tvb, offset) >= 4) {
        int hf_array2[2] = { hf_ieee80211_osen_pairwise_cipher_suite_oui,
                            hf_ieee80211_osen_pairwise_cipher_suite_type };
        char label[128];

        snprintf(label, sizeof(label), "OSEN Pairwise Cipher Suite %d", pwc_index);
        offset = dissect_group_data_cipher_suite(tvb, pinfo, pwc_list,
                        offset, hf_array2, ett_osen_pairwise_cipher_suite,
                        label);
        pwc_index++;
        pwc_count--;
      } else {
        /* Insert the remaining? Expert Info? */
        offset += tvb_reported_length_remaining(tvb, offset);
        break;
      }
    }

    proto_item_set_len(pwcsi, offset - start_offset);
  }

  if (tvb_reported_length_remaining(tvb, offset) == 0) {
    return tvb_captured_length(tvb);
  }

  /* Now handle the AKM Suites */
  akms_count = tvb_get_letohs(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_osen_akm_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  if (akms_count > 0) {
    int start_offset = offset;
    proto_tree *akm_list = NULL;
    proto_item *akmcsi = NULL;

    akm_list = proto_tree_add_subtree(tree, tvb, offset, -1,
                        ett_osen_akm_cipher_suites, &akmcsi,
                        "OSEN AKM Cipher Suite List");

    while (akms_count > 0) {
      if (tvb_reported_length_remaining(tvb, offset) >= 4) {
        int hf_array3[2] = { hf_ieee80211_osen_akm_cipher_suite_oui,
                             hf_ieee80211_osen_akm_cipher_suite_type};
        char label[128];

        snprintf(label, sizeof(label), "OSEN AKM Cipher Suite %d", akms_index);
        offset = dissect_group_data_cipher_suite(tvb, pinfo, akm_list,
                          offset, hf_array3, ett_osen_akm_cipher_suite,
                          label);
        akms_index++;
        akms_count--;
      } else {
        /* Expert info? */
        offset += tvb_reported_length_remaining(tvb, offset);
        break;
      }
    }
    proto_item_set_len(akmcsi, offset - start_offset);
  }

  /* Any more? */
  if (tvb_reported_length_remaining(tvb, offset) == 0) {
    return tvb_captured_length(tvb);
  }

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_osen_rsn_cap_flags,
                                    ett_osen_rsn_cap_tree, osen_rsn_cap,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;

  /* Any more? */
  if (tvb_reported_length_remaining(tvb, offset) == 0) {
    return tvb_captured_length(tvb);
  }

  pmkid_count = tvb_get_letohs(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_osen_pmkid_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  if (pmkid_count > 0) {
    proto_tree *pmkid_list = NULL;

    pmkid_list = proto_tree_add_subtree(tree, tvb, offset, pmkid_count * 16,
                                ett_osen_pmkid_list, NULL,
                                "OSEN PKMID List");

    while (pmkid_count > 0) {
      proto_tree *pmkid_tree = NULL;

      pmkid_tree = proto_tree_add_subtree_format(pmkid_list, tvb,offset, 16,
                                ett_osen_pmkid_tree, NULL,
                                "OSEN PKMID %d", pmkid_index);
      proto_tree_add_item(pmkid_tree, hf_ieee80211_osen_pmkid, tvb, offset, 16,
                          ENC_NA);
      offset += 16;
      pmkid_index++;
      pmkid_count--;
    }
  }

  offset = dissect_group_data_cipher_suite(tvb, pinfo, tree, offset, gmcs_array,
                        ett_osen_group_management_cipher_suite,
                        "OSEN Group Management Cipher Suite");

  return offset;
}

static const value_string hs20_indication_version_number_vals[] = {
  { 0, "1.x" },
  { 1, "2.x" },
  { 2, "3.x" },
  { 0, NULL }
};

static int
dissect_hs20_indication(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  static int * const ieee80211_hs20_indication[] = {
    &hf_ieee80211_hs20_indication_dgaf_disabled,
    &hf_ieee80211_hs20_indication_pps_mo_id_present,
    &hf_ieee80211_hs20_indication_anqp_domain_id_present,
    &hf_ieee80211_hs20_reserved,
    &hf_ieee80211_hs20_indication_version_number,
    NULL
  };
  int len = tvb_captured_length(tvb);
  int offset = 0;
  uint8_t indic = tvb_get_uint8(tvb, offset);

  proto_tree_add_bitmask_list(tree, tvb, offset, 1, ieee80211_hs20_indication,
                              ENC_NA);
  offset++;

  if (len >= 3 && (indic & 0x02)) { /* Contains a PPS MO ID field ... display it. */
      proto_tree_add_item(tree, hf_ieee80211_hs20_indication_pps_mo_id, tvb, offset,
                          2, ENC_LITTLE_ENDIAN);
      offset += 2;
  }

  if ((len >= (offset + 2)) && (indic & 0x04)) {
     proto_tree_add_item(tree, hf_ieee80211_hs20_indication_anqp_domain_id, tvb, offset,
                         2, ENC_LITTLE_ENDIAN);
     offset += 2;
  }

  return offset;
}

enum ieee80211_wfa_60g_attr {
  /* 0 Reserved */
  WIFI_60G_ATTR_CAPABILITY = 1,
  /* 2 - 225 Reserved */
};

static const value_string ieee80211_wfa_60g_attr_ids[] = {
  { WIFI_60G_ATTR_CAPABILITY, "60GHz Capability" },
  { 0, NULL }
};

static int
dissect_wfa_60g_ie(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
{
  int end = tvb_reported_length(tvb);
  int offset = 0;
  uint8_t id;
  uint16_t len;
  proto_tree *wf60g_tree;
  proto_item *attrs;

  while (offset < end) {
    if (end - offset < 2) {
      expert_add_info_format(pinfo, tree, &ei_ieee80211_wfa_60g_attr_len_invalid, "Packet too short for Wi-Fi 60G attribute");
      break;
    }

    id = tvb_get_uint8(tvb, offset);
    len = tvb_get_ntohs(tvb, offset + 1);
    attrs = proto_tree_add_item(tree, hf_ieee80211_wfa_60g_attr, tvb, offset, 0, ENC_NA);
    proto_item_append_text(attrs, ": %s", val_to_str(id, ieee80211_wfa_60g_attr_ids,
                                             "Unknown attribute ID (%u)"));
    wf60g_tree = proto_item_add_subtree(attrs, ett_ieee80211_wfa_60g_attr);
    proto_tree_add_item(wf60g_tree, hf_ieee80211_wfa_60g_attr_id, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;
    proto_tree_add_item(wf60g_tree, hf_ieee80211_wfa_60g_attr_len, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;


    switch (id) {
    case WIFI_60G_ATTR_CAPABILITY:
      if (len - offset < 7) {
        expert_add_info_format(pinfo, tree, &ei_ieee80211_wfa_60g_attr_len_invalid, "Packet too short for 60G capability attribute");
        break;
      }

      proto_tree_add_item(wf60g_tree, hf_ieee80211_wfa_60g_attr_cap_sta_mac_addr, tvb, offset, 6, ENC_NA);
      offset += 6;
      proto_tree_add_item(wf60g_tree, hf_ieee80211_wfa_60g_attr_cap_recv_amsdu_frames, tvb, offset, 1, ENC_BIG_ENDIAN);
      proto_tree_add_item(wf60g_tree, hf_ieee80211_wfa_60g_attr_cap_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);
      offset += 1;
      break;
    default:
      proto_tree_add_expert_format(tree, pinfo, &ei_ieee80211_wfa_60g_unknown_attribute, tvb,
                                         offset, len+2, "Unknown attribute ID (%u)", id);
    }

    offset += len;
  }
  return offset;
}

static int
dissect_owe_transition_mode(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
  uint8_t ssid_len;

  int len = tvb_captured_length(tvb);
  int offset = 0;

  proto_tree_add_item(tree, hf_ieee80211_wfa_ie_owe_bssid, tvb, offset, 6, ENC_NA);
  offset  += 6;
  len -= 6;

  ssid_len = tvb_get_uint8(tvb, offset);

  proto_tree_add_uint(tree, hf_ieee80211_wfa_ie_owe_ssid_length, tvb, offset, 1, ssid_len);
  offset  += 1;
  len -= 1;

  if (len < ssid_len) {
    expert_add_info(pinfo, tree, &ei_ieee80211_bad_length);
    return offset;
  }

  proto_tree_add_item(tree, hf_ieee80211_wfa_ie_owe_ssid, tvb, offset, ssid_len, ENC_ASCII);
  offset  += len;
  len -= len;

  if (len >= 2) {
    proto_tree_add_item(tree, hf_ieee80211_wfa_ie_owe_band_info, tvb, offset, 1, ENC_NA);
    offset  += 1;

    proto_tree_add_item(tree, hf_ieee80211_wfa_ie_owe_channel_info, tvb, offset, 1, ENC_NA);
    offset  += 1;
  }

  return offset;
}

static int
dissect_transition_disable_kde(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
  int tag_len = tvb_captured_length(tvb);
  int offset = 0;
  static int * const ieee80211_wfa_transition_disable_flags[] = {
    &hf_ieee80211_wfa_ie_transition_disable_wpa3_personal,
    &hf_ieee80211_wfa_ie_transition_disable_sae_pk,
    &hf_ieee80211_wfa_ie_transition_disable_wpa3_enterprise,
    &hf_ieee80211_wfa_ie_transition_disable_enhanced_open,
    &hf_ieee80211_wfa_ie_transition_disable_reserved_b4thru7,
    NULL
  };

  if (tag_len < 1) {
    expert_add_info(pinfo, tree, &ei_ieee80211_bad_length);
    return 0;
  }

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_wfa_ie_transition_disable_bitmap,
                                    ett_ieee80211_wfa_transition_disable_tree,
                                    ieee80211_wfa_transition_disable_flags,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset++;

  if (offset < tag_len)
    proto_tree_add_item(tree, hf_ieee80211_wfa_ie_transition_disable_reserved, tvb, offset, tag_len-offset, ENC_NA);
  offset = tag_len;

  return offset;
}

static int
dissect_mbo_oce(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
  int len = tvb_reported_length(tvb);
  int offset = 0;

  while (len >= 2) {
    proto_item *attr_item;
    proto_tree *attr_tree;
    uint8_t attr_id = tvb_get_uint8(tvb, offset);
    uint8_t attr_len = tvb_get_uint8(tvb, offset + 1);

    if (len < (attr_len + 2)) {
      expert_add_info(pinfo, tree, &ei_ieee80211_bad_length);
      return offset;
    }

    attr_item = proto_tree_add_item(tree, hf_ieee80211_wfa_ie_mbo_oce_attr, tvb, offset, attr_len + 2, ENC_NA);
    attr_tree = proto_item_add_subtree(attr_item, ett_mbo_oce_attr);
    proto_item_append_text(attr_item, " (%s)", val_to_str_const(attr_id, wfa_mbo_oce_attr_id_vals, "Unknown"));

    proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_mbo_oce_attr_id, tvb, offset, 1, ENC_NA);
    offset += 1;
    len -= 1;

    proto_tree_add_uint(attr_tree, hf_ieee80211_wfa_ie_mbo_oce_attr_len, tvb, offset, 1, attr_len);
    offset  += 1;
    len -= 1;

    switch (attr_id) {
    case MBO_AP_CAPABILTY_INDICATION:
    {
      proto_item *cap_item;
      proto_tree *cap_tree;

      if (attr_len != 1) {
        expert_add_info(pinfo, attr_tree, &ei_ieee80211_bad_length);
        return offset;
      }
      cap_item = proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_mbo_ap_cap, tvb, offset, 1, ENC_NA);
      cap_tree = proto_item_add_subtree(cap_item, ett_mbo_ap_cap);
      proto_tree_add_item(cap_tree, hf_ieee80211_wfa_ie_mbo_ap_cap_cell, tvb, offset, 1, ENC_NA);
      proto_tree_add_item(cap_tree, hf_ieee80211_wfa_ie_mbo_ap_cap_reserved, tvb, offset, 1, ENC_NA);
      break;
    }
    case MBO_NON_PREF_CHANNEL_REPORT:
      if (attr_len == 0)
        break;

      if (attr_len < 3) {
        expert_add_info(pinfo, attr_tree, &ei_ieee80211_bad_length);
        return offset;
      }
      proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_mbo_non_pref_chan_op_class, tvb, offset, 1, ENC_NA);
      offset += 1;
      len -= 1;
      attr_len -= 1;
      while (attr_len > 2) {
        proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_mbo_non_pref_chan_chan, tvb, offset, 1, ENC_NA);
        offset += 1;
        len -= 1;
        attr_len -= 1;
      }

      proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_mbo_non_pref_chan_pref, tvb, offset, 1, ENC_NA);
      proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_mbo_non_pref_chan_reason, tvb, offset + 1, 1, ENC_NA);
      break;
    case MBO_CELLULAR_DATA_CAPABILITIES:
      if (attr_len != 1) {
        expert_add_info(pinfo, attr_tree, &ei_ieee80211_bad_length);
        return offset;
      }
      proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_mbo_cellular_cap, tvb, offset, 1, ENC_NA);
      break;
    case MBO_ASSOCIATION_DISALLOWED:
      if (attr_len != 1) {
        expert_add_info(pinfo, attr_tree, &ei_ieee80211_bad_length);
        return offset;
      }
      proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_mbo_assoc_disallow_reason, tvb, offset, 1, ENC_NA);
      break;
    case MBO_CELLULAR_DATA_PREFERENCE:
      if (attr_len != 1) {
        expert_add_info(pinfo, attr_tree, &ei_ieee80211_bad_length);
        return offset;
      }
      proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_mbo_cellular_pref, tvb, offset, 1, ENC_NA);
      break;
    case MBO_TRANSITION_REASON:
      if (attr_len != 1) {
        expert_add_info(pinfo, attr_tree, &ei_ieee80211_bad_length);
        return offset;
      }
      proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_mbo_transition_reason, tvb, offset, 1, ENC_NA);
      break;
    case MBO_TRANSITION_REJECTION_REASON:
      if (attr_len != 1) {
        expert_add_info(pinfo, attr_tree, &ei_ieee80211_bad_length);
        return offset;
      }
      proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_mbo_transition_rej_reason, tvb, offset, 1, ENC_NA);
      break;
    case MBO_ASSOCIATION_RETRY_DELAY:
    {
      if (attr_len != 2) {
        expert_add_info(pinfo, attr_tree, &ei_ieee80211_bad_length);
        return offset;
      }
      proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_mbo_assoc_retry_delay, tvb, offset,
                          2, ENC_LITTLE_ENDIAN);
      break;
    }
    case OCE_CAPABILTY_INDICATION:
    {
      proto_item *cap_item;
      proto_tree *cap_tree;

      if (attr_len != 1) {
        expert_add_info(pinfo, attr_tree, &ei_ieee80211_bad_length);
        return offset;
      }
      cap_item = proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_oce_cap_ctrl, tvb, offset, 1, ENC_NA);
      cap_tree = proto_item_add_subtree(cap_item, ett_oce_cap);
      proto_tree_add_item(cap_tree, hf_ieee80211_wfa_ie_oce_cap_release, tvb, offset, 1, ENC_NA);
      proto_tree_add_item(cap_tree, hf_ieee80211_wfa_ie_oce_cap_sta_cfon, tvb, offset, 1, ENC_NA);
      proto_tree_add_item(cap_tree, hf_ieee80211_wfa_ie_oce_cap_11b_only_ap, tvb, offset, 1, ENC_NA);
      proto_tree_add_item(cap_tree, hf_ieee80211_wfa_ie_oce_cap_hlp, tvb, offset, 1, ENC_NA);
      proto_tree_add_item(cap_tree, hf_ieee80211_wfa_ie_oce_cap_non_oce_ap, tvb, offset, 1, ENC_NA);
      proto_tree_add_item(cap_tree, hf_ieee80211_wfa_ie_oce_cap_reserved, tvb, offset, 1, ENC_NA);
      break;
    }
    case OCE_RSSI_ASSOCIATION_REJECTION:
    {
      if (attr_len != 2) {
        expert_add_info(pinfo, attr_tree, &ei_ieee80211_bad_length);
        return offset;
      }
      proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_oce_rssi_assoc_rej_delta, tvb,
                          offset, 1, ENC_NA);
      proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_oce_rssi_assoc_rej_delay, tvb,
                          offset + 1, 1, ENC_NA);
      break;
    }
    case OCE_REDUCED_WAN_METRICS:
    {
      proto_item *cap_item;
      proto_tree *cap_tree;
      uint8_t capacity;

      if (attr_len != 1) {
        expert_add_info(pinfo, attr_tree, &ei_ieee80211_bad_length);
        return offset;
      }
      cap_item = proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_oce_wan_metrics_avail_cap,
                                     tvb, offset, 1, ENC_NA);
      cap_tree = proto_item_add_subtree(cap_item, ett_oce_metrics_cap);

      capacity = tvb_get_uint8(tvb, offset);
      cap_item = proto_tree_add_item(cap_tree, hf_ieee80211_wfa_ie_oce_wan_metrics_avail_cap_downlink,
                                     tvb, offset, 1, ENC_NA);
      proto_item_append_text(cap_item, " (%d kbit/s)", (1 << (capacity & 0xF)) * 100);
      cap_item = proto_tree_add_item(cap_tree, hf_ieee80211_wfa_ie_oce_wan_metrics_avail_cap_uplink,
                                     tvb, offset, 1, ENC_NA);
      capacity >>= 4;
      proto_item_append_text(cap_item, " (%d kbit/s)", (1 << (capacity & 0xF)) * 100);
      break;
    }
    case OCE_RNR_COMPLETENESS:
      while (attr_len >= 4) {
        proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_oce_rnr_completeness_short_ssid,
                            tvb, offset, 4, ENC_ASCII);
        offset += 4;
        attr_len -= 4;
        len -= 4;
      }
      break;
    case OCE_PROBE_SUPPR_BSSID:
      while (attr_len >= 6) {
        proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_oce_probe_suppr_bssid,
                            tvb, offset, 6, ENC_NA);
        offset += 6;
        attr_len -= 6;
        len -= 6;
      }
      break;
    case OCE_PROBE_SUPPR_SSID:
      if (attr_len < 4) {
        expert_add_info(pinfo, attr_tree, &ei_ieee80211_bad_length);
        return offset;
      }
      while (attr_len >= 4) {
        proto_tree_add_item(attr_tree, hf_ieee80211_wfa_ie_oce_probe_suppr_ssid,
                            tvb, offset, 4, ENC_ASCII);
        offset += 4;
        attr_len -= 4;
        len -= 4;
      }
      break;
    default:
      break;
    }

    offset += attr_len;
    len -= attr_len;
  }

  if (len != 0) {
    expert_add_info(pinfo, tree, &ei_ieee80211_bad_length);
  }

  return offset;
}

static int
dissect_wfa_wnm_non_pref_chan(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
  int len = tvb_reported_length(tvb);
  int offset = 0;

  if (len == 0)
    return 0;

  if (len < 3) {
    expert_add_info(pinfo, tree, &ei_ieee80211_bad_length);
    return 0;
  }

  proto_tree_add_item(tree, hf_ieee80211_wfa_ie_mbo_non_pref_chan_op_class, tvb, offset, 1, ENC_NA);
  offset ++;
  len --;
  while (len > 2) {
    proto_tree_add_item(tree, hf_ieee80211_wfa_ie_mbo_non_pref_chan_chan, tvb, offset, 1, ENC_NA);
    offset ++;
    len --;
  }

  proto_tree_add_item(tree, hf_ieee80211_wfa_ie_mbo_non_pref_chan_pref, tvb, offset, 1, ENC_NA);
  offset ++;
  proto_tree_add_item(tree, hf_ieee80211_wfa_ie_mbo_non_pref_chan_reason, tvb, offset, 1, ENC_NA);
  offset ++;
  return offset;
}

static int
dissect_wfa_wnm_cell_cap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
  int len = tvb_reported_length(tvb);

  if (len != 1) {
    expert_add_info(pinfo, tree, &ei_ieee80211_bad_length);
    return 0;
  }

  proto_tree_add_item(tree, hf_ieee80211_wfa_ie_mbo_cellular_cap, tvb, 0, 1, ENC_NA);
  return len;
}

static void
dissect_vendor_ie_wfa(packet_info *pinfo, proto_item *item, tvbuff_t *tag_tvb)
{
  int tag_len = tvb_reported_length(tag_tvb);
  uint8_t subtype;
  int offset = 0;
  tvbuff_t *vendor_tvb;

  if (tag_len < 4)
    return;

  subtype = tvb_get_uint8(tag_tvb, 3);
  proto_item_append_text(item, ": %s", val_to_str_const(subtype, wfa_subtype_vals, "Unknown"));
  vendor_tvb = tvb_new_subset_length(tag_tvb, offset + 4, tag_len - 4);
  dissector_try_uint_new(wifi_alliance_ie_table, subtype, vendor_tvb, pinfo, item, false, NULL);
}

static const range_string kde_selectors_rvals[] = {
  { 0, 0, "Reserved" },
  { 1, 1, "GTK KDE" },
  { 2, 2, "Reserved" },
  { 3, 3, "MAC address KDE" },
  { 4, 4, "PMKID KDE" },
  { 5, 5, "Reserved" },
  { 6, 6, "Nonce KDE" },
  { 7, 7, "Lifetime KDE" },
  { 8, 8, "Error KDE" },
  { 9, 9, "IGTK KDE" },
  { 10, 10, "Key ID KDE" },
  { 11, 11, "Multi-band GTK KDE" },
  { 12, 12, "Multi-band Key ID KDE" },
  { 13, 13, "OCI KDE" },
  { 14, 14, "BIGTK KDE" },
  { 15, 15, "Reserved" },
  { 16, 16, "MLO GTK KDE" },
  { 17, 17, "MLO IGTK KDE" },
  { 18, 18, "MLO BIGTK KDE" },
  { 19, 19, "MLO LINK KDE" },
  { 20, 255, "Reserved" },
  { 0, 0, NULL }
};

static const true_false_string tfs_rsn_gtk_kde_tx = {
  "Temporal key used for both transmission and reception",
  "Temporal key used only for reception"
};

static int * const mlo_kde_link_hdrs[] = {
  &hf_ieee80211_rsn_ie_mlo_linkid,
  &hf_ieee80211_rsn_ie_mlo_rnse_present,
  &hf_ieee80211_rsn_ie_mlo_rnsxe_present,
  &hf_ieee80211_rsn_ie_mlo_reserved,
  NULL
};

static void
dissect_rsn_ie_mlo_link(proto_item *item, proto_tree *tree, tvbuff_t *tvb,
                        int offset, uint32_t tag_len _U_, packet_info *pinfo)
{
  uint8_t info = tvb_get_uint8(tvb, offset);

  proto_tree_add_bitmask(tree, tvb, offset,
                         hf_ieee80211_rsn_ie_mlo_link_info,
                         ett_kde_mlo_link_info, mlo_kde_link_hdrs,
                         ENC_NA);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_rsn_ie_mlo_mac_addr, tvb, offset, 6,
                      ENC_NA);
  offset += 6;
  if ((info & 0x10) == 0x10) { /* Add the RSNE if present */
    offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
  }

  if ((info & 0x20) == 0x20) { /* Add the RSNXE if present */
    add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
  }

  proto_item_append_text(item, ": MLO Link KDE");
}

static void
dissect_vendor_ie_rsn(proto_item * item, proto_tree * tree, tvbuff_t * tvb,
                      int offset, uint32_t tag_len, packet_info *pinfo)
{
  uint8_t data_type = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_rsn_ie_gtk_kde_data_type, tvb,
                      offset, 1, ENC_NA);
  offset += 1;

  switch(data_type) {
    case 1:
    {
      /* IEEE 802.11i / Key Data Encapsulation / Data Type=1 - GTK.
       * This is only used within EAPOL-Key frame Key Data. */
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_gtk_kde_key_id, tvb,
                          offset, 1, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_gtk_kde_tx, tvb, offset,
                          1, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_gtk_kde_reserved1, tvb,
                          offset, 1, ENC_LITTLE_ENDIAN);
      offset += 1;
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_gtk_kde_reserved2, tvb,
                          offset, 1, ENC_LITTLE_ENDIAN);
      offset += 1;
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_gtk_kde_gtk, tvb, offset,
                          tag_len - 3, ENC_NA);
      proto_item_append_text(item, ": RSN GTK");
      save_proto_data(tvb, pinfo, offset, tag_len - 3, GTK_KEY);
      save_proto_data_value(pinfo, tag_len - 3, GTK_LEN_KEY);
      break;
    }
    case 3: /* MAC Address KDE */
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_mac_address_kde_mac, tvb,
                          offset, 6, ENC_NA);
      proto_item_append_text(item, ": MAC Address KDE");
      break;
    case 4:
    {
      /* IEEE 802.11i / Key Data Encapsulation / Data Type=4 - PMKID.
       * This is only used within EAPOL-Key frame Key Data. */
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_pmkid, tvb, offset, 16, ENC_NA);
      proto_item_append_text(item, ": RSN PMKID");
      break;
    }
    case 6:
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_gtk_kde_nonce, tvb, offset,
                          32, ENC_NA);
      proto_item_append_text(item, ": NONCE KDE");
      break;
    case 7: /* Lifetime KDE */
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_gtk_kde_lifetime, tvb,
                          offset, 4, ENC_LITTLE_ENDIAN);
      proto_item_append_text(item, ": Lifetime KDE");
      break;
    case 8: /* Error KDE */
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_error_kde_res, tvb, offset,
                          2, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_error_kde_error_type, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      proto_item_append_text(item, ": Error KDE");
      break;
    case 9: /* IGTK KDE */
    {
      /* IEEE 802.11i / Key Data Encapsulation / Data Type=9 - IGTK.
       * This is only used within EAPOL-Key frame Key Data. */
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_igtk_kde_keyid, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_igtk_kde_ipn, tvb, offset,
                          6, ENC_LITTLE_ENDIAN);
      offset += 6;
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_igtk_kde_igtk, tvb, offset,
                          tag_len - 9, ENC_NA);
      proto_item_append_text(item, ": RSN IGTK");
      break;
    }
    case 10:
    {
      /* IEEE 802.11 - 2016 / Key Data Encapsulation / Data Type=10 - KeyID
       * This is only used within EAPOL-Key frame Key Data when using Extended Key ID */
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_ptk_keyid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
      proto_item_append_text(item, ": RSN PTK");
      break;
    }
    case 13: /* OCI KDE */
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_oci_operating_class, tvb,
                          offset, 1, ENC_NA);
      offset += 1;
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_oci_primary_channel_number,
                          tvb, offset, 1, ENC_NA);
      offset += 1;
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_oci_frequency_segment_1,
                          tvb, offset, 1, ENC_NA);
      proto_item_append_text(item, ": OCI KDE");
      break;
    case 14: /* BIGTK KDE */
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_bigtk_key_id, tvb, offset,
                          2, ENC_LITTLE_ENDIAN);
      offset += 2;
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_bigtk_bipn, tvb, offset,
                          6, ENC_LITTLE_ENDIAN);
      offset += 6;
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_bigtk_bigtk, tvb, offset,
                          tag_len - 9, ENC_NA);
      proto_item_append_text(item, ": BIGTK KDE");
      break;
    case 16: /* MLO GTK KDE */
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_mlo_gtk_kde_key_id, tvb,
                          offset, 1, ENC_NA);
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_mlo_gtk_kde_tx, tvb,
                          offset, 1, ENC_NA);
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_mlo_gtk_kde_reserved, tvb,
                          offset, 1, ENC_NA);
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_mlo_gtk_kde_linkid, tvb,
                          offset, 1, ENC_NA);
      offset += 1;

      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_mlo_gtk_kde_pn, tvb,
                          offset, 6, ENC_NA);
      offset += 6;

      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_mlo_gtk_kde_gtk, tvb,
                          offset, tag_len - 7, ENC_NA);

      proto_item_append_text(item, ": MLO GTK KDE");
      break;
    case 17: /* MLO IGTK KDE */
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_mlo_igtk_kde_key_id, tvb,
                          offset, 2, ENC_NA);
      offset += 2;

      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_mlo_igtk_kde_ipn, tvb,
                          offset, 6, ENC_NA);
      offset += 6;

      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_mlo_igtk_kde_reserved, tvb,
                          offset, 1, ENC_NA);
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_mlo_igtk_kde_linkid, tvb,
                          offset, 1, ENC_NA);
      offset += 1;

      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_mlo_igtk_kde_igtk, tvb,
                          offset, tag_len - 9, ENC_NA);

      proto_item_append_text(item, ": MLO IGTK KDE");
      break;
    case 18: /* MLO BIGTK KDE */
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_mlo_bigtk_kde_key_id, tvb,
                          offset, 2, ENC_NA);
      offset += 2;

      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_mlo_bigtk_kde_ipn, tvb,
                          offset, 6, ENC_NA);
      offset += 6;

      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_mlo_bigtk_kde_reserved, tvb,
                          offset, 1, ENC_NA);
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_mlo_bigtk_kde_linkid, tvb,
                          offset, 1, ENC_NA);
      offset += 1;

      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_mlo_bigtk_kde_bigtk, tvb,
                          offset, tag_len - 9, ENC_NA);

      proto_item_append_text(item, ": MLO BIGTK KDE");
      break;
    case 19: /*
              * MLO Link KDE, contains  Link info, MAC Addr and possibly
              * RSNE and RSNXE
              */
      dissect_rsn_ie_mlo_link(item, tree, tvb, offset, tag_len, pinfo);
      break;
    default:
      proto_tree_add_item(tree, hf_ieee80211_rsn_ie_unknown, tvb, offset,
                          tag_len - 1, ENC_NA);
      proto_item_append_text(item, ": RSN UNKNOWN");
      break;
  }
}

typedef enum {
  MARVELL_IE_MESH = 4
} marvell_ie_type_t;

static void
dissect_vendor_ie_marvell(proto_item *item _U_, proto_tree *ietree,
                          tvbuff_t *tvb, int offset, uint32_t tag_len)
{
  uint8_t type;

  type = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(ietree, hf_ieee80211_marvell_ie_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  switch (type) {
  case MARVELL_IE_MESH:
    proto_tree_add_item(ietree, hf_ieee80211_marvell_ie_mesh_subtype, tvb,
                         offset++, 1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(ietree, hf_ieee80211_marvell_ie_mesh_version, tvb,
                         offset++, 1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(ietree, hf_ieee80211_marvell_ie_mesh_active_proto_id, tvb,
                         offset++, 1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(ietree, hf_ieee80211_marvell_ie_mesh_active_metric_id, tvb,
                         offset++, 1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(ietree, hf_ieee80211_marvell_ie_mesh_cap, tvb,
                         offset++, 1, ENC_LITTLE_ENDIAN);
    break;

  default:
    proto_tree_add_item(ietree, hf_ieee80211_marvell_ie_data, tvb, offset,
      tag_len - 1, ENC_NA);
    break;
  }
}

typedef enum {
  ATHEROS_IE_ADVCAP = 1,
  ATHEROS_IE_XR = 3
} atheros_ie_type_t;

typedef enum {
  ATHEROS_IE_ADVCAP_S = 1
} atheros_ie_advcap_subtype_t;

typedef enum {
  ATHEROS_IE_XR_S = 1
} atheros_ie_xr_subtype_t;

typedef enum {
  ATHEROS_IE_CAP_TURBOP = 0x01,
  ATHEROS_IE_CAP_COMP   = 0x02,
  ATHEROS_IE_CAP_FF     = 0x04,
  ATHEROS_IE_CAP_XR     = 0x08,
  ATHEROS_IE_CAP_AR     = 0x10,
  ATHEROS_IE_CAP_BURST  = 0x20,
  ATHEROS_IE_CAP_WME    = 0x40,
  ATHEROS_IE_CAP_BOOST  = 0x80
} atheros_ie_cap_t;

static const value_string atheros_ie_type_vals[] = {
  { ATHEROS_IE_ADVCAP, "Advanced Capability"},
  { ATHEROS_IE_XR,     "eXtended Range"},
  { 0,                 NULL }
};

static int * const ieee80211_atheros_ie_cap[] = {
  &hf_ieee80211_atheros_ie_cap_f_turbop,
  &hf_ieee80211_atheros_ie_cap_f_comp,
  &hf_ieee80211_atheros_ie_cap_f_ff,
  &hf_ieee80211_atheros_ie_cap_f_xr,
  &hf_ieee80211_atheros_ie_cap_f_ar,
  &hf_ieee80211_atheros_ie_cap_f_burst,
  &hf_ieee80211_atheros_ie_cap_f_wme,
  &hf_ieee80211_atheros_ie_cap_f_boost,
  NULL
};

static int * const ieee80211_extreme_mesh_ie_hello[] = {
  &hf_ieee80211_extreme_mesh_ie_hello_f_root,
  &hf_ieee80211_extreme_mesh_ie_hello_f_proxy,
  &hf_ieee80211_extreme_mesh_ie_hello_f_geo,
  &hf_ieee80211_extreme_mesh_ie_hello_f_path_pref,
  &hf_ieee80211_extreme_mesh_ie_hello_f_mobile,
  NULL
};

typedef enum {
  EXTREME_MESH_IE_SERVICES_ROOT      = 0x01,
  EXTREME_MESH_IE_SERVICES_PROXY     = 0x02,
  EXTREME_MESH_IE_SERVICES_GEO       = 0x04,
  EXTREME_MESH_IE_SERVICES_PATH_PREF = 0x08,
  EXTREME_MESH_IE_SERVICES_MOBILE    = 0x10,
} extreme_mesh_ie_services;

/* Mesh Fields found in Management Frames KJG */
static const value_string extreme_mesh_ie_type_vals[] = {
  {1, "Hello"},
  {2, "Mesh ID"},
  {3, "MPID"},
  {0, NULL}
};

static void
dissect_vendor_ie_extreme_mesh(proto_item *item _U_, proto_tree *ietree,
                          tvbuff_t *tvb, int offset, unsigned tag_len,
                          packet_info *pinfo, proto_item *ti_len)
{
  uint8_t     type;

  if (tag_len <= 3) {
    expert_add_info_format(pinfo, ti_len, &ei_ieee80211_tag_length, "Tag length %u too short, must be >= 6", tag_len+3);
    /* Add length of OUI to tag_length */
    return;
  }
  type = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(ietree, hf_ieee80211_extreme_mesh_ie_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(item, ": %s", val_to_str_const(type, extreme_mesh_ie_type_vals, "Unknown"));
  offset  += 1;
  tag_len -= 1;

  switch (type) {
    case 1:
      {
        proto_tree_add_bitmask_with_flags(ietree, tvb, offset, hf_ieee80211_extreme_mesh_ie_services,
        ett_extreme_mesh_services_tree, ieee80211_extreme_mesh_ie_hello, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
        offset   += 1;

        proto_tree_add_item(ietree, hf_ieee80211_extreme_mesh_ie_htr, tvb, offset, 1, ENC_NA);
        offset   += 1;

        proto_tree_add_item(ietree, hf_ieee80211_extreme_mesh_ie_mtr, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset   += 2;

        proto_tree_add_item(ietree, hf_ieee80211_extreme_mesh_ie_root, tvb, offset, 6, ENC_NA);
        offset   += 6;

        proto_tree_add_item(ietree, hf_ieee80211_extreme_mesh_ie_nh, tvb, offset, 6, ENC_NA);
      }
      break;
    case 2:
      {
         proto_tree_add_item(ietree, hf_ieee80211_extreme_mesh_ie_mesh_id, tvb, offset, tag_len, ENC_ASCII);
      }
      break;
    case 3:
      {
         proto_tree_add_item(ietree, hf_ieee80211_extreme_mesh_ie_mp_id, tvb, offset, 6, ENC_NA);
      }
      break;
    default:
      break;
  }
}

static void
dissect_vendor_ie_atheros(proto_item *item _U_, proto_tree *ietree,
                          tvbuff_t *tvb, int offset, unsigned tag_len,
                          packet_info *pinfo, proto_item *ti_len)
{
  uint8_t     type;
  uint8_t     subtype;
  uint8_t     version;

  if (tag_len <= 3) {
        expert_add_info_format(pinfo, ti_len, &ei_ieee80211_tag_length, "Tag length %u too short, must be >= 6", tag_len+3); /* Add length of OUI to tag_length */
        return;
  }
  proto_tree_add_item(ietree, hf_ieee80211_atheros_ie_type, tvb, offset, 1, ENC_NA);
  type = tvb_get_uint8(tvb, offset);
  proto_item_append_text(item, ": %s", val_to_str_const(type, atheros_ie_type_vals, "Unknown"));
  offset  += 1;
  tag_len -= 1;

  proto_tree_add_item(ietree, hf_ieee80211_atheros_ie_subtype, tvb, offset, 1, ENC_NA);
  subtype  = tvb_get_uint8(tvb, offset);
  offset  += 1;
  tag_len -= 1;

  proto_tree_add_item(ietree, hf_ieee80211_atheros_ie_version, tvb, offset, 1, ENC_NA);
  version  = tvb_get_uint8(tvb, offset);
  offset  += 1;
  tag_len -= 1;

  if (version == 0)
  {
    switch (type) {
      case ATHEROS_IE_ADVCAP:
      {
        switch (subtype) {
          case ATHEROS_IE_ADVCAP_S:
          {
            proto_tree_add_bitmask_with_flags(ietree, tvb, offset, hf_ieee80211_atheros_ie_advcap_cap,
                                    ett_ath_cap_tree, ieee80211_atheros_ie_cap,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
            offset   += 1;
            tag_len  -= 1;

            proto_tree_add_item(ietree, hf_ieee80211_atheros_ie_advcap_defkey, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            offset  += 2;
            tag_len -= 2;
            break;
          }
          default:
          /* No default Action */
          break;
        } /* End switch (subtype) */
        break;
      }
      case ATHEROS_IE_XR:
      {
        switch (subtype) {
          case ATHEROS_IE_XR_S:
          {
            proto_tree_add_item(ietree, hf_ieee80211_atheros_ie_xr_info, tvb, offset, 1, ENC_NA);
            offset  += 1;
            tag_len -= 1;

            proto_tree_add_item(ietree, hf_ieee80211_atheros_ie_xr_base_bssid, tvb, offset, 6, ENC_NA);
            offset  += 6;
            tag_len -= 6;

            proto_tree_add_item(ietree, hf_ieee80211_atheros_ie_xr_xr_bssid, tvb, offset, 6, ENC_NA);
            offset  += 6;
            tag_len -= 6;

            proto_tree_add_item(ietree, hf_ieee80211_atheros_ie_xr_xr_beacon, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            offset  += 2;
            tag_len -= 2;

            proto_tree_add_bitmask_with_flags(ietree, tvb, offset, hf_ieee80211_atheros_ie_xr_base_cap,
                                    ett_ath_cap_tree, ieee80211_atheros_ie_cap,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
            offset   += 1;
            tag_len  -= 1;

            proto_tree_add_bitmask_with_flags(ietree, tvb, offset, hf_ieee80211_atheros_ie_xr_xr_cap,
                                    ett_ath_cap_tree, ieee80211_atheros_ie_cap,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
            offset   += 1;
            tag_len  -= 1;
            break;
          }
          default:
          /* No default Action */
          break;
        } /* End switch (subtype) */
        break;
        default:
        /* No default Action */
        break;
      } /* End switch (type) */

    }
  }
  if (tag_len > 0) {
    proto_tree_add_item(ietree, hf_ieee80211_atheros_ie_data, tvb, offset, tag_len, ENC_NA);
  }
}

typedef enum {
  AIRONET_IE_DTPC = 0,
  AIRONET_IE_UNKNOWN1 = 1,
  AIRONET_IE_VERSION = 3,
  AIRONET_IE_QOS,
  AIRONET_IE_UNKNOWN11 = 11,
  AIRONET_IE_QBSS_V2 = 14,
  AIRONET_IE_CLIENT_MFP = 20
} aironet_ie_type_t;

static const value_string aironet_ie_type_vals[] = {
  { AIRONET_IE_DTPC,      "DTPC"},
  { AIRONET_IE_UNKNOWN1,  "Unknown (1)"},
  { AIRONET_IE_VERSION,   "CCX version"},
  { AIRONET_IE_QOS,       "Qos"},
  { AIRONET_IE_UNKNOWN11, "Unknown (11)"},
  { AIRONET_IE_QBSS_V2,   "QBSS V2 - CCA"},
  { AIRONET_IE_CLIENT_MFP, "Client MFP"},
  { 0,                    NULL }
};

static const value_string aironet_mfp_vals[] = {
  { 0,      "Disabled"},
  { 1,      "Enabled"},
  { 0,      NULL }
};

static void
dissect_vendor_ie_aironet(proto_item *aironet_item, proto_tree *ietree,
                          tvbuff_t *tvb, int offset, uint32_t tag_len)
{
  uint8_t type;
  int i;
  bool dont_change = false; /* Don't change the IE item text to default */

  type = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(ietree, hf_ieee80211_aironet_ie_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  switch (type) {
  case AIRONET_IE_DTPC:
    proto_tree_add_item(ietree, hf_ieee80211_aironet_ie_dtpc, tvb, offset, 1, ENC_NA);
    proto_item_append_text(aironet_item, ": Aironet DTPC Powerlevel %ddBm", tvb_get_uint8(tvb, offset));
    offset += 1;
    proto_tree_add_item(ietree, hf_ieee80211_aironet_ie_dtpc_unknown, tvb, offset, 1, ENC_NA);
    dont_change = true;
    break;
  case AIRONET_IE_VERSION:
    proto_tree_add_item(ietree, hf_ieee80211_aironet_ie_version, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    proto_item_append_text(aironet_item, ": Aironet CCX version = %d", tvb_get_uint8(tvb, offset));
    dont_change = true;
    break;
  case AIRONET_IE_QOS:
    proto_tree_add_item(ietree, hf_ieee80211_aironet_ie_qos_reserved, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(ietree, hf_ieee80211_aironet_ie_qos_paramset, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    /* XXX: just copied over from WME. Maybe "Best Effort" and "Background"
     *  need to be swapped. Also, the "TXOP" may be TXOP - or not.
     */
    for (i = 0; i < 4; i++) {
      uint8_t byte1, byte2;
      uint16_t txop;
      byte1 = tvb_get_uint8(tvb, offset);
      byte2 = tvb_get_uint8(tvb, offset + 1);
      txop = tvb_get_letohs(tvb, offset + 2);
      proto_tree_add_bytes_format(ietree, hf_ieee80211_aironet_ie_qos_val, tvb, offset, 4, NULL,
          "CCX QoS Parameters: ACI %u (%s), Admission Control %sMandatory, AIFSN %u, ECWmin %u, ECWmax %u, TXOP %u",
        (byte1 & 0x60) >> 5, val_to_str((byte1 & 0x60) >> 5, wme_acs, "(Unknown: %d)"),
        (byte1 & 0x10) ? "" : "not ", byte1 & 0x0f,
        byte2 & 0x0f, (byte2 & 0xf0) >> 4,
        txop);
      offset += 4;
    }
    break;
  case AIRONET_IE_QBSS_V2:
    /* Extract Values */
    proto_tree_add_item(ietree, hf_ieee80211_qbss2_scount, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(ietree, hf_ieee80211_qbss2_cu, tvb, offset + 2, 1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(ietree, hf_ieee80211_qbss2_cal, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(ietree, hf_ieee80211_qbss2_gl, tvb, offset + 4, 1, ENC_LITTLE_ENDIAN);
    break;
  case AIRONET_IE_CLIENT_MFP:
    proto_tree_add_item(ietree, hf_ieee80211_aironet_ie_clientmfp, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    proto_item_append_text(aironet_item, ": Aironet Client MFP %s",
      val_to_str_const(1 & tvb_get_uint8(tvb, offset), aironet_mfp_vals, "Unknown"));
    dont_change = true;
    break;
  default:
    proto_tree_add_item(ietree, hf_ieee80211_aironet_ie_data, tvb, offset,
      tag_len - 1, ENC_NA);
    break;
  }
  if (!dont_change) {
    proto_item_append_text(aironet_item, ": Aironet %s (%d)",
      val_to_str_const(type, aironet_ie_type_vals, "Unknown"), type);
  }
}

#define ARUBA_APNAME  3
static const value_string ieee80211_vs_aruba_subtype_vals[] = {
  { ARUBA_APNAME, "AP Name"},
  { 0,                 NULL }
};
static void
dissect_vendor_ie_aruba(proto_item *item, proto_tree *ietree,
                          tvbuff_t *tvb, int offset, uint32_t tag_len, packet_info *pinfo)
{
  uint8_t type;
  const uint8_t* name;

  offset += 1; /* VS OUI Type */
  tag_len -= 1;

  type = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(ietree, hf_ieee80211_vs_aruba_subtype, tvb, offset, 1, ENC_NA);
  proto_item_append_text(item, ": %s", val_to_str_const(type, ieee80211_vs_aruba_subtype_vals, "Unknown"));
  offset += 1;
  tag_len -= 1;

  switch (type) {
  case ARUBA_APNAME:
    offset += 1;
    tag_len -= 1;

    proto_tree_add_item_ret_string(ietree, hf_ieee80211_vs_aruba_apname, tvb,
                         offset, tag_len, ENC_ASCII|ENC_NA, pinfo->pool, &name);
    proto_item_append_text(item, " (%s)", name);
    break;

  default:
    proto_tree_add_item(ietree, hf_ieee80211_vs_aruba_data, tvb, offset,
      tag_len, ENC_NA);
    if (tag_len > 0)
      proto_item_append_text(item, " (Data: %s)", tvb_bytes_to_str(pinfo->pool, tvb, offset, tag_len));
    break;
  }
}

static void
dissect_vendor_ie_routerboard(proto_item *item _U_, proto_tree *ietree,
                          tvbuff_t *tvb, int offset, uint32_t tag_len, packet_info *pinfo)
{
  uint8_t type, length;
  proto_item *subitem;
  proto_tree *subtree;

  offset += 1; /* VS OUI Type */
  tag_len -= 1;
  /* FIXME: Make sure we have at least 2 bytes left */
  proto_tree_add_item(ietree, hf_ieee80211_vs_routerboard_unknown, tvb, offset, 2, ENC_NA);

  offset += 2;
  tag_len -= 2;

  while (tag_len >= 2) {
    type = tvb_get_uint8(tvb, offset);
    length = tvb_get_uint8(tvb, offset+1);
    subitem = proto_tree_add_item(ietree, hf_ieee80211_vs_routerboard_subitem, tvb, offset, length+2, ENC_NA);
    subtree = proto_item_add_subtree(subitem, ett_routerboard);
    proto_item_set_text(subitem, "Sub IE (T/L: %d/%d)", type, length);

    proto_tree_add_item(subtree, hf_ieee80211_vs_routerboard_subtype, tvb, offset, 1, ENC_NA);
    offset += 1;
    tag_len -= 1;

    proto_tree_add_item(subtree, hf_ieee80211_vs_routerboard_sublength, tvb, offset, 1, ENC_NA);
    offset += 1;
    tag_len -= 1;

    if (tag_len < length)
      length = tag_len;
    if (length == 0) {
      expert_add_info(pinfo, subitem, &ei_ieee80211_vs_routerboard_unexpected_len);
      break;
    }

    proto_tree_add_item(subtree, hf_ieee80211_vs_routerboard_subdata, tvb, offset, length, ENC_NA);

    if(type == 1){
      if(length == 30){
        proto_tree_add_item(subtree, hf_ieee80211_vs_routerboard_subtype1_prefix, tvb, offset, 10, ENC_NA);
        proto_tree_add_item(subtree, hf_ieee80211_vs_routerboard_subtype1_data, tvb, offset + 10, length - 10, ENC_ASCII);
      }else{
        expert_add_info(pinfo, subitem, &ei_ieee80211_vs_routerboard_unexpected_len);
      }
    }

    offset += length;
    tag_len -= length;
  }
}

#define AEROHIVE_HOSTNAME 33
static const value_string ieee80211_vs_aerohive_type_vals[] = {
  { AEROHIVE_HOSTNAME, "Host Name"},
  { 0,                 NULL }
};
static void
dissect_vendor_ie_aerohive(proto_item *item _U_, proto_tree *ietree,
                          tvbuff_t *tvb, int offset, uint32_t tag_len, packet_info *pinfo)
{
  uint32_t type, length;
  const uint8_t* hostname;
  proto_item *ti_len;

  /* VS OUI Type */
  type = tvb_get_uint8(tvb, offset);
  offset += 1;
  tag_len -= 1;

  proto_tree_add_item(ietree, hf_ieee80211_vs_aerohive_version, tvb, offset, 1, ENC_NA);
  proto_item_append_text(item, ": %s", val_to_str_const(type, ieee80211_vs_aerohive_type_vals, "Unknown"));
  offset += 1;
  tag_len -= 1;

  switch(type){
    case AEROHIVE_HOSTNAME: /* Subtype (1 byte) + Host Name Length (1 byte) + Host Name */

      proto_tree_add_item(ietree, hf_ieee80211_vs_aerohive_subtype, tvb, offset, 1, ENC_NA);
      offset += 1;
      tag_len -= 1;

      ti_len = proto_tree_add_item_ret_uint(ietree, hf_ieee80211_vs_aerohive_hostname_length, tvb, offset, 1, ENC_NA, &length);
      offset += 1;
      tag_len -= 1;

      if (tag_len < length) {
        expert_add_info_format(pinfo, ti_len, &ei_ieee80211_tag_length, "Tag length < Host Name Length");
        length = tag_len;
      }

      proto_tree_add_item_ret_string(ietree, hf_ieee80211_vs_aerohive_hostname, tvb, offset, length, ENC_ASCII|ENC_NA, pinfo->pool, &hostname);
      proto_item_append_text(item, " (%s)", hostname);

    break;

    default:
      proto_tree_add_item(ietree, hf_ieee80211_vs_aerohive_data, tvb, offset, tag_len, ENC_NA);
    break;
  }
}

#define MIST_APNAME 1
static const value_string ieee80211_vs_mist_type_vals[] = {
    { MIST_APNAME, "AP Name"},
    { 0,           NULL }
};
static void
dissect_vendor_ie_mist(proto_item *item _U_, proto_tree *ietree,
                       tvbuff_t *tvb, int offset, uint32_t tag_len, packet_info *pinfo)
{
    uint32_t type, length;
    const uint8_t* apname;

    /* VS OUI Type */
    type = tvb_get_uint8(tvb, offset);
    proto_item_append_text(item, ": %s", val_to_str_const(type, ieee80211_vs_mist_type_vals, "Unknown"));
    offset += 1;
    tag_len -= 1;

    switch(type){
        case MIST_APNAME:
            length = tag_len;
            proto_tree_add_item_ret_string(ietree, hf_ieee80211_vs_mist_ap_name, tvb, offset, length, ENC_ASCII|ENC_NA, pinfo->pool, &apname);
            proto_item_append_text(item, " (%s)", apname);
            break;

        default:
            proto_tree_add_item(ietree, hf_ieee80211_vs_mist_data, tvb, offset, tag_len, ENC_NA);
            break;
    }
}

#define RUCKUS_APNAME 3
static const value_string ieee80211_vs_ruckus_type_vals[] = {
    { RUCKUS_APNAME, "AP Name"},
    { 0,           NULL }
};
static void
dissect_vendor_ie_ruckus(proto_item *item _U_, proto_tree *ietree,
                       tvbuff_t *tvb, int offset, uint32_t tag_len, packet_info *pinfo)
{
    uint32_t type, length;
    const uint8_t* apname;

    /* VS OUI Type */
    type = tvb_get_uint8(tvb, offset);
    proto_item_append_text(item, ": %s", val_to_str_const(type, ieee80211_vs_ruckus_type_vals, "Unknown"));
    offset += 1;
    tag_len -= 1;

    switch(type){
        case RUCKUS_APNAME:
          length = tag_len;
            proto_tree_add_item_ret_string(ietree, hf_ieee80211_vs_ruckus_ap_name, tvb, offset, length, ENC_ASCII|ENC_NA, pinfo->pool, &apname);
            proto_item_append_text(item, " (%s)", apname);
            break;

        default:
            proto_tree_add_item(ietree, hf_ieee80211_vs_ruckus_data, tvb, offset, tag_len, ENC_NA);
            break;
    }
}

#define ALCATEL_APNAME 1
static const value_string ieee80211_vs_alcatel_type_vals[] = {
    { ALCATEL_APNAME, "AP Name"},
    { 0, NULL }
};
static void
dissect_vendor_ie_alcatel(proto_item *item _U_, proto_tree *ietree,
                       tvbuff_t *tvb, int offset, uint32_t tag_len, packet_info *pinfo)
{
    uint32_t type, length;
    const uint8_t* apname;

    /* VS OUI Type */
    type = tvb_get_uint8(tvb, offset);
    proto_item_append_text(item, ": %s", val_to_str_const(type, ieee80211_vs_alcatel_type_vals, "Unknown"));
    offset += 1;
    tag_len -= 1;

    switch(type){
        case ALCATEL_APNAME:
            length = tag_len;
            proto_tree_add_item_ret_string(ietree, hf_ieee80211_vs_alcatel_ap_name, tvb, offset, length, ENC_ASCII|ENC_NA, pinfo->pool, &apname);
            proto_item_append_text(item, " (%s)", apname);
            break;

        default:
            proto_tree_add_item(ietree, hf_ieee80211_vs_alcatel_data, tvb, offset, tag_len, ENC_NA);
            break;
    }
}

enum vs_sgdsn_type {
  SGDSN_VERSION = 0x01,
  SGDSN_IDFR = 0x02,
  SGDSN_IDANSI = 0x03,
  SGDSN_LATITUDE = 0x04,
  SGDSN_LONGITUDE = 0x05,
  SGDSN_ALTITUDE_ABS = 0x06,
  SGDSN_ALTITUDE_REL = 0x07,
  SGDSN_LATITUDE_TAKEOFF = 0x08,
  SGDSN_LONGITUDE_TAKEOFF = 0x09,
  SGDSN_H_SPEED = 0x0a,
  SGDSN_HEADING = 0x0b,
};

static const value_string ieee80211_vs_sgdsn_type_vals[] = {
  { SGDSN_VERSION,  "Version"},
  { SGDSN_IDFR, "ID FR"},
  { SGDSN_IDANSI, "ID ANSI"},
  { SGDSN_LATITUDE, "Latitude"},
  { SGDSN_LONGITUDE, "Longitude"},
  { SGDSN_ALTITUDE_ABS, "Altitude AMSL"},
  { SGDSN_ALTITUDE_REL, "Altitude AGL"},
  { SGDSN_LATITUDE_TAKEOFF, "Latitude Takeoff"},
  { SGDSN_LONGITUDE_TAKEOFF, "Longitude Takeoff"},
  { SGDSN_H_SPEED, "Horizontal Speed"},
  { SGDSN_HEADING, "Heading"},
  { 0, NULL }
};

static void
dissect_vendor_ie_sgdsn(proto_item *item _U_, proto_tree *ietree,
                       tvbuff_t *tvb, int offset, uint32_t tag_len,
                       packet_info *pinfo)
{
  // Technical specification defined in French law "NOR: ECOI1934044A"
  // https://www.legifrance.gouv.fr/eli/arrete/2019/12/27/ECOI1934044A/jo/texte

  uint8_t type = tvb_get_uint8(tvb, offset);
  offset += 1;
  tag_len -= 1;

  if (type == 1) {

    while (tag_len > 2) {

      uint8_t tlv_type = tvb_get_uint8(tvb, offset);
      uint8_t tlv_len = tvb_get_uint8(tvb, offset+1);

      if (tag_len < tlv_len) {
        break;
      }

      proto_item *item_tlv = proto_tree_add_item(ietree, hf_ieee80211_vs_sgdsn_tag, tvb, offset, tlv_len + 2, ENC_NA);
      proto_item *tree = proto_item_add_subtree(item_tlv, ett_sgdsn);

      proto_tree_add_item(tree, hf_ieee80211_vs_sgdsn_type, tvb, offset, 1, ENC_NA);
      proto_tree_add_item(tree, hf_ieee80211_vs_sgdsn_length, tvb, offset + 1,  1, ENC_NA);

      offset += 2;
      tag_len -= 2;

      proto_item_append_text(tree, ": %s", val_to_str_const(tlv_type, ieee80211_vs_sgdsn_type_vals, "Unknown"));

      switch(tlv_type) {
      case SGDSN_VERSION:
        if (tlv_len == 1) {
          uint32_t value;
          proto_tree_add_item_ret_uint(tree, hf_ieee80211_vs_sgdsn_version, tvb, offset, 1, ENC_NA, &value);
          proto_item_append_text(tree, ": %d", value);
        } else {
          expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length, "Value length must be 1");
        }
        break;
      case SGDSN_IDFR:
        if (tlv_len == 30) {
          const uint8_t* string1;
          const uint8_t* string2;
          const uint8_t* string3;
          proto_tree_add_item_ret_string(tree, hf_ieee80211_vs_sgdsn_manufacturer, tvb, offset, 3, ENC_ASCII|ENC_NA, pinfo->pool, &string1);
          proto_tree_add_item_ret_string(tree, hf_ieee80211_vs_sgdsn_model, tvb, offset+3, 3, ENC_ASCII|ENC_NA, pinfo->pool, &string2);
          proto_tree_add_item_ret_string(tree, hf_ieee80211_vs_sgdsn_serialnumber, tvb, offset+6, tlv_len-6, ENC_ASCII|ENC_NA, pinfo->pool, &string3);
          proto_item_append_text(tree, ": %s %s %s", string1, string2, string3);
        } else {
          expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length, "Value length must be 30");
        }
        break;
      case SGDSN_IDANSI:
        if (tlv_len >= 6 && tlv_len <= 20) {
          // ANSI/CTA-2063 Small UAS Serial Number.
          // Doc (free): https://shop.cta.tech/products/small-unmanned-aerial-systems-serial-numbers
          const uint8_t* icao_mfr_code;
          uint32_t sn_len;
          const uint8_t* serial_number;
          proto_tree_add_item_ret_string(tree, hf_ieee80211_vs_sgdsn_icaomfrcode, tvb, offset, 4, ENC_ASCII|ENC_NA, pinfo->pool, &icao_mfr_code);
          proto_tree_add_item_ret_uint(tree, hf_ieee80211_vs_sgdsn_serialnumber_len, tvb, offset+4, 1, ENC_NA, &sn_len);
          if(sn_len < 0x30 || (sn_len > 0x39 && sn_len < 0x41) || sn_len > 0x46) {
            expert_add_info_format(pinfo, tree, &ei_ieee80211_vs_sgdsn_serialnumber_invalid_len_val, "Serial Number Length must be '0' to '9', or 'A' to 'F'");
          } else if (sn_len != (uint32_t)tlv_len+(sn_len>0x39 ? 0x32 : 0x2A)) {
            // Check that sn_len equals tlv_len - 5 + ( 0x37 if sn_len is 'A' to 'F', 0x30 otherwise).
            // We suppressed the minus 5 in the check above to avoid a compilation warning
            expert_add_info_format(pinfo, tree, &ei_ieee80211_vs_sgdsn_serialnumber_unexpected_len_val, "Expected %d byte(s), got %d byte(s)", tlv_len-5, (sn_len>0x39?sn_len-0x37:sn_len-0x30));
          }
          proto_tree_add_item_ret_string(tree, hf_ieee80211_vs_sgdsn_serialnumber, tvb, offset+5, tlv_len-5, ENC_ASCII|ENC_NA, pinfo->pool, &serial_number);
          proto_item_append_text(tree, ": %s %s", icao_mfr_code, serial_number);
        } else {
          expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length, "Value length must be between 6 and 20");
        }
        break;
      case SGDSN_LATITUDE_TAKEOFF:
      case SGDSN_LATITUDE:
      case SGDSN_LONGITUDE_TAKEOFF:
      case SGDSN_LONGITUDE:
        if (tlv_len == 4) {
          int32_t value;
          proto_tree_add_item_ret_int(tree, hf_ieee80211_vs_sgdsn_gpscoord, tvb, offset, 4, ENC_NA, &value);
          proto_item_append_text(tree, ": %.5f", value / 100000.0);
        } else {
          expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length, "Value length must be 4");
        }
        break;
      case SGDSN_ALTITUDE_ABS:
      case SGDSN_ALTITUDE_REL:
        if (tlv_len == 2) {
          uint32_t value;
          proto_tree_add_item_ret_uint(tree, hf_ieee80211_vs_sgdsn_altitude, tvb, offset, 2, ENC_NA, &value);
          proto_item_append_text(tree, ": %d m", value);
        } else {
          expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length, "Value length must be 4");
        }
        break;
      case SGDSN_H_SPEED:
        if (tlv_len == 1) {
          uint32_t value;
          proto_tree_add_item_ret_uint(tree, hf_ieee80211_vs_sgdsn_speed, tvb, offset, 1, ENC_NA, &value);
          proto_item_append_text(tree, ": %d m/s", value);
        } else {
          expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length, "Value length must be 1");
        }
        break;
      case SGDSN_HEADING:
        if (tlv_len == 2) {
          uint32_t value;
          proto_tree_add_item_ret_uint(tree, hf_ieee80211_vs_sgdsn_heading, tvb, offset, 2, ENC_NA, &value);
          proto_item_append_text(tree, ": %d deg", value);
        } else {
          expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length, "Value length must be 2");
        }
        break;
      default:
        expert_add_info_format(pinfo, tree, &ei_ieee80211_extra_data, "Unknown type");
        break;
      }

      offset += tlv_len;
      tag_len -= tlv_len;
    }

    if (tag_len) {
      expert_add_info_format(pinfo, item, &ei_ieee80211_tag_length, "Remaining bytes, TLV structure error");
    }
  }
}

enum vs_nintendo_type {
  NINTENDO_SERVICES = 0x11,
  NINTENDO_CONSOLEID = 0xF0
};

static const value_string ieee80211_vs_nintendo_type_vals[] = {
  { NINTENDO_SERVICES,  "Services"},
  { NINTENDO_CONSOLEID, "ConsoleID"},
  { 0, NULL }
};

static proto_tree*
dissect_vendor_ie_nintendo_tlv(const int hfindex, proto_tree *ietree,
                          tvbuff_t *tvb, int offset, uint32_t sublen)
{
  proto_item *nintendo_item;
  proto_tree *nintendo_tree;

  nintendo_item = proto_tree_add_item(ietree, hfindex, tvb, offset, sublen, ENC_NA);
  nintendo_tree = proto_item_add_subtree(nintendo_item, ett_nintendo);

  proto_tree_add_item(nintendo_tree, hf_ieee80211_vs_nintendo_type, tvb, offset, 1, ENC_NA);
  proto_tree_add_item(nintendo_tree, hf_ieee80211_vs_nintendo_length, tvb, offset + 1,  1, ENC_NA);

  return nintendo_tree;
}

static void
dissect_vendor_ie_nintendo(proto_item *item _U_, proto_tree *ietree,
                          tvbuff_t *tvb, int offset, uint32_t tag_len)
{
  proto_tree *nintendo_tree;

  uint8_t     subtype;
  uint8_t     sublength;
  uint32_t    length = tag_len;

  /* Skip OUI type for now - the code is for type 1 (StreetPass) only */
  /* http://3dbrew.org/wiki/StreetPass */
  offset += 1;
  length -= 1;

  while(length > 0 && length < 256) { /* otherwise we are < 0 but on unsigned */
    subtype = tvb_get_uint8(tvb, offset);
    sublength = tvb_get_uint8(tvb, offset + 1);

    switch(subtype) {
    case NINTENDO_SERVICES:
      nintendo_tree = dissect_vendor_ie_nintendo_tlv(hf_ieee80211_vs_nintendo_servicelist, ietree, tvb, offset, sublength + 2);
      offset += 2;
      length -= 2;

      while (sublength > 4) {

        proto_tree_add_item(nintendo_tree, hf_ieee80211_vs_nintendo_service, tvb, offset, 5, ENC_NA);
        offset += 5;
        length -= 5;
        sublength -= 5;
      }
      break;
    case NINTENDO_CONSOLEID:
      nintendo_tree = dissect_vendor_ie_nintendo_tlv(hf_ieee80211_vs_nintendo_consoleid, ietree, tvb, offset, sublength + 2);
      offset += + 2;
      length -= + 2;

      proto_tree_add_item(nintendo_tree, hf_ieee80211_vs_nintendo_consoleid, tvb, offset, sublength, ENC_NA);
      offset += sublength;
      length -= sublength;
      break;
    default:
      nintendo_tree = dissect_vendor_ie_nintendo_tlv(hf_ieee80211_vs_nintendo_unknown, ietree, tvb, offset, sublength + 2);
      offset += + 2;
      length -= + 2;

      proto_tree_add_item(nintendo_tree, hf_ieee80211_vs_nintendo_unknown, tvb, offset, sublength, ENC_NA);
      offset += sublength;
      length -= sublength;
      break;
    }
  }
}

static void
dissect_vendor_ie_meru(proto_item *item _U_, proto_tree *ietree,
                       tvbuff_t *tvb, int offset, uint32_t tag_len,
                       packet_info *pinfo)
{
  uint32_t type, length;
  proto_item *subitem, *ti_len;
  proto_tree *subtree;

  while (tag_len >= 2) {
    subitem = proto_tree_add_item(ietree, hf_ieee80211_vs_meru_subitem, tvb, offset, 2, ENC_NA);
    subtree = proto_item_add_subtree(subitem, ett_meru);

    proto_tree_add_item_ret_uint(subtree, hf_ieee80211_vs_meru_subtype, tvb, offset, 1, ENC_NA, &type);
    offset += 1;
    tag_len -= 1;

    ti_len = proto_tree_add_item_ret_uint(subtree, hf_ieee80211_vs_meru_sublength, tvb, offset, 1, ENC_NA, &length);
    offset += 1;
    tag_len -= 1;

    if (tag_len < length) {
      expert_add_info_format(pinfo, ti_len, &ei_ieee80211_tag_length, "Tag length < Sub Length");
      length = tag_len;
    }

    proto_item_append_text(subitem, " (t=%d, l=%d)", type, length);
    proto_item_set_len(subitem, 2+length);

    proto_tree_add_item(subtree, hf_ieee80211_vs_meru_subdata, tvb, offset, length, ENC_NA);
    offset += length;
    tag_len -= length;

  }
}

static const value_string ieee80211_vs_extreme_subtype_vals[] = {
  { 1, "AP Name"},
  { 0, NULL }
};

static void
dissect_vendor_ie_extreme(proto_item *item _U_, proto_tree *ietree,
                          tvbuff_t *tvb, int offset, uint32_t tag_len,
                          packet_info *pinfo)
{
  uint32_t type, length;
  proto_item *ti_len;

  proto_tree_add_item_ret_uint(ietree, hf_ieee80211_vs_extreme_subtype, tvb, offset, 1, ENC_NA, &type);
  offset += 1;
  tag_len -= 1;

  proto_tree_add_item(ietree, hf_ieee80211_vs_extreme_subdata, tvb, offset, tag_len, ENC_NA);

  switch(type){
    case 1: /* Unknown (7 bytes) + AP Name Length (1 byte) + AP Name */

      proto_tree_add_item(ietree, hf_ieee80211_vs_extreme_unknown, tvb, offset, 7, ENC_NA);
      offset += 7;
      tag_len -= 1;

      ti_len = proto_tree_add_item_ret_uint(ietree, hf_ieee80211_vs_extreme_ap_length, tvb, offset, 1, ENC_NA, &length);
      offset += 1;
      tag_len -= 1;

      if (tag_len < length) {
        expert_add_info_format(pinfo, ti_len, &ei_ieee80211_tag_length, "Tag length < AP Length");
        length = tag_len;
      }

    proto_tree_add_item(ietree, hf_ieee80211_vs_extreme_ap_name, tvb, offset, length, ENC_ASCII);

    break;
    default:
    /* Expert info ? */
    break;
  }
}

#define FORTINET_SYSTEM 10
static const value_string ieee80211_vs_fortinet_subtype_vals[] = {
  { FORTINET_SYSTEM, "SYSTEM"},
  { 0,                 NULL }
};

#define FORTINET_SYSTEM_APNAME 1
#define FORTINET_SYSTEM_APMODEL 2
#define FORTINET_SYSTEM_APSERIAL 3
static const value_string ieee80211_vs_fortinet_system_type_vals[] = {
  { FORTINET_SYSTEM_APNAME, "AP NAME"},
  { FORTINET_SYSTEM_APMODEL, "AP MODEL"},
  { FORTINET_SYSTEM_APSERIAL, "AP SERIAL"},
  { 0,                 NULL }
};

static void
dissect_vendor_ie_fortinet(proto_item *item, proto_tree *ietree,
                          tvbuff_t *tvb, int offset, uint32_t tag_len, packet_info *pinfo)
{
  uint32_t type;


  proto_tree_add_item_ret_uint(ietree, hf_ieee80211_vs_fortinet_subtype, tvb, offset, 2, ENC_LITTLE_ENDIAN, &type);
  proto_item_append_text(item, ": %s", val_to_str_const(type, ieee80211_vs_fortinet_subtype_vals, "Unknown"));
  offset += 2;
  tag_len -= 2;

  switch (type) {
  case FORTINET_SYSTEM:
    while (tag_len > 2) {
      uint32_t system_type, system_length;

      proto_tree_add_item_ret_uint(ietree, hf_ieee80211_vs_fortinet_system_type, tvb, offset, 1, ENC_NA, &system_type);
      proto_item_append_text(item, " - %s:", val_to_str_const(system_type, ieee80211_vs_fortinet_system_type_vals, "Unknown"));
      offset += 1;
      tag_len -= 1;

      proto_tree_add_item_ret_uint(ietree, hf_ieee80211_vs_fortinet_system_length, tvb, offset, 1, ENC_NA, &system_length);
      offset += 1;
      tag_len -= 1;

      switch (system_type) {
        case FORTINET_SYSTEM_APNAME:{
          const uint8_t* name;
          proto_tree_add_item_ret_string(ietree, hf_ieee80211_vs_fortinet_system_apname, tvb,
                               offset, system_length, ENC_ASCII|ENC_NA, pinfo->pool, &name);
          proto_item_append_text(item, " %s", name);
        }
        break;
        case FORTINET_SYSTEM_APMODEL:{
          const uint8_t* model;
          proto_tree_add_item_ret_string(ietree, hf_ieee80211_vs_fortinet_system_apmodel, tvb,
                               offset, system_length, ENC_ASCII|ENC_NA, pinfo->pool, &model);
          proto_item_append_text(item, " %s", model);
        }
        break;
        case FORTINET_SYSTEM_APSERIAL:{
          const uint8_t* serial;
          proto_tree_add_item_ret_string(ietree, hf_ieee80211_vs_fortinet_system_apserial, tvb,
                               offset, system_length, ENC_ASCII|ENC_NA, pinfo->pool, &serial);
          proto_item_append_text(item, " %s", serial);
        }
        break;
      }
      offset += system_length;
      tag_len -= system_length;
    }
    break;

  default:
    proto_tree_add_item(ietree, hf_ieee80211_vs_fortinet_data, tvb, offset,
      tag_len, ENC_NA);
    if (tag_len > 0)
      proto_item_append_text(item, " (Data: %s)", tvb_bytes_to_str(pinfo->pool, tvb, offset, tag_len));
    break;
  }
}

#define ARISTA_APNAME  6
static const value_string ieee80211_vs_arista_subtype_vals[] = {
  { ARISTA_APNAME, "AP Name"},
  { 0,                 NULL }
};
static void
dissect_vendor_ie_arista(proto_item *item, proto_tree *ietree,
                          tvbuff_t *tvb, int offset, uint32_t tag_len, packet_info *pinfo)
{
  uint8_t type;
  const uint8_t* name;

  offset += 1; /* VS OUI Type */
  tag_len -= 1;

  type = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(ietree, hf_ieee80211_vs_arista_subtype, tvb, offset, 1, ENC_NA);
  proto_item_append_text(item, ": %s", val_to_str_const(type, ieee80211_vs_arista_subtype_vals, "Unknown"));
  offset += 1;
  tag_len -= 1;

  switch (type) {
  case ARISTA_APNAME:
    offset += 1;
    tag_len -= 1;

    proto_tree_add_item_ret_string(ietree, hf_ieee80211_vs_arista_apname, tvb,
                         offset, tag_len, ENC_ASCII|ENC_NA, pinfo->pool, &name);
    proto_item_append_text(item, " (%s)", name);
    break;

  default:
    proto_tree_add_item(ietree, hf_ieee80211_vs_arista_data, tvb, offset,
      tag_len, ENC_NA);
    if (tag_len > 0)
      proto_item_append_text(item, " (Data: %s)", tvb_bytes_to_str(pinfo->pool, tvb, offset, tag_len));
    break;
  }
}

#define WISUN_PTKID 1
#define WISUN_GTKL  2
#define WISUN_NR    3
#define WISUN_LGTKL 4
#define WISUN_LGTK  5

static const value_string ieee80211_vs_wisun_type_vals[] = {
  { WISUN_PTKID, "PTKID" },
  { WISUN_GTKL,  "GTKL"  },
  { WISUN_NR,    "NR"    },
  { WISUN_LGTKL, "LGTKL" },
  { WISUN_LGTK,  "LGTK"  },
  { 0,           NULL    }
};

#define WISUN_GTKL_GTK0 0x01
#define WISUN_GTKL_GTK1 0x02
#define WISUN_GTKL_GTK2 0x04
#define WISUN_GTKL_GTK3 0x08

#define WISUN_NR_BR     0
#define WISUN_NR_ROUTER 1
#define WISUN_NR_LFN    2

static const value_string ieee80211_vs_wisun_nr_vals[] = {
  { WISUN_NR_BR,     "Border Router" },
  { WISUN_NR_ROUTER, "Router"        },
  { WISUN_NR_LFN,    "LFN"           },
  { 0,               NULL            }
};

#define WISUN_LGTKL_LGTK0 0x01
#define WISUN_LGTKL_LGTK1 0x02
#define WISUN_LGTKL_LGTK2 0x04

static void
dissect_vendor_ie_wisun(proto_item *item, proto_tree *ietree,
                        tvbuff_t *tvb, int offset, uint32_t tag_len, packet_info *pinfo)
{
  uint32_t type;

  proto_tree_add_item_ret_uint(ietree, hf_ieee80211_vs_wisun_type, tvb, offset, 1, ENC_LITTLE_ENDIAN, &type);
  proto_item_append_text(item, ": %s", val_to_str_const(type, ieee80211_vs_wisun_type_vals, "Unknown"));
  offset += 1;
  tag_len -= 1;

  switch(type) {
  case WISUN_PTKID:
    proto_tree_add_item(ietree, hf_ieee80211_vs_wisun_ptkid, tvb, offset, 16, ENC_NA);
    break;
  case WISUN_GTKL: {
    static int * const wisun_gtkl[] = {
        &hf_ieee80211_vs_wisun_gtkl_gtk0,
        &hf_ieee80211_vs_wisun_gtkl_gtk1,
        &hf_ieee80211_vs_wisun_gtkl_gtk2,
        &hf_ieee80211_vs_wisun_gtkl_gtk3,
        NULL,
    };

    proto_tree_add_bitmask(ietree, tvb, offset, hf_ieee80211_vs_wisun_gtkl,
                           ett_wisun_gtkl, wisun_gtkl, ENC_LITTLE_ENDIAN);
    break;
  }
  case WISUN_NR:
    proto_tree_add_item(ietree, hf_ieee80211_vs_wisun_nr, tvb,
                        offset, 1, ENC_LITTLE_ENDIAN);
    break;
  case WISUN_LGTKL: {
    static int * const wisun_lgtkl[] = {
        &hf_ieee80211_vs_wisun_lgtkl_lgtk0,
        &hf_ieee80211_vs_wisun_lgtkl_lgtk1,
        &hf_ieee80211_vs_wisun_lgtkl_lgtk2,
        NULL,
    };

    proto_tree_add_bitmask(ietree, tvb, offset, hf_ieee80211_vs_wisun_lgtkl,
                           ett_wisun_lgtkl, wisun_lgtkl, ENC_LITTLE_ENDIAN);
    break;
  }
  case WISUN_LGTK:
    proto_tree_add_item(ietree, hf_ieee80211_vs_wisun_lgtk_key_id, tvb,
                        offset, 1, ENC_LITTLE_ENDIAN);
    offset += 2;
    tag_len -= 2;
    proto_tree_add_item(ietree, hf_ieee80211_vs_wisun_lgtk_lgtk, tvb,
                        offset, tag_len, ENC_NA);
    break;
  default:
    proto_tree_add_item(ietree, hf_ieee80211_vs_wisun_data, tvb, offset, tag_len, ENC_NA);
    if (tag_len > 0)
      proto_item_append_text(item, " (Data: %s)", tvb_bytes_to_str(pinfo->pool, tvb, offset, tag_len));
    break;
  }
}

/* 802.11-2012 8.4.2.37 QoS Capability element */
static int
dissect_qos_capability(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset, int ftype)
{
  switch (ftype) {
    case MGT_ASSOC_REQ:
    case MGT_PROBE_REQ:
    case MGT_REASSOC_REQ:
    {
      /* To AP so decode Qos Info as STA */
      offset += add_ff_qos_info_sta(tree, tvb, pinfo, offset);
      break;
    }

    case MGT_BEACON:
    case MGT_PROBE_RESP:
    case MGT_ASSOC_RESP:
    case MGT_REASSOC_RESP:
    {
      /* From AP so decode QoS Info as AP */
      offset += add_ff_qos_info_ap(tree, tvb, pinfo, offset);
      break;
    }

    default:
      expert_add_info_format(pinfo, proto_tree_get_parent(tree), &ei_ieee80211_qos_info_bad_ftype,
                             "Could not deduce direction to decode correctly, ftype %u", ftype);
      break;
  }

  return offset;
}

static ieee80211_packet_data_t* get_or_create_packet_data(packet_info *pinfo) {
  ieee80211_packet_data_t *packet_data =
    (ieee80211_packet_data_t*)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, PACKET_DATA_KEY);
  if (!packet_data) {
    packet_data = wmem_new(pinfo->pool, ieee80211_packet_data_t);
    p_add_proto_data(pinfo->pool, pinfo, proto_wlan, PACKET_DATA_KEY, packet_data);
    memset(packet_data, 0, sizeof(ieee80211_packet_data_t));
  }
  return packet_data;
}

/* See ieee80211_rsn_keymgmt_vals */
static bool is_ft_akm_suite(uint32_t akm_suite)
{
  switch (akm_suite) {
    case AKMS_FT_IEEE802_1X:
    case AKMS_FT_PSK:
    case AKMS_FT_SAE:
    case AKMS_FT_IEEE802_1X_SHA384:
    case AKMS_FT_FILS_SHA256:
    case AKMS_FT_FILS_SHA384:
      return true;
    default:
      return false;
  }
}

static void
save_proto_data(tvbuff_t *tvb, packet_info *pinfo, int offset, size_t size, int key)
{
  uint8_t *data;

  if (!enable_decryption) {
    return;
  }
  data = (uint8_t *)wmem_alloc(pinfo->pool, size);
  tvb_memcpy(tvb, data, offset, size);
  p_add_proto_data(pinfo->pool, pinfo, proto_wlan, key, data);
}

static void
save_proto_data_value(packet_info *pinfo, unsigned value, int key)
{
  if (!enable_decryption) {
    return;
  }
  p_add_proto_data(pinfo->pool, pinfo, proto_wlan, key, GUINT_TO_POINTER(value));
}

static void
save_tag_for_dot11decrypt(tvbuff_t *tvb, packet_info *pinfo, int offset)
{
  uint8_t tag_no;
  uint8_t tag_len;

  if (!enable_decryption) {
    return;
  }
  tag_no  = tvb_get_uint8(tvb, offset);
  tag_len = tvb_get_uint8(tvb, offset + 1);

  switch (tag_no) {
    case TAG_MOBILITY_DOMAIN:
      save_proto_data(tvb, pinfo, offset, tag_len + 2, MDE_TAG_KEY);
      break;
    case TAG_FAST_BSS_TRANSITION:
      save_proto_data(tvb, pinfo, offset, tag_len + 2, FTE_TAG_KEY);
      break;
    case TAG_RIC_DATA:
      save_proto_data(tvb, pinfo, offset, tag_len + 2, RDE_TAG_KEY);
      break;
    case TAG_RSN_IE:
      save_proto_data(tvb, pinfo, offset, tag_len + 2, RSNE_TAG_KEY);
      break;
    default:
      break;
  }
}

static void
set_packet_data_last_akm_suite(ieee80211_packet_data_t *packet_data,
                               uint32_t last_akm_suite)
{
  packet_data->last_akm_suite_set = true;
  packet_data->last_akm_suite = last_akm_suite;
}

static void
set_conversation_last_akm_suite(ieee80211_conversation_data_t *conv,
                                uint32_t last_akm_suite)
{
  conv->last_akm_suite_set = true;
  conv->last_akm_suite = last_akm_suite;
}

/*
 * 7.3.2.25 RSNE information element. Common format with OSEN except the
 * version... should refactor
 */
static int
dissect_rsn_ie(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,
               int offset, uint32_t tag_len, association_sanity_check_t *association_sanity_check)
{
  proto_item *rsn_gcs_item, *rsn_pcs_item, *rsn_akms_item, *rsn_pmkid_item, *rsn_gmcs_item;
  proto_item *rsn_sub_pcs_item, *rsn_sub_akms_item;
  proto_item *rsn_pcs_count, *rsn_akms_count, *rsn_pmkid_count;
  proto_tree *rsn_gcs_tree, *rsn_pcs_tree, *rsn_akms_tree, *rsn_pmkid_tree, *rsn_gmcs_tree;
  proto_tree *rsn_sub_pcs_tree, *rsn_sub_akms_tree;
  uint16_t    pcs_count, akms_count, pmkid_count;
  unsigned    ii;
  int         tag_end = offset + tag_len;
  static int * const ieee80211_rsn_cap[] = {
    &hf_ieee80211_rsn_cap_preauth,
    &hf_ieee80211_rsn_cap_no_pairwise,
    &hf_ieee80211_rsn_cap_ptksa_replay_counter,
    &hf_ieee80211_rsn_cap_gtksa_replay_counter,
    &hf_ieee80211_rsn_cap_mfpr,
    &hf_ieee80211_rsn_cap_mfpc,
    &hf_ieee80211_rsn_cap_jmr,
    &hf_ieee80211_rsn_cap_peerkey,
    &hf_ieee80211_rsn_cap_extended_key_id_iaf,
    &hf_ieee80211_rsn_cap_ocvc,
    NULL
  };

  proto_tree_add_item(tree, hf_ieee80211_rsn_version, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  if (offset >= tag_end)
    return offset;

  /* 7.3.2.25.1 Group Cipher suites */
  rsn_gcs_item = proto_tree_add_item(tree, hf_ieee80211_rsn_gcs, tvb, offset, 4, ENC_BIG_ENDIAN);
  rsn_gcs_tree = proto_item_add_subtree(rsn_gcs_item, ett_rsn_gcs_tree);
  proto_tree_add_item(rsn_gcs_tree, hf_ieee80211_rsn_gcs_oui, tvb, offset, 3, ENC_BIG_ENDIAN);

    /* Check if OUI is 00:0F:AC (ieee80211) */
  if (tvb_get_ntoh24(tvb, offset) == OUI_RSN)
  {
    proto_tree_add_item(rsn_gcs_tree, hf_ieee80211_rsn_gcs_80211_type, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);
    save_proto_data_value(pinfo, tvb_get_uint8(tvb, offset + 3), GROUP_CIPHER_KEY);
  } else {
    proto_tree_add_item(rsn_gcs_tree, hf_ieee80211_rsn_gcs_type, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);
  }
  offset += 4;

  if (offset >= tag_end)
    return offset;

  /* 7.3.2.25.2 Pairwise Cipher suites */
  rsn_pcs_count = proto_tree_add_item(tree, hf_ieee80211_rsn_pcs_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  pcs_count = tvb_get_letohs(tvb, offset);
  offset += 2;

  if (offset + (pcs_count * 4) > tag_end)
  {
    expert_add_info_format(pinfo, rsn_pcs_count, &ei_ieee80211_rsn_pcs_count,
        "Pairwise Cipher Suite Count too large, 4*%u > %d", pcs_count, tag_end - offset);
    pcs_count = (tag_end - offset) / 4;
  }

  rsn_pcs_item = proto_tree_add_item(tree, hf_ieee80211_rsn_pcs_list, tvb, offset, pcs_count * 4, ENC_NA);
  rsn_pcs_tree = proto_item_add_subtree(rsn_pcs_item, ett_rsn_pcs_tree);
  for (ii = 0; ii < pcs_count; ii++)
  {
    rsn_sub_pcs_item = proto_tree_add_item(rsn_pcs_tree, hf_ieee80211_rsn_pcs, tvb, offset, 4, ENC_BIG_ENDIAN);
    rsn_sub_pcs_tree = proto_item_add_subtree(rsn_sub_pcs_item, ett_rsn_sub_pcs_tree);
    proto_tree_add_item(rsn_sub_pcs_tree, hf_ieee80211_rsn_pcs_oui, tvb, offset, 3, ENC_BIG_ENDIAN);

    /* Check if OUI is 00:0F:AC (ieee80211) */
    if (tvb_get_ntoh24(tvb, offset) == OUI_RSN)
    {
      proto_tree_add_item(rsn_sub_pcs_tree, hf_ieee80211_rsn_pcs_80211_type, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);
      proto_item_append_text(rsn_pcs_item, " %s", rsn_pcs_return(pinfo->pool, tvb_get_ntohl(tvb, offset)));
      save_proto_data_value(pinfo, tvb_get_uint8(tvb, offset + 3), CIPHER_KEY);
    } else {
      proto_tree_add_item(rsn_sub_pcs_tree, hf_ieee80211_rsn_pcs_type, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);
    }
    offset += 4;
  }

  if (offset >= tag_end)
  {
    return offset;
  }

  /* 7.3.2.25.2 AKM suites */
  rsn_akms_count = proto_tree_add_item(tree, hf_ieee80211_rsn_akms_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  akms_count = tvb_get_letohs(tvb, offset);
  offset += 2;

  if (offset + (akms_count * 4) > tag_end)
  {
    expert_add_info_format(pinfo, rsn_akms_count, &ei_ieee80211_rsn_pmkid_count,
        "Auth Key Management (AKM) Suite Count too large, 4*%u > %d", akms_count, tag_end - offset);
    akms_count = (tag_end - offset) / 4;
  }

  rsn_akms_item = proto_tree_add_item(tree, hf_ieee80211_rsn_akms_list, tvb, offset, akms_count * 4, ENC_NA);
  rsn_akms_tree = proto_item_add_subtree(rsn_akms_item, ett_rsn_akms_tree);

  ieee80211_packet_data_t *packet_data = get_or_create_packet_data(pinfo);

  for (ii = 0; ii < akms_count; ii++)
  {
    rsn_sub_akms_item = proto_tree_add_item(rsn_akms_tree, hf_ieee80211_rsn_akms, tvb, offset, 4, ENC_BIG_ENDIAN);
    rsn_sub_akms_tree = proto_item_add_subtree(rsn_sub_akms_item, ett_rsn_sub_akms_tree);
    proto_tree_add_item(rsn_sub_akms_tree, hf_ieee80211_rsn_akms_oui, tvb, offset, 3, ENC_BIG_ENDIAN);

    /* Check if OUI is 00:0F:AC (ieee80211) */
    if (tvb_get_ntoh24(tvb, offset) == OUI_RSN)
    {
      proto_tree_add_item(rsn_sub_akms_tree, hf_ieee80211_rsn_akms_80211_type, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);
      proto_item_append_text(rsn_akms_item, " %s", rsn_akms_return(pinfo->pool, tvb_get_ntohl(tvb, offset)));
      save_proto_data_value(pinfo, tvb_get_uint8(tvb, offset + 3), AKM_KEY);

      set_packet_data_last_akm_suite(packet_data, tvb_get_ntohl(tvb, offset));
      if (association_sanity_check) {
        uint32_t akm_suite = tvb_get_ntohl(tvb, offset);
        association_sanity_check->last_akm_suite = akm_suite;

        if (is_ft_akm_suite(akm_suite)) {
          /* This is an FT AKM suite */
          association_sanity_check->has_ft_akm_suite = true;
          if (association_sanity_check->rsn_first_ft_akm_suite == NULL && rsn_sub_akms_tree != NULL) {
            association_sanity_check->rsn_first_ft_akm_suite = rsn_sub_akms_tree->last_child;
          }
        } else {
          /* This is a non-FT AKM suite */
          association_sanity_check->has_non_ft_akm_suite = true;
          if (association_sanity_check->rsn_first_non_ft_akm_suite == NULL && rsn_sub_akms_tree != NULL) {
            association_sanity_check->rsn_first_non_ft_akm_suite = rsn_sub_akms_tree->last_child;
          }
        }
      }
    } else {
      proto_tree_add_item(rsn_sub_akms_tree, hf_ieee80211_rsn_akms_type, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);
    }
    offset += 4;
  }

  /* 7.3.2.25.3 RSN capabilities */
  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_rsn_cap,
                                    ett_rsn_cap_tree, ieee80211_rsn_cap,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;
  if (offset >= tag_end)
  {
    return offset;
  }
  /* 7.3.2.25.4 PMKID */
  rsn_pmkid_count = proto_tree_add_item(tree, hf_ieee80211_rsn_pmkid_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  pmkid_count = tvb_get_letohs(tvb, offset);
  offset += 2;

  if (offset + (pmkid_count * 16) > tag_end)
  {
    expert_add_info_format(pinfo, rsn_pmkid_count, &ei_ieee80211_pmkid_count_too_large,
        "PMKID Count too large, 16*%u > %d", pmkid_count, tag_end - offset);
    pmkid_count = (tag_end - offset) / 16;
  }

  rsn_pmkid_item = proto_tree_add_item(tree, hf_ieee80211_rsn_pmkid_list, tvb, offset, pmkid_count * 16, ENC_NA);
  rsn_pmkid_tree = proto_item_add_subtree(rsn_pmkid_item, ett_rsn_pmkid_tree);
  for (ii = 0; ii < pmkid_count; ii++)
  {
    proto_tree_add_item(rsn_pmkid_tree, hf_ieee80211_rsn_pmkid, tvb, offset, 16, ENC_NA);
    offset += 16;
  }

  if (offset >= tag_end)
  {
    return offset;
  }
  /* Group Management Cipher Suite (802.11w)*/
  rsn_gmcs_item = proto_tree_add_item(tree, hf_ieee80211_rsn_gmcs, tvb, offset, 4, ENC_BIG_ENDIAN);
  rsn_gmcs_tree = proto_item_add_subtree(rsn_gmcs_item, ett_rsn_gmcs_tree);
  proto_tree_add_item(rsn_gmcs_tree, hf_ieee80211_rsn_gmcs_oui, tvb, offset, 3, ENC_BIG_ENDIAN);
  /* Check if OUI is 00:0F:AC (ieee80211) */
  if (tvb_get_ntoh24(tvb, offset) == OUI_RSN)
  {
    proto_tree_add_item(rsn_gmcs_tree, hf_ieee80211_rsn_gmcs_80211_type, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);
  } else {
    proto_tree_add_item(rsn_gmcs_tree, hf_ieee80211_rsn_gmcs_type, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);
  }
  offset += 4;

  return offset;
}

/* 7.3.2.27 Extended Capabilities information element (127) */
static int
dissect_extended_capabilities_ie(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  proto_item *ti_ex_cap;
  static int * const ieee80211_tag_extended_capabilities_byte1[] = {
    &hf_ieee80211_tag_extended_capabilities_b0,
    &hf_ieee80211_tag_extended_capabilities_b1,
    &hf_ieee80211_tag_extended_capabilities_b2,
    &hf_ieee80211_tag_extended_capabilities_b3,
    &hf_ieee80211_tag_extended_capabilities_b4,
    &hf_ieee80211_tag_extended_capabilities_b5,
    &hf_ieee80211_tag_extended_capabilities_b6,
    &hf_ieee80211_tag_extended_capabilities_b7,
    NULL
  };
  static int * const ieee80211_tag_extended_capabilities_byte2[] = {
    &hf_ieee80211_tag_extended_capabilities_b8,
    &hf_ieee80211_tag_extended_capabilities_b9,
    &hf_ieee80211_tag_extended_capabilities_b10,
    &hf_ieee80211_tag_extended_capabilities_b11,
    &hf_ieee80211_tag_extended_capabilities_b12,
    &hf_ieee80211_tag_extended_capabilities_b13,
    &hf_ieee80211_tag_extended_capabilities_b14,
    &hf_ieee80211_tag_extended_capabilities_b15,
    NULL
  };
  static int * const ieee80211_tag_extended_capabilities_byte3[] = {
    &hf_ieee80211_tag_extended_capabilities_b16,
    &hf_ieee80211_tag_extended_capabilities_b17,
    &hf_ieee80211_tag_extended_capabilities_b18,
    &hf_ieee80211_tag_extended_capabilities_b19,
    &hf_ieee80211_tag_extended_capabilities_b20,
    &hf_ieee80211_tag_extended_capabilities_b21,
    &hf_ieee80211_tag_extended_capabilities_b22,
    &hf_ieee80211_tag_extended_capabilities_b23,
    NULL
  };
  static int * const ieee80211_tag_extended_capabilities_byte4[] = {
    &hf_ieee80211_tag_extended_capabilities_b24,
    &hf_ieee80211_tag_extended_capabilities_b25,
    &hf_ieee80211_tag_extended_capabilities_b26,
    &hf_ieee80211_tag_extended_capabilities_b27,
    &hf_ieee80211_tag_extended_capabilities_b28,
    &hf_ieee80211_tag_extended_capabilities_b29,
    &hf_ieee80211_tag_extended_capabilities_b30,
    &hf_ieee80211_tag_extended_capabilities_b31,
    NULL
  };
  static int * const ieee80211_tag_extended_capabilities_byte5[] = {
    &hf_ieee80211_tag_extended_capabilities_b32,
    &hf_ieee80211_tag_extended_capabilities_b33,
    &hf_ieee80211_tag_extended_capabilities_b34,
    &hf_ieee80211_tag_extended_capabilities_b35,
    &hf_ieee80211_tag_extended_capabilities_b36,
    &hf_ieee80211_tag_extended_capabilities_b37,
    &hf_ieee80211_tag_extended_capabilities_b38,
    &hf_ieee80211_tag_extended_capabilities_b39,
    NULL
  };
  static int * const ieee80211_tag_extended_capabilities_byte6[] = {
    &hf_ieee80211_tag_extended_capabilities_b40,
    &hf_ieee80211_tag_extended_capabilities_serv_int_granularity,
    &hf_ieee80211_tag_extended_capabilities_b44,
    &hf_ieee80211_tag_extended_capabilities_b45,
    &hf_ieee80211_tag_extended_capabilities_b46,
    &hf_ieee80211_tag_extended_capabilities_b47,
    NULL
  };
  static int * const ieee80211_tag_extended_capabilities_byte7[] = {
    &hf_ieee80211_tag_extended_capabilities_b48,
    &hf_ieee80211_tag_extended_capabilities_b49,
    &hf_ieee80211_tag_extended_capabilities_b50,
    &hf_ieee80211_tag_extended_capabilities_b51,
    &hf_ieee80211_tag_extended_capabilities_b52,
    &hf_ieee80211_tag_extended_capabilities_b53,
    &hf_ieee80211_tag_extended_capabilities_b54,
    &hf_ieee80211_tag_extended_capabilities_b55,
    NULL
  };

  static int * const ieee80211_tag_extended_capabilities_byte8[] = {
    &hf_ieee80211_tag_extended_capabilities_b56,
    &hf_ieee80211_tag_extended_capabilities_b57,
    &hf_ieee80211_tag_extended_capabilities_b58,
    &hf_ieee80211_tag_extended_capabilities_b59,
    &hf_ieee80211_tag_extended_capabilities_b60,
    &hf_ieee80211_tag_extended_capabilities_b61,
    &hf_ieee80211_tag_extended_capabilities_b62,
    &hf_ieee80211_tag_extended_capabilities_b63,
    NULL
  };

  static int * const ieee80211_tag_extended_capabilities_bytes89[] = {
    &hf_ieee80211_tag_extended_capabilities_b56_2,
    &hf_ieee80211_tag_extended_capabilities_b57_2,
    &hf_ieee80211_tag_extended_capabilities_b58_2,
    &hf_ieee80211_tag_extended_capabilities_b59_2,
    &hf_ieee80211_tag_extended_capabilities_b60_2,
    &hf_ieee80211_tag_extended_capabilities_b61_2,
    &hf_ieee80211_tag_extended_capabilities_b62_2,
    &hf_ieee80211_tag_extended_capabilities_max_num_msdus,
    &hf_ieee80211_tag_extended_capabilities_b65_2,
    &hf_ieee80211_tag_extended_capabilities_b66_2,
    &hf_ieee80211_tag_extended_capabilities_b67_2,
    &hf_ieee80211_tag_extended_capabilities_b68_2,
    &hf_ieee80211_tag_extended_capabilities_b69_2,
    &hf_ieee80211_tag_extended_capabilities_b70_2,
    &hf_ieee80211_tag_extended_capabilities_b71_2,
    NULL
  };

  static int * const ieee80211_tag_extended_capabilities_byte10[] = {
    &hf_ieee80211_tag_extended_capabilities_b72,
    &hf_ieee80211_tag_extended_capabilities_b73,
    &hf_ieee80211_tag_extended_capabilities_b74,
    &hf_ieee80211_tag_extended_capabilities_b75,
    &hf_ieee80211_tag_extended_capabilities_b76,
    &hf_ieee80211_tag_extended_capabilities_b77,
    &hf_ieee80211_tag_extended_capabilities_b78,
    &hf_ieee80211_tag_extended_capabilities_b79,
    NULL
  };

  static int * const ieee80211_tag_extended_capabilities_byte11[] = {
    &hf_ieee80211_tag_extended_capabilities_b80,
    &hf_ieee80211_tag_extended_capabilities_b81,
    &hf_ieee80211_tag_extended_capabilities_b82,
    &hf_ieee80211_tag_extended_capabilities_b83,
    &hf_ieee80211_tag_extended_capabilities_b84,
    &hf_ieee80211_tag_extended_capabilities_b85,
    &hf_ieee80211_tag_extended_capabilities_b86,
    &hf_ieee80211_tag_extended_capabilities_b87,
    NULL
  };

  static int * const ieee80211_tag_extended_capabilities_byte12[] = {
    &hf_ieee80211_tag_extended_capabilities_b88,
    &hf_ieee80211_tag_extended_capabilities_b89,
    &hf_ieee80211_tag_extended_capabilities_b90,
    &hf_ieee80211_tag_extended_capabilities_b91,
    &hf_ieee80211_tag_extended_capabilities_b92,
    &hf_ieee80211_tag_extended_capabilities_b93,
    &hf_ieee80211_tag_extended_capabilities_b94,
    &hf_ieee80211_tag_extended_capabilities_b95,
    NULL
  };

  static int * const ieee80211_tag_extended_capabilities_byte13[] = {
    &hf_ieee80211_tag_extended_capabilities_b96,
    &hf_ieee80211_tag_extended_capabilities_b97,
    &hf_ieee80211_tag_extended_capabilities_reserved2,
    NULL
  };

  if (tag_len < 1)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag length %u too short, must be greater than 0", tag_len);
    return 1;
  }
  proto_item_append_text(field_data->item_tag, " (%u octet%s)", tag_len, plurality(tag_len, "", "s"));

  /* Extended Capability octet 1 */
  ti_ex_cap = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_extended_capabilities,
                                    ett_tag_ex_cap1, ieee80211_tag_extended_capabilities_byte1,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  proto_item_append_text(ti_ex_cap, " (octet 1)");
  offset += 1;

  /* Extended Capability octet 2 */
  if (offset >= tag_len) {
    return offset;
  }
  ti_ex_cap = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_extended_capabilities,
                                    ett_tag_ex_cap2, ieee80211_tag_extended_capabilities_byte2,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  proto_item_append_text(ti_ex_cap, " (octet 2)");
  offset += 1;

  /* Extended Capability octet 3 */
  if (offset >= tag_len) {
    return offset;
  }
  ti_ex_cap = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_extended_capabilities,
                                    ett_tag_ex_cap3, ieee80211_tag_extended_capabilities_byte3,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  proto_item_append_text(ti_ex_cap, " (octet 3)");
  offset += 1;

  /* Extended Capability octet 4 */
  if (offset >= tag_len) {
    return offset;
  }
  ti_ex_cap = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_extended_capabilities,
                                    ett_tag_ex_cap4, ieee80211_tag_extended_capabilities_byte4,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  proto_item_append_text(ti_ex_cap, " (octet 4)");
  offset += 1;

  /* Extended Capability octet 5 */
  if (offset >= tag_len) {
    return offset;
  }
  ti_ex_cap = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_extended_capabilities,
                                    ett_tag_ex_cap5, ieee80211_tag_extended_capabilities_byte5,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  proto_item_append_text(ti_ex_cap, " (octet 5)");
  offset += 1;

  /* Extended Capability octet 6 */
  if (offset >= tag_len) {
    return offset;
  }

  ti_ex_cap = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_extended_capabilities,
                                    ett_tag_ex_cap6, ieee80211_tag_extended_capabilities_byte6,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  proto_item_append_text(ti_ex_cap, " (octet 6)");
  offset += 1;


  /* Extended Capability octet 7 */
  if (offset >= tag_len) {
    return offset;
  }
  ti_ex_cap = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_extended_capabilities,
                                    ett_tag_ex_cap7, ieee80211_tag_extended_capabilities_byte7,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  proto_item_append_text(ti_ex_cap, " (octet 7)");
  offset += 1;

  /* Extended Capability octet 8 & 9 since two bits cross the boundary */
  if (offset >= tag_len) {
    return offset;
  }

  /* If only the first of the two bytes is present, do the best we can */
  if (offset == tag_len - 1) {
    ti_ex_cap = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_extended_capabilities,
                                    ett_tag_ex_cap8, ieee80211_tag_extended_capabilities_byte8,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    proto_item_append_text(ti_ex_cap, " (octet 8)");
    offset += 1;
  } else { /* Both bytes are there */
    ti_ex_cap = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_extended_capabilities_2,
                                    ett_tag_ex_cap89, ieee80211_tag_extended_capabilities_bytes89,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    proto_item_append_text(ti_ex_cap, " (octets 8 & 9)");
    offset += 2;
  }

  if (offset >= tag_len) {
    return offset;
  }

  /* Extended Capability octet 10 */
  ti_ex_cap = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_extended_capabilities,
                                    ett_tag_ex_cap10, ieee80211_tag_extended_capabilities_byte10,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  proto_item_append_text(ti_ex_cap, " (octet 10)");
  offset += 1;

  if (offset >= tag_len) {
    return offset;
  }

  /* Extended Capability octet 11 */
#if 0
  /* Added for SAE support */
  sae_byte = tvb_get_uint8(tvb, offset);
  /*
   * If one of the SAE bits is set, assume we will see Password identifiers
   */
  if (sae_byte & 0x6) {
    bool sae_val = true;
    uint64_t *key = NULL;

    /* Must be for the source of the request */
    key = (uint64_t *)wmem_new(wmem_file_scope(), uint64_t);
    *key = *(uint64_t *)pinfo->src.data;
    wmem_map_insert(sae_prop_hash, key, GINT_TO_POINTER(sae_val));
  }
#endif
  ti_ex_cap = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_extended_capabilities,
                                    ett_tag_ex_cap11, ieee80211_tag_extended_capabilities_byte11,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  proto_item_append_text(ti_ex_cap, " (octet 11)");
  offset += 1;

  if (offset >= tag_len) {
    return offset;
  }

  ti_ex_cap = proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_tag_extended_capabilities,
                                    ett_tag_ex_cap12,
                                    ieee80211_tag_extended_capabilities_byte12,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  proto_item_append_text(ti_ex_cap, " (octet 12)");
  offset += 1;

  if (offset >= tag_len) {
    return offset;
  }

  ti_ex_cap = proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_tag_extended_capabilities,
                                    ett_tag_ex_cap13,
                                    ieee80211_tag_extended_capabilities_byte13,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  proto_item_append_text(ti_ex_cap, " (octet 13)");
  offset += 1;

  return offset;
}

static int
dissect_vht_mcs_set(proto_tree *tree, tvbuff_t *tvb, int offset)
{
  proto_item *ti;
  proto_tree *mcs_tree;
  static int * const ieee80211_vht_mcsset_rx_max_mcs[] = {
    &hf_ieee80211_vht_mcsset_rx_max_mcs_for_1_ss,
    &hf_ieee80211_vht_mcsset_rx_max_mcs_for_2_ss,
    &hf_ieee80211_vht_mcsset_rx_max_mcs_for_3_ss,
    &hf_ieee80211_vht_mcsset_rx_max_mcs_for_4_ss,
    &hf_ieee80211_vht_mcsset_rx_max_mcs_for_5_ss,
    &hf_ieee80211_vht_mcsset_rx_max_mcs_for_6_ss,
    &hf_ieee80211_vht_mcsset_rx_max_mcs_for_7_ss,
    &hf_ieee80211_vht_mcsset_rx_max_mcs_for_8_ss,
    NULL
  };
  static int * const ieee80211_vht_mcsset_tx_max_mcs[] = {
    &hf_ieee80211_vht_mcsset_tx_max_mcs_for_1_ss,
    &hf_ieee80211_vht_mcsset_tx_max_mcs_for_2_ss,
    &hf_ieee80211_vht_mcsset_tx_max_mcs_for_3_ss,
    &hf_ieee80211_vht_mcsset_tx_max_mcs_for_4_ss,
    &hf_ieee80211_vht_mcsset_tx_max_mcs_for_5_ss,
    &hf_ieee80211_vht_mcsset_tx_max_mcs_for_6_ss,
    &hf_ieee80211_vht_mcsset_tx_max_mcs_for_7_ss,
    &hf_ieee80211_vht_mcsset_tx_max_mcs_for_8_ss,
    NULL
  };

  /* 8 byte Supported MCS set */
  ti = proto_tree_add_item(tree, hf_ieee80211_vht_mcsset, tvb, offset, 8, ENC_NA);

  mcs_tree = proto_item_add_subtree(ti, ett_vht_mcsset_tree);

  /* B0 - B15 */
  proto_tree_add_bitmask_with_flags(mcs_tree, tvb, offset, hf_ieee80211_vht_mcsset_rx_mcs_map,
                                    ett_vht_rx_mcsbit_tree, ieee80211_vht_mcsset_rx_max_mcs,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;

  /* B16 - B28 13 bits*/
  proto_tree_add_item(mcs_tree, hf_ieee80211_vht_mcsset_rx_highest_long_gi, tvb, offset, 2, ENC_LITTLE_ENDIAN);

  /* B29 - B31 2 Max NSTS, total*/

  proto_tree_add_item(mcs_tree, hf_ieee80211_vht_mcsset_max_nsts_total, tvb, offset,
                                2, ENC_LITTLE_ENDIAN);
  offset += 2;

  /* B32 - B47 */
  proto_tree_add_bitmask_with_flags(mcs_tree, tvb, offset, hf_ieee80211_vht_mcsset_tx_mcs_map,
                                    ett_vht_tx_mcsbit_tree, ieee80211_vht_mcsset_tx_max_mcs,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;
  /* B48 - B60 13 bits */
  proto_tree_add_item(mcs_tree, hf_ieee80211_vht_mcsset_tx_highest_long_gi, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  /* B61 */
  proto_tree_add_item(mcs_tree, hf_ieee80211_vht_mcsset_extended_nss_bw_capable,
                                tvb, offset, 2, ENC_LITTLE_ENDIAN);

  /* B62 - B63 2 reserved bits*/
  proto_tree_add_item(mcs_tree, hf_ieee80211_vht_mcsset_reserved, tvb, offset, 2,
                                ENC_LITTLE_ENDIAN);offset += 2;

  return offset;
}

static int
dissect_vht_capability_ie(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  static int * const ieee80211_vht_caps[] = {
    &hf_ieee80211_vht_max_mpdu_length,
    &hf_ieee80211_vht_supported_chan_width_set,
    &hf_ieee80211_vht_rx_ldpc,
    &hf_ieee80211_vht_short_gi_for_80,
    &hf_ieee80211_vht_short_gi_for_160,
    &hf_ieee80211_vht_tx_stbc,
    /* End of first byte */
    &hf_ieee80211_vht_rx_stbc,
    &hf_ieee80211_vht_su_beamformer_cap,
    &hf_ieee80211_vht_su_beamformee_cap,
    &hf_ieee80211_vht_beamformer_antennas,
    /* End of second byte */
    &hf_ieee80211_vht_sounding_dimensions,
    &hf_ieee80211_vht_mu_beamformer_cap,
    &hf_ieee80211_vht_mu_beamformee_cap,
    &hf_ieee80211_vht_txop_ps,
    &hf_ieee80211_vht_var_htc_field,
    &hf_ieee80211_vht_max_ampdu,
    &hf_ieee80211_vht_link_adaptation_cap,
    &hf_ieee80211_vht_rx_pattern,
    &hf_ieee80211_vht_tx_pattern,
    &hf_ieee80211_vht_ext_nss_bw_support,
    NULL
  };

  if (tag_len != 12) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "VHT Capabilities IE length %u wrong, must be = 12", tag_len);
    return 1;
  }

  /* 4 byte VHT Capabilities  Info*/
  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_vht_cap,
                                    ett_vht_cap_tree, ieee80211_vht_caps,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 4;

  /* 8 byte MCS set */
  offset = dissect_vht_mcs_set(tree, tvb, offset);

  return offset;
}

static int
dissect_vht_operation_ie(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  proto_item *op_item;
  proto_tree *op_tree;
  static int * const ieee80211_vht_op_max_basic_mcs[] = {
    &hf_ieee80211_vht_op_max_basic_mcs_for_1_ss,
    &hf_ieee80211_vht_op_max_basic_mcs_for_2_ss,
    &hf_ieee80211_vht_op_max_basic_mcs_for_3_ss,
    &hf_ieee80211_vht_op_max_basic_mcs_for_4_ss,
    &hf_ieee80211_vht_op_max_basic_mcs_for_5_ss,
    &hf_ieee80211_vht_op_max_basic_mcs_for_6_ss,
    &hf_ieee80211_vht_op_max_basic_mcs_for_7_ss,
    &hf_ieee80211_vht_op_max_basic_mcs_for_8_ss,
    NULL
  };

  if (tag_len != 5) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "VHT Operation IE length %u wrong, must be = 5", tag_len);
    return 1;
  }

  /* 3 byte VHT Operation Info*/
  op_item = proto_tree_add_item(tree, hf_ieee80211_vht_op, tvb, offset, 3, ENC_NA);
  op_tree = proto_item_add_subtree(op_item, ett_vht_op_tree);
  proto_tree_add_item(op_tree, hf_ieee80211_vht_op_channel_width, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(op_tree, hf_ieee80211_vht_op_channel_center0, tvb, offset+1, 1, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(op_tree, hf_ieee80211_vht_op_channel_center1, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);

  offset += 3;
  /* VHT Basic MCS Set */
  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_vht_op_basic_mcs_map,
                                    ett_vht_basic_mcsbit_tree, ieee80211_vht_op_max_basic_mcs,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;

  return offset;
}

static int
dissect_vht_tx_pwr_envelope(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  proto_item *tx_pwr_item, *ti;
  proto_tree *tx_pwr_info_tree;
  uint8_t opt_ie_cnt=0;
  uint8_t i;
  unsigned mtpi;

  if (tag_len < 2 || tag_len > 9) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "VHT TX PWR Envelope IE length %u wrong, must be >= 2 and <= 9", tag_len);
    return 1;
  }

  mtpi = (tvb_get_uint8(tvb, offset) >> 3) & 0x7;
  tx_pwr_item = proto_tree_add_item(tree, hf_ieee80211_vht_tpe_pwr_info, tvb, offset, 1, ENC_NA);
  tx_pwr_info_tree =  proto_item_add_subtree(tx_pwr_item, ett_vht_tpe_info_tree);

  ti = proto_tree_add_item(tx_pwr_info_tree, hf_ieee80211_vht_tpe_pwr_info_count, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tx_pwr_info_tree, hf_ieee80211_vht_tpe_pwr_info_unit, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tx_pwr_info_tree, hf_ieee80211_vht_tpe_pwr_info_category, tvb, offset, 1, ENC_LITTLE_ENDIAN);

  opt_ie_cnt = tvb_get_uint8(tvb, offset) & 0x07;

  offset += 1;

  if (mtpi == 1 || mtpi == 3) { /* Is it a power spectral density? */
    /* Handle the zero case */
    if (opt_ie_cnt == 0) {
      proto_tree_add_item(tree, hf_ieee80211_vht_tpe_any_bw_psd, tvb, offset,
                          1, ENC_NA);
      offset += 1;
      return offset;
    }
    switch (opt_ie_cnt) {
    case 0:
      opt_ie_cnt = 0;
      break;
    case 1:
      opt_ie_cnt = 1;
      break;
    case 2:
      opt_ie_cnt = 2;
      break;
    case 3:
      opt_ie_cnt = 4;
      break;
    case 4:
      opt_ie_cnt = 8;
      break;
    default:
      opt_ie_cnt = 1; /* Add an expert info here ... */
      break;
    }
    for (i= 0; i < opt_ie_cnt; i++) {
      proto_tree *psd_tree;
      psd_tree = proto_tree_add_subtree_format(tree, tvb, offset, 1,
                                               ett_tpe_psd, NULL,
                                               "20 MHz Channel #%u", i);
      proto_tree_add_item(psd_tree, hf_ieee80211_vht_tpe_psd,
                          tvb, offset, 1, ENC_NA);
      offset += 1;
    }
  } else {
    /* Power Constraint info is mandatory only for 20MHz, others are optional*/
    /* Power is expressed in terms of 0.5dBm from -64 to 63 and is encoded
     * as 8-bit 2's compliment */
    for (i = 0; i <= opt_ie_cnt; i++) {
      switch(i) {
      case 0:
        proto_tree_add_item(tree, hf_ieee80211_vht_tpe_pwr_constr_20, tvb, offset, 1, ENC_NA);
        offset += 1;
        break;
      case 1:
        proto_tree_add_item(tree, hf_ieee80211_vht_tpe_pwr_constr_40, tvb, offset, 1, ENC_NA);
        offset += 1;
        break;
      case 2:
        proto_tree_add_item(tree, hf_ieee80211_vht_tpe_pwr_constr_80, tvb, offset, 1, ENC_NA);
        offset += 1;
        break;
      case 3:
        proto_tree_add_item(tree, hf_ieee80211_vht_tpe_pwr_constr_160, tvb, offset, 1, ENC_NA);
        offset += 1;
        break;
      default:
        expert_add_info(pinfo, ti, &ei_ieee80211_vht_tpe_pwr_info_count);
        offset += 1;
        break;
      }
    }
  }

  return offset;
}

static int
dissect_mobility_domain(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if (field_data->sanity_check != NULL) {
    field_data->sanity_check->association_has_mobility_domain_element = true;
  }

  if (tag_len < 3) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                          "MDIE content length must be at least 3 bytes");
    return 1;
  }

  save_proto_data(tvb, pinfo, offset, 2, MDID_KEY);
  proto_tree_add_item(tree, hf_ieee80211_tag_mobility_domain_mdid,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  proto_tree_add_bitmask_with_flags(tree, tvb, offset + 2,
                                    hf_ieee80211_tag_mobility_domain_ft_capab,
                                    ett_tag_mobility_domain_ft_capab_tree,
                                    ieee80211_tag_mobility_domain_ft_capab_fields,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  return tvb_captured_length(tvb);
}

static uint16_t get_mic_len_owe(uint16_t group) {
  switch(group) {
    // FFC, len(p) <= 2048
    case 1:
    case 2:
    case 5:
    case 14:
    case 22:
    case 23:
    case 24:
    // ECC, len(p) <= 256
    case 19:
    case 25:
    case 26:
    case 27:
    case 28:
    case 31:
      // HMAC-SHA-256
      return 16;

    // FFC, 2048 < len(p) <= 3072
    case 15:
    // ECC, 256 < len(p) <= 384
    case 20:
    case 29:
      // HMAC-SHA-384
      return 24;

    // FCC, 3072 < len(p)
    case 16:
    case 17:
    case 18:
    // ECC, 384 < len(p)
    case 21:
    case 30:
    case 32:
      // HMAC-SHA-512
      return 32;

    default:
      return 16;
  }
}

static uint16_t get_mic_len(uint32_t akm_suite) {
  switch(akm_suite) {
    case AKMS_WPA_SHA384_SUITEB:
    case AKMS_FT_IEEE802_1X_SHA384:
    case AKMS_FT_FILS_SHA384:
      // HMAC-SHA-384
      return 24;

    case AKMS_FILS_SHA256:
    case AKMS_FILS_SHA384:
      // AES-SIV-256 and AES-SIV-512
      return 0;

    default:
      // HMAC-SHA-1-128, AES-128-CMAC, HMAC-SHA-256, AKMS_FT_FILS_SHA256
      return 16;
  }
}

static conversation_t *find_wlan_conversation_pinfo(packet_info *pinfo)
{
  /* HACK to avoid collision with conversation in EAP dissector */
  pinfo->srcport = GPOINTER_TO_UINT(
    p_get_proto_data(wmem_file_scope(), pinfo, proto_wlan, ASSOC_COUNTER_KEY));
  pinfo->destport = pinfo->srcport;
  return find_conversation_pinfo(pinfo, 0);
}

static bool determine_nonce_is_set(tvbuff_t *tvb) {
  int offset;

  for (offset = 12; offset < 12 + 32; offset++)
    if (tvb_get_uint8(tvb, offset))
      return true;
  return false;
}

static uint16_t determine_mic_len(packet_info *pinfo, bool assoc_frame,
                                 bool *defaulted) {
  uint16_t eapol_key_mic_len = 16; /* Default MIC length */
  conversation_t *conversation = find_wlan_conversation_pinfo(pinfo);
  ieee80211_conversation_data_t *conversation_data = NULL;
  ieee80211_packet_data_t *packet_data =
    (ieee80211_packet_data_t*)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, PACKET_DATA_KEY);
  if (conversation) {
      conversation_data = (ieee80211_conversation_data_t*)conversation_get_proto_data(conversation, proto_wlan);
  }

  if (wlan_key_mic_len_enable) {
    /* 1st - Use user overridden MIC length setting */
    eapol_key_mic_len = wlan_key_mic_len;
  }
  else if (!assoc_frame && conversation_data &&
           conversation_data->discovered_key_mic_len) {
    /*
     * 2nd - Use the discovered key mic len.
     * We will only set the discovered key mic len if it was defaulted
     * in an earlier call to determine_mic_len, so it should be tested second.
     */
      eapol_key_mic_len = conversation_data->discovered_key_mic_len;
  }
  else if (!assoc_frame && conversation_data &&
           conversation_data->last_akm_suite_set) {
    /* 3rd - Use AKMS negotiated during association to determine MIC length */
    if (conversation_data->last_akm_suite == AKMS_OWE) {
      /* For OWE the length of MIC depends on the selected group */
      eapol_key_mic_len = get_mic_len_owe(conversation_data->owe_group);
    } else if (conversation_data->last_akm_suite == AKMS_SAE_GROUP_DEPEND ||
               conversation_data->last_akm_suite == AKMS_FT_SAE_GROUP_DEPEND) {
      *defaulted = true;
    }
    else {
      eapol_key_mic_len = get_mic_len(conversation_data->last_akm_suite);
    }
  }
  else if (packet_data && packet_data->last_akm_suite_set) {
    /* 3rd - Use AKMS from current packet to determine MIC length */
    if (packet_data->last_akm_suite == AKMS_OWE) {
      /* For OWE the length of MIC depends on the selected group */
      eapol_key_mic_len = get_mic_len_owe(packet_data->owe_group);
    } else if (packet_data->last_akm_suite == AKMS_SAE_GROUP_DEPEND ||
               packet_data->last_akm_suite == AKMS_FT_SAE_GROUP_DEPEND) {
      *defaulted = true;
    }
    else {
      eapol_key_mic_len = get_mic_len(packet_data->last_akm_suite);
    }
  } else {
    /*
     * We used the default so say so.
     */
    *defaulted = true;
  }
  return eapol_key_mic_len;
}

static int
dissect_fast_bss_transition(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  bool assoc_frame = field_data->sanity_check != NULL;
  int offset = 0;
  if (tag_len < 82) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                          "FTIE content length must be at least 82 bytes");
    return 1;
  }

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_ft_mic_control,
                                    ett_tag_ft_mic_control_tree,
                                    ieee80211_tag_ft_mic_control_fields,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;

  bool defaulted_mic_len = false;
  int mic_len = determine_mic_len(pinfo, assoc_frame, &defaulted_mic_len);
  save_proto_data(tvb, pinfo, offset, mic_len, FTE_MIC_KEY);
  save_proto_data_value(pinfo, mic_len, FTE_MIC_LEN_KEY);
  proto_tree_add_item(tree, hf_ieee80211_tag_ft_mic,
                      tvb, offset, mic_len, ENC_NA);
  offset += mic_len;

  save_proto_data(tvb, pinfo, offset, 32, FTE_ANONCE_KEY);
  proto_tree_add_item(tree, hf_ieee80211_tag_ft_anonce,
                      tvb, offset, 32, ENC_NA);
  offset += 32;

  save_proto_data(tvb, pinfo, offset, 32, FTE_SNONCE_KEY);
  proto_tree_add_item(tree, hf_ieee80211_tag_ft_snonce,
                      tvb, offset, 32, ENC_NA);
  offset += 32;

  while (offset + 2 <= tag_len) {
    uint8_t id, len;
    int s_end;
    proto_item *ti;
    proto_tree *subtree;
    const char *subtree_name;
    proto_keydata_t *proto;

    id = tvb_get_uint8(tvb, offset);
    len = tvb_get_uint8(tvb, offset + 1);
    subtree_name = val_to_str_const(id, ft_subelem_id_vals, "Unknown");
    subtree = proto_tree_add_subtree_format(tree, tvb, offset, len + 2,
                                            ett_tag_ft_subelem_tree, NULL,
                                            "Subelement: %s", subtree_name);

    proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_id,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    ti = proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_len,
                             tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    if (offset + len > tag_len) {
      expert_add_info_format(pinfo, ti, &ei_ieee80211_tag_length,
                            "FTIE subelement length is too large for the FTIE content length");
      return offset;
    }

    s_end = offset + len;
    switch (id) {
    case 1:
      save_proto_data(tvb, pinfo, offset, len, FTE_R1KH_ID_KEY);
      save_proto_data_value(pinfo, len, FTE_R1KH_ID_LEN_KEY);
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_r1kh_id,
                          tvb, offset, len, ENC_NA);
      break;
    case 2:
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_gtk_key_info,
                          tvb, offset, 2, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_gtk_key_id,
                          tvb, offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
      if (offset > s_end)
        break;
      save_proto_data_value(pinfo, tvb_get_uint8(tvb, offset), GTK_SUBELEM_KEY_LEN_KEY);
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_gtk_key_length,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      offset += 1;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_gtk_rsc,
                          tvb, offset, 8, ENC_NA);
      offset += 8;
      if (offset > s_end)
        break;
      save_proto_data_value(pinfo, s_end - offset, GTK_LEN_KEY);
      save_proto_data(tvb, pinfo, offset, s_end - offset, GTK_KEY);

      proto = (proto_keydata_t *)
        p_get_proto_data(wmem_file_scope(), pinfo, proto_wlan, DECRYPTED_GTK_KEY);
      if (proto) {
        unsigned keydata_len = proto->keydata_len;
        tvbuff_t *next_tvb = tvb_new_child_real_data(tvb, proto->keydata,
                                                    keydata_len, keydata_len);
        add_new_data_source(pinfo, next_tvb, "Decrypted GTK");
        proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_gtk_key,
                            next_tvb, 0, keydata_len, ENC_NA);
        add_ptk_analysis(tvb, subtree, &proto->used_key);
      } else {
        proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_gtk_key_encrypted,
                            tvb, offset, s_end - offset, ENC_NA);
      }
      break;
    case 3:
      save_proto_data(tvb, pinfo, offset, len, FTE_R0KH_ID_KEY);
      save_proto_data_value(pinfo, len, FTE_R0KH_ID_LEN_KEY);
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_r0kh_id,
                          tvb, offset, len, ENC_NA);
      break;
    case 4:
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_igtk_key_id,
                          tvb, offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_igtk_ipn,
                          tvb, offset, 6, ENC_NA);
      offset += 6;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_igtk_key_length,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      offset += 1;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_igtk_key,
                          tvb, offset, 24, ENC_NA);
      break;
    case 5:
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_oci_op_class,
                          tvb, offset, 1, ENC_NA);
      offset += 1;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_oci_prim_chan_num,
                          tvb, offset, 1, ENC_NA);
      offset += 1;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_oci_freq_seg_1,
                          tvb, offset, 1, ENC_NA);
      offset += 1;
      if (offset >= s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_oci_oct_op_class,
                          tvb, offset, 1, ENC_NA);
      offset += 1;
      if (offset >= s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_oci_oct_prim_chan_num,
                          tvb, offset, 1, ENC_NA);
      offset += 1;
      if (offset >= s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_oci_oct_freq_seg_1,
                          tvb, offset, 1, ENC_NA);
      break;
    case 6:
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_bigtk_key_id,
                          tvb, offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_bigtk_bipn,
                          tvb, offset, 6, ENC_NA);
      offset += 6;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_bigtk_key_length,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      offset += 1;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_bigtk_key,
                          tvb, offset, s_end - offset, ENC_NA);
      break;
    case 8: /* MLO GTK */
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_gtk_key_info,
                          tvb, offset, 2, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_gtk_key_id,
                          tvb, offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_gtk_link_id_info,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_gtk_link_id,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      offset += 1;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_gtk_key_length,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      offset += 1;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_gtk_rsc,
                          tvb, offset, 8, ENC_NA);
      offset += 8;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_gtk_key,
                          tvb, offset, s_end - offset, ENC_NA);
      break;
    case 9: /* MLO IGTK */
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_igtk_key_id,
                          tvb, offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_igtk_ipn,
                          tvb, offset, 6, ENC_NA);
      offset += 6;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_igtk_link_id_info,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_igtk_link_id,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      offset += 1;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_igtk_key_length,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      offset += 1;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_igtk_key,
                          tvb, offset, s_end - offset, ENC_NA);
      break;
    case 10: /* MLO BIGTK */
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_bigtk_key_id,
                          tvb, offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_bigtk_bipn,
                          tvb, offset, 6, ENC_NA);
      offset += 6;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_bigtk_link_id_info,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_bigtk_link_id,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      offset += 1;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_bigtk_key_length,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      offset += 1;
      if (offset > s_end)
        break;
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_mlo_bigtk_key,
                          tvb, offset, s_end - offset, ENC_NA);
      break;
    default:
      proto_tree_add_item(subtree, hf_ieee80211_tag_ft_subelem_data,
                          tvb, offset, len, ENC_NA);
      break;
    }
    offset = s_end;
  }

  return tvb_captured_length(tvb);
}

static int
dissect_mmie(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if (tag_len < 16) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                          "MMIE content length must be at least 16 bytes");
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_mmie_keyid, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tree, hf_ieee80211_tag_mmie_ipn, tvb, offset + 2, 6,
                      ENC_NA);
  proto_tree_add_item(tree, hf_ieee80211_tag_mmie_mic, tvb, offset + 8, 8,
                      ENC_NA);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_dmg_capabilities(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data);

static int
dissect_no_bssid_capability(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  int offset = 0;

  static int * const ieee80211_tag_no_bssid_capability_dmg_bss_control[] = {
    &hf_ieee80211_tag_no_bssid_capability_dmg_bss_control_type,
    &hf_ieee80211_tag_no_bssid_capability_dmg_bss_control_reserved,
    NULL
  };

  add_ff_cap_info(tree, tvb, pinfo, offset);
  offset += 2;
  tag_len -= 2;

  /* On nontransmitted BSSID, there is only DMG Capability Info */
  if (tag_len) {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_no_bssid_capability_dmg_bss_control,
                                      ett_tag_no_bssid_capability_dmg_bss_control_tree,
                                      ieee80211_tag_no_bssid_capability_dmg_bss_control,
                                      ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    /* offset += 1; */

    ieee80211_tag_dmg_capabilities(tvb, pinfo, tree, data);
  }

  return tvb_captured_length(tvb);
}

static int
dissect_ssid_list(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int tag_len = tvb_reported_length(tvb);
  int offset = 0;
  proto_tree *entry;
  bool first = true;

  while (offset + 1 <= tag_len) {
    uint8_t len = tvb_get_uint8(tvb, offset + 1);
    uint8_t *str;

    if (offset + 2 + len > tag_len)
      break;

    str = tvb_format_text(pinfo->pool, tvb, offset + 2, len);
    proto_item_append_text(tree, "%c %s", (first ? ':' : ','), str);
    first = false;
    entry = proto_tree_add_subtree_format(tree, tvb, offset, 2 + len, ett_ssid_list, NULL, "SSID: %s", str);
    proto_tree_add_item(entry, hf_ieee80211_tag_number, tvb, offset, 1,
                        ENC_LITTLE_ENDIAN);
    offset++;
    proto_tree_add_uint(entry, hf_ieee80211_tag_length, tvb, offset, 1, len);
    offset++;
    /* XXX: IEEE 802.11-2020 seems to say that these SSIDs are also affected
     * by the UTF-8 Encoding bit in the Extended Capabilities element
     * (though at least SSID List comes after Extended Capabilities).
     */
    proto_tree_add_item(entry, hf_ieee80211_tag_ssid, tvb, offset, len,
                        ENC_NA);
    offset += len;
  }

  return tvb_captured_length(tvb);
}

static int
dissect_multiple_bssid_index(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int tag_len = tvb_reported_length(tvb);
  int offset = 0;

  proto_tree_add_item(tree, hf_ieee80211_tag_multiple_bssid_index_bssid_index, tvb, offset, 1, ENC_NA);
  offset += 1;
  tag_len -= 1;

  if (tag_len) {
    proto_tree_add_item(tree, hf_ieee80211_tag_multiple_bssid_index_dtim_period, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(tree, hf_ieee80211_tag_multiple_bssid_index_dtim_count, tvb, offset, 1, ENC_NA);
    offset += 1;
  }

  return offset;
}

static int
dissect_link_identifier(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if (tag_len < 18) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                          "Link Identifier content length must be at least "
                          "18 bytes");
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_link_id_bssid, tvb,
                      offset, 6, ENC_NA);
  proto_tree_add_item(tree, hf_ieee80211_tag_link_id_init_sta, tvb,
                      offset + 6, 6, ENC_NA);
  proto_tree_add_item(tree, hf_ieee80211_tag_link_id_resp_sta, tvb,
                      offset + 12, 6, ENC_NA);
  return tvb_captured_length(tvb);
}

static int
dissect_wakeup_schedule(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if (tag_len < 18) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                          "Wakeup Schedule content length must be at least "
                          "18 bytes");
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_wakeup_schedule_offset, tvb,
                      offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_tag_wakeup_schedule_interval, tvb,
                      offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree,
                      hf_ieee80211_tag_wakeup_schedule_awake_window_slots, tvb,
                      offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_tag_wakeup_schedule_max_awake_dur,
                      tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_tag_wakeup_schedule_idle_count, tvb,
                      offset, 2, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

static int
dissect_channel_switch_timing(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if (tag_len < 4) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                          "Channel Switch Timing content length must be at "
                          "least 4 bytes");
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_channel_switch_timing_switch_time,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree,
                      hf_ieee80211_tag_channel_switch_timing_switch_timeout,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

static int
dissect_pti_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if (tag_len < 3) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "PTI Control content length must be at least 3 bytes");
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_pti_control_tid, tvb,
                      offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_tag_pti_control_sequence_control, tvb,
                      offset, 2, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

static int
dissect_pu_buffer_status(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  static int * const ieee80211_pu_buffer_status[] = {
    &hf_ieee80211_tag_pu_buffer_status_ac_bk,
    &hf_ieee80211_tag_pu_buffer_status_ac_be,
    &hf_ieee80211_tag_pu_buffer_status_ac_vi,
    &hf_ieee80211_tag_pu_buffer_status_ac_vo,
    NULL
  };

  if (tag_len < 1) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "PU Buffer Status content length must be at least 1 byte");
    return tvb_captured_length(tvb);
  }

  proto_tree_add_bitmask_list(tree, tvb, offset, 1, ieee80211_pu_buffer_status, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

static int
dissect_timeout_interval(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
  int tag_len = tvb_reported_length(tvb);
  int offset = 0;
  proto_item *pi;

  pi = proto_tree_add_item(tree, hf_ieee80211_tag_timeout_int_type, tvb,
                           offset, 1, ENC_LITTLE_ENDIAN);
  if (tag_len < 5) {
    expert_add_info_format(pinfo, pi, &ei_ieee80211_tag_length,
                           "Timeout Interval content length must be at least "
                          "5 bytes");
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_timeout_int_value, tvb,
                      offset + 1, 4, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

static int
dissect_ric_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  proto_tree  *sub_tree;
  uint8_t      desc_cnt = 0;
  uint32_t     next_ie;
  int          offset_r = 0;
  const uint8_t ids[] = { TAG_RIC_DESCRIPTOR };

  if (tag_len != 4)  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "RIC Data Length must be 4 bytes");
    return 0;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_ric_data_id, tvb,
                           offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  desc_cnt = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_tag_ric_data_desc_cnt, tvb,
                           offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_tag_ric_data_status_code, tvb,
                           offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  /* Our Design is such that all the Resource request IE's part of the RIC
   * must be in the sub tree of RIC for better readability
   * Even omnipeek does the same way.
   */
  sub_tree = proto_item_add_subtree(tree, ett_tag_ric_data_desc_ie);

  proto_item_append_text(field_data->item_tag, " :Resource Descriptor List");
  if (desc_cnt == 0) {
    proto_item_append_text(field_data->item_tag, " :0 (Weird?)");
  }

  while ( desc_cnt != 0 ) {

    next_ie = tvb_get_uint8(tvb, offset);
    proto_item_append_text(field_data->item_tag, " :(%d:%s)", desc_cnt, val_to_str_ext(next_ie, &tag_num_vals_ext, "Reserved (%d)"));
    /* Recursive call to avoid duplication of code*/
    offset_r = add_tagged_field(pinfo, sub_tree, tvb, offset, field_data->ftype, ids, G_N_ELEMENTS(ids), NULL);
    if (offset_r == 0 )/* should never happen, returns a min of 2*/
      break;
    /* This will ensure that the IE after RIC is processed
     * only once. This gives us a good looking RIC IE :-)
     */
    tag_len += offset_r;
    desc_cnt--;
  }

  return tvb_captured_length(tvb);
}

/* Overlapping BSS Scan Parameters (74) */
static int
dissect_overlap_bss_scan_par(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int offset = 0;
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int tag_len = tvb_reported_length(tvb);

  if (tag_len != 14)  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "OBSS Length must be 14 bytes");
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_obss_spd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_tag_obss_sad, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_tag_obss_cwtsi, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_tag_obss_sptpc, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_tag_obss_satpc, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_tag_obss_wctdf, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_tag_obss_sat, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  return offset;
}

/* RIC Descriptor (75) */
static int
dissect_ric_descriptor(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int offset = 0;
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int tag_len = tvb_reported_length(tvb);
  uint8_t      rsrc_type = 0;

  if (tag_len < 1)  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "RIC Data Length must be at least 1 byte");
    return 1;
  }

  rsrc_type = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_tag_ric_desc_rsrc_type, tvb,
                           offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  if (rsrc_type == 1) {
    /* Block ACK params
     * 802.11-2012: 8.4.2.53 RIC Descriptor element
     * Block Ack parameter set as defined in 8.4.1.14,
     * Block Ack timeout value as defined in 8.4.1.15, and
     * Block Ack starting sequence control as defined in 8.3.1.8
     */
    /* TODO: Still figuring out how to parse these ones,
     * need a sample capture with at least HEX Dump
     */
    proto_item_append_text(field_data->item_tag, " : Block ACK Params");
    proto_tree_add_item(tree, hf_ieee80211_tag_ric_desc_var_params, tvb,
                        offset, tag_len-1, ENC_NA);
    offset += tag_len -1;
  }else {
    /* 0, 2-255 are reserved*/
    proto_item_append_text(field_data->item_tag, " :Reserved (type != 1)");
  }

  return offset;
}

static int
dissect_ext_bss_load(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  proto_tree_add_item(tree, hf_ieee80211_ext_bss_mu_mimo_capable_sta_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;
  proto_tree_add_item(tree, hf_ieee80211_ext_bss_ss_underutilization, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_ext_bss_observable_sec_20mhz_utilization, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_ext_bss_observable_sec_40mhz_utilization, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_ext_bss_observable_sec_80mhz_utilization, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  return offset;
}

static int
dissect_wide_bw_channel_switch(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;

  proto_tree_add_item(tree, hf_ieee80211_wide_bw_new_channel_width, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_wide_bw_new_channel_center_freq_segment0, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_wide_bw_new_channel_center_freq_segment1, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  return offset;
}

static int
dissect_channel_switch_wrapper(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int tag_len = tvb_reported_length(tvb);
  int offset = 0;
  int tmp_sublen;
  const uint8_t ids[] = { TAG_COUNTRY_INFO, TAG_WIDE_BW_CHANNEL_SWITCH,
    TAG_TX_PWR_ENVELOPE };
  const uint8_t ext_ids[] = {ETAG_BANDWIDTH_INDICATION};

  /*
  Decode three subelement in IE-196(Channel Switch Wrapper element):
        (1) New Country subelement
        (2) Wide Bandwidth Channel Switch subelement
        (3) New VHT Transmit Power Envelope subelement
        (4) Bandwidth Indication subelement
  */
  while (tag_len > 0){
    tmp_sublen = tvb_get_uint8(tvb, offset + 1);
    if (add_tagged_field_with_validation(pinfo, tree, tvb, offset, 0, ids,
        G_N_ELEMENTS(ids), false, ext_ids, G_N_ELEMENTS(ext_ids), false, NULL) == 0) {
      break;
    }
    tag_len -= (tmp_sublen + 2);
    offset += (tmp_sublen + 2);
  }
  return offset;
}

static int
dissect_operating_mode_notification(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  static int * const ieee80211_operat_mode_field[] = {
    &hf_ieee80211_operat_mode_field_channel_width,
    &hf_ieee80211_operat_mode_field_reserved,
    &hf_ieee80211_operat_mode_field_rxnss,
    &hf_ieee80211_operat_mode_field_rxnsstype,
    NULL
  };

  /* Operating Mode field */
  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_operat_notification_mode,
                                    ett_mcsbit_tree, ieee80211_operat_mode_field,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;
  return offset;
}

static const range_string tbtt_info_length[] = {
  { 0, 0, "Reserved" },
  { 1, 1, "Neighbor AP TBTT Offset subfield" },
  { 2, 2, "Neighbor AP TBTT Offset subfield and the BSS Parameters subfield" },
  { 3, 4, "Reserved" },
  { 5, 5, "Neighbor AP TBTT Offset subfield and the Short-SSID subfield" },
  { 6, 6, "Neighbor AP TBTT offset subfield, the Short SSID subfield and the BSS Parameters subfield" },
  { 7, 7, "Neighbor AP TBTT Offset subfield and the BSSID subfield" },
  { 8, 8, "Neighbor AP TBTT Offset subfield, the BSSID subfield and the BSS Parameters subfield" },
  { 9, 9, "Neighbor AP TBTT Offset subfield, the BSSID subfield, the BSS Parameters subfield and the 20 MHz PSD subfield" },
  { 10, 10, "Reserved" },
  { 11, 11, "Neighbor AP TBTT Offset subfield, the BSSID subfield and the Short-SSID subfield" },
  { 12, 12, "Neighbor AP TBTT Offset subfield, the BSSID subfield, the Short SSID subfield and the BSS Parameters subfield" },
  { 13, 13, "Neighbor AP TBTT Offset subfield, the BSSID subfield, the Short SSID subfield, the BSS Parameters subfield and the 20 MHz PSD subfield" },
  { 14, 15, "Reserved" },
  { 16, 16, "Neighbor AP TBTT Offset subfield, the BSSID subfield, the Short SSID subfield, the BSS Parameters subfield, the 20 MHz PSD subfield and the MLD Parameters subfield" },
  { 17, 255, "First 16 octets contain Neighbor AP TBTT Offset, the BSSID, the Short SSID, the BSS Parameters, the 20 MHz PSD and the MLD Parameters subfield. The remaining octets are reserved"},
  { 0, 0, NULL }
};

static int * const bss_params_headers[] = {
  &hf_ieee80211_rnr_oct_recommended,
  &hf_ieee80211_rnr_same_ssid,
  &hf_ieee80211_rnr_multiple_bssid,
  &hf_ieee80211_rnr_transmitted_bssid,
  &hf_ieee80211_rnr_ess_with_colocated_ap,
  &hf_ieee80211_rnr_unsolicited_probe_responses,
  &hf_ieee80211_rnr_same_colocated_ap,
  &hf_ieee80211_rnr_same_reserved,
  NULL
};

static int * const mld_params_headers[] = {
  &hf_ieee80211_rnr_mld_id,
  &hf_ieee80211_rnr_mld_link_id,
  &hf_ieee80211_rnr_mld_bss_params_change_count,
  &hf_ieee80211_rnr_mld_all_updates_included,
  &hf_ieee80211_rnr_mld_disabled_link_indication,
  &hf_ieee80211_rnr_mld_reserved,
  NULL
};

static int
dissect_neighbor_ap_info(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,
                         int offset)
{
  uint16_t tbtt_info_h;
  uint16_t tbtt_info_len;
  uint16_t tbtt_info_count;
  uint16_t len_remain = 0;
  int i = 0;
  bool display_tbtt_offset = false;
  bool display_bssid_subfield = false;
  bool display_short_bssid_subfield = false;
  bool display_bss_parameters_subfield = false;
  bool display_20mhz_psd_subfield = false;
  bool display_mld_params_subfield = false;
  bool display_reserved = false;

  proto_item *item;
  proto_tree *query;

  tbtt_info_h = tvb_get_uint16(tvb, offset, ENC_LITTLE_ENDIAN);
  tbtt_info_len = TBTT_INFO_LENGTH(tbtt_info_h);
  tbtt_info_count = TBTT_INFO_COUNT(tbtt_info_h);
  switch(tbtt_info_len) {
  case 0: case 3: case 4: case 10: case 14: case 15:
    /* Reserved cases */
    display_reserved = true;
    len_remain = tbtt_info_len;
    break;
  case 1:
    display_tbtt_offset = true;
    break;
  case 2:
    display_tbtt_offset = true;
    display_bss_parameters_subfield = true;
    break;
  case 5:
    display_tbtt_offset = true;
    display_short_bssid_subfield = true;
    break;
  case 6:
    display_tbtt_offset = true;
    display_short_bssid_subfield = true;
    display_bss_parameters_subfield = true;
    break;
  case 7:
    display_tbtt_offset = true;
    display_bssid_subfield = true;
    break;
  case 8:
    display_tbtt_offset = true;
    display_bssid_subfield = true;
    display_bss_parameters_subfield = true;
    break;
  case 9:
    display_tbtt_offset = true;
    display_bssid_subfield = true;
    display_bss_parameters_subfield = true;
    display_20mhz_psd_subfield = true;
    break;
  case 11:
    display_tbtt_offset = true;
    display_bssid_subfield = true;
    display_short_bssid_subfield = true;
    break;
  case 12:
    display_tbtt_offset = true;
    display_bssid_subfield = true;
    display_short_bssid_subfield = true;
    display_bss_parameters_subfield = true;
    break;
  case 13:
    display_tbtt_offset = true;
    display_bssid_subfield = true;
    display_short_bssid_subfield = true;
    display_bss_parameters_subfield = true;
    display_20mhz_psd_subfield = true;
    break;
  case 16: /* EHT stuff */
    display_tbtt_offset = true;
    display_bssid_subfield = true;
    display_short_bssid_subfield = true;
    display_bss_parameters_subfield = true;
    display_20mhz_psd_subfield = true;
    display_mld_params_subfield = true;
    break;
  default: /* 17- 255: Same as 16 but the remaining bytes are reserved. */
    display_tbtt_offset = true;
    display_bssid_subfield = true;
    display_short_bssid_subfield = true;
    display_bss_parameters_subfield = true;
    display_20mhz_psd_subfield = true;
    display_mld_params_subfield = true;
    display_reserved = true;
    len_remain = tbtt_info_len - 16;
    break;
  }

  proto_tree_add_item(tree, hf_ieee80211_tbtt_info, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tree, hf_ieee80211_tbtt_filtered_nap, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  item = proto_tree_add_item(tree, hf_ieee80211_tbtt_info_count, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tree, hf_ieee80211_tbtt_info_length, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  offset+=2;

  proto_tree_add_item(tree, hf_ieee80211_tbtt_operating_class, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset+=1;
  proto_tree_add_item(tree, hf_ieee80211_tbtt_channel_number, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset+=1;

  for (i=0; i < tbtt_info_count + 1; i++) {
    query = proto_tree_add_subtree(tree, tvb, offset, tbtt_info_len,
                                  ett_tbtt_infos, &item, "TBTT Information");

    if (display_tbtt_offset) {
      proto_tree_add_item(query, hf_ieee80211_tbtt_offset, tvb, offset, 1, ENC_LITTLE_ENDIAN);
      offset+=1;
    }
    if (display_bssid_subfield) {
      proto_tree_add_item(query, hf_ieee80211_tbtt_bssid, tvb, offset, 6, ENC_NA);
      offset+=6;
    }
    if (display_short_bssid_subfield) {
      proto_tree_add_item(query, hf_ieee80211_tbtt_short_ssid, tvb, offset, 4, ENC_LITTLE_ENDIAN);
      offset+=4;
    }
    if (display_bss_parameters_subfield) {

      proto_tree_add_bitmask_with_flags(query, tvb, offset,
                                        hf_ieee80211_rnr_bss_params,
                                        ett_rnr_bss_params_tree,
                                        bss_params_headers,
                                        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
      offset += 1;
    }
    if (display_20mhz_psd_subfield) {
      proto_tree_add_item(query, hf_ieee80211_rnr_20mhz_psd_subfield, tvb,
                          offset, 1, ENC_NA);
      offset += 1;
    }
    if (display_mld_params_subfield) {

      proto_tree_add_bitmask_with_flags(query, tvb, offset,
                                        hf_ieee80211_rnr_mld_params,
                                        ett_rnr_mld_params_tree,
                                        mld_params_headers,
                                        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
      offset += 3;
    }
    if (display_reserved) {
        proto_tree_add_item(query, hf_ieee80211_rnr_reserved_data, tvb, offset,
                            len_remain, ENC_NA);
    }

    offset += len_remain;
  }

  return offset;
}

static int
dissect_reduced_neighbor_report(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;

  while (tvb_reported_length_remaining(tvb, offset)) {
    int start_offset;
    proto_tree *neighbor_ap_info = NULL;
    proto_item *naii = NULL;

    start_offset = offset;
    neighbor_ap_info = proto_tree_add_subtree(tree, tvb, offset, -1,
                                              ett_neighbor_ap_info, &naii,
                                              "Neighbor AP Information");
    offset = dissect_neighbor_ap_info(tvb, pinfo, neighbor_ap_info, offset);

    proto_item_set_len(naii, offset - start_offset);
  }

  return tvb_reported_length(tvb);
}

static const value_string s1g_supported_channel_width_vals[] = {
  { 0, "STA supports 1MHz and 2MHz operation" },
  { 1, "STA supports 1MHz, 2MHz and 4MHz operation" },
  { 2, "STA supports 1MHz, 2MHz, 4MHz and 8MHz operation" },
  { 3, "STA supports 1MHz, 2MHz, 4MHz, 8MHz and 16MHz operation" },
  { 0, NULL }
};

static const value_string s1g_traveling_pilot_support_vals[] = {
  { 0, "Traveling Pilot Support not activated" },
  { 1, "Traveling Pilot Support activated for only one space-time stream" },
  { 2, "Reserved" },
  { 3, "Traveling Pilot Support activated for one and two space-time streams" },
  { 0, NULL }
};

static const value_string s1g_max_mpdu_length_vals[] = {
  { 0, "3895" },
  { 1, "7991" },
  { 0, NULL }
};

static const value_string s1g_min_mpdu_start_spacing_vals[] = {
  { 0, "No restriction" },
  { 1, "1/4 uS" },
  { 2, "1/2 uS" },
  { 3, "1 uS" },
  { 4, "2 uS" },
  { 5, "4 uS" },
  { 6, "8 uS" },
  { 7, "16 uS" },
  { 0, NULL }
};

static const value_string s1g_sta_type_support_vals[] = {
  { 0, "AP-Only. Supports sensor and non-sensor STAs." },
  { 1, "AP supports only sensor STAs. STA is a sensor STA." },
  { 2, "AP supports only non-sensor STAs. STA is a non-sensor STA" },
  { 3, "Reserved" },
  { 0, NULL }
};

static const value_string s1g_sectorized_beam_capable_vals[] = {
  { 0, "AP or non-AP: Not supported" },
  { 1, "AP: TXOP-based sectorization only. Non-AP: Both group and TXOP" },
  { 2, "AP: Group sectorization only. Non-AP: Reserved" },
  { 3, "AP: Both group and TXOP sectorization. Non-AP: Reserved" },
  { 0, NULL }
};

static const value_string s1g_vht_link_adaptation_vals[] = {
  { 0, "STA does not provide VHT MFB" },
  { 1, "Reserved" },
  { 2, "STA can only provide unsolicited VHT MFB" },
  { 3, "STA can provide unsolicited and solicited VHT MFB" },
  { 0, NULL }
};

#if 0
static const value_string s1g_mcs_map[] = {
  { 0, "Support for S1G-MCS 2 for n spatial streams" },
  { 1, "Support for S1G-MCS 7 for n spatial streamS" },
  { 2, "Support for S1G-MCS 9 for n spatial streams" },
  { 3, "n spatial streams not supported" },
  { 0, NULL }
};
#endif

static int * const ieee80211_s1g_cap_byte1[] = {
  &hf_ieee80211_s1g_cap_s1g_long_support,
  &hf_ieee80211_s1g_cap_short_gi_for_1_mhz,
  &hf_ieee80211_s1g_cap_short_gi_for_2_mhz,
  &hf_ieee80211_s1g_cap_short_gi_for_4_mhz,
  &hf_ieee80211_s1g_cap_short_gi_for_8_mhz,
  &hf_ieee80211_s1g_cap_short_gi_for_16_mhz,
  &hf_ieee80211_s1g_cap_supported_channel_width,
  NULL
};

static int * const ieee80211_s1g_cap_byte2[] = {
  &hf_ieee80211_s1g_cap_rx_lpdc,
  &hf_ieee80211_s1g_cap_tx_stbc,
  &hf_ieee80211_s1g_cap_rx_stbc,
  &hf_ieee80211_s1g_cap_su_beamformer_capable,
  &hf_ieee80211_s1g_cap_su_beamformee_capable,
  &hf_ieee80211_s1g_cap_beamformee_sts_capability, /* Needs global */
  NULL
};

static int * const ieee80211_s1g_cap_byte3[] = {
  &hf_ieee80211_s1g_cap_number_sounding_dimensions,
  &hf_ieee80211_s1g_cap_mu_beamformer_capable,
  &hf_ieee80211_s1g_cap_mu_beamformee_capable,
  &hf_ieee80211_s1g_cap_htc_vht_capable,
  &hf_ieee80211_s1g_cap_travelling_pilot_support,
  NULL
};

static int * const ieee80211_s1g_cap_byte4[] = {
  &hf_ieee80211_s1g_cap_rd_responder,
  &hf_ieee80211_s1g_cap_ht_delayed_block_ack,
  &hf_ieee80211_s1g_cap_maximum_mpdu_length,
  &hf_ieee80211_s1g_cap_maximum_a_mpdu_length_exp,
  &hf_ieee80211_s1g_cap_minimum_mpdu_start_spacing,
  NULL
};

static int * const ieee80211_s1g_cap_byte5[] = {
  &hf_ieee80211_s1g_cap_uplink_sync_capable,
  &hf_ieee80211_s1g_cap_dynamic_aid,
  &hf_ieee80211_s1g_cap_bat_support,
  &hf_ieee80211_s1g_cap_tim_ade_support,
  &hf_ieee80211_s1g_cap_non_tim_support,
  &hf_ieee80211_s1g_cap_group_aid_support,
  &hf_ieee80211_s1g_cap_sta_type_support,
  NULL
};

static int * const ieee80211_s1g_cap_byte6[] = {
  &hf_ieee80211_s1g_cap_centralized_authentication_control,
  &hf_ieee80211_s1g_cap_distributed_authentication_control,
  &hf_ieee80211_s1g_cap_a_msdu_support,
  &hf_ieee80211_s1g_cap_a_mpdu_support,
  &hf_ieee80211_s1g_cap_asymmetic_block_ack_support,
  &hf_ieee80211_s1g_cap_flow_control_support,
  &hf_ieee80211_s1g_cap_sectorized_beam_capable,
  NULL
};

static int * const ieee80211_s1g_cap_byte7[] = {
  &hf_ieee80211_s1g_cap_obss_mitigation_support,
  &hf_ieee80211_s1g_cap_fragment_ba_support,
  &hf_ieee80211_s1g_cap_ndp_ps_poll_supported,
  &hf_ieee80211_s1g_cap_raw_operation_support,
  &hf_ieee80211_s1g_cap_page_slicing_support,
  &hf_ieee80211_s1g_cap_txop_sharing_implicit_ack_support,
  &hf_ieee80211_s1g_cap_vht_link_adaptation_capable,
  NULL
};

static int * const ieee80211_s1g_cap_byte8[] = {
  &hf_ieee80211_s1g_cap_tack_support_as_ps_poll_response,
  &hf_ieee80211_s1g_cap_duplicate_1_mhz_support,
  &hf_ieee80211_s1g_cap_mcs_negotiation_support,
  &hf_ieee80211_s1g_cap_1_mhz_control_response_preamble_support,
  &hf_ieee80211_s1g_cap_ndp_beamforming_report_poll_support,
  &hf_ieee80211_s1g_cap_unsolicited_dynamic_aid,
  &hf_ieee80211_s1g_cap_sector_training_operation_supported,
  &hf_ieee80211_s1g_cap_temporary_ps_mode_switch,
  NULL,
};

static int * const ieee80211_s1g_cap_byte9[] = {
  &hf_ieee80211_s1g_cap_twt_grouping_support,
  &hf_ieee80211_s1g_cap_bdt_capable,
  &hf_ieee80211_s1g_cap_color,
  &hf_ieee80211_s1g_cap_twt_requester_support,
  &hf_ieee80211_s1g_cap_twt_responder_support,
  &hf_ieee80211_s1g_cap_pv1_frame_support,
  NULL
};

static int * const ieee80211_s1g_cap_byte10[] = {
  &hf_ieee80211_s1g_cap_link_adaptation_per_normal_control_response_capable,
  &hf_ieee80211_s1g_cap_reserved,
  NULL
};

static int * const ieee80211_s1g_mcs_and_nss_set[] = {
  &hf_ieee80211_s1g_rx_s1g_mcs_map,
  &hf_ieee80211_s1g_rx_highest_supported_long_gi_data_rate,
  &hf_ieee80211_s1g_tx_s1g_mcs_map,
  &hf_ieee80211_s1g_tx_highest_supported_long_gi_data_rate,
  &hf_ieee80211_s1g_rx_single_spatial_stream_map_for_1_mhz,
  &hf_ieee80211_s1g_tx_single_spatial_stream_map_for_1_mhz,
  &hf_ieee80211_s1g_mcs_and_nss_reserved,
  NULL
};

static int
dissect_s1g_capabilities(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  proto_tree *s1g_cap_info = NULL;
  proto_tree *s1g_caps = NULL;
  proto_tree *sup_mcs_nss_set = NULL;

  s1g_cap_info = proto_tree_add_subtree(tree, tvb, offset, 15,
                                ett_ieee80211_s1g_capabilities_info,
                                NULL, "S1G Capabilities Information");

  s1g_caps = proto_tree_add_subtree(s1g_cap_info, tvb, offset, 10,
                                ett_ieee80211_s1g_capabilities,
                                NULL, "S1G Capabilities");

  proto_tree_add_bitmask_with_flags(s1g_caps, tvb, offset,
                                    hf_ieee80211_s1g_cap_byte1,
                                    ett_s1g_cap_byte1,
                                    ieee80211_s1g_cap_byte1,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  proto_tree_add_bitmask_with_flags(s1g_caps, tvb, offset,
                                    hf_ieee80211_s1g_cap_byte2,
                                    ett_s1g_cap_byte2,
                                    ieee80211_s1g_cap_byte2,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  proto_tree_add_bitmask_with_flags(s1g_caps, tvb, offset,
                                    hf_ieee80211_s1g_cap_byte3,
                                    ett_s1g_cap_byte3,
                                    ieee80211_s1g_cap_byte3,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  proto_tree_add_bitmask_with_flags(s1g_caps, tvb, offset,
                                    hf_ieee80211_s1g_cap_byte4,
                                    ett_s1g_cap_byte4,
                                    ieee80211_s1g_cap_byte4,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  proto_tree_add_bitmask_with_flags(s1g_caps, tvb, offset,
                                    hf_ieee80211_s1g_cap_byte5,
                                    ett_s1g_cap_byte5,
                                    ieee80211_s1g_cap_byte5,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  proto_tree_add_bitmask_with_flags(s1g_caps, tvb, offset,
                                    hf_ieee80211_s1g_cap_byte6,
                                    ett_s1g_cap_byte6,
                                    ieee80211_s1g_cap_byte6,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  proto_tree_add_bitmask_with_flags(s1g_caps, tvb, offset,
                                    hf_ieee80211_s1g_cap_byte7,
                                    ett_s1g_cap_byte7,
                                    ieee80211_s1g_cap_byte7,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  proto_tree_add_bitmask_with_flags(s1g_caps, tvb, offset,
                                    hf_ieee80211_s1g_cap_byte8,
                                    ett_s1g_cap_byte8,
                                    ieee80211_s1g_cap_byte8,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  proto_tree_add_bitmask_with_flags(s1g_caps, tvb, offset,
                                    hf_ieee80211_s1g_cap_byte9,
                                    ett_s1g_cap_byte9,
                                    ieee80211_s1g_cap_byte9,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  proto_tree_add_bitmask_with_flags(s1g_caps, tvb, offset,
                                    hf_ieee80211_s1g_cap_byte10,
                                    ett_s1g_cap_byte10,
                                    ieee80211_s1g_cap_byte10,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  sup_mcs_nss_set = proto_tree_add_subtree(s1g_cap_info, tvb, offset, 5,
                                    ett_ieee80211_s1g_sup_mcs_and_nss_set,
                                    NULL, "Supported S1G-MCS and NSS Set");

  proto_tree_add_bitmask_with_flags(sup_mcs_nss_set, tvb, offset,
                                    hf_ieee80211_s1g_mcs_and_nss_set,
                                    ett_s1g_mcs_and_mcs_set,
                                    ieee80211_s1g_mcs_and_nss_set,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 5;

  return offset;
}

static int * const s1g_subchannel_selective_transmission_headers0[] = {
  &hf_ieee80211_s1g_sst_sounding_option,
  &hf_ieee80211_s1g_channel_activity_bitmap,
  &hf_ieee80211_s1g_ul_activity,
  &hf_ieee80211_s1g_dl_activity,
  &hf_ieee80211_s1g_max_trans_width,
  &hf_ieee80211_s1g_activity_start_time,
  NULL
};

static const value_string max_trans_width_vals[] = {
  { 0, "channel width unit" },
  { 1, "4MHz" },
  { 2, "8MHz" },
  { 3, "16MHz" },
  { 0, NULL }
};

static int
dissect_subchannel_selective_transmission(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  uint8_t control = tvb_get_uint8(tvb, offset);

  /* Different if sounding option is 0 or 1 */
  if ((control & 0x01) == 0x00) {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                        hf_ieee80211_s1g_subchannel_selective_transmission,
                        ett_s1g_subchannel_selective_transmission,
                        s1g_subchannel_selective_transmission_headers0,
                        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 4;
  } else {
    uint8_t control2 = tvb_get_uint8(tvb, offset + 1);
    proto_item *pi = NULL;
    proto_tree *chan_tree = NULL;

    chan_tree = proto_tree_add_subtree(tree, tvb, offset, -1,
                                       ett_s1g_subchannel_selective_transmission,
                                       &pi , "Channel Activity Schedule");
    proto_tree_add_item(chan_tree, hf_ieee80211_s1g_sst_sounding_option1, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(chan_tree, hf_ieee80211_s1g_channel_activity_bitmap1,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(chan_tree, hf_ieee80211_s1g_sounding_start_time_present,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(chan_tree, hf_ieee80211_s1g_channel_activity_reserved,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(chan_tree, hf_ieee80211_s1g_max_trans_width1, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    /* sounding_start_time_present */
    if (control2 & 0x02) {
      proto_tree_add_item(chan_tree, hf_ieee80211_s1g_sounding_start_time, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
      proto_item_set_len(pi, 4);
    } else {
      proto_item_set_len(pi, 2);
    }
  }

  return offset;
}

static void
s1g_open_loop_link_margin_custom(char *result, uint8_t ollm_index)
{
  snprintf(result, ITEM_LABEL_LENGTH, "%3.1f dB",
                                        (-128.0 + ollm_index * 0.5));
}

static int
dissect_s1g_open_loop_link_margin_index(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;

  proto_tree_add_item(tree, hf_ieee80211_s1g_open_loop_link_margin, tvb,
                      offset, 1, ENC_NA);
  offset += 1;

  return offset;
}

#define RAW_START_TIME_INDICATION       0x10
#define RAW_GROUP_INDICATION            0x20
#define RAW_CHANNEL_INDICATION_PRESENCE 0x40
#define RAW_PERIODIC_RAW_INDICATION     0x80

static const value_string s1g_raw_control_raw_type[] = {
  { 0, "Generic RAW" },
  { 1, "Sounding RAW" },
  { 2, "Simplex RAW" },
  { 3, "Triggering frame RAW" },
  { 0, NULL }
};

static uint8_t global_s1g_raw_type;

static void
s1g_raw_type_options_custom(char *result, uint8_t raw_type)
{
  switch (global_s1g_raw_type) {
  case 0x00:
    switch (raw_type) {
    case 0x00:
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "None");
      break;
    case 0x01:
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "Paged STA");
      break;
    case 0x02:
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "RA Frame");
      break;
    case 0x03:
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "Paged STA and RA Frame");
      break;
    }
    break;
  case 0x01:
    switch (raw_type) {
    case 0x00:
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "SST sounding RAW");
      break;
    case 0x01:
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "SST report RAW");
      break;
    case 0x02:
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "Sector sounding RAW");
      break;
    case 0x03:
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "Sector report RAW");
      break;
    }
    break;
  case 0x02:
    switch (raw_type) {
    case 0x00:
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "AP PM RAW");
      break;
    case 0x01:
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "Non-TIM RAW");
      break;
    case 0x02:
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "Omni RAW");
      break;
    case 0x03:
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "Reserved");
      break;
    }
    break;
  case 0x03:
    snprintf(result, ITEM_LABEL_LENGTH, "%s", "Reserved");
    break;
  }
}

static void s1g_raw_slot_duration_custom(char *result, uint16_t slot_def)
{
  snprintf(result, ITEM_LABEL_LENGTH, "%u (%u uS)", slot_def, (500 + slot_def * 120));
}

static int * const s1g_raw_control_headers[] = {
  &hf_ieee80211_s1g_raw_type,
  &hf_ieee80211_s1g_raw_type_options,
  &hf_ieee80211_s1g_raw_start_time_indication,
  &hf_ieee80211_s1g_raw_raw_group_indication,
  &hf_ieee80211_s1g_raw_channel_indication_preference,
  &hf_ieee80211_s1g_raw_periodic_raw_indication,
  NULL
};

static int * const s1g_slot_def_8_bit[] = {
  &hf_ieee80211_s1g_slot_def_format_indication,
  &hf_ieee80211_s1g_slot_def_cross_slot_boundary,
  &hf_ieee80211_s1g_slot_def_slot_duration_count8,
  &hf_ieee80211_s1g_slot_def_num_slots6,
  NULL
};

static int * const s1g_slot_def_11_bit[] = {
  &hf_ieee80211_s1g_slot_def_format_indication,
  &hf_ieee80211_s1g_slot_def_cross_slot_boundary,
  &hf_ieee80211_s1g_slot_def_slot_duration_count11,
  &hf_ieee80211_s1g_slot_def_num_slots3,
  NULL
};

static int * const s1g_raw_group_fields[] = {
  &hf_ieee80211_s1g_raw_group_page_index,
  &hf_ieee80211_s1g_raw_group_start_aid,
  &hf_ieee80211_s1g_raw_group_end_aid,
  NULL
};

static int * const s1g_raw_channel_indication_fields[] = {
  &hf_ieee80211_s1g_raw_ci_channel_activity_bitmap,
  &hf_ieee80211_s1g_raw_ci_max_trans_width,
  &hf_ieee80211_s1g_raw_ci_ul_activity,
  &hf_ieee80211_s1g_raw_ci_dl_activity,
  &hf_ieee80211_s1g_raw_ci_reserved,
  NULL
};

static int
dissect_rps(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  proto_tree *raw_assignment_tree;
  proto_tree *assn_tree;
  proto_item *rati;
  int offset = 0;
  int idx = 0;
  uint8_t rps_len = tvb_reported_length_remaining(tvb, offset);

  raw_assignment_tree = proto_tree_add_subtree(tree, tvb, offset, rps_len,
                                    ett_s1g_raw_assignment, NULL,
                                    "RAW assignments");

  while (tvb_reported_length_remaining(tvb, offset) > 0) {

    assn_tree = proto_tree_add_subtree_format(raw_assignment_tree, tvb, offset, -1,
                                          ett_s1g_raw_assn_tree, &rati,
                                          "Assignment %d", idx);

    uint8_t raw_control = tvb_get_uint8(tvb, offset);
    uint8_t raw_slot_def = tvb_get_uint8(tvb, offset + 1);

    global_s1g_raw_type = raw_control & 0x03;

    proto_tree_add_bitmask_with_flags(assn_tree, tvb, offset,
                                      hf_ieee80211_s1g_raw_control,
                                      ett_s1g_raw_control,
                                      s1g_raw_control_headers,
                                      ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 1;

    if (((raw_slot_def & 0x01) == 0x00) || (global_s1g_raw_type == 0x01)) {
      proto_tree_add_bitmask_with_flags(assn_tree, tvb, offset,
                                      hf_ieee80211_s1g_raw_slot_def,
                                      ett_s1g_raw_slot_def,
                                      s1g_slot_def_8_bit,
                                      ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    } else {
      proto_tree_add_bitmask_with_flags(assn_tree, tvb, offset,
                                      hf_ieee80211_s1g_raw_slot_def,
                                      ett_s1g_raw_slot_def,
                                      s1g_slot_def_11_bit,
                                      ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    }

    offset += 2;

    if (raw_control & RAW_START_TIME_INDICATION) {
      proto_tree_add_item(assn_tree, hf_ieee80211_s1g_raw_start_time, tvb, offset, 1,
                          ENC_NA);
      offset += 1;
    }

    if (raw_control & RAW_GROUP_INDICATION) {
      uint32_t raw_group = tvb_get_letoh24(tvb, offset);

      if (raw_group == 0) {
        proto_item *it = NULL;

        it = proto_tree_add_item(assn_tree, hf_ieee80211_s1g_raw_group_subfield, tvb,
                                offset, 3, ENC_LITTLE_ENDIAN);
        proto_item_append_text(it, ": All STAs allowed access within the RAW");
      } else {
        proto_tree_add_bitmask_with_flags(assn_tree, tvb, offset,
                                      hf_ieee80211_s1g_raw_group_subfield,
                                      ett_s1g_raw_group_subfield,
                                      s1g_raw_group_fields,
                                      ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
      }
      offset += 3;
    }

    if (raw_control & RAW_CHANNEL_INDICATION_PRESENCE) {
      proto_tree_add_bitmask_with_flags(assn_tree, tvb, offset,
                                      hf_ieee80211_s1g_raw_channel_indication,
                                      ett_s1g_raw_channel_indication,
                                      s1g_raw_channel_indication_fields,
                                      ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
      offset += 2;
    }

    if (raw_control & RAW_PERIODIC_RAW_INDICATION) {
      proto_tree_add_item(assn_tree, hf_ieee80211_s1g_raw_praw_periodicity, tvb,
                          offset, 1, ENC_NA);
      offset += 1;
      proto_tree_add_item(assn_tree, hf_ieee80211_s1g_raw_praw_validity, tvb,
                          offset, 1, ENC_NA);
      offset += 1;
      proto_tree_add_item(assn_tree, hf_ieee80211_s1g_raw_praw_start_offset, tvb,
                          offset, 1, ENC_NA);
      offset += 1;
    }

    idx += 1;
  }
  return offset;
}

static int * const s1g_page_slice_headers[] = {
  &hf_ieee80211_s1g_page_slice_page_index,
  &hf_ieee80211_s1g_page_slice_page_slice_length,
  &hf_ieee80211_s1g_page_slice_page_slice_count,
  &hf_ieee80211_s1g_page_slice_block_offset,
  &hf_ieee80211_s1g_page_slice_tim_offset,
  &hf_ieee80211_s1g_page_slice_reserved,
  NULL
};

static int
dissect_page_slice(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  int len = 0;

  proto_tree_add_item(tree, hf_ieee80211_s1g_page_slice_page_period, tvb,
                      offset, 1, ENC_NA);
  offset += 1;

  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_s1g_page_slice_control,
                                    ett_s1g_page_slice_control,
                                    s1g_page_slice_headers,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);

  offset += 3;

  len = tvb_reported_length_remaining(tvb, offset);
  if (len > 0) {
    proto_tree_add_item(tree, hf_ieee80211_s1g_page_slice_page_bitmap, tvb,
                        offset, len, ENC_NA);
    offset += len;
  }

  return offset;
}

#define AID_REQUEST_INTERVAL_PRESENT   0x01
#define PER_STA_ADDRESS_PRESENT        0x02
#define SERVICE_CHARACTERISTIC_PRESENT 0x04
#define GROUP_ADDRESS_PRESENT          0x20

static int * const s1g_aid_request_mode_headers[] = {
  &hf_ieee80211_s1g_aid_request_interval_present,
  &hf_ieee80211_s1g_aid_request_per_sta_address_present,
  &hf_ieee80211_s1g_aid_request_service_characteristic_present,
  &hf_ieee80211_s1g_aid_request_non_tim_mode_switch,
  &hf_ieee80211_s1g_aid_request_tim_mode_switch,
  &hf_ieee80211_s1g_aid_request_group_address_present,
  &hf_ieee80211_s1g_aid_request_reserved,
  NULL
};

static int * const s1g_aid_request_characteristic_headers[] = {
  &hf_ieee80211_s1g_aid_request_characteristic_sensor,
  &hf_ieee80211_s1g_aid_request_characteristic_offload,
  &hf_ieee80211_s1g_aid_request_characteristic_official_service,
  &hf_ieee80211_s1g_aid_request_characteristic_reserved,
  NULL
};

static int
dissect_aid_request(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  uint8_t mode = tvb_get_uint8(tvb, offset);

  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_s1g_aid_request_mode,
                                    ett_s1g_aid_request_mode,
                                    s1g_aid_request_mode_headers,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  if (mode & AID_REQUEST_INTERVAL_PRESENT) {
    proto_tree_add_item(tree, hf_ieee80211_s1g_aid_request_interval, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }

  if (mode & PER_STA_ADDRESS_PRESENT) {
    proto_tree_add_item(tree, hf_ieee80211_s1g_aid_req_peer_sta_addr, tvb,
                        offset, 6, ENC_NA);
    offset += 6;
  }

  if (mode & SERVICE_CHARACTERISTIC_PRESENT) {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                      hf_ieee80211_s1g_aid_request_characteristic,
                                      ett_s1g_aid_characteristic,
                                      s1g_aid_request_characteristic_headers,
                                      ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 1;
  }

  if (mode & GROUP_ADDRESS_PRESENT) {
    proto_tree_add_item(tree, hf_ieee80211_s1g_aid_req_group_addr, tvb, offset,
                        6, ENC_NA);
    offset += 6;
  }

  return offset;
}

static int
dissect_aid_response(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;

  proto_tree_add_item(tree, hf_ieee80211_s1g_aid_rsp_aid_group_aid, tvb,
                      offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_s1g_aid_rsp_aid_switch_count,
                      tvb, offset, 1, ENC_NA);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_s1g_aid_rsp_aid_response_interval,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  return offset;
}

static int * const s1g_sector_op_control_headers[] = {
  &hf_ieee80211_s1g_sector_op_sectorization_type,
  &hf_ieee80211_s1g_sector_op_period,
  &hf_ieee80211_s1g_sector_op_omni,
  NULL
};

static int * const s1g_txop_sector_op_control_headers[] = {
  &hf_ieee80211_s1g_sector_op_sectorization_type_b16,
  &hf_ieee80211_s1g_sector_op_periodic_training_indicator,
  &hf_ieee80211_s1g_sector_op_training_period,
  &hf_ieee80211_s1g_sector_op_remaining_beacon_interval,
  &hf_ieee80211_s1g_sector_op_reserved_b16,
  NULL
};

static const true_false_string sectorization_type_tfs = {
  "Reserved",
  "Group Sectorization Operation"
};

static const true_false_string sectorization_omni_tfs = {
  "Omnidirectional",
  "Sectorized"
};

static int
dissect_s1g_sector_operation(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  int len = 0;
  uint8_t control = tvb_get_uint8(tvb, offset);

  if (control & 0x01) {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_s1g_sector_op_control_16b,
                                    ett_s1g_sector_operation,
                                    s1g_txop_sector_op_control_headers,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);

    offset += 2;
  } else {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_s1g_sector_op_control,
                                    ett_s1g_sector_operation,
                                    s1g_sector_op_control_headers,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 1;
  }

  /* Break this out more */
  len = tvb_reported_length_remaining(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_s1g_sector_op_group_info, tvb,
                      offset, len, ENC_NA);
  offset += len;

  return offset;
}

static int
dissect_s1g_beacon_compatibility(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;

  proto_tree_add_item(tree, hf_ieee80211_s1g_beacon_compatibility_info, tvb,
                      offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_s1g_beacon_interval, tvb, offset,
                      2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_s1g_tsf_completion, tvb, offset,
                      4, ENC_LITTLE_ENDIAN);
  offset += 4;

  return offset;
}

static int
dissect_s1g_short_beacon_interval(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;

   proto_tree_add_item(tree, hf_ieee80211_s1g_short_beacon_interval, tvb,
                       offset, 2, ENC_LITTLE_ENDIAN);
   offset += 2;

   return offset;
}

static int
dissect_s1g_change_sequence(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;

  proto_tree_add_item(tree, hf_ieee80211_s1g_change_sequence, tvb, offset, 1,
                      ENC_NA);
  offset += 1;

  return offset;
}

static int
dissect_authentication_control(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  uint16_t control_params = tvb_get_letohs(tvb, offset);
  proto_tree *auth_tree = NULL;

  if ((control_params & 0x0001) == 0) {
    auth_tree = proto_tree_add_subtree(tree, tvb, offset, 2,
                        ett_ieee80211_s1g_auth_control,
                        NULL,
                        "Centralized Authentication Control Parameters");
  } else {
    auth_tree = proto_tree_add_subtree(tree, tvb, offset, 3,
                        ett_ieee80211_s1g_auth_control,
                        NULL,
                        "Distributed Authentication Control Parameters");
  }

  if ((control_params & 0x0001) == 0) { /* This is all there should be here */
    proto_tree_add_item(auth_tree, hf_ieee80211_s1g_auth_control_control,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(auth_tree, hf_ieee80211_s1g_auth_control_deferral,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(auth_tree, hf_ieee80211_s1g_auth_control_reserved,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);

    if ((control_params & 0x0002) == 0) { /* Deferral or not */
      proto_tree_add_item(auth_tree, hf_ieee80211_s1g_auth_control_thresh,
                          tvb, offset, 2, ENC_LITTLE_ENDIAN);
    } else {
      proto_tree_add_item(auth_tree, hf_ieee80211_s1g_auth_control_thresh_tus,
                          tvb, offset, 2, ENC_LITTLE_ENDIAN);
    }
    offset += 2;
  } else {
    proto_tree_add_item(auth_tree, hf_ieee80211_s1g_auth_control_control,
                        tvb, offset, 3, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(auth_tree, hf_ieee80211_s1g_auth_slot_duration, tvb,
                        offset, 3, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(auth_tree, hf_ieee80211_s1g_auth_max_trans_int, tvb,
                        offset, 3, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(auth_tree, hf_ieee80211_s1g_auth_min_trans_int, tvb,
                        offset, 3, ENC_LITTLE_ENDIAN);
    offset += 3;
  }
  return offset;
}

static int
dissect_tsf_timer_accuracy(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;

  proto_tree_add_item(tree, hf_ieee80211_s1g_tsf_timer_accuracy, tvb, offset,
                      1, ENC_NA);
  offset += 1;

  return offset;
}

static int * const relay_control_headers[] = {
  &hf_ieee80211_s1g_relay_hierarchy_identifier,
  &hf_ieee80211_s1g_relay_no_more_relay_flag,
  NULL
};

static const range_string relay_hierarchy_rstrs[] = {
  { 0, 0,   "Root AP" },
  { 1, 1,   "S1G Relay AP" },
  { 2, 127, "Reserved" },
  { 0, 0,   NULL }
};

static const true_false_string no_more_relay_flag_tfs = {
  "AP does not accept any requests for relaying",
  "AP does accept requests for relaying"
};

static int
dissect_s1g_relay(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  uint8_t relay_control = tvb_get_uint8(tvb, offset);

  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_s1g_relay_control,
                                    ett_s1g_relay_control,
                                    relay_control_headers,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;
  if ((relay_control & 0x7F) == 1) {
    proto_tree_add_item(tree, hf_ieee80211_s1g_relay_control_rootap_bssid,
                        tvb, offset, 6, ENC_NA);
    offset += 6;
  }

  return offset;
}

static const true_false_string relay_activation_mode_tfs = {
  "Relay Activation Request",
  "Relay Activation Response"
};

static const true_false_string relay_direction_tfs = {
  "Sent by an AP",
  "Sent by a non-AP STA"
};

static unsigned relay_function_field;

static void
enable_relay_function_custom(char *result, uint8_t enable_relay_function)
{
  switch (relay_function_field & 0x03) {
  case 0x00: /* Relay Activation Mode == 0 && Direction == 0 */
    if (enable_relay_function)
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "non-AP STA activates its relay function");
    else
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "non-AP STA terminates its relay function");
    break;
  case 0x01: /* Relay Activation Mode == 1 && Direction == 0 */
    if (enable_relay_function)
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "non-AP STA requests to activate relay function");
    else
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "non-AP STA requests to terminate relay function");
    break;
  case 0x02: /* Relay Activation Mode == 0 && Direction == 1 */
    if (enable_relay_function)
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "non-AP STA is allowed to operate as a relay");
    else
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "non-AP STA must not operate as a relay");
    break;
  case 0x03: /* Relay Activation Mode == 1 && Direction == 1 */
    if (enable_relay_function)
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "Non-AP STA can operate as a relay");
    else
      snprintf(result, ITEM_LABEL_LENGTH, "%s", "Non-AP STA must terminate relay function");
    break;
  }
}

static int
dissect_s1g_relay_activation(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  proto_tree *relay_activ = NULL;

  relay_function_field = tvb_get_uint8(tvb, offset);

  relay_activ = proto_tree_add_subtree_format(tree, tvb, offset, 1,
                                       ett_s1g_relay_function,
                                       NULL, "Relay Activation: 0x%0x",
                                       relay_function_field);

  proto_tree_add_item(relay_activ,
                      hf_ieee80211_s1g_relay_function_activation_mode, tvb,
                      offset, 1, ENC_NA);
  proto_tree_add_item(relay_activ, hf_ieee80211_s1g_relay_function_direction,
                      tvb, offset, 1, ENC_NA);
  proto_tree_add_item(relay_activ,
                      hf_ieee80211_s1g_relay_function_enable_relay_function,
                      tvb, offset, 1, ENC_NA);
  proto_tree_add_item(relay_activ,
                      hf_ieee80211_s1g_relay_function_stas_present_indic,
                      tvb, offset, 1, ENC_NA);
  proto_tree_add_item(relay_activ, hf_ieee80211_s1g_relay_function_reserved,
                      tvb, offset, 1, ENC_NA);
  offset += 1;

  if (relay_function_field & 0x04) {
    proto_tree_add_item(tree, hf_ieee80211_s1g_number_of_stas, tvb, offset,
                        1, ENC_NA);
    offset += 1;
  }

  return offset;
}

static const true_false_string reachable_address_add_remove_tfs = {
  "STA joining the relay",
  "STA leaving the relay"
};

static int
dissect_reachable_address(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  proto_tree *reach_list = NULL;
  uint8_t addr_count = 0, addr_num = 0;

  proto_tree_add_item(tree, hf_ieee80211_s1g_initiator_mac_address, tvb,
                      offset, 6, ENC_NA);
  offset += 6;

  addr_count = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_s1g_address_count, tvb, offset, 1,
                      ENC_NA);
  offset++;

  reach_list = proto_tree_add_subtree(tree, tvb, offset, 7 * addr_count,
                                      ett_ieee80211_s1g_addr_list,
                                      NULL, "Reachable Addresses");
  while (addr_count != 0) {
    proto_tree *reach_addr = NULL;

    reach_addr = proto_tree_add_subtree_format(reach_list, tvb, offset, 7,
                                        ett_ieee80211_s1g_reach_addr,
                                        NULL, "Reachable Address %u", addr_num);

    proto_tree_add_item(reach_addr, hf_ieee80211_s1g_reachable_add_remove,
                        tvb, offset, 1, ENC_NA);
    proto_tree_add_item(reach_addr, hf_ieee80211_s1g_reachable_relay_capable,
                        tvb, offset, 1, ENC_NA);
    proto_tree_add_item(reach_addr, hf_ieee80211_s1g_reachable_reserved,
                        tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(reach_addr, hf_ieee80211_s1g_reachable_mac_address,
                        tvb, offset, 6, ENC_NA);
    offset += 6;

    addr_num++;
    addr_count--;
  }
  return offset;
}

static int * const relay_discovery_control_headers[] = {
  &hf_ieee80211_s1g_min_data_rate_included,
  &hf_ieee80211_s1g_mean_data_rate_included,
  &hf_ieee80211_s1g_max_data_rate_included,
  &hf_ieee80211_s1g_delay_and_min_phy_rate,
  &hf_ieee80211_s1g_information_not_available,
  &hf_ieee80211_s1g_relay_discovery_reserved,
  NULL
};

static int
dissect_s1g_relay_discovery(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  uint8_t relay_discovery_control = tvb_get_uint8(tvb, offset);

  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_s1g_relay_discovery_control,
                                    ett_s1g_relay_discovery_control,
                                    relay_discovery_control_headers,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  if (relay_discovery_control & 0x01) {
    proto_tree_add_item(tree, hf_ieee80211_s1g_relay_control_ul_min, tvb,
                        offset, 1, ENC_NA);
    offset += 1;
  }

  if (relay_discovery_control & 0x02) {
    proto_tree_add_item(tree, hf_ieee80211_s1g_relay_control_ul_mean, tvb,
                        offset, 1, ENC_NA);
    offset += 1;
  }

  if (relay_discovery_control & 0x04) {
    proto_tree_add_item(tree, hf_ieee80211_s1g_relay_control_ul_max, tvb,
                        offset, 1, ENC_NA);
    offset += 1;
  }

  if (relay_discovery_control & 0x01) {
    proto_tree_add_item(tree, hf_ieee80211_s1g_relay_control_dl_min, tvb,
                        offset, 1, ENC_NA);
    offset += 1;
  }

  if (relay_discovery_control & 0x02) {
    proto_tree_add_item(tree, hf_ieee80211_s1g_relay_control_dl_mean, tvb,
                        offset, 1, ENC_NA);
    offset += 1;
  }

  if (relay_discovery_control & 0x04) {
    proto_tree_add_item(tree, hf_ieee80211_s1g_relay_control_dl_max, tvb,
                        offset, 1, ENC_NA);
    offset += 1;
  }

  if (relay_discovery_control & 0x08) {

  }

  return offset;
}

static int
dissect_aid_announcement(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  int entry_no = 0;

  /*
   * There should be 8N bytes ...
   */
  while (tvb_reported_length_remaining(tvb, offset) >= 8) {
    proto_tree *aid_entry = NULL;

    aid_entry = proto_tree_add_subtree_format(tree, tvb, offset, 8,
                                ett_ieee80211_s1g_aid_entry,
                                NULL, "AID Entry %d", entry_no++);
    proto_tree_add_item(aid_entry, hf_ieee80211_s1g_aid_entry_mac_addr,
                        tvb, offset, 6, ENC_NA);
    offset += 6;

    proto_tree_add_item(aid_entry, hf_ieee80211_s1g_aid_entry_assoc_id,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }

  /* TODO: EI if bytes remaining. */

  return offset;
}

static int * const subfield_0[] = {
  &hf_ieee80211_pv1_probe_response_req_full_ssid,
  &hf_ieee80211_pv1_probe_response_req_next_tbtt,
  &hf_ieee80211_pv1_probe_response_req_access_network_option,
  &hf_ieee80211_pv1_probe_response_req_s1g_beacon_compatibility,
  &hf_ieee80211_pv1_probe_response_req_supported_rates,
  &hf_ieee80211_pv1_probe_response_req_s1g_capability,
  &hf_ieee80211_pv1_probe_response_req_s1g_operation,
  &hf_ieee80211_pv1_probe_response_req_rsn,
  NULL
};

static int
dissect_pv1_probe_response_option(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;

  /*
   * TODO: Check that the number of bytes matches what the probe response
   * group bitmap says should be there.
   */
  if (tvb_reported_length_remaining(tvb, offset) == 1) {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_s1g_probe_resp_subfield_0,
                                    ett_s1g_probe_resp_subfield_0,
                                    subfield_0,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 1;
  } else if (tvb_reported_length_remaining(tvb, offset) > 1) {
    uint8_t opt_bitmaps = tvb_get_uint8(tvb, offset);

    proto_tree_add_item(tree, hf_ieee80211_s1g_probe_response_group_bitmap,
                        tvb, offset, 1, ENC_NA);
    offset += 1;
    if (opt_bitmaps & 0x01) { /* Default Bitmap */
      proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_s1g_probe_resp_subfield_0,
                                    ett_s1g_probe_resp_subfield_0,
                                    subfield_0,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
      offset += 1;
    }
  }

  return offset;
}

static void
s1g_max_awake_duration_custom(char *result, uint16_t duration)
{
  if (duration == 0)
    snprintf(result, ITEM_LABEL_LENGTH, "%s", "No limit applies");
  else
    snprintf(result, ITEM_LABEL_LENGTH, "%d uS", (int)duration * 40);
}

static void
s1g_recovery_time_duration_custom(char *result, uint16_t duration)
{
  snprintf(result, ITEM_LABEL_LENGTH, "%d uS", (int)duration * 40);
}

static int
dissect_el_operation(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;

  proto_tree_add_item(tree, hf_ieee80211_s1g_el_op_max_awake_duration, tvb,
                      offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_s1g_el_op_recovery_time_duration, tvb,
                      offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  return offset;
}

static int
dissect_sectorized_group_id_list(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  int len = tvb_reported_length_remaining(tvb, offset);

  /* Break this out some more */
  proto_tree_add_item(tree, hf_ieee80211_s1g_sectorized_group_id_list, tvb,
                      offset, len, ENC_NA);
  offset += len;

  return offset;
}

static int * const channel_width_fields[] = {
  &hf_ieee80211_s1g_primary_channel_width,
  &hf_ieee80211_s1g_bss_operating_channel_width,
  &hf_ieee80211_s1g_primary_channel_location,
  &hf_ieee80211_s1g_reserved_b6,
  &hf_ieee80211_s1g_mcs10_use,
  NULL
};

static const value_string one_mhz_primary_channel_vals[] = {
  { 0, "1 MHz BSS operating channel width" },
  { 1, "2 MHz BSS operating channel width" },
  { 3, "4 MHz BSS operating channel width" },
  { 7, "8 MHz BSS operating channel width" },
  { 15, "16 MHz BSS operating channel width" },
  { 0, NULL },
};

static const value_string two_mhz_primary_channel_vals[] = {
  { 1, "2 MHz BSS operating channel width" },
  { 3, "4 MHz BSS operating channel width" },
  { 7, "8 MHz BSS operating channel width" },
  { 15, "16 MHz BSS operating channel width" },
  { 0, NULL },
};

static const value_string primary_channel_width_vals[] = {
  { 0, "2MHz BSS Primary Channel Width" },
  { 1, "1MHz BSS Primary Channel Width" },
  { 0, NULL }
};

static const value_string one_mhz_primary_channel_location_vals[] = {
  { 0, "Located on lower side of 2MHz primary channel" },
  { 1, "Located on upper side of 2MHz primary channel" },
  { 0, NULL }
};

static const value_string mcs10_use_vals[] = {
  { 0, "Use of MCS10 possible" },
  { 1, "Use of MCS10 not recommended" },
  { 0, NULL }
};

static int
dissect_s1g_operation(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  proto_tree *s1g_op_info = NULL;
  proto_item *cw_item = NULL;
  uint8_t chan_width = 0;

  s1g_op_info = proto_tree_add_subtree(tree, tvb, offset, 4,
                         ett_s1g_operation_info,
                         NULL, "S1G Operation Information");

  chan_width = tvb_get_uint8(tvb, offset);
  cw_item = proto_tree_add_bitmask_with_flags(s1g_op_info, tvb, offset,
                                    hf_ieee80211_s1g_channel_width,
                                    ett_s1g_channel_width,
                                    channel_width_fields,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  if (chan_width & 0x01) {
        proto_item_append_text(cw_item, ": %s",
                               val_to_str((chan_width >> 1) & 0x0F,
                                          one_mhz_primary_channel_vals,
                                          "Invalid BSS Channel Width value"));
  } else {
        proto_item_append_text(cw_item, ": %s",
                               val_to_str((chan_width >> 1) & 0x0F,
                                          two_mhz_primary_channel_vals,
                                          "Invalid BSS Channel Width value"));
  }
  offset += 1;

  proto_tree_add_item(s1g_op_info, hf_ieee80211_s1g_operating_class, tvb,
                      offset, 1, ENC_NA);
  offset += 1;

  proto_tree_add_item(s1g_op_info, hf_ieee80211_s1g_primary_channel_number, tvb,
                      offset, 1, ENC_NA);
  offset += 1;

  proto_tree_add_item(s1g_op_info, hf_ieee80211_s1g_channel_center_frequency,
                      tvb, offset, 1, ENC_NA);
  offset += 1;

  proto_tree_add_item(s1g_op_info, hf_ieee80211_s1g_basic_mcs_and_nss_set,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  return offset;
}

#define HEADER_COMP_STORE_A3    0x02
#define HEADER_COMP_STORE_A4    0x04
#define HEADER_COMP_CCMP_UPDATE 0x08

static int * const header_compression_control_headers[] = {
  &hf_ieee80211_s1g_header_comp_req_resp,
  &hf_ieee80211_s1g_header_comp_store_a3,
  &hf_ieee80211_s1g_header_comp_store_a4,
  &hf_ieee80211_s1g_header_comp_ccmp_update_present,
  &hf_ieee80211_s1g_header_comp_pv1_data_type_3_supported,
  &hf_ieee80211_s1g_header_comp_reserved,
  NULL
};

static int
dissect_header_compression(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  uint8_t control = tvb_get_uint8(tvb, offset);

  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_s1g_header_comp_control,
                                    ett_s1g_header_comp_control,
                                    header_compression_control_headers,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  if (control & HEADER_COMP_STORE_A3) {
    proto_tree_add_item(tree, hf_ieee80211_s1g_header_comp_a3, tvb,
                        offset, 6, ENC_NA);
    offset += 6;
  }

  if (control & HEADER_COMP_STORE_A4) {
    proto_tree_add_item(tree, hf_ieee80211_s1g_header_comp_a4, tvb,
                        offset, 6, ENC_NA);
    offset += 6;
  }

  /* TODO: Break this out */
  if (control & HEADER_COMP_CCMP_UPDATE) {
    proto_tree_add_item(tree, hf_ieee80211_s1g_header_comp_ccmp_update, tvb,
                        offset, 5, ENC_NA);
    offset += 5;
  }

  return offset;
}

static const value_string sst_channel_unit_vals[] = {
  { 0, "Channel Width Unit is 2 MHz" },
  { 1, "Channel Width Unit is 1 MHz" },
  { 0, NULL }
};

static int
dissect_sst_operation(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;

  proto_tree_add_item(tree, hf_ieee80211_s1g_sst_enabled_channel_bitmap, tvb,
                      offset, 1, ENC_NA);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_s1g_sst_primary_channel_offset, tvb,
                      offset, 1, ENC_NA);
  proto_tree_add_item(tree, hf_ieee80211_s1g_sst_channel_unit, tvb, offset,
                      1, ENC_NA);
  proto_tree_add_item(tree, hf_ieee80211_s1g_sst_reserved, tvb, offset, 1,
                      ENC_NA);
  offset += 1;

  return offset;
}

static int
dissect_max_away_duration(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;

  proto_tree_add_item(tree, hf_ieee80211_s1g_max_away_duration, tvb, offset,
                      2, ENC_LITTLE_ENDIAN);
  offset += 2;

  return offset;
}

static int
dissect_mcs_set(proto_tree *tree, tvbuff_t *tvb, int offset, bool basic, bool vendorspecific)
{
  proto_item *ti;
  proto_tree *mcs_tree, *bit_tree;
  uint8_t rx_nss, tx_nss; /* 0-4 for HT and 0-8 for VHT*/
  uint32_t value_mcs_0_31, value_mcs_32_52, value_mcs_53_76;
  uint16_t tx_mcs_set;
  rx_nss = tx_nss = 8;
  /* 16 byte Supported MCS set */
  if (vendorspecific)
  {
    ti = proto_tree_add_item(tree, hf_ieee80211_mcsset_vs, tvb, offset, 16, ENC_NA);
  } else
  {
    ti = proto_tree_add_item(tree, hf_ieee80211_mcsset, tvb, offset, 16, ENC_NA);
  }
  proto_item_append_text(ti, ": %s", basic ? "Basic MCS Set" : "MCS Set");
  mcs_tree = proto_item_add_subtree(ti, ett_mcsset_tree);

  /* Rx MCS Bitmask */
  ti = proto_tree_add_item(mcs_tree, hf_ieee80211_mcsset_rx_bitmask, tvb, offset, 10, ENC_NA);
  bit_tree = proto_item_add_subtree(ti, ett_mcsbit_tree);

  /* Bits 0 - 31 */
  value_mcs_0_31 = tvb_get_letohl(tvb, offset);

  /* Handle all zeroes/ff's case..*/
  if (value_mcs_0_31 != 0x0)
  {
    if (!(value_mcs_0_31 & (0xffffff00))) {
      /*
       * At least one MCS from 0-7 is supported, but no MCS from 8-31 are
       * supported, so only 1 spatial stream is supported.
       */
      rx_nss = 0;
    } else if (!(value_mcs_0_31 & (0xffff0000))) {
      /*
       * At least one MCS from 8-15 is supported, but no MCS from 16-31 are
       * supported, so only 2 spatial streams are supported.
       */
      rx_nss = 1;
    } else if (!(value_mcs_0_31 & (0xff000000))) {
      /*
       * At least one MCS from 16-23 is supported, but no MCS from 24-31 are
       * supported, so only 3 spatial streams are supported.
       */
      rx_nss = 2;
    } else {
      /*
       * At least one MCS from 24-31 is supported, so 4 spatial streams
       * are supported.
       */
      rx_nss = 3;
    }
  }

  proto_tree_add_item(bit_tree, hf_ieee80211_mcsset_rx_bitmask_0to7, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bit_tree, hf_ieee80211_mcsset_rx_bitmask_8to15, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bit_tree, hf_ieee80211_mcsset_rx_bitmask_16to23, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bit_tree, hf_ieee80211_mcsset_rx_bitmask_24to31, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  /* Should be we check UEQM Supported?*/
  /* Bits 32 - 52 */
  value_mcs_32_52 = tvb_get_letohl(tvb, offset);
  if (!(value_mcs_32_52 & (0x1ffffe))) {
    /*
     * MCS 33-52 aren't supported, so the number of spatial streams we get
     * from whichever MCSes from 0-31 that we support is the total number
     * of spatial streams we support.
     */
    ;
  } else if (!(value_mcs_32_52 & (0x1fff80))) {
    /*
     * At least one MCS from 33-38 is supported, but no MCS from 39-52 is
     * supported, so we have at least 2 spatial streams, but none of the
     * MCSs in that range give us any more.
     */
    rx_nss = MAX(1, rx_nss);
  } else {
    /*
     * At least one MCS from 39-52 is supported, so we have at least 3
     * spatial streams.
     */
    rx_nss = MAX(2, rx_nss);
  }

  proto_tree_add_item(bit_tree, hf_ieee80211_mcsset_rx_bitmask_32, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bit_tree, hf_ieee80211_mcsset_rx_bitmask_33to38, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bit_tree, hf_ieee80211_mcsset_rx_bitmask_39to52, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 2;

  /* Bits 53 - 76 */
  value_mcs_53_76 = tvb_get_letohl(tvb, offset);
  if ((value_mcs_53_76 & (0x1fffffe0))) {
    /*
     * At least one MCS from 53-76 is supported, so we have at least 4
     * spatial streams.
     */
    rx_nss = MAX(3, rx_nss);
  }

  proto_tree_add_item(bit_tree, hf_ieee80211_mcsset_rx_bitmask_53to76, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(mcs_tree, hf_ieee80211_mcsset_highest_data_rate, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  /* Follow table 8-126 from 802.11-2012 */
  tx_mcs_set = tvb_get_letohs(tvb, offset);

  if (!(tx_mcs_set & 0x0001) && !(tx_mcs_set & 0x0002))
  {
    /* TX MCS Set is not defined
     * so there is no interpretation for Max Tx Spatial Streams
     */
     tx_nss = 4; /* Not Defined*/
  }

  if ((tx_mcs_set & 0x0001) && !(tx_mcs_set & 0x0002))
  {
    /* TX MCS Set is defined to be equal to Rx MCS Set
     * So, get the Max Spatial Streams from Rx
     * MCS set
     */
     tx_nss = rx_nss;
  }
  proto_item_append_text(ti, ": %s", val_to_str(rx_nss, mcsset_tx_max_spatial_streams_flags, "Reserved:%d" ) );

  proto_tree_add_item(mcs_tree, hf_ieee80211_mcsset_tx_mcs_set_defined, tvb, offset, 1,
      ENC_LITTLE_ENDIAN);
  proto_tree_add_item(mcs_tree, hf_ieee80211_mcsset_tx_rx_mcs_set_not_equal, tvb, offset, 1,
      ENC_LITTLE_ENDIAN);
  ti = proto_tree_add_item(mcs_tree, hf_ieee80211_mcsset_tx_max_spatial_streams, tvb, offset, 1,
      ENC_LITTLE_ENDIAN);
  proto_item_append_text(ti, ", %s", val_to_str(tx_nss, mcsset_tx_max_spatial_streams_flags, "Reserved:%d" ) );
  proto_tree_add_item(mcs_tree, hf_ieee80211_mcsset_tx_unequal_modulation, tvb, offset, 1,
      ENC_LITTLE_ENDIAN);
  offset += 1;

  offset += 3;
  return offset;
}

/*  802.11n D1.10 - HT Information IE  */
static int
dissect_ht_info_ie_1_1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  static int * const ieee80211_ht_info1_field[] = {
    &hf_ieee80211_ht_info_secondary_channel_offset,
    &hf_ieee80211_ht_info_sta_channel_width,
    &hf_ieee80211_ht_info_rifs_mode,
    &hf_ieee80211_ht_info_reserved_b4_b7,
    NULL
  };

  static int * const ieee80211_ht_info2_field[] = {
    &hf_ieee80211_ht_info_protection,
    &hf_ieee80211_ht_info_non_greenfield_sta_present,
    &hf_ieee80211_ht_info_reserved_b11,
    &hf_ieee80211_ht_info_obss_non_ht_stas_present,
    &hf_ieee80211_ht_info_channel_center_freq_seg_2,
    &hf_ieee80211_ht_info_reserved_b21_b23,
    NULL
  };

  static int * const ieee80211_ht_info3_field[] = {
    &hf_ieee80211_ht_info_reserved_b24_b29,
    &hf_ieee80211_ht_info_dual_beacon,
    &hf_ieee80211_ht_info_dual_cts_protection,
    &hf_ieee80211_ht_info_secondary_beacon,
    &hf_ieee80211_ht_info_lsig_txop_protection_full_support,
    &hf_ieee80211_ht_info_pco_active,
    &hf_ieee80211_ht_info_pco_phase,
    &hf_ieee80211_ht_info_reserved_b36_b39,
    NULL
  };

  if (tag_len < 22) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "HT Information IE content length %u wrong, must be at least 22 bytes", tag_len);
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_ht_info_primary_channel, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ht_info_delimiter1,
                                    ett_ht_info_delimiter1_tree, ieee80211_ht_info1_field,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;


  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ht_info_delimiter2,
                                    ett_ht_info_delimiter2_tree, ieee80211_ht_info2_field,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ht_info_delimiter3,
                                    ett_ht_info_delimiter3_tree, ieee80211_ht_info3_field,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;

  offset = dissect_mcs_set(tree, tvb, offset, true, false);

  return offset;
}

static int
dissect_wapi_param_set(tvbuff_t *tvb, packet_info *pinfo,
                          proto_tree *tree, int offset, uint32_t tag_len, proto_item *ti_len,
                          proto_item *ti, int ftype)
{
  /* Parse the WAPI Parameter Set IE Here*/
  proto_item *item;
  proto_tree *subtree;
  uint16_t loop_cnt, version, akm_cnt  = 1, ucast_cnt = 1, bkid_cnt = 1;
  uint8_t akm_suite_type = 0, ucast_cipher_type = 0, mcast_cipher_type = 0;
  static int * const ieee80211_tag_wapi_param_set[] = {
    &hf_ieee80211_tag_wapi_param_set_capab_preauth,
    &hf_ieee80211_tag_wapi_param_set_capab_rsvd,
    NULL
  };

  version = tvb_get_letohs(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_tag_wapi_param_set_version, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  /*MIN: 2 + (2+4)+ (2+4) + 4 + 2 + 0 (BKID CNT and LIST)  =20*/
  if (tag_len < 20) {
      expert_add_info_format(pinfo, ti_len, &ei_ieee80211_tag_length,
                "tag_len is  %d, it's neither WAPI not BSS-AC-Access-Delay", tag_len);
    return offset;
  }

  if (version != 1) {
    expert_add_info_format(pinfo, ti_len, &ei_ieee80211_tag_length,
                           "Version of WAPI protocol is %d, must be = 1", version);
    return offset;
  }

  /* AKM Suites: list can't be 0*/
  akm_cnt = tvb_get_letohs(tvb, offset);
  item = proto_tree_add_item(tree, hf_ieee80211_tag_wapi_param_set_akm_suite_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;
  if (akm_cnt != 0) {
    proto_item_append_text(ti, " : AKM Suite List:");
    for (loop_cnt = 0; loop_cnt < akm_cnt; loop_cnt++) {
      subtree = proto_item_add_subtree(item, ett_tag_wapi_param_set_akm_tree);
      proto_tree_add_item(subtree, hf_ieee80211_tag_wapi_param_set_akm_suite_oui, tvb, offset, 3, ENC_NA);
      offset += 3;
      akm_suite_type = tvb_get_uint8(tvb, offset);
      proto_tree_add_item(subtree, hf_ieee80211_tag_wapi_param_set_akm_suite_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
      offset += 1;
      proto_item_append_text(ti, " (%d,%s)", loop_cnt+1, val_to_str(akm_suite_type,
      ieee80211_wapi_suite_type_short, "Reserved: %d"));
    }
    proto_item_append_text(ti, " /");
  } else {
    expert_add_info_format(pinfo, ti_len, &ei_ieee80211_tag_length, "Number of AKM suites is 0, must be min 1");
    return offset;

  }
  /* Unicast Cipher Suites: list can't be 0*/
  ucast_cnt = tvb_get_letohs(tvb, offset);
  item = proto_tree_add_item(tree, hf_ieee80211_tag_wapi_param_set_ucast_cipher_suite_count,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;
  if (ucast_cnt != 0) {
    proto_item_append_text(ti, " Unicast Cipher List:");
    for (loop_cnt = 0; loop_cnt < ucast_cnt; loop_cnt++) {
      subtree = proto_item_add_subtree(item, ett_tag_wapi_param_set_ucast_tree);
      proto_tree_add_item(subtree, hf_ieee80211_tag_wapi_param_set_ucast_cipher_suite_oui, tvb, offset, 3, ENC_BIG_ENDIAN);
      offset += 3;
      ucast_cipher_type = tvb_get_uint8(tvb, offset);
      proto_tree_add_item(subtree, hf_ieee80211_tag_wapi_param_set_ucast_cipher_suite_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
      offset += 1;
      proto_item_append_text(ti, " (%d,%s)", loop_cnt+1, val_to_str(ucast_cipher_type, ieee80211_wapi_cipher_type, "Reserved: %d"));
    }
  proto_item_append_text(ti, " /");
  } else {
    expert_add_info_format(pinfo, ti_len, &ei_ieee80211_tag_length, "Number of Unicast Cipher suites is 0, must be min 1");
    return offset;

  }

  /* Multicast Cipher Suites*/
  proto_tree_add_item(tree, hf_ieee80211_tag_wapi_param_set_mcast_cipher_suite_oui, tvb, offset, 3, ENC_NA);
  offset += 3;
  mcast_cipher_type = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_tag_wapi_param_set_mcast_cipher_suite_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_item_append_text(ti, " Multicast Cipher: %s", val_to_str(mcast_cipher_type, ieee80211_wapi_cipher_type, "Reserved: %d"));

  /* WAPI capability */
  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_wapi_param_set_capab,
                                    ett_tag_wapi_param_set_preauth_tree, ieee80211_tag_wapi_param_set,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;

  /* BKID List: The list can be 0
   * Applicable only for assoc/re-assoc
   */
  if (ftype == MGT_ASSOC_REQ || ftype == MGT_REASSOC_REQ ) {
    bkid_cnt = tvb_get_letohs(tvb, offset);
    proto_tree_add_item(tree, hf_ieee80211_tag_wapi_param_set_bkid_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    if (bkid_cnt != 0) {
      for (loop_cnt = 0; loop_cnt < bkid_cnt; loop_cnt++) {
        proto_tree_add_item(tree, hf_ieee80211_tag_wapi_param_set_bkid_list, tvb, offset, 16, ENC_NA);
        offset += 16;
      }
    }
  }
  return offset;
}

static int * const ieee80211_bss_max_idle_options[] = {
  &hf_ieee80211_tag_bss_max_idle_options_protected,
  &hf_ieee80211_tag_bss_idle_options_reserved,
  NULL
};

static int
dissect_bss_max_idle_period(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;

  proto_tree_add_item(tree, hf_ieee80211_tag_bss_max_idle_period,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_tag_bss_max_idle_options,
                                    ett_max_idle_period_options,
                                    ieee80211_bss_max_idle_options,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset++;

  return offset;
}

enum tfs_request_subelem_id {
  TFS_REQ_SUBELEM_TFS = 1,
  TFS_REQ_SUBELEM_VENDOR_SPECIFIC = 221
};

static const value_string tfs_request_subelem_ids[] = {
  { TFS_REQ_SUBELEM_TFS, "TFS subelement" },
  { TFS_REQ_SUBELEM_VENDOR_SPECIFIC, "Vendor Specific subelement" },
  { 0, NULL }
};

static int
dissect_tfs_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  const uint8_t ids[] = {
    1, /* TFS Subelement */
    TAG_VENDOR_SPECIFIC_IE
  };

  proto_tree_add_item(tree, hf_ieee80211_tag_tfs_request_id,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset++;
  proto_tree_add_item(tree, hf_ieee80211_tag_tfs_request_ac_delete_after_match,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tree, hf_ieee80211_tag_tfs_request_ac_notify,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset++;
  if (offset + 1 >= tag_len) {
    expert_add_info_format(pinfo, tree, &ei_ieee80211_missing_data,
                           "No TFS Request subelements in TFS Request");
    return tvb_captured_length(tvb);
  }

  while (offset + 1 < tag_len) {
    uint8_t id, len;
    int s_offset, s_end;

    id = tvb_get_uint8(tvb, offset);
    proto_tree_add_item(tree, hf_ieee80211_tag_tfs_request_subelem_id,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;
    len = tvb_get_uint8(tvb, offset);
    proto_tree_add_item(tree, hf_ieee80211_tag_tfs_request_subelem_len,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;
    if (offset + len > tag_len) {
      expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length,
                             "Not enough data for TFS Request subelement");
      return tvb_captured_length(tvb);
    }
    switch (id) {
    case TFS_REQ_SUBELEM_TFS:
      s_offset = offset;
      s_end = offset + len;
      while (s_offset < s_end) {
        /* TODO 1 is interpreted as TAG_SUPP_RATES, fix this! */
        int tlen = add_tagged_field(pinfo, tree, tvb, s_offset, field_data->ftype, ids, G_N_ELEMENTS(ids), NULL);
        if (tlen==0)
          break;
        s_offset += tlen;
      }
      break;
    default:
      proto_tree_add_item(tree, hf_ieee80211_tag_tfs_request_subelem,
                          tvb, offset, len, ENC_NA);
      break;
    }
    offset += len;
  }

  if (offset < tag_len) {
    proto_tree_add_expert_format(tree, pinfo, &ei_ieee80211_extra_data,
                           tvb, offset, tag_len - offset, "Extra data after TFS Subelements");
  }

  return tvb_captured_length(tvb);
}

enum tfs_response_subelem_id {
  TFS_RESP_SUBELEM_TFS_STATUS = 1,
  TFS_RESP_SUBELEM_TFS = 2,
  TFS_RESP_SUBELEM_VENDOR_SPECIFIC = 221
};

static const value_string tfs_response_subelem_ids[] = {
  { TFS_RESP_SUBELEM_TFS_STATUS, "TFS Status subelement" },
  { TFS_RESP_SUBELEM_TFS, "TFS subelement" },
  { TFS_RESP_SUBELEM_VENDOR_SPECIFIC, "Vendor Specific subelement" },
  { 0, NULL }
};

static int
dissect_tfs_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  const uint8_t ids[] = {
    1, /* TFS Status subelement*/
    2, /* TFS subelement */
    TAG_VENDOR_SPECIFIC_IE
  };

  while (offset + 3 <= tag_len) {
    uint8_t id, len;
    int s_offset, s_end;

    id = tvb_get_uint8(tvb, offset);
    proto_tree_add_item(tree, hf_ieee80211_tag_tfs_response_subelem_id,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;
    len = tvb_get_uint8(tvb, offset);
    proto_tree_add_item(tree, hf_ieee80211_tag_tfs_response_subelem_len,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;
    if (offset + len > tag_len) {
      expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length,
                             "Not enough data for TFS Request subelement");
      return tvb_captured_length(tvb);
    }
    switch (id) {
    case TFS_RESP_SUBELEM_TFS_STATUS:
      proto_tree_add_item(tree, hf_ieee80211_tag_tfs_response_status,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(tree, hf_ieee80211_tag_tfs_response_id,
                          tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);
      break;
    case TFS_RESP_SUBELEM_TFS:
      s_offset = offset;
      s_end = offset + len;
      while (s_offset < s_end) {
        /* TODO Element IDs 1 and 2 are misinterpreted! */
        int tlen = add_tagged_field(pinfo, tree, tvb, s_offset, field_data->ftype, ids, G_N_ELEMENTS(ids), NULL);
        if (tlen==0)
          break;
        s_offset += tlen;
      }
      break;
    default:
      proto_tree_add_item(tree, hf_ieee80211_tag_tfs_response_subelem,
                          tvb, offset, len, ENC_NA);
      break;
    }

    offset += len;
  }

  if (offset < tag_len) {
    proto_tree_add_expert_format(tree, pinfo, &ei_ieee80211_extra_data,
                           tvb, offset, tag_len - offset, "Extra data after TFS Subelements");
  }

  return tvb_captured_length(tvb);
}

static const value_string wnm_sleep_mode_action_types[] = {
  { 0, "Enter WNM-Sleep Mode" },
  { 1, "Exit WNM-Sleep Mode" },
  { 0, NULL }
};

static const value_string wnm_sleep_mode_response_status_vals[] = {
  { 0, "Enter/Exit WNM-Sleep Mode Accept" },
  { 1, "Exit WNM-Sleep Mode Accept, GTK/IGTK update required" },
  { 2, "Denied. The AP is unable to perform the requested action." },
  { 3, "Denied temporarily. The AP is unable to perform the requested action "
    "at the current time. The request can be submitted again at a later time."
  },
  { 4, "Denied. Due to the pending key expiration." },
  { 5, "Denied. The requested action was not granted due to other WNM services "
    "in use by the requesting STA." },
  { 0, NULL }
};

static int
dissect_wnm_sleep_mode(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  proto_tree_add_item(tree, hf_ieee80211_tag_wnm_sleep_mode_action_type,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset++;
  proto_tree_add_item(tree, hf_ieee80211_tag_wnm_sleep_mode_response_status,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset++;
  proto_tree_add_item(tree, hf_ieee80211_tag_wnm_sleep_mode_interval,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;
  return offset;
}

static const value_string time_adv_timing_capab_vals[] = {
  { 0, "No standardized external time source" },
  { 1, "Timestamp offset based on UTC" },
  { 2, "UTC time at which the TSF timer is 0" },
  { 0, NULL }
};

static int
dissect_time_adv(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  uint8_t capab;
  proto_item *item;
  proto_tree *subtree;
  struct tm tm, *now;
  time_t t;

  capab = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_tag_time_adv_timing_capab,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  switch (capab) {
  case 1:
    proto_tree_add_item(tree, hf_ieee80211_tag_time_adv_time_value,
                        tvb, offset, 10, ENC_NA);
    offset += 10;

    proto_tree_add_item(tree, hf_ieee80211_tag_time_adv_time_error,
                        tvb, offset, 5, ENC_NA);
    offset += 5;
    break;
  case 2:
    item = proto_tree_add_item(tree, hf_ieee80211_tag_time_adv_time_value,
                               tvb, offset, 10, ENC_NA);
    subtree = proto_item_add_subtree(item, ett_tag_time_adv_tree);
    memset(&tm, 0, sizeof(tm));
    tm.tm_year = tvb_get_letohs(tvb, offset) - 1900;
    proto_tree_add_item(subtree, hf_ieee80211_tag_time_adv_time_value_year,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    tm.tm_mon = tvb_get_uint8(tvb, offset) - 1;
    proto_tree_add_item(subtree, hf_ieee80211_tag_time_adv_time_value_month,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    tm.tm_mday = tvb_get_uint8(tvb, offset);
    proto_tree_add_item(subtree, hf_ieee80211_tag_time_adv_time_value_day,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    tm.tm_hour = tvb_get_uint8(tvb, offset);
    proto_tree_add_item(subtree, hf_ieee80211_tag_time_adv_time_value_hours,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    tm.tm_min = tvb_get_uint8(tvb, offset);
    proto_tree_add_item(subtree, hf_ieee80211_tag_time_adv_time_value_minutes,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    tm.tm_sec = tvb_get_uint8(tvb, offset);
    proto_tree_add_item(subtree, hf_ieee80211_tag_time_adv_time_value_seconds,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(subtree,
                        hf_ieee80211_tag_time_adv_time_value_milliseconds,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    proto_tree_add_item(subtree, hf_ieee80211_tag_time_adv_time_value_reserved,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    tm.tm_isdst = -1;
    t = mktime(&tm);
    if (t != -1) {
      t += (time_t)(last_timestamp / 1000000);
      now = localtime(&t);
      if (now)
        proto_item_append_text(item,
                               ": current time=%u-%02u-%02u %02u:%02u:%02u",
                               now->tm_year + 1900, now->tm_mon + 1,
                               now->tm_mday, now->tm_hour, now->tm_min,
                               now->tm_sec);
    }

    proto_tree_add_item(tree, hf_ieee80211_tag_time_adv_time_error,
                        tvb, offset, 5, ENC_NA);
    offset += 5;

    proto_tree_add_item(tree, hf_ieee80211_tag_time_adv_time_update_counter,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    break;
  }

  return offset;
}

static int
dissect_time_zone(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int tag_len = tvb_reported_length(tvb);
  int offset = 0;

  proto_tree_add_item(tree, hf_ieee80211_tag_time_zone, tvb, offset, tag_len,
                      ENC_ASCII);
  return tvb_captured_length(tvb);
}

static int
dissect_ap_channel_report(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if (tag_len < 1) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "AP Channel Report length %u wrong, must be > 1", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_ap_channel_report_operating_class, tvb,
                      offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, ": Operating Class %u, Channel List :", tvb_get_uint8(tvb, offset));
  offset += 1;

  while (offset < tag_len)
  {
    proto_tree_add_item(tree, hf_ieee80211_tag_ap_channel_report_channel_list, tvb, offset, 1, ENC_NA);
    proto_item_append_text(field_data->item_tag, " %u,", tvb_get_uint8(tvb, offset));
    offset += 1;
  }
  return tvb_captured_length(tvb);
}

static int
dissect_secondary_channel_offset_ie(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  if (tag_len != 1) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "Secondary Channel Offset length %u wrong, must be = 1", tag_len);
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_secondary_channel_offset, tvb,
                      offset, 1, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

/* RCPI (53) */
static int
dissect_rcpi_ie(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if (tag_len != 1)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "RCPI length %u wrong, must = 1", tag_len);
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_rcpi, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  return offset;
}

/* BSS Average Access Delay element (63) */
static int
dissect_bss_avg_access_delay_ie(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  if (tag_len != 1) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "BSS Average Access Delay length %u wrong, must be = 1", tag_len);
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_bss_ap_avg_access_delay, tvb,
                      offset, 1, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

static int
dissect_antenna_ie(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if (tag_len != 1) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "Antenna length %u wrong, must be = 1", tag_len);
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_antenna_id, tvb,
                      offset, 1, ENC_LITTLE_ENDIAN);

  return tvb_captured_length(tvb);
}

static int
dissect_rsni_ie(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if (tag_len != 1) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "RSNI length %u wrong, must be = 1", tag_len);
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_rsni, tvb,
                      offset, 1, ENC_LITTLE_ENDIAN);

  return tvb_captured_length(tvb);
}

static int
dissect_measurement_pilot_trans_ie(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int tag_len = tvb_reported_length(tvb);
  int offset = 0;
  const uint8_t ids[] = { TAG_VENDOR_SPECIFIC_IE };

  /* The tag len can be 1 or more if there are sub-elements */

  proto_tree_add_item(tree, hf_ieee80211_ff_measurement_pilot_int, tvb, offset,
                      1, ENC_NA);

  tag_len--;
  offset++;

  /* Also handle the optional sub-elements */

  if (tag_len > 0) {
    while (tag_len > 0) {
      uint8_t elt_len;

      if (tvb_reported_length_remaining(tvb, offset) < 2) {
        proto_tree_add_expert_format(tree, pinfo, &ei_ieee80211_bad_length,
             tvb, offset, tag_len - offset,
             "Remaining data does not include the tag length");
        break;
      }
      elt_len = tvb_get_uint8(tvb, offset + 1);

      if(add_tagged_field(pinfo, tree, tvb, offset + 2, 0, ids, G_N_ELEMENTS(ids), NULL) == 0){
        /* TODO: Add an expert info here and skip the field. */
        break;
      }

      tag_len -= elt_len + 2;
      offset += elt_len + 2;
    }
  }

  return tvb_captured_length(tvb);
}

static int
dissect_bss_available_admission_capacity_ie(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  uint16_t bitmask;
  static int * const ieee80211_tag_bss_avb_adm_cap_bitmask[] = {
    &hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up0,
    &hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up1,
    &hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up2,
    &hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up3,
    &hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up4,
    &hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up5,
    &hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up6,
    &hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up7,
    &hf_ieee80211_tag_bss_avb_adm_cap_bitmask_ac0,
    &hf_ieee80211_tag_bss_avb_adm_cap_bitmask_ac1,
    &hf_ieee80211_tag_bss_avb_adm_cap_bitmask_ac2,
    &hf_ieee80211_tag_bss_avb_adm_cap_bitmask_ac3,
    &hf_ieee80211_tag_bss_avb_adm_cap_bitmask_rsv,
    NULL
  };

  if (tag_len < 2) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "BSS Available Admission Capacity length %u wrong, must > = 2", tag_len);
    return offset;
  }

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_bss_avb_adm_cap_bitmask,
                                    ett_tag_bss_bitmask_tree, ieee80211_tag_bss_avb_adm_cap_bitmask,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  bitmask = tvb_get_letohs(tvb, offset);
  offset += 2;

  if(bitmask & BSS_BITMASK_UP0)
  {
    proto_tree_add_item(tree, hf_ieee80211_tag_bss_avb_adm_cap_up0, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }
  if(bitmask & BSS_BITMASK_UP1)
  {
    proto_tree_add_item(tree, hf_ieee80211_tag_bss_avb_adm_cap_up1, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }
  if(bitmask & BSS_BITMASK_UP2)
  {
    proto_tree_add_item(tree, hf_ieee80211_tag_bss_avb_adm_cap_up2, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }
  if(bitmask & BSS_BITMASK_UP3)
  {
    proto_tree_add_item(tree, hf_ieee80211_tag_bss_avb_adm_cap_up3, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }
  if(bitmask & BSS_BITMASK_UP4)
  {
    proto_tree_add_item(tree, hf_ieee80211_tag_bss_avb_adm_cap_up4, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }
  if(bitmask & BSS_BITMASK_UP5)
  {
    proto_tree_add_item(tree, hf_ieee80211_tag_bss_avb_adm_cap_up5, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }
  if(bitmask & BSS_BITMASK_UP6)
  {
    proto_tree_add_item(tree, hf_ieee80211_tag_bss_avb_adm_cap_up6, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }
  if(bitmask & BSS_BITMASK_UP7)
  {
    proto_tree_add_item(tree, hf_ieee80211_tag_bss_avb_adm_cap_up7, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }
  if(bitmask & BSS_BITMASK_AC0)
  {
    proto_tree_add_item(tree, hf_ieee80211_tag_bss_avb_adm_cap_ac0, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }
  if(bitmask & BSS_BITMASK_AC1)
  {
    proto_tree_add_item(tree, hf_ieee80211_tag_bss_avb_adm_cap_ac1, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }
  if(bitmask & BSS_BITMASK_AC2)
  {
    proto_tree_add_item(tree, hf_ieee80211_tag_bss_avb_adm_cap_ac2, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }
  if(bitmask & BSS_BITMASK_AC3)
  {
    proto_tree_add_item(tree, hf_ieee80211_tag_bss_avb_adm_cap_ac3, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }
  return offset;
}

static int
dissect_bss_ac_access_delay_ie(tvbuff_t *tvb, packet_info *pinfo,
                                    proto_tree *tree, int offset, uint32_t tag_len, proto_item *ti_len)
{

  if (tag_len != 4) {
    expert_add_info_format(pinfo, ti_len, &ei_ieee80211_tag_length,
                           "BSS AC Access Delay length %u wrong, must = 4", tag_len);
    return offset;
  }

  /* TODO: Display the scaled representation of the average
    medium access delay (a big (precalculed) value_string ?)
    See 8.4.2.46 BSS AC Access Delay element ... */

  proto_tree_add_item(tree, hf_ieee80211_tag_bss_avg_ac_access_delay_be, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_bss_avg_ac_access_delay_bk, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_bss_avg_ac_access_delay_vi, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_bss_avg_ac_access_delay_vo, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  return offset;
}

/* RM Enabled Capabilities (70) */
static int
dissect_rm_enabled_capabilities_ie(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  proto_item *ti_ex_cap;
  static int * const ieee80211_tag_rm_enabled_capabilities_octet1[] = {
    &hf_ieee80211_tag_rm_enabled_capabilities_b0,
    &hf_ieee80211_tag_rm_enabled_capabilities_b1,
    &hf_ieee80211_tag_rm_enabled_capabilities_b2,
    &hf_ieee80211_tag_rm_enabled_capabilities_b3,
    &hf_ieee80211_tag_rm_enabled_capabilities_b4,
    &hf_ieee80211_tag_rm_enabled_capabilities_b5,
    &hf_ieee80211_tag_rm_enabled_capabilities_b6,
    &hf_ieee80211_tag_rm_enabled_capabilities_b7,
    NULL
  };

  static int * const ieee80211_tag_rm_enabled_capabilities_octet2[] = {
    &hf_ieee80211_tag_rm_enabled_capabilities_b8,
    &hf_ieee80211_tag_rm_enabled_capabilities_b9,
    &hf_ieee80211_tag_rm_enabled_capabilities_b10,
    &hf_ieee80211_tag_rm_enabled_capabilities_b11,
    &hf_ieee80211_tag_rm_enabled_capabilities_b12,
    &hf_ieee80211_tag_rm_enabled_capabilities_b13,
    &hf_ieee80211_tag_rm_enabled_capabilities_b14,
    &hf_ieee80211_tag_rm_enabled_capabilities_b15,
    NULL
  };

  static int * const ieee80211_tag_rm_enabled_capabilities_octet3[] = {
    &hf_ieee80211_tag_rm_enabled_capabilities_b16,
    &hf_ieee80211_tag_rm_enabled_capabilities_b17,
    &hf_ieee80211_tag_rm_enabled_capabilities_b18to20,
    &hf_ieee80211_tag_rm_enabled_capabilities_b21to23,
    NULL
  };

  static int * const ieee80211_tag_rm_enabled_capabilities_octet4[] = {
    &hf_ieee80211_tag_rm_enabled_capabilities_b24to26,
    &hf_ieee80211_tag_rm_enabled_capabilities_b27,
    &hf_ieee80211_tag_rm_enabled_capabilities_b28,
    &hf_ieee80211_tag_rm_enabled_capabilities_b29,
    &hf_ieee80211_tag_rm_enabled_capabilities_b30,
    &hf_ieee80211_tag_rm_enabled_capabilities_b31,
    NULL
  };

  static int * const ieee80211_tag_rm_enabled_capabilities_octet5[] = {
    &hf_ieee80211_tag_rm_enabled_capabilities_b32,
    &hf_ieee80211_tag_rm_enabled_capabilities_b33,
    &hf_ieee80211_tag_rm_enabled_capabilities_b34,
    &hf_ieee80211_tag_rm_enabled_capabilities_b35,
    &hf_ieee80211_tag_rm_enabled_capabilities_o5,
    NULL
  };

  if (tag_len != 5)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "RM Enabled Capabilities length %u wrong, must = 5", tag_len);
    return 1;
  }
  proto_item_append_text(field_data->item_tag, " (%d octets)", tag_len);

  /* RM Enabled Capability octet 1 */
  ti_ex_cap = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_rm_enabled_capabilities,
                                    ett_tag_rm_cap1, ieee80211_tag_rm_enabled_capabilities_octet1,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  proto_item_append_text(ti_ex_cap, " (octet 1)");
  offset += 1;

  /* RM Enabled Capability octet 2 */
  ti_ex_cap = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_rm_enabled_capabilities,
                                    ett_tag_rm_cap2, ieee80211_tag_rm_enabled_capabilities_octet2,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  proto_item_append_text(ti_ex_cap, " (octet 2)");
  offset += 1;

  /* RM Enabled Capability octet 3 */
  ti_ex_cap = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_rm_enabled_capabilities,
                                    ett_tag_rm_cap3, ieee80211_tag_rm_enabled_capabilities_octet3,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  proto_item_append_text(ti_ex_cap, " (octet 3)");
  offset += 1;

  /* RM Enabled Capability octet 4 */
  ti_ex_cap = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_rm_enabled_capabilities,
                                    ett_tag_rm_cap4, ieee80211_tag_rm_enabled_capabilities_octet4,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  proto_item_append_text(ti_ex_cap, " (octet 4)");
  offset += 1;

  /* RM Enabled Capability octet 5 */
  ti_ex_cap = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_rm_enabled_capabilities,
                                    ett_tag_rm_cap5, ieee80211_tag_rm_enabled_capabilities_octet5,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  proto_item_append_text(ti_ex_cap, " (octet 5)");
  offset += 1;

  return offset;
}

/* Multiple BSSID (71) */
enum multiple_bssid_subelem_id {
  MULTIPLE_BSSID_SUBELEM_NO_BSSID_PROFILE = 0,
  MULTIPLE_BSSID_SUBELEM_VENDOR_SPECIFIC = 221
};

static const value_string multiple_bssid_subelem_ids[] = {
  { MULTIPLE_BSSID_SUBELEM_NO_BSSID_PROFILE, "Nontransmitted BSSID Profile" },
  { MULTIPLE_BSSID_SUBELEM_VENDOR_SPECIFIC, "Vendor Specific" },
  { 0, NULL }
};

static int
dissect_multiple_bssid_ie(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  unsigned tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  unsigned offset = 0;
  uint8_t sub_tag_id, sub_tag_len;
  const char *sub_tag_name;
  proto_tree *sub_tag_tree;
  const uint8_t valid_ids[] = { TAG_VENDOR_SPECIFIC_IE };
  const uint8_t invalid_ids[] = { TAG_TIM, TAG_DS_PARAMETER, TAG_IBSS_PARAMETER,
    TAG_COUNTRY_INFO, TAG_CHANNEL_SWITCH_ANN, TAG_EXTENDED_CHANNEL_SWITCH_ANNOUNCEMENT,
    TAG_WIDE_BW_CHANNEL_SWITCH, TAG_TX_PWR_ENVELOPE, TAG_SUPPORTED_OPERATING_CLASSES, TAG_IBSS_DFS,
    TAG_ERP_INFO, TAG_ERP_INFO_OLD, TAG_HT_CAPABILITY, TAG_HT_INFO, TAG_VHT_CAPABILITY,
    TAG_VHT_OPERATION, TAG_S1G_BEACON_COMPATIBILITY, TAG_SHORT_BEACON_INTERVAL,
    TAG_S1G_CAPABILITIES, TAG_S1G_OPERATION };
  const uint8_t invalid_ext_ids[] = { ETAG_HE_CAPABILITIES, ETAG_HE_OPERATION,
    ETAG_HE_6GHZ_BAND_CAPABILITIES, ETAG_BSS_COLOR_CHANGE_ANNOUNCEMENT, ETAG_SPATIAL_REUSE_PARAMETER_SET };
  uint32_t s_offset, s_end;

  if (tag_len < 1)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Multiple BSSID length %u wrong, must be at least 1", tag_len);
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_multiple_bssid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset++;

  /* Optional sub-elements */

  while (offset + 1 < tag_len) {
    sub_tag_id = tvb_get_uint8(tvb, offset);
    sub_tag_len = tvb_get_uint8(tvb, offset + 1);
    sub_tag_name = val_to_str_const(sub_tag_id, multiple_bssid_subelem_ids, "Unknown");

    sub_tag_tree = proto_tree_add_subtree_format(tree, tvb, offset, sub_tag_len + 2, ett_tag_multiple_bssid_subelem_tree, NULL, "Subelement: %s", sub_tag_name);

    proto_tree_add_item(sub_tag_tree, hf_ieee80211_tag_multiple_bssid_subelem_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(sub_tag_tree, hf_ieee80211_tag_multiple_bssid_subelem_len, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    if (offset + sub_tag_len > tag_len) {
      expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length, "Not enough data for subelement");
      break;
    }

    switch (sub_tag_id)
    {
    case MULTIPLE_BSSID_SUBELEM_NO_BSSID_PROFILE:
      proto_tree_add_item(sub_tag_tree, hf_ieee80211_tag_multiple_bssid_subelem_nontrans_profile, tvb, offset, sub_tag_len, ENC_NA);

      s_offset = offset;
      s_end = offset + sub_tag_len;
      beacon_padding = 0; /* this is for the beacon padding confused with ssid fix */
      while (s_offset < s_end) {
        int tlen = add_tagged_field_with_validation(pinfo, sub_tag_tree, tvb, s_offset, 0,
          invalid_ids, G_N_ELEMENTS(invalid_ids), true,
          invalid_ext_ids, G_N_ELEMENTS(invalid_ext_ids), true, NULL);
        if (tlen==0)
          break;
        s_offset += tlen;
      }

      break;

    case MULTIPLE_BSSID_SUBELEM_VENDOR_SPECIFIC:
      /*
       * add_tagged_field will insert expert info if there is a problem so
       * we ignore the return value.
       */
      add_tagged_field(pinfo, sub_tag_tree, tvb, offset, 0, valid_ids, G_N_ELEMENTS(valid_ids), NULL);
      break;

    default:
      /* RESERVED */
      proto_tree_add_item(sub_tag_tree, hf_ieee80211_tag_multiple_bssid_subelem_reserved, tvb, offset, sub_tag_len, ENC_NA);
      break;
    }

    offset += sub_tag_len;

  }

  if (offset < tag_len) {
    proto_tree_add_expert_format(tree, pinfo, &ei_ieee80211_extra_data,
      tvb, offset, tag_len - offset, "Extra data after subelements");
  }

  return tvb_captured_length(tvb);
}

/* 20/40 BSS Coexistence (72) */
static int
dissect_20_40_bss_coexistence(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  static int * const ieee80211_20_40_bss_coexistence_fields[] = {
    &hf_ieee80211_tag_20_40_bc_information_request,
    &hf_ieee80211_tag_20_40_bc_forty_mhz_intolerant,
    &hf_ieee80211_tag_20_40_bc_20_mhz_bss_width_request,
    &hf_ieee80211_tag_20_40_bc_obss_scanning_exemption_request,
    &hf_ieee80211_tag_20_40_bc_obss_scanning_exemption_grant,
    &hf_ieee80211_tag_20_40_bc_reserved,
    NULL
  };

  if (tag_len != 1)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "20/40 BSS Coexistence length %u wrong, must = 1", tag_len);
    return 1;
  }

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_20_40_bc,
                                    ett_tag_20_40_bc, ieee80211_20_40_bss_coexistence_fields,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);

  offset += 1;

  return offset;
}

/* 20/40 BSS Intolerant Channel Report (73) */
static int
dissect_20_40_bss_intolerant(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  proto_item *intolerant_item;
  proto_tree *intolerant_tree;
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  int channel_report_size = tag_len - 1; // minus regulator_class field
  int i;

  if (tag_len < 2) {
      expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                             "20/40 BSS Intolerant Channel Report length %u wrong, must > 1", tag_len);
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_intolerant_operating_class, tvb, offset, 1, ENC_NA);
  offset += 1;

  intolerant_item = proto_tree_add_item(tree, hf_ieee80211_tag_intolerant_channel_list, tvb, offset, channel_report_size, ENC_NA);
  intolerant_tree = proto_item_add_subtree(intolerant_item, ett_tag_intolerant_tree);
  for (i = 0; i < channel_report_size; i++)
  {
    proto_tree_add_item(intolerant_tree, hf_ieee80211_tag_intolerant_channel, tvb, offset, 1, ENC_NA);
    offset += 1;
  }

  return offset;
}

static int
dissect_ht_capability_ie_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset,
                         uint32_t tag_len, proto_item *ti_len, bool vendorspecific)
{
  proto_item *cap_item, *ti;
  proto_tree *cap_tree;
  static int * const ieee80211_ht[] = {
    &hf_ieee80211_ht_ldpc_coding,
    &hf_ieee80211_ht_chan_width,
    &hf_ieee80211_ht_sm_pwsave,
    &hf_ieee80211_ht_green,
    &hf_ieee80211_ht_short20,
    &hf_ieee80211_ht_short40,
    &hf_ieee80211_ht_tx_stbc,
    &hf_ieee80211_ht_rx_stbc,
    &hf_ieee80211_ht_delayed_block_ack,
    &hf_ieee80211_ht_max_amsdu,
    &hf_ieee80211_ht_dss_cck_40,
    &hf_ieee80211_ht_psmp,
    &hf_ieee80211_ht_40_mhz_intolerant,
    &hf_ieee80211_ht_l_sig,
    NULL
  };

  static int * const ieee80211_htex[] = {
    &hf_ieee80211_htex_pco,
    &hf_ieee80211_htex_transtime,
    &hf_ieee80211_htex_mcs,
    &hf_ieee80211_htex_htc_support,
    &hf_ieee80211_htex_rd_responder,
    NULL
  };

  static int * const ieee80211_txbf[] = {
    &hf_ieee80211_txbf_cap,
    &hf_ieee80211_txbf_rcv_ssc,
    &hf_ieee80211_txbf_tx_ssc,
    &hf_ieee80211_txbf_rcv_ndp,
    &hf_ieee80211_txbf_tx_ndp,
    &hf_ieee80211_txbf_impl_txbf,
    &hf_ieee80211_txbf_calib,
    &hf_ieee80211_txbf_expl_csi,
    &hf_ieee80211_txbf_expl_uncomp_fm,
    &hf_ieee80211_txbf_expl_comp_fm,
    &hf_ieee80211_txbf_expl_bf_csi,
    &hf_ieee80211_txbf_expl_uncomp_fm_feed,
    &hf_ieee80211_txbf_expl_comp_fm_feed,
    &hf_ieee80211_txbf_min_group,
    &hf_ieee80211_txbf_csi_num_bf_ant,
    &hf_ieee80211_txbf_uncomp_sm_bf_ant,
    &hf_ieee80211_txbf_comp_sm_bf_ant,
    &hf_ieee80211_txbf_csi_max_rows_bf,
    &hf_ieee80211_txbf_chan_est,
    &hf_ieee80211_txbf_resrv,
    NULL
  };

  static int * const ieee80211_antsel[] = {
    &hf_ieee80211_antsel_b0,
    &hf_ieee80211_antsel_b1,
    &hf_ieee80211_antsel_b2,
    &hf_ieee80211_antsel_b3,
    &hf_ieee80211_antsel_b4,
    &hf_ieee80211_antsel_b5,
    &hf_ieee80211_antsel_b6,
    &hf_ieee80211_antsel_b7,
    NULL
  };

  if (tag_len != 26) {
    expert_add_info_format(pinfo, ti_len, &ei_ieee80211_tag_length,
                           "HT Capabilities IE length %u wrong, must be = 26", tag_len);
    return (offset > 0) ? offset : 1;
  }

  if (wlan_ignore_draft_ht && vendorspecific)
    return (offset > 0) ? offset : 1;

  /* 2 byte HT Capabilities  Info*/
  if (vendorspecific)
  {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ht_vs_cap,
                                    ett_ht_cap_tree, ieee80211_ht,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  }
  else
  {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ht_cap,
                                    ett_ht_cap_tree, ieee80211_ht,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  }
  offset += 2;

  /* 1 byte A-MPDU Parameters */
  if (vendorspecific)
  {
    cap_item = proto_tree_add_item(tree, hf_ieee80211_ampduparam_vs, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  } else
  {
    cap_item = proto_tree_add_item(tree, hf_ieee80211_ampduparam, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  }
  cap_tree = proto_item_add_subtree(cap_item, ett_ampduparam_tree);
  ti = proto_tree_add_item(cap_tree, hf_ieee80211_ampduparam_mpdu, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(ti, " (%04.0f[Bytes])", pow(2, 13+(tvb_get_uint8(tvb, offset) & 0x3))-1);
  proto_tree_add_item(cap_tree, hf_ieee80211_ampduparam_mpdu_start_spacing, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(cap_tree, hf_ieee80211_ampduparam_reserved, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  /* 16 byte MCS set */
  offset = dissect_mcs_set(tree, tvb, offset, false, vendorspecific);


  /* 2 byte HT Extended Capabilities */
  if (vendorspecific)
  {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_htex_vs_cap,
                                    ett_htex_cap_tree, ieee80211_htex,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  } else {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_htex_cap,
                                    ett_htex_cap_tree, ieee80211_htex,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  }
  offset += 2;


  /* 4 byte TxBF capabilities */
  if (vendorspecific)
  {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_txbf_vs,
                                    ett_txbf_tree, ieee80211_txbf,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  } else {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_txbf,
                                    ett_txbf_tree, ieee80211_txbf,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  }
  offset += 4;

  /* 1 byte Antenna Selection (ASEL) capabilities */
  if (vendorspecific)
  {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_antsel_vs,
                                    ett_antsel_tree, ieee80211_antsel,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  }
  else
  {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_antsel,
                                    ett_antsel_tree, ieee80211_antsel,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  }
  offset += 1;

  return offset;
}

static int
dissect_ht_capability_ie(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;

  return dissect_ht_capability_ie_common(tvb, pinfo, tree, 0, tvb_reported_length(tvb),
            field_data->item_tag_length, false);
}

static int
dissect_ht_info_ie_1_0(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset,
                       uint32_t tag_len, proto_item *ti_len)
{
  static int * const ieee80211_hta1[] = {
    &hf_ieee80211_hta_ext_chan_offset,
    &hf_ieee80211_hta_rec_tx_width,
    &hf_ieee80211_hta_rifs_mode,
    &hf_ieee80211_hta_controlled_access,
    &hf_ieee80211_hta_service_interval,
    NULL
  };

  static int * const ieee80211_hta2[] = {
    &hf_ieee80211_hta_operating_mode,
    &hf_ieee80211_hta_non_gf_devices,
    NULL
  };

  static int * const ieee80211_hta3[] = {
    &hf_ieee80211_hta_basic_stbc_mcs,
    &hf_ieee80211_hta_dual_stbc_protection,
    &hf_ieee80211_hta_secondary_beacon,
    &hf_ieee80211_hta_lsig_txop_protection,
    &hf_ieee80211_hta_pco_active,
    &hf_ieee80211_hta_pco_phase,
    NULL
  };

  if (tag_len != 22) {
    expert_add_info_format(pinfo, ti_len, &ei_ieee80211_tag_length,
                           "Tag length %u wrong, must be = 22", tag_len);
    return offset;
  }

  if (wlan_ignore_draft_ht)
    return offset;

  /* 1 HT Control Channel */
  proto_tree_add_item(tree, hf_ieee80211_hta_cc, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  /* 1 byte HT additional capabilities */
  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_hta_cap1,
                                    ett_hta_cap_tree, ieee80211_hta1,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  /* 2 byte HT additional capabilities */
  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_hta_cap2,
                                    ett_hta_cap1_tree, ieee80211_hta2,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;

  /* 2 byte HT additional capabilities */
  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_hta_cap2,
                                    ett_hta_cap2_tree, ieee80211_hta3,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;

  /* 16 byte Supported MCS set */
  offset = dissect_mcs_set(tree, tvb, offset, false, true);

  return offset;
}

/* 802.11n-D1.10 and 802.11n-D2.0, 7.1.3.5a */

/*
 * IEEE 802.11-2016 section 9.2.4.6 "HT Control field" says that B0 of
 * the field is 0 for HT and 1 for VHT, bits B1 through B29 are the
 * "HT Control Middle" subfield, the format of which differs between
 * HT and VHT, bit B30 is the "AC Constraint" subfield, and bit B31
 * is the "RDG/More PPDU" subfield.
 *
 * 802.11ax changes the meaning of the first two bits:
 *
 *     B0 = 0         means High Throughput
 *     B0 = 1, B1 = 0 means Very High Throughput
 *     B0 = 1, B1 = 1 means High Efficiency
 *
 * taking a reserved bit from the VHT version of the "HT Control Middle"
 * field.
 */
#define A_CONTROL_TRS 0
#define A_CONTROL_OM   1
#define A_CONTROL_HLA  2
#define A_CONTROL_BSR  3
#define A_CONTROL_UPH  4
#define A_CONTROL_BQR  5
#define A_CONTROL_CCI  6
#define A_CONTROL_EHT_OM 7
#define A_CONTROL_SRS 8
#define A_CONTROL_AAR 9
#define A_CONTROL_ONES 15

static const value_string a_control_control_id_vals[] = {
  { A_CONTROL_TRS,  "Triggered response scheduling" },
  { A_CONTROL_OM,   "Operating mode" },
  { A_CONTROL_HLA,  "HE link adaptation" },
  { A_CONTROL_BSR,  "Buffer status report" },
  { A_CONTROL_UPH,  "UL power headroom" },
  { A_CONTROL_BQR,  "Bandwidth query report" },
  { A_CONTROL_CCI,  "Command Control Indication" },
  { A_CONTROL_EHT_OM, "EHT operating mode" },
  { A_CONTROL_SRS,  "Single response scheduling" },
  { A_CONTROL_AAR,  "AP assistance request" },
  { A_CONTROL_ONES,  "Ones need expansion surely" },
  { 0, NULL }
};

/*
 * Print the UL target RSSI field as per the spec.
 *  0->30 map to -90 to -30 dBm.
 *  31 maps to Max ransmit power
 */
static void
ul_target_rssi_base_custom(char *result, uint32_t target_rssi)
{
  if (target_rssi <= 30) {
    snprintf(result, ITEM_LABEL_LENGTH, "%ddBm", -90 + (2 * target_rssi));
  } else if (target_rssi == 31) {
    snprintf(result, ITEM_LABEL_LENGTH, "Max transmit power");
  }
}

static void
dissect_a_control_padding(proto_tree *tree, tvbuff_t *tvb, int offset,
  uint32_t bits _U_, uint32_t start_bit)
{
  proto_tree *trs_tree = NULL;
  unsigned the_bits = (tvb_get_letohl(tvb, offset) >> start_bit) & 0x03FFFFFF;
  unsigned offset_in_bits = (offset << 3) + start_bit;

  /*
   * We isolated the bits and moved them to the bottom ... so display them
   */
  trs_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4,
                                ett_ieee80211_a_control_padding,
                                NULL, "Padding: 0x%x(%u bits)", the_bits, 32 - start_bit);

  proto_tree_add_bits_item(trs_tree, hf_ieee80211_he_a_control_padding, tvb, offset_in_bits,
                           32 - start_bit, ENC_LITTLE_ENDIAN);
}

static void
dissect_a_control_ones(proto_tree *tree, tvbuff_t *tvb, int offset,
  uint32_t bits _U_, uint32_t start_bit)
{
  proto_tree *trs_tree = NULL;
  unsigned the_bits = (tvb_get_letohl(tvb, offset) >> start_bit) & 0x03FFFFFF;

  /*
   * We isolated the bits and moved them to the bottom ... so display them
   */
  trs_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4,
                                ett_ieee80211_a_control_ones,
                                NULL, "ONES: 0x%0x", the_bits);

  proto_tree_add_uint(trs_tree, hf_ieee80211_he_a_control_ones, tvb,
                        offset, 4, the_bits);
}

static void
dissect_a_control_trs(proto_tree *tree, tvbuff_t *tvb, int offset,
  uint32_t bits _U_, uint32_t start_bit)
{
  proto_tree *trs_tree = NULL;
  unsigned the_bits = (tvb_get_letohl(tvb, offset) >> start_bit) & 0x03FFFFFF;

  /*
   * We isolated the bits and moved them to the bottom ... so display them
   */
  trs_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4,
                                ett_ieee80211_triggered_response_schedule,
                                NULL, "TRS Control: 0x%08x", the_bits);

  proto_tree_add_uint(trs_tree, hf_ieee80211_he_trs_he_tb_ppdu_len, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(trs_tree, hf_ieee80211_he_trs_ru_allocation, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(trs_tree, hf_ieee80211_he_dl_tx_power, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(trs_tree, hf_ieee80211_he_ul_target_rssi, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(trs_tree, hf_ieee80211_he_ul_mcs, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(trs_tree, hf_ieee80211_he_ul_reserved, tvb,
                        offset, 4, the_bits);
}

static void
dissect_a_control_om(proto_tree *tree, tvbuff_t *tvb, int offset,
  uint32_t bits _U_, uint32_t start_bit)
{
  proto_tree *om_tree = NULL;
  unsigned the_bits = (tvb_get_letohl(tvb, offset) >> start_bit) & 0x0000003FF;

  /*
   * We isolated the bits and moved them to the bottom ... so display them
   */
  om_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4,
                                ett_ieee80211_control_om,
                                NULL, "OM Control: 0x%04x", the_bits);

  proto_tree_add_uint(om_tree, hf_ieee80211_he_om_rx_nss, tvb,
                      offset, 4, the_bits);
  proto_tree_add_uint(om_tree, hf_ieee80211_he_om_channel_width, tvb,
                      offset, 4, the_bits);
  proto_tree_add_boolean(om_tree, hf_ieee80211_he_om_ul_mu_disable, tvb,
                         offset, 4, the_bits);
  proto_tree_add_uint(om_tree, hf_ieee80211_he_om_tx_nsts, tvb,
                      offset, 4, the_bits);
  proto_tree_add_boolean(om_tree, hf_ieee80211_he_om_er_su_disable, tvb,
                         offset, 4, the_bits);
  proto_tree_add_boolean(om_tree, hf_ieee80211_he_om_dl_mu_mimo_resound, tvb,
                         offset, 4, the_bits);
  proto_tree_add_boolean(om_tree, hf_ieee80211_he_om_ul_mu_data_disable, tvb,
                         offset, 4, the_bits);
}

static const true_false_string he_hla_tx_bf_tfs = {
  "beamformed PPDU",
  "non-beamformed PPDU"
};

static void
dissect_a_control_hla(proto_tree *tree, tvbuff_t *tvb, int offset,
  uint32_t bits _U_, uint32_t start_bit)
{
  proto_tree *hla_tree = NULL;
  unsigned the_bits = (tvb_get_letohl(tvb, offset) >> start_bit) & 0x03FFFFFF;

  /*
   * We isolated the bits and moved them to the bottom ... so display them
   */
  hla_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4,
                                ett_ieee80211_hla_control,
                                NULL, "HLA Control: 0x%08x", the_bits);

  proto_tree_add_boolean(hla_tree, hf_ieee80211_he_hla_unsolicited_mfb, tvb,
                        offset, 4, the_bits);
  proto_tree_add_boolean(hla_tree, hf_ieee80211_he_hla_mrq, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(hla_tree, hf_ieee80211_he_hla_nss, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(hla_tree, hf_ieee80211_he_hla_he_mcs, tvb,
                        offset, 4, the_bits);
  proto_tree_add_boolean(hla_tree, hf_ieee80211_he_hla_dcm, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(hla_tree, hf_ieee80211_he_hla_ru, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(hla_tree, hf_ieee80211_he_hla_bw, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(hla_tree, hf_ieee80211_he_hla_msi_ppdu_type, tvb,
                        offset, 4, the_bits);
  proto_tree_add_boolean(hla_tree, hf_ieee80211_he_hla_tx_bf, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(hla_tree, hf_ieee80211_he_hla_reserved, tvb,
                        offset, 4, the_bits);
}

static void
dissect_a_control_bsr(proto_tree *tree, tvbuff_t *tvb, int offset,
  uint32_t bits _U_, uint32_t start_bit)
{
  proto_tree *bsr_tree = NULL;
  unsigned the_bits = (tvb_get_letohl(tvb, offset) >> start_bit) & 0x03FFFFFF;

  /*
   * We isolated the bits and moved them to the bottom ... so display them
   */
  bsr_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4,
                                ett_ieee80211_buffer_status_report,
                                NULL, "Buffer Status Report: 0x%08x", the_bits);

  proto_tree_add_uint(bsr_tree, hf_ieee80211_he_bsr_aci_bitmap, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(bsr_tree, hf_ieee80211_he_bsr_delta_tid, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(bsr_tree, hf_ieee80211_he_bsr_aci_high, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(bsr_tree, hf_ieee80211_he_bsr_scaling_factor, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(bsr_tree, hf_ieee80211_he_bsr_queue_size_high, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(bsr_tree, hf_ieee80211_he_bsr_queue_size_all, tvb,
                        offset, 4, the_bits);
}

static void
dissect_a_control_uph(proto_tree *tree, tvbuff_t *tvb, int offset,
  uint32_t bits _U_, uint32_t start_bit)
{
  proto_tree *uph_tree = NULL;
  unsigned the_bits = (tvb_get_letohl(tvb, offset) >> start_bit) & 0x000000FF;

  /*
   * We isolated the bits and moved them to the bottom ... so display them
   */
  uph_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4,
                                ett_ieee80211_control_uph,
                                NULL, "UPH Control: 0x%02x", the_bits);

  proto_tree_add_uint(uph_tree, hf_ieee80211_he_uph_ul_power_headroom, tvb,
                        offset, 4, the_bits);
  proto_tree_add_boolean(uph_tree, hf_ieee80211_he_uph_ul_min_transmit_power_flag,
                        tvb, offset, 4, the_bits);
  proto_tree_add_uint(uph_tree, hf_ieee80211_he_uph_reserved,
                        tvb, offset, 4, the_bits);
}

static void
dissect_a_control_bqr(proto_tree *tree, tvbuff_t *tvb, int offset,
  uint32_t bits _U_, uint32_t start_bit)
{
  proto_tree *bqr_tree = NULL;
  unsigned the_bits = (tvb_get_letohl(tvb, offset) >> start_bit) & 0x03FF;

  /*
   * We isolated the bits and moved them to the bottom ... so display them
   */
  bqr_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4,
                                ett_ieee80211_buffer_control_bqr,
                                NULL, "BQR Control: 0x%04x", the_bits);

  proto_tree_add_uint(bqr_tree, hf_ieee80211_he_btc_avail_chan, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(bqr_tree, hf_ieee80211_he_btc_reserved, tvb,
                        offset, 4, the_bits);
}

static void
dissect_a_control_cci(proto_tree *tree, tvbuff_t *tvb, int offset,
  uint32_t bits _U_, uint32_t start_bit)
{
  proto_tree *cci_tree = NULL;
  unsigned the_bits = (tvb_get_letohl(tvb, offset) >> start_bit) & 0x000000FF;

  /*
   * We isolated the bits and moved them to the bottom ... so display them
   */
  cci_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4,
                                ett_ieee80211_control_cci,
                                NULL, "Command and status: 0x%02x", the_bits);

  proto_tree_add_boolean(cci_tree, hf_ieee80211_he_cci_ac_constraint, tvb,
                        offset, 4, the_bits);
  proto_tree_add_boolean(cci_tree, hf_ieee80211_he_cci_rdg_more_ppdu, tvb,
                        offset, 4, the_bits);
  proto_tree_add_boolean(cci_tree, hf_ieee80211_he_cci_sr_ppdu_indic, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(cci_tree, hf_ieee80211_he_cci_reserved, tvb,
                        offset, 4, the_bits);
}

static void
dissect_a_control_eht_om(proto_tree *tree, tvbuff_t *tvb, int offset,
  uint32_t bits _U_, uint32_t start_bit)
{
  proto_tree *eht_om_tree = NULL;
  unsigned the_bits = (tvb_get_letohl(tvb, offset) >> start_bit) & 0x0000003F;

  /*
   * We isolated the bits and moved them to the bottom ... so display them
   */
  eht_om_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4,
                                ett_ieee80211_control_eht_om,
                                NULL, "EHT operating mode: 0x%02x", the_bits);
  proto_tree_add_boolean(eht_om_tree, hf_ieee80211_he_eht_om_rx_nss_ext, tvb,
                         offset, 4, the_bits);
  proto_tree_add_boolean(eht_om_tree, hf_ieee80211_he_eht_om_chan_w_ext, tvb,
                         offset, 4, the_bits);
  proto_tree_add_boolean(eht_om_tree, hf_ieee80211_he_eht_om_tx_nsts_ext, tvb,
                         offset, 4, the_bits);
  proto_tree_add_uint(eht_om_tree, hf_ieee80211_he_eht_om_reserved, tvb,
                        offset, 4, the_bits);

}

static void
dissect_a_control_srs(proto_tree *tree, tvbuff_t *tvb, int offset,
  uint32_t bits _U_, uint32_t start_bit)
{
  proto_tree *srs_tree = NULL;
  unsigned the_bits = (tvb_get_letohl(tvb, offset) >> start_bit) & 0x000003FF;

  srs_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4,
                                ett_ieee80211_control_srs,
                                NULL, "Simple response scheduling: 0x%02x",
                                the_bits);
  proto_tree_add_uint(srs_tree, hf_ieee80211_he_srs_ppdu_resp_dur, tvb,
                        offset, 4, the_bits);
  proto_tree_add_uint(srs_tree, hf_ieee80211_he_srs_reserved, tvb, offset, 4,
                      the_bits);
}

static void
dissect_a_control_aar(proto_tree *tree, tvbuff_t *tvb, int offset,
  uint32_t bits _U_, uint32_t start_bit)
{
  proto_tree *aar_tree = NULL;
  unsigned the_bits = (tvb_get_letohl(tvb, offset) >> start_bit) & 0x000FFFFF;

  aar_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4,
                                ett_ieee80211_control_aar,
                                NULL, "AP assistance request: 0x%02x",
                                the_bits);
  proto_tree_add_uint(aar_tree, hf_ieee80211_he_aar_assisted_ap_bitmap, tvb,
                      offset, 4, the_bits);
  proto_tree_add_uint(aar_tree, hf_ieee80211_he_aar_reserved, tvb, offset, 4,
                      the_bits);
}

static void
dissect_ht_control(packet_info* pinfo, proto_tree *tree, tvbuff_t *tvb, int offset)
{
  proto_item *ti;
  proto_tree *htc_tree, *lac_subtree, *mfb_subtree;
  uint32_t htc;

  htc = tvb_get_letohl(tvb, offset);

  ti = proto_tree_add_item(tree, hf_ieee80211_htc, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  htc_tree = proto_item_add_subtree(ti, ett_htc_tree);

  /* Check the HT vs. VHT bit. */
  proto_tree_add_item(htc_tree, hf_ieee80211_htc_vht, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  if (htc & HTC_VHT) {
    /* VHT or HE */
    proto_tree_add_item(htc_tree, hf_ieee80211_htc_he, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    if (htc & HTC_HE) {
      /*
       * We have a 30-bit field, of which the first is a 4-bit Control ID which
       * determines how the rest is handled. There can be multiple fields.
       */
      proto_tree *a_control_tree = NULL;
      proto_item *pi = NULL;
      uint8_t start_bit_offset = 2;

      a_control_tree = proto_tree_add_subtree_format(htc_tree, tvb, offset, 4,
                                ett_htc_he_a_control, NULL,
                                "Aggregate Control: 0x%0x", htc >> 2);
      while (start_bit_offset < 32) {
        /* No enough space for Control ID */
        if (start_bit_offset >= 28) {
            dissect_a_control_padding(a_control_tree, tvb, offset, htc,
                                      start_bit_offset);
            break;
        }
        uint8_t control_id = (htc >> start_bit_offset) & 0x0F;
        start_bit_offset += 4;
        if (control_id != 0 || start_bit_offset == 6) {
          pi = proto_tree_add_uint(a_control_tree, hf_ieee80211_htc_he_ctrl_id,
                        tvb, offset, 4, control_id);
          proto_item_append_text(pi, ": %s",
                        val_to_str(control_id, a_control_control_id_vals,
                                        "Reserved (%u)"));
        }
        if (start_bit_offset > 31) {
          expert_add_info(pinfo, a_control_tree, &ei_ieee80211_invalid_control_word);
          break;
        }
        switch (control_id) {
        case A_CONTROL_TRS:
          /*
           * Padding looks like TRS ... so distinguish. If there are not
           * enough bits left it must be padding
           */
          if (start_bit_offset == 6)
            dissect_a_control_trs(a_control_tree, tvb, offset, htc,
                                  start_bit_offset);
          else
            dissect_a_control_padding(a_control_tree, tvb, offset, htc,
                                      start_bit_offset - 4);
          start_bit_offset += 26;
          break;
        case A_CONTROL_OM:
          dissect_a_control_om(a_control_tree, tvb, offset, htc,
                               start_bit_offset);
          start_bit_offset += 12;
          break;
        case A_CONTROL_HLA:
          dissect_a_control_hla(a_control_tree, tvb, offset, htc,
                                start_bit_offset);
          start_bit_offset += 26;
          break;
        case A_CONTROL_BSR:
          dissect_a_control_bsr(a_control_tree, tvb, offset, htc,
                                start_bit_offset);
          start_bit_offset += 26;
          break;
        case A_CONTROL_UPH:
          dissect_a_control_uph(a_control_tree, tvb, offset, htc,
                                start_bit_offset);
          start_bit_offset += 8;
          break;
        case A_CONTROL_BQR:
          dissect_a_control_bqr(a_control_tree, tvb, offset, htc,
                                start_bit_offset);
          start_bit_offset += 10;
          break;
        case A_CONTROL_CCI:
          dissect_a_control_cci(a_control_tree, tvb, offset, htc,
                                start_bit_offset);
          start_bit_offset += 8;
          break;
        case A_CONTROL_EHT_OM:
          dissect_a_control_eht_om(a_control_tree, tvb, offset, htc,
                                   start_bit_offset);
          start_bit_offset += 6;
          break;
        case A_CONTROL_SRS:
          dissect_a_control_srs(a_control_tree, tvb, offset, htc,
                                start_bit_offset);
          start_bit_offset += 10;
          break;
        case A_CONTROL_AAR:
          dissect_a_control_aar(a_control_tree, tvb, offset, htc,
                                start_bit_offset);
          start_bit_offset += 20;
          break;
        case A_CONTROL_ONES:
          if (start_bit_offset == 6) {
            dissect_a_control_ones(a_control_tree, tvb, offset, htc,
                                   start_bit_offset);
          } else {
            expert_add_info(pinfo, a_control_tree, &ei_ieee80211_invalid_control_length);
          }
          start_bit_offset += 26;
          break;
        default:
          expert_add_info(pinfo, a_control_tree, &ei_ieee80211_invalid_control_id);
          start_bit_offset += 32;  /* Abandon */
          break;
        }
      }
    } else {
      proto_tree_add_item(htc_tree, hf_ieee80211_htc_mrq, tvb, offset, 4, ENC_LITTLE_ENDIAN);
      if (!(htc & HTC_UNSOLICITED_MFB)) {
        if (htc & HTC_MRQ) {
          proto_tree_add_item(htc_tree, hf_ieee80211_htc_msi, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        } else {
          proto_tree_add_item(htc_tree, hf_ieee80211_htc_msi_stbc_reserved, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        }
        proto_tree_add_item(htc_tree, hf_ieee80211_htc_mfsi, tvb, offset, 4, ENC_LITTLE_ENDIAN);
      } else {
        if (!HTC_NO_FEEDBACK_PRESENT(HTC_MFB(htc))) {
          proto_tree_add_item(htc_tree, hf_ieee80211_htc_compressed_msi, tvb, offset, 4, ENC_LITTLE_ENDIAN);
          proto_tree_add_item(htc_tree, hf_ieee80211_htc_ppdu_stbc_encoded, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        } else {
          proto_tree_add_item(htc_tree, hf_ieee80211_htc_msi_stbc_reserved, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        }
        proto_tree_add_item(htc_tree, hf_ieee80211_htc_gid_l, tvb, offset, 4, ENC_LITTLE_ENDIAN);
      }
      ti = proto_tree_add_item(htc_tree, hf_ieee80211_htc_mfb, tvb, offset, 4, ENC_LITTLE_ENDIAN);
      mfb_subtree = proto_item_add_subtree(ti, ett_mfb_subtree);
      proto_tree_add_item(mfb_subtree, hf_ieee80211_htc_num_sts, tvb, offset, 4, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(mfb_subtree, hf_ieee80211_htc_vht_mcs, tvb, offset, 4, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(mfb_subtree, hf_ieee80211_htc_bw, tvb, offset, 4, ENC_LITTLE_ENDIAN);
      /* This should be converted to dB by adding 22  */
      proto_tree_add_item(mfb_subtree, hf_ieee80211_htc_snr, tvb, offset, 4, ENC_LITTLE_ENDIAN);
      if (!HTC_NO_FEEDBACK_PRESENT(HTC_MFB(htc))) {
        proto_tree_add_item(htc_tree, hf_ieee80211_htc_gid_h, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(htc_tree, hf_ieee80211_htc_coding_type, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(htc_tree, hf_ieee80211_htc_fb_tx_type, tvb, offset, 4, ENC_LITTLE_ENDIAN);
      } else {
        proto_tree_add_item(htc_tree, hf_ieee80211_htc_reserved3, tvb, offset, 4, ENC_LITTLE_ENDIAN);
      }
      proto_tree_add_item(htc_tree, hf_ieee80211_htc_unsolicited_mfb, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    }
  } else {
    /* Start: Link Adaptation Control */
    ti = proto_tree_add_item(htc_tree, hf_ieee80211_htc_ht_lac, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    lac_subtree = proto_item_add_subtree(ti, ett_lac_subtree);
    proto_tree_add_item(lac_subtree, hf_ieee80211_htc_lac_trq, tvb, offset, 2, ENC_LITTLE_ENDIAN);

    if (HTC_IS_ASELI(htc)) {
      proto_tree_add_item(lac_subtree, hf_ieee80211_htc_lac_mai_aseli, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    } else {
      proto_tree_add_item(lac_subtree, hf_ieee80211_htc_lac_mai_mrq, tvb, offset, 2, ENC_LITTLE_ENDIAN);
      if (HTC_LAC_MAI_MRQ(htc)) {
        proto_tree_add_item(lac_subtree, hf_ieee80211_htc_lac_mai_msi, tvb, offset, 2, ENC_LITTLE_ENDIAN);
      } else {
        proto_tree_add_item(lac_subtree, hf_ieee80211_htc_lac_mai_reserved, tvb, offset, 2, ENC_LITTLE_ENDIAN);
      }
    }

    proto_tree_add_item(lac_subtree, hf_ieee80211_htc_lac_mfsi, tvb, offset, 2, ENC_LITTLE_ENDIAN);

    if (HTC_IS_ASELI(htc)) {
      proto_tree_add_item(lac_subtree, hf_ieee80211_htc_lac_asel_command, tvb, offset, 2, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(lac_subtree, hf_ieee80211_htc_lac_asel_data, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    } else {
      proto_tree_add_item(lac_subtree, hf_ieee80211_htc_lac_mfb, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    }
    /* End: Link Adaptation Control */

    proto_tree_add_item(htc_tree, hf_ieee80211_htc_cal_pos, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(htc_tree, hf_ieee80211_htc_cal_seq, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(htc_tree, hf_ieee80211_htc_reserved1, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(htc_tree, hf_ieee80211_htc_csi_steering, tvb, offset, 4, ENC_LITTLE_ENDIAN);

    proto_tree_add_item(htc_tree, hf_ieee80211_htc_ndp_announcement, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(htc_tree, hf_ieee80211_htc_reserved2, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  }

  /*
   * These bits are part of the Aggregate Control field for 802.11ax
   */
  if (!(htc & HTC_HE)) {
    proto_tree_add_item(htc_tree, hf_ieee80211_htc_ac_constraint, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(htc_tree, hf_ieee80211_htc_rdg_more_ppdu, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  }

  /* offset += 2; */
}

#define IEEE80211_COMMON_OPT_BROKEN_FC         0x00000001
#define IEEE80211_COMMON_OPT_IS_CENTRINO       0x00000002
#define IEEE80211_COMMON_OPT_NORMAL_QOS        0x00000004

static void
dissect_frame_control(proto_tree *tree, tvbuff_t *tvb, uint32_t option_flags,
                      uint32_t offset, packet_info *pinfo, bool isDMG)
{
  uint16_t fcf, flags, frame_type_subtype;
  proto_tree *fc_tree, *flag_tree;
  proto_item *fc_item, *flag_item, *hidden_item, *ti;
  uint32_t swap_offset = 0;

  fcf = FETCH_FCF(offset);

  flags = FCF_FLAGS(fcf);
  frame_type_subtype = COMPOSE_FRAME_TYPE(fcf);

  /* Swap offset... */
  if(option_flags & IEEE80211_COMMON_OPT_BROKEN_FC)
  {
    swap_offset += 1;
  }

  proto_tree_add_uint(tree, hf_ieee80211_fc_frame_type_subtype, tvb, offset + swap_offset, 1, frame_type_subtype);

  fc_item = proto_tree_add_item(tree, hf_ieee80211_fc_field, tvb, offset, 2, ENC_BIG_ENDIAN);

  fc_tree = proto_item_add_subtree(fc_item, ett_fc_tree);

 /* at this point, we can permanently fix the offset, so that it will be used to parse the fcf first 8 bits */
  offset += swap_offset;

  proto_tree_add_item(fc_tree, hf_ieee80211_fc_proto_version, tvb, offset, 1, ENC_NA);
  proto_tree_add_item(fc_tree, hf_ieee80211_fc_frame_type, tvb, offset, 1, ENC_NA);
  proto_tree_add_item(fc_tree, hf_ieee80211_fc_frame_subtype, tvb, offset, 1, ENC_NA);
  /* Changing control frame extension for extension frames */
  if(IS_FRAME_EXTENSION(fcf) == 1) {
    proto_tree_add_uint(fc_tree, hf_ieee80211_fc_frame_extension, tvb, offset, 1, FCF_FRAME_EXTENSION(fcf));
  }

  /* Reswap offset...*/
  if(option_flags & IEEE80211_COMMON_OPT_BROKEN_FC)
  {
    offset -= 1;
    proto_item_append_text(fc_item, "(Swapped)");
  } else {
    offset += 1;
  }

  /*
   * S1G has a different format in the flags portion.
   */
  if (frame_type_subtype == EXTENSION_S1G_BEACON) {
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_s1g_next_tbtt_present, tvb,
                        offset, 1, ENC_NA);
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_s1g_compressed_ssid_present,
                        tvb, offset, 1, ENC_NA);
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_s1g_ano_present, tvb,
                        offset, 1, ENC_NA);
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_s1g_bss_bw, tvb, offset, 1,
                        ENC_NA);
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_s1g_security, tvb, offset, 1,
                        ENC_NA);
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_s1g_ap_pm, tvb, offset, 1,
                        ENC_NA);

    return;
  }

  /* Flags */
  flag_item = proto_tree_add_item(fc_tree, hf_ieee80211_fc_flags, tvb, offset, 1, ENC_NA);
  flag_tree = proto_item_add_subtree(flag_item, ett_proto_flags);
  /* Changing control frame flags for extension frames */
  if(IS_FRAME_EXTENSION(fcf) == 0) {
    proto_tree_add_item(flag_tree, hf_ieee80211_fc_data_ds, tvb, offset, 1, ENC_NA);
    hidden_item = proto_tree_add_item(flag_tree, hf_ieee80211_fc_to_ds, tvb, offset, 1, ENC_NA);
    proto_item_set_hidden(hidden_item);
    hidden_item = proto_tree_add_item(flag_tree, hf_ieee80211_fc_from_ds, tvb, offset, 1, ENC_NA);
    proto_item_set_hidden(hidden_item);
    proto_tree_add_item(flag_tree, hf_ieee80211_fc_more_frag, tvb, offset, 1, ENC_NA);
    ti = proto_tree_add_item(flag_tree, hf_ieee80211_fc_retry, tvb, offset, 1, ENC_NA);
    if( IS_RETRY(flags) )
    {
      expert_add_info(pinfo, ti, &ei_ieee80211_fc_retry);
      wlan_stats.fc_retry = 1;
    }
  }
  proto_tree_add_item(flag_tree, hf_ieee80211_fc_pwr_mgt, tvb, offset, 1, ENC_NA);
  proto_tree_add_item(flag_tree, hf_ieee80211_fc_more_data, tvb, offset, 1, ENC_NA);
  /* Changing control frame flags for extension frames */
  if(IS_FRAME_EXTENSION(fcf) == 0) {
    proto_tree_add_item(flag_tree, hf_ieee80211_fc_protected, tvb, offset, 1, ENC_NA);
  }
  ti = proto_tree_add_item(flag_tree, hf_ieee80211_fc_order, tvb, offset, 1, ENC_NA);
  if (option_flags & IEEE80211_COMMON_OPT_NORMAL_QOS) {
    if (DATA_FRAME_IS_QOS(frame_type_subtype)) {
      if (HAS_HT_CONTROL(FCF_FLAGS(fcf))) {
        /*
         * IEEE 802.11-2016 section 9.2.4.1.10 "+HTC/Order subfield" says:
         *
         *  The +HTC/Order subfield is 1 bit in length. It is used for two
         *  purposes:
         *
         *    -- It is set to 1 in a non-QoS Data frame transmitted by a
         *       non-QoS STA to indicate that the frame contains an MSDU,
         *       or fragment thereof, that is being transferred using the
         *       StrictlyOrdered service class.
         *
         *    -- It is set to 1 in a QoS Data or Management frame transmitted
         *       with a value of HT_GF, HT_MF, or VHT for the FORMAT parameter
         *       of the TXVECTOR to indicate that the frame contains an
         *       HT Control field.
         *
         *  Otherwise, the +HTC/Order subfield is set to 0.
         *
         *  NOTE -- The +HTC/Order subfield is always set to 0 for frames
         *  transmitted by a DMG STA.
         *
         * and 802.11ax drafts appear to say that the +HTC/Order flag, for
         * QoS frames, also indicates that there's an HT Control field.
         *
         * For DMG frames, we flag this as an error.
         *
         * XXX - as I read the above, this shouldn't be set except for
         * HT, VHT, or HE PHYs; however, some QoS frames appear to have
         * it set, and have an HT Control field, even though they don't
         * have HT/VHT/HE radiotap fields.  That might be because the
         * code that provided the header didn't provide those radiotap
         * fields, or because there is no radiotap header, meaning that
         * they might still be HT/VHT/HE frames, so we don't report it
         * as an error.
         */
        if (isDMG) {
          /*
           * DMG, so flag this as having +HTC/Order set, as it's not supposed
           * to be set.
           */
          expert_add_info(pinfo, ti, &ei_ieee80211_htc_in_dmg_packet);
        }
      }
    }
  }
}

static void
dissect_durid(proto_tree *hdr_tree, tvbuff_t *tvb, uint16_t fts, int offset)
{
  uint16_t durid = tvb_get_letohs(tvb, offset);

  if (durid < 0x8000) {
    proto_tree_add_uint_format_value(hdr_tree, hf_ieee80211_did_duration, tvb,
      offset, 2, durid, "%u microseconds", durid);
  } else if (((durid & 0xC000) == 0xC000) &&
             ((durid & 0x3FFF) > 0) && ((durid & 0x3FFF) <= 2007) &&
             (fts == CTRL_PS_POLL)) {
    proto_tree_add_item(hdr_tree, hf_ieee80211_assoc_id, tvb, offset, 2,
      ENC_LITTLE_ENDIAN);
  } else if (durid == 0x8000) {
    proto_tree_add_uint_format(hdr_tree, hf_ieee80211_did_duration, tvb,
      offset, 2, durid, "Duration/ID: %u", durid);
  } else {
    proto_tree_add_uint_format(hdr_tree, hf_ieee80211_did_duration, tvb,
      offset, 2, durid, "Duration/ID: %u (reserved)", durid & 0x3FFF);
  }
}


static void
dissect_vendor_ie_ht(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
                    unsigned offset, proto_item *item, proto_item *ti_len, int tag_len)
{

  uint8_t type;

  proto_tree_add_item(tree, hf_ieee80211_ht_pren_type, tvb, offset, 1, ENC_NA);
  type = tvb_get_uint8(tvb, offset);
  offset += 1;
  tag_len -= 1;


  switch(type){
    case 51:
      dissect_ht_capability_ie_common(tvb, pinfo, tree, offset, tag_len, ti_len, true);
      proto_item_append_text(item, ": HT Capabilities (802.11n D1.10)");
    break;

    case 52:
      dissect_ht_info_ie_1_0(tvb, pinfo, tree, offset, tag_len, ti_len);
      proto_item_append_text(item, ": HT Additional Capabilities (802.11n D1.00)");
    break;

    default:
      proto_tree_add_item(tree, hf_ieee80211_ht_pren_unknown, tvb, offset, tag_len, ENC_NA);
    break;
  }

}

static int
dissect_interworking(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  static int * const ieee80211_tag_interworking[] = {
    &hf_ieee80211_tag_interworking_access_network_type,
    &hf_ieee80211_tag_interworking_internet,
    &hf_ieee80211_tag_interworking_asra,
    &hf_ieee80211_tag_interworking_esr,
    &hf_ieee80211_tag_interworking_uesa,
    NULL
  };

  proto_tree_add_bitmask_list(tree, tvb, offset, 1, ieee80211_tag_interworking, ENC_LITTLE_ENDIAN);
  offset += 1;

  if ((tag_len == (1 + 2)) || (tag_len == (1 + 2 + 6))) {
    dissect_venue_info(tree, tvb, offset);
    offset += 2;
  }

  if ((tag_len == (1 + 6)) || (tag_len == (1 + 2 + 6))) {
    proto_tree_add_item(tree, hf_ieee80211_tag_interworking_hessid,
                        tvb, offset, 6, ENC_NA);
    offset += 6;
  }

  if ((tag_len != 1) && (tag_len != (1 + 2)) && (tag_len != (1 + 6)) && (tag_len != (1 + 2 + 6))) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "Invalid Interworking element length");
  }

  return offset;
}

static int
dissect_qos_map_set(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  uint8_t left;
  uint8_t val, val2;
  int i;
  proto_item *dscp_item, *item;
  proto_tree *dscp_tree;

  if (tag_len < 16 || tag_len & 1) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_bad_length,
                                "Truncated QoS Map Set element");
    return tvb_captured_length(tvb);
  }

  left = tag_len - 16;
  while (left >= 2) {
    dscp_item = proto_tree_add_item(tree, hf_ieee80211_tag_qos_map_set_dscp_exc,
                                    tvb, offset, 2, ENC_LITTLE_ENDIAN);
    dscp_tree = proto_item_add_subtree(dscp_item, ett_qos_map_set_exception);

    item = proto_tree_add_item(dscp_tree,
                               hf_ieee80211_tag_qos_map_set_dscp_exc_val,
                               tvb, offset, 1, ENC_NA);
    val = tvb_get_uint8(tvb, offset);
    if (val > 63 && val != 255) {
      expert_add_info_format(pinfo, item, &ei_ieee80211_inv_val,
                                  "Invalid DSCP Value");
    }
    offset++;

    item = proto_tree_add_item(dscp_tree,
                               hf_ieee80211_tag_qos_map_set_dscp_exc_up,
                               tvb, offset, 1, ENC_NA);
    val2 = tvb_get_uint8(tvb, offset);
    if (val2 > 7) {
      expert_add_info_format(pinfo, item, &ei_ieee80211_inv_val,
                                  "Invalid User Priority");
    }
    offset++;

    proto_item_append_text(dscp_item, " (0x%02x: UP %u)", val, val2);

    left -= 2;
  }

  for (i = 0; i < 8; i++) {
    dscp_item = proto_tree_add_item(tree, hf_ieee80211_tag_qos_map_set_range,
                                    tvb, offset, 2, ENC_NA);
    dscp_tree = proto_item_add_subtree(dscp_item, ett_qos_map_set_exception);

    item = proto_tree_add_item(dscp_tree, hf_ieee80211_tag_qos_map_set_low,
                               tvb, offset, 1, ENC_NA);
    val = tvb_get_uint8(tvb, offset);
    if (val > 63 && val != 255) {
      expert_add_info_format(pinfo, item, &ei_ieee80211_inv_val,
                                  "Invalid DSCP Value");
    }
    offset++;

    item = proto_tree_add_item(dscp_tree, hf_ieee80211_tag_qos_map_set_high,
                               tvb, offset, 1, ENC_NA);
    val2 = tvb_get_uint8(tvb, offset);
    if ((val2 > 63 && val2 != 255) || val2 < val ||
        (val == 255 && val2 != 255) || (val != 255 && val2 == 255)) {
      expert_add_info_format(pinfo, item, &ei_ieee80211_inv_val,
                                  "Invalid DSCP Value");
    }
    offset++;

    if (val == 255 && val2 == 255) {
      proto_item_append_text(dscp_item, " (UP %u not in use)", i);
    } else {
      proto_item_append_text(dscp_item, " (0x%02x-0x%02x: UP %u)",
                             val, val2, i);
    }
  }

  return tvb_captured_length(tvb);
}

static int
dissect_roaming_consortium(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  proto_item* item;
  uint8_t oi_lens, oi1_len, oi2_len;

  proto_tree_add_item(tree, hf_ieee80211_tag_roaming_consortium_num_anqp_oi,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  oi_lens = tvb_get_uint8(tvb, offset);
  oi1_len = oi_lens & 0x0f;
  oi2_len = (oi_lens & 0xf0) >> 4;
  proto_tree_add_item(tree, hf_ieee80211_tag_roaming_consortium_oi1_len,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tree, hf_ieee80211_tag_roaming_consortium_oi2_len,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  if (offset + oi1_len > tag_len) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "Truncated Roaming Consortium element");
    return tvb_captured_length(tvb);
  }

  item = proto_tree_add_item(tree, hf_ieee80211_tag_roaming_consortium_oi1,
                             tvb, offset, oi1_len, ENC_NA);
  add_manuf(item, tvb, offset);
  offset += oi1_len;

  if (offset + oi2_len > tag_len) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "Truncated Roaming Consortium element");
    return tvb_captured_length(tvb);
  }

  if (oi2_len > 0) {
    item = proto_tree_add_item(tree, hf_ieee80211_tag_roaming_consortium_oi2,
                        tvb, offset, oi2_len, ENC_NA);
    add_manuf(item, tvb, offset);
    offset += oi2_len;
  }

  if (tag_len > offset) {
    proto_tree_add_item(tree, hf_ieee80211_tag_roaming_consortium_oi3,
                        tvb, offset, tag_len - offset, ENC_NA);
  }

  return tvb_captured_length(tvb);
}

static void
dissect_extended_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int len)
{
  if (len < 2) {
    expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length,
                           "Extended Request must be at least 2 octets long");
    return;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_extended_request_id, tvb, offset, 1, ENC_NA);
  offset += 1;
  len -= 1;

  while (len--) {
    proto_tree_add_item(tree, hf_ieee80211_tag_extended_request_extension, tvb, offset, 1, ENC_NA);
    offset += 1;
  }
}

static void
dissect_he_6ghz_band_capabilities(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int len)
{
  if (len != 2) {
    expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length,
                           "HE 6 GHz Band Capabilities must be at 2 octets long");
    return;
  }

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_he_6ghz_cap_inf,
                         ett_tag_he_6ghz_cap_inf_tree,
                         ieee80211_tag_he_6ghz_cap_inf,
                         ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
}

static void
dissect_secure_ltf_parameters(tvbuff_t *tvb, packet_info *pinfo _U_,
                              proto_tree *tree, int offset, int len _U_)
{
  proto_tree_add_item(tree, hf_ieee80211_tag_secure_ltf_params_counter, tvb,
                      offset, 6, ENC_LITTLE_ENDIAN);
  offset += 6;

  proto_tree_add_item(tree, hf_ieee80211_tag_secure_ltf_generation_sac, tvb,
                      offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_tag_secure_ltf_management_sac, tvb,
                      offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_tag_secure_ltf_result_ltf_ofs, tvb,
                      offset, 1, ENC_NA);
}

static void
dissect_ista_availability_window(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, int len)
{
  uint16_t count = tvb_get_letohs(tvb, offset) & 0x1FF;
  char avail_string[513];
  char pad_string[8];
  int i = 0, j;
  int avail_bits_offset;
  int8_t bits;

  memset(avail_string, 0x0, sizeof(avail_string));
  memset(pad_string, 0x0, sizeof(pad_string));

  /* These are at the same level as the avail bits */
  proto_tree_add_item(tree, hf_ieee80211_ftm_ista_availability_count,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tree, hf_ieee80211_ftm_ista_availability_reserved,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  avail_bits_offset = offset;

  /* Now, extract count  bits and set up the string 8-bits at a time */
  for (i = 1; i <= (count / 8); i++) {
    bits = tvb_get_uint8(tvb, offset);

    for (j = 0; j < 8; j++) {
      avail_string[(i - 1) * 8 + j] = (bits & 0x01) ? '1' : '0';
      bits = bits >> 1;
    }

    offset += 1;
  }

  avail_string[i * 8] = 0;

  if (count % 8) {
    /* Deal with the remaining bits */
    bits = tvb_get_uint8(tvb, offset);

    for (j = (i - 1) * 8; j < count; j++) {
      avail_string[j] = (bits & 0x01) ? '1' : '0';
      bits = bits >> 1;
    }

    avail_string[j] = 0;

    /* Deal with the padding */
    for (j = 0; j < 8 - (count % 8); j++) {
      pad_string[j] = (bits & 0x01) ? '1' : '0';
      bits = bits >> 1;
    }

    pad_string[j] = 0;
  }

  proto_tree_add_string(tree, hf_ieee80211_ftm_ista_avail_bits, tvb,
                        avail_bits_offset, (count + 7) / 8, avail_string);

  if (((len - 2) * 8) != count) {
    proto_tree_add_string(tree, hf_ieee80211_ftm_ista_avail_pad, tvb,
                          offset, 1, pad_string);
  }
}

static int * const rsta_avail_info_header[] = {
  &hf_ieee80211_ftm_rsta_count,
  &hf_ieee80211_ftm_rsta_avail_window_bcast_fmt,
  NULL
};

static int * const rsta_availability_subfield_hdr1[] = {
  &hf_ieee80211_ftm_rsta_partial_tsf_timer1,
  &hf_ieee80211_ftm_rsta_duration1,
  &hf_ieee80211_ftm_rsta_passive_tb_ranging_reserved1,
  &hf_ieee80211_ftm_rsta_periodicity1,
  NULL
};

static int * const rsta_availability_subfield_hdr2[] = {
  &hf_ieee80211_ftm_rsta_partial_tsf_timer,
  &hf_ieee80211_ftm_rsta_duration,
  &hf_ieee80211_ftm_rsta_passive_tb_ranging_reserved,
  &hf_ieee80211_ftm_rsta_periodicity,
  &hf_ieee80211_ftm_rsta_format_and_bandwidth,
  &hf_ieee80211_ftm_rsta_reserved,
  NULL
};

static void
dissect_rsta_availability_window(tvbuff_t *tvb, packet_info *pinfo _U_,
                                 proto_tree *tree, int offset, int len _U_)
{
  uint8_t count = tvb_get_uint8(tvb, offset) &0x7F;
  int i;

  proto_tree_add_bitmask(tree, tvb, offset, hf_ieee80211_ftm_rsta_header,
                         ett_rsta_avail_header, rsta_avail_info_header, ENC_NA);

  offset += 1;

  for (i = 0; i < count; i++) {
    proto_tree *subfield_tree = NULL;
    bool has_passive_ranging_params =
                (tvb_get_letohl(tvb, offset) >> 23) & 1;

    subfield_tree = proto_tree_add_subtree_format(tree, tvb, offset,
                                           has_passive_ranging_params ? 5 : 4,
                                           ett_rsta_avail_tree, NULL,
                                           "Availability Window Information %d",
                                           i);
    if (has_passive_ranging_params) {
      proto_tree_add_bitmask(subfield_tree, tvb, offset,
                             hf_ieee80211_ftm_rsta_avail_subfield_long,
                             ett_rsta_avail_subfield,
                             rsta_availability_subfield_hdr2,
                             ENC_LITTLE_ENDIAN);
      offset += 5;
    } else {
      proto_tree_add_bitmask(subfield_tree, tvb, offset,
                             hf_ieee80211_ftm_rsta_avail_subfield_short,
                             ett_rsta_avail_subfield,
                             rsta_availability_subfield_hdr1,
                             ENC_LITTLE_ENDIAN);
      offset += 4;
    }
  }
}

/*
 * "Comeback after subfield shall not be present (ie, zero octets) in PASN
 * authentication frames from a non-AP STA."
 *
 * Attempt to figure out if the Comeback After field is present.
 */
#define PASN_COMEBACK_INFO_PRESENT 0x01
#define PASN_GROUP_KEY_PRESENT     0x02

static bool
has_comeback_after(uint8_t flags, tvbuff_t *tvb, int offset, int len _U_)
{
  int tvb_left = tvb_captured_length_remaining(tvb, offset);
  bool comeback_after = false;
  //int cookie_len = 0;
  int fixed_len = 0;

  if (flags & PASN_GROUP_KEY_PRESENT) { /* Group and Key present */
    fixed_len += 2;
  }

  /*
   * If there is a comeback field and the comback_after is present ...
   */
  if (flags & 0x01) {
        /* Check if the comeback_after field is there? */
        if (tvb_get_letohs(tvb, offset) <= (tvb_left - fixed_len)) {
                comeback_after = true;
        }
  }

  return comeback_after;
}

static int * const pasn_params_fields[] = {
  &hf_ieee80211_tag_pasn_params_comeback_info_present,
  &hf_ieee80211_tag_pasn_params_group_and_key_present,
  &hf_ieee80211_tag_pasn_parameters_reserved,
  NULL
};

static const range_string wrapped_data_fmt_rvals[] = {
  { 0, 0, "No wrapped data" },
  { 1, 1, "Fast BSS Transition Wrapped Data" },
  { 2, 2, "FILS Shared Key authentication without PFS Wrapped Data" },
  { 3, 3, "SAE Wrapped Data" },
  { 4, 255, "Reserved" },
  { 0, 0, NULL }
};

static void
dissect_pasn_parameters(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int len)
{
  int public_key_len = 0;
  unsigned pasn_control = tvb_get_uint8(tvb, offset);

  if (len < 2) {
    expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length,
                           "PASN Parameters must be at least 2 octets long");
    return;
  }

  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_tag_pasn_parameters_control,
                                    ett_pasn_parameters, pasn_params_fields,
                                    ENC_LITTLE_ENDIAN,
                                    BMT_NO_FALSE | BMT_NO_INT);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_tag_pasn_parameters_wrapped_fmt,
                      tvb, offset, 1, ENC_NA);
  offset += 1;

  /*
   * If the Comeback field is present, it might not have a Comeback After
   * field. Use the following heuristic function to check.
   */
  if (pasn_control & PASN_COMEBACK_INFO_PRESENT) {
    proto_tree *comeback_tree = NULL;
    proto_item *cbi = NULL;
    uint8_t cookie_len;

    comeback_tree = proto_tree_add_subtree(tree, tvb, offset, -1,
                    ett_pasn_comeback_tree, &cbi, "Comeback field");

    if (has_comeback_after(pasn_control, tvb, offset, len)) {
      proto_tree_add_item(comeback_tree, hf_ieee80211_tag_pasn_comeback_after,
                          tvb, offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
    }

    cookie_len = tvb_get_uint8(tvb, offset);

    proto_tree_add_item(comeback_tree, hf_ieee80211_tag_pasn_cookie_length,
                        tvb, offset, 1, ENC_NA);
    offset += 1;

    if (cookie_len) {
      proto_tree_add_item(comeback_tree, hf_ieee80211_tag_pasn_cookie,
                          tvb, offset, cookie_len, ENC_NA);
      offset += cookie_len;
    }
  }

  if (pasn_control & PASN_GROUP_KEY_PRESENT) {
    public_key_len = tvb_get_uint8(tvb, offset + 2);

    proto_tree_add_item(tree, hf_ieee80211_tag_pasn_finite_cyclic_group_id, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    proto_tree_add_item(tree, hf_ieee80211_tag_pasn_ephemeral_public_key_len,
                        tvb, offset, 1, ENC_NA);
    offset += 1;

    if (public_key_len) {
      proto_tree_add_item(tree, hf_ieee80211_tag_pasn_ephemeral_public_key, tvb,
                        offset, public_key_len, ENC_NA);
    }
  }
}

static int * const sta_control_hdrs[] = {
  &hf_ieee80211_eht_profile_link_id,
  &hf_ieee80211_eht_profile_complete_profile,
  &hf_ieee80211_eht_profile_mac_address_present,
  &hf_ieee80211_eht_profile_beacon_interval_present,
  &hf_ieee80211_eht_profile_tsf_offset_present,
  &hf_ieee80211_eht_profile_dtim_info_present,
  &hf_ieee80211_eht_profile_nstr_link_pair_present,
  &hf_ieee80211_eht_profile_nstr_bitmap_size,
  &hf_ieee80211_eht_profile_bss_params_change_count_present,
  &hf_ieee80211_eht_profile_reserved,
  NULL
};

static int * const probe_sta_control_hdrs[] = {
  &hf_ieee80211_eht_profile_link_id,
  &hf_ieee80211_eht_profile_complete_profile,
  &hf_ieee80211_eht_profile_probe_reserved,
  NULL
};

static const range_string eht_reconfig_op_type_rvals[] = {
  { 0, 0, "AP Removal" },
  { 1, 1, "Operation Parameter Update" },
  { 2, 2, "Add Link" },
  { 3, 3, "Delete Link" },
  { 4, 15, "Reserved" },
  { 0, 0, NULL }
};

static int * const reconfig_sta_control_hdrs[] = {
  &hf_ieee80211_eht_profile_link_id,
  &hf_ieee80211_eht_profile_complete_profile,
  &hf_ieee80211_eht_profile_mac_address_present,
  &hf_ieee80211_eht_profile_removal_timer_present,
  &hf_ieee80211_eht_profile_reconfig_operation_type,
  &hf_ieee80211_eht_profile_operation_para_present,
  &hf_ieee80211_eht_profile_reconfig_nstr_bitmap_size,
  &hf_ieee80211_eht_profile_reconfig_reserved,
  NULL
};

static int * const prio_access_sta_control_hdrs[] = {
  &hf_ieee80211_eht_profile_link_id,
  &hf_ieee80211_eht_profile_prio_acc_reserved,
  NULL
};

static int * const reconfig_presence_indi_hdrs[] = {
  &hf_ieee80211_eht_sta_profile_presence_indi_max_mpdu_length_present,
  &hf_ieee80211_eht_sta_profile_presence_indi_max_amsdu_length_present,
  &hf_ieee80211_eht_sta_profile_presence_indi_reserved,
  NULL
};

static int * const reconfig_operation_para_info_hdrs[] = {
  &hf_ieee80211_eht_sta_profile_operation_para_info_max_mpdu_length,
  &hf_ieee80211_eht_sta_profile_operation_para_info_amsdu_length,
  &hf_ieee80211_eht_sta_profile_operation_para_info_pad,
  NULL
};

/* Presence Bitmap in ML Control */
/* Basic */
#define EHT_LINK_ID         0x01
#define EHT_BSS_PARAMS      0x02
#define EHT_MEDIUM_SYNC     0x04
#define EHT_EML_CAPA        0x08
#define EHT_MLD_CAPA        0x10
#define EHT_MLD_ID          0x20
#define EHT_EXT_MLD_CAPA    0x40
/* Probe */
#define EHT_PML_MLD_ID      0x01
/* Reconf */
#define EHT_RECONF_MLD_MAC  0x01
#define EHT_RECONF_EML_CAPA 0x02
#define EHT_RECONF_MLD_CAPA 0x04

#define BASIC_MULTI_LINK           0
#define PROBE_MULTI_LINK           1
#define RECONFIGURATION_MULTI_LINK 2
#define TDLS_MULTI_LINK            3
#define PRIORITY_ACCESS_MULTI_LINK 4

/* Bits from the STA Control field */
/* Basic */
#define STA_CTRL_LINK_ID                         0x000F
#define STA_CTRL_COMPLETE_PROFILE                0x0010
#define STA_CTRL_MAC_ADDR_PRESENT                0x0020
#define STA_CTRL_BEACON_INT_PRESENT              0x0040
#define STA_CTRL_TSF_OFFSET_PRESENT              0x0080
#define STA_CTRL_DTIM_INFO_PRESENT               0x0100
#define STA_CTRL_NSTR_LINK_PAIR_PRESENT          0x0200
#define STA_CTRL_NSTR_BITMAP_SIZE                0x0400
#define STA_CTRL_BSS_PARAMS_CHANGE_CNT_PRESENT   0x0800
#define STA_CTRL_RESERVED                        0xF000

/* Reconf */
#define AP_REMOVAL_TIMER_PRESENT                 0x0040
#define OPERATION_PARAMS_PRESENT                 0x0800
#define RECONF_NSTR_BITMAP_SIZE                  0x1000

static int
dissect_multi_link_per_sta(tvbuff_t *tvb, packet_info *pinfo _U_,
                           proto_tree *tree,
                           uint8_t multi_link_type,
                           int *found_link_id)
{
  proto_tree *subelt_tree = NULL, *sta_info_tree = NULL;
  int offset = 0;
  int len = tvb_captured_length_remaining(tvb, offset);
  uint16_t sta_control = tvb_get_uint16(tvb, offset, ENC_LITTLE_ENDIAN);
  uint8_t sta_info_len = 0;
  int start_offset = offset, tree_offset;
  uint8_t link_id;

  subelt_tree = proto_tree_add_subtree(tree, tvb, offset, len,
                                       ett_eht_multi_link_per_sta,
                                       NULL, "Per-STA Profile");

  switch (multi_link_type) {
  case BASIC_MULTI_LINK:
    link_id = tvb_get_uint8(tvb, offset) & 0x0F;
    *found_link_id = link_id;
    proto_item_append_text(subelt_tree, ", Link-ID = %d", link_id);

    proto_tree_add_bitmask(subelt_tree, tvb, offset,
                           hf_ieee80211_eht_profile_sta_control,
                           ett_eht_multi_link_sta_control,
                           sta_control_hdrs, ENC_LITTLE_ENDIAN);
    offset += 2;

    /* Check the length of STA Info is 0 */
    if (offset >= start_offset + len) {
      return len;
    }

    sta_info_len = tvb_get_uint8(tvb, offset);
    sta_info_tree = proto_tree_add_subtree(subelt_tree, tvb, offset,
                                           sta_info_len,
                                           ett_eht_multi_link_per_sta_info,
                                           NULL, "STA Info");

    proto_tree_add_item(sta_info_tree, hf_ieee80211_eht_sta_profile_info_len,
                        tvb, offset, 1, ENC_NA);
    offset += 1;

    if (sta_control & STA_CTRL_MAC_ADDR_PRESENT) {
      proto_tree_add_item(sta_info_tree, hf_ieee80211_eht_sta_profile_info_mac,
                          tvb, offset, 6, ENC_NA);
      offset += 6;
    }

    if (sta_control & STA_CTRL_BEACON_INT_PRESENT) {
      proto_tree_add_item(sta_info_tree,
                          hf_ieee80211_eht_sta_profile_info_beacon,
                          tvb, offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
    }

    if (sta_control & STA_CTRL_TSF_OFFSET_PRESENT) {
      proto_tree_add_item(sta_info_tree, hf_ieee80211_eht_sta_profile_info_tsf_offset,
                          tvb, offset, 8, ENC_LITTLE_ENDIAN);
      offset += 8;
    }

    if (sta_control & STA_CTRL_DTIM_INFO_PRESENT) {
      proto_tree * dtim_tree;

      dtim_tree = proto_tree_add_subtree(sta_info_tree, tvb, offset, 2,
                             ett_eht_multi_link_sta_dtim, NULL, "DTIM Info");

      proto_tree_add_item(dtim_tree,
                          hf_ieee80211_eht_sta_profile_info_dtim_count,
                          tvb, offset, 1, ENC_NA);
      offset += 1;

      proto_tree_add_item(dtim_tree,
                          hf_ieee80211_eht_sta_profile_info_dtim_period,
                          tvb, offset, 1, ENC_NA);
      offset += 1;
    }

    if (sta_control & STA_CTRL_NSTR_LINK_PAIR_PRESENT) {
      int bitmap_size = (sta_control & STA_CTRL_NSTR_BITMAP_SIZE) ? 2 : 1;

      proto_tree_add_item(sta_info_tree,
                          hf_ieee80211_eht_sta_profile_info_bitmap,
                          tvb, offset, bitmap_size, ENC_NA);
      offset += bitmap_size;
    }

    if (sta_control & STA_CTRL_BSS_PARAMS_CHANGE_CNT_PRESENT) {
      proto_tree_add_item(sta_info_tree,
                      hf_ieee80211_eht_sta_profile_bss_params_change_count,
                      tvb, offset, 1, ENC_NA);
      offset += 1;
    }
    break;
  case PROBE_MULTI_LINK:
    link_id = tvb_get_uint8(tvb, offset) & 0x0F;
    *found_link_id = link_id;

    proto_tree_add_bitmask(subelt_tree, tvb, offset,
                           hf_ieee80211_eht_profile_sta_control,
                           ett_eht_multi_link_sta_control,
                           probe_sta_control_hdrs, ENC_LITTLE_ENDIAN);
    offset += 2;

    /*
     * Now there will be some elements if complete profile is 0
     *
     * There can be one Request element, one Extended Request Element or
     * one of both.
     */
    if ((sta_control & STA_CTRL_COMPLETE_PROFILE) == 0) {
      bool seen_request = false, seen_ext_request = false;

      while (tvb_captured_length_remaining(tvb, offset) >= 2) {
        static const uint8_t ids[] = { TAG_TSPEC };
        uint8_t elt_type = 0;

        if (tvb_captured_length_remaining(tvb, offset) < 2) {
          expert_add_info_format(pinfo, subelt_tree,
                           &ei_ieee80211_eht_invalid_multi_link,
                           "Invalid Probe Request Multi-Link element "
                           "STA Control field, should contain a Request "
                           "element or an Extended Request element or both "
                           "but there are insufficient bytes");

          return len;
        }

        elt_type = tvb_get_uint8(tvb, offset);

        if ((elt_type != TAG_REQUEST && elt_type != TAG_ELEMENT_ID_EXTENSION) ||
            (elt_type == TAG_ELEMENT_ID_EXTENSION &&
             (tvb_get_uint8(tvb, offset + 1) < 3 ||
              tvb_get_uint8(tvb, offset + 2) != ETAG_EXTENDED_REQUEST))) {
          /* Add an expert Info */

          expert_add_info_format(pinfo, subelt_tree,
                           &ei_ieee80211_eht_invalid_multi_link,
                           "Invalid Probe Request Multi-Link element "
                           "STA Control field, should contain a Request "
                           "element or an Extended Request element or both "
                           "but it contains other elements or there are "
                           "insufficient bytes for an extended element");
          return len;
        }

        if (elt_type == TAG_REQUEST) {
          if (!seen_request) {
            offset += add_tagged_field(pinfo, tree, tvb, offset, 0, ids,
                                       G_N_ELEMENTS(ids), NULL);
            seen_request = true;
          } else {
            expert_add_info_format(pinfo, subelt_tree,
                           &ei_ieee80211_eht_invalid_multi_link,
                           "Invalid Probe Request Multi-Link element "
                           "STA Control field. May only contain one Request "
                           "element");

            return len;
          }
        } else { /* It can only be a ETAG_EXTENDED_REQUEST */
          if (!seen_ext_request) {
            uint8_t ext_tag_len = tvb_get_uint8(tvb, offset + 1);

            offset += 3;
            dissect_extended_request(tvb, pinfo, tree, offset, ext_tag_len);

            offset += ext_tag_len;
            seen_ext_request = true;
          } else {
            expert_add_info_format(pinfo, subelt_tree,
                           &ei_ieee80211_eht_invalid_multi_link,
                           "Invalid Probe Request Multi-Link element "
                           "STA Control field. May only contain one Extended "
                           "Request element");

            return len;
          }
        }
      }
    }
    break;
  case RECONFIGURATION_MULTI_LINK:
    link_id = tvb_get_uint8(tvb, offset) & 0x0F;
    *found_link_id = link_id;

    proto_tree_add_bitmask(subelt_tree, tvb, offset,
                           hf_ieee80211_eht_profile_sta_control,
                           ett_eht_multi_link_sta_control,
                           reconfig_sta_control_hdrs, ENC_LITTLE_ENDIAN);
    offset += 2;

    /* Check the length of STA Info is 0 */
    if (offset >= start_offset + len) {
      return len;
    }

    sta_info_len = tvb_get_uint8(tvb, offset);
    sta_info_tree = proto_tree_add_subtree(subelt_tree, tvb, offset, sta_info_len,
                                           ett_eht_multi_link_per_sta_info,
                                           NULL, "STA Info");
    tree_offset = offset;

    proto_tree_add_item(sta_info_tree, hf_ieee80211_eht_sta_profile_info_len,
                        tvb, offset, 1, ENC_NA);
    offset += 1;

    if (sta_control & STA_CTRL_MAC_ADDR_PRESENT) {
      proto_tree_add_item(sta_info_tree, hf_ieee80211_eht_sta_profile_info_mac,
                          tvb, offset, 6, ENC_NA);
      offset += 6;
    }

    if (sta_control & AP_REMOVAL_TIMER_PRESENT) {
      proto_tree_add_item(sta_info_tree,
                          hf_ieee80211_eht_sta_profile_removal_timer,
                          tvb, offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
    }

    if (sta_control & OPERATION_PARAMS_PRESENT) {
      proto_tree * oper_tree;

      oper_tree = proto_tree_add_subtree(sta_info_tree, tvb, offset, 3,
                                         ett_eht_multi_link_reconf_oper_param, NULL, "Operation Parameters");

      proto_tree_add_bitmask_with_flags(oper_tree, tvb, offset,
                             hf_ieee80211_eht_sta_profile_presence_indi,
                             ett_eht_multi_link_reconfig_presence_indi,
                             reconfig_presence_indi_hdrs, ENC_LITTLE_ENDIAN,
                             BMT_NO_APPEND);
      offset += 1;

      proto_tree_add_bitmask_with_flags(oper_tree, tvb, offset,
                             hf_ieee80211_eht_sta_profile_operation_para_info,
                             ett_eht_multi_link_reconfig_operation_para_info,
                             reconfig_operation_para_info_hdrs, ENC_LITTLE_ENDIAN,
                             BMT_NO_APPEND);
      offset += 2;
    }

    if (sta_info_len > (offset - tree_offset)) {
      int bitmap_size = (sta_control & RECONF_NSTR_BITMAP_SIZE) ? 2 : 1;

      proto_tree_add_item(sta_info_tree,
                          hf_ieee80211_eht_sta_profile_info_bitmap,
                          tvb, offset, bitmap_size, ENC_NA);
      offset += bitmap_size;
    }
    break;
  case TDLS_MULTI_LINK:
    expert_add_info_format(pinfo, subelt_tree,
                           &ei_ieee80211_eht_invalid_multi_link,
                           "Invalid TDLS Multi-Link element. There should not "
                           "be any Link Info fields.");

    break;
  case PRIORITY_ACCESS_MULTI_LINK:
    link_id = tvb_get_uint8(tvb, offset) & 0x0F;
    *found_link_id = link_id;
    proto_tree_add_bitmask(subelt_tree, tvb, offset,
                           hf_ieee80211_eht_profile_sta_control,
                           ett_eht_multi_link_sta_control,
                           prio_access_sta_control_hdrs, ENC_LITTLE_ENDIAN);
    offset += 2;

    /*
     * Could contain the EDCA Parameter Set elt or the MU EDCA Parameter Set
     * elt, or none.
     */
    if (tvb_captured_length_remaining(tvb, offset) > 2) {

    }
    break;
  default:
    DISSECTOR_ASSERT_NOT_REACHED();
    break;
  }

  // Sta Profile
  // Save HE capa settings
  {
    unsigned *p_channel_width_set =
    (unsigned *)p_get_proto_data(wmem_file_scope(), pinfo, proto_wlan,
                              HE_CHANNEL_WIDTH_KEY);
    unsigned channel_width_set = GPOINTER_TO_INT(p_channel_width_set);
    uint32_t ftype = GPOINTER_TO_UINT(p_get_proto_data(wmem_file_scope(),
                                                      pinfo, proto_wlan,
                                                      FRAME_TYPE_KEY));

    int end_offset = start_offset + len;
    if (offset < end_offset) {
      /* Check CSA, EX CSA or MAX CST elements to skip parsing cap info */
      uint8_t elem = tvb_get_uint8(tvb, offset);
      uint8_t elem_len = tvb_get_uint8(tvb, offset+1);
      uint8_t ext_elem = 0;
      if (elem == TAG_ELEMENT_ID_EXTENSION) {
        ext_elem = tvb_get_uint8(tvb, offset+2);
      }
      if (multi_link_type == PRIORITY_ACCESS_MULTI_LINK) {
      } else if ((elem == TAG_CHANNEL_SWITCH_ANN && elem_len == 3) ||
          (elem == TAG_EXTENDED_CHANNEL_SWITCH_ANNOUNCEMENT && elem_len == 4) ||
          (ext_elem == ETAG_MAX_CHANNEL_SWITCH_TIME && elem_len == 4)) {
      } else {
        offset += add_ff_cap_info(subelt_tree, tvb, pinfo, offset);
      }
      /*
       * If it is an association or re-association response, deal with the
       * status code.
       */
      if ((ftype == MGT_ASSOC_RESP || ftype == MGT_REASSOC_RESP) &&
          multi_link_type == BASIC_MULTI_LINK) {
        offset += add_ff_status_code(subelt_tree, tvb, pinfo, offset);
      }
    }
    while (offset < end_offset) {
      int tag_len = tvb_get_uint8(tvb, offset+1);
      if (offset + 1 + tag_len >= end_offset) {
        /* Detect wrong format to avoid from corrupting default_context */
        expert_add_info_format(pinfo, subelt_tree, &ei_ieee80211_eht_invalid_subelement,
          "Per-STA Profile subelements had wrong element/length");
        *found_link_id = -1;
        return len;
      }
      offset += add_tagged_field(pinfo, subelt_tree, tvb, offset, ftype, NULL, 0, NULL);
    }

    // Set he capa settings back
    p_add_proto_data(wmem_file_scope(), pinfo, proto_wlan, HE_CHANNEL_WIDTH_KEY,
                     GINT_TO_POINTER(channel_width_set | (1<<31)));
  }
  return len;
}

static const value_string multi_link_type_vals[] = {
  { BASIC_MULTI_LINK, "Basic" },
  { PROBE_MULTI_LINK, "Probe Request" },
  { RECONFIGURATION_MULTI_LINK, "Reconfiguration" },
  { TDLS_MULTI_LINK, "TDLS" },
  { PRIORITY_ACCESS_MULTI_LINK, "Priority Access" },
  { 5, "Reserved" },
  { 6, "Reserved" },
  { 7, "Reserved" },
  { 0, NULL }
};

static const range_string multi_link_sub_elt_string[] = {
  { 0,   0, "Per-STA Profile" },
  { 1,   220, "Reserved" },
  { 221, 221, "Vendor Specific" },
  { 222, 255, "Reserved" },
  { 0,   0, NULL }
};

static int * const eht_link_id_hdrs[] = {
  &hf_ieee80211_eht_common_info_link_id,
  &hf_ieee80211_eht_common_info_link_id_reserved,
  NULL
};

static int * const eht_medium_sync_delay_hdrs[] = {
  &hf_ieee80211_eht_common_info_medium_sync_duration,
  &hf_ieee80211_eht_common_info_medium_sync_threshold,
  &hf_ieee80211_eht_common_info_medium_sync_max_txops,
  NULL
};

static int * const eht_eml_capabilities_hdrs[] = {
  &hf_ieee80211_eht_common_info_eml_capa_emlsr_support,
  &hf_ieee80211_eht_common_info_eml_capa_emlsr_padding_delay,
  &hf_ieee80211_eht_common_info_eml_capa_emlsr_transition_delay,
  &hf_ieee80211_eht_common_info_eml_capa_emlmr_support,
  &hf_ieee80211_eht_common_info_eml_capa_emlmr_delay,
  &hf_ieee80211_eht_common_info_eml_capa_transition_timeout,
  &hf_ieee80211_eht_common_info_eml_capa_reserved,
  NULL
};

static int * const eht_mld_capabilities_hdrs[] = {
  &hf_ieee80211_eht_common_info_mld_max_simul_links,
  &hf_ieee80211_eht_common_info_mld_srs_support,
  &hf_ieee80211_eht_common_info_mld_tid_to_link_map_neg,
  &hf_ieee80211_eht_common_info_mld_freq_sep_for_str,
  &hf_ieee80211_eht_common_info_mld_aar_support,
  &hf_ieee80211_eht_common_info_mld_link_reconf_op_support,
  &hf_ieee80211_eht_common_info_mld_aligned_twt_support,
  &hf_ieee80211_eht_common_info_mld_reserved,
  NULL
};

static int * const eht_ext_mld_capabilities_hdrs[] = {
  &hf_ieee80211_eht_common_info_ext_mld_op_update_support,
  &hf_ieee80211_eht_common_info_ext_mld_max_simul_links,
  &hf_ieee80211_eht_common_info_ext_mld_reserved,
  NULL
};

/*
 * Build a TVB containing the sub-elt. Offset will point to the subelt id in
 * tvb, and the sub-elt might span several fragments. Subsequent fragments
 * will have an id of 254.
 */
static tvbuff_t *
get_subelt_tvb(tvbuff_t *tvb, packet_info *pinfo, int offset, int *overhead)
{
  uint8_t subelt_len = tvb_get_uint8(tvb, offset + 1);
  tvbuff_t *tmp_tvb;
  int ohead = 0;

  if (subelt_len == 255 &&
      tvb_captured_length_remaining(tvb, offset) > 259 &&
      tvb_get_uint8(tvb, offset + 255 + 2) == 0xfe) {
    tvbuff_t *tvb_comp;
    uint8_t frag_len;

    tvb_comp = tvb_new_composite();

    do {
      offset += 1;
      frag_len = tvb_get_uint8(tvb, offset);
      offset += 1;
      tmp_tvb = tvb_new_subset_length(tvb, offset, frag_len);
      /* Insert this fragment ... */
      tvb_composite_append(tvb_comp, tmp_tvb);
      offset += frag_len;
      ohead += 2;
    } while (frag_len == 255 &&
             tvb_captured_length_remaining(tvb, offset) > 2 &&
             tvb_get_uint8(tvb, offset) == 0xfe);

    tvb_composite_finalize(tvb_comp);

    *overhead = ohead - 2;
    add_new_data_source(pinfo, tvb_comp, "Reassembled Subelt");
    return tvb_comp;
  } else {
    *overhead = 0;
    return tvb_new_subset_length(tvb, offset + 2, subelt_len);
  }
}

static void
dissect_multi_link(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,
                   int offset, int len _U_)
{
  proto_item *control = NULL, *type = NULL;
  proto_tree *ctl_tree = NULL, *common_tree = NULL, *subelt_tree = NULL;
  uint8_t common_info_len = 0;
  uint16_t multi_link_control = tvb_get_uint16(tvb, offset, ENC_LITTLE_ENDIAN);
  uint8_t multi_link_type = multi_link_control & 0x0007;
  uint16_t present = multi_link_control >> 4;
  int elt = 0, hf_index;
  int local_link_ids[16];

  control = proto_tree_add_item(tree, hf_ieee80211_eht_multi_link_control, tvb,
                                offset, 2, ENC_LITTLE_ENDIAN);
  ctl_tree = proto_item_add_subtree(control, ett_eht_multi_link_control);

  type = proto_tree_add_item(ctl_tree, hf_ieee80211_eht_multi_link_control_type,
                             tvb, offset, 2, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(ctl_tree, hf_ieee80211_eht_multi_link_control_reserved,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);

  /* Handle the control elt here, separate items */
  if (multi_link_type == BASIC_MULTI_LINK) {
    proto_item_append_text(control, " Basic");
    proto_tree_add_item(ctl_tree,
                        hf_ieee80211_eht_multi_link_control_link_id_present,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(ctl_tree,
                        hf_ieee80211_eht_multi_link_control_bss_parms_ch_count,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(ctl_tree,
                        hf_ieee80211_eht_multi_link_control_medium_sync_delay,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(ctl_tree,
                        hf_ieee80211_eht_multi_link_control_eml_capa,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(ctl_tree,
                        hf_ieee80211_eht_multi_link_control_mld_capa,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(ctl_tree,
                        hf_ieee80211_eht_multi_link_control_basic_mld_id_present,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(ctl_tree,
                        hf_ieee80211_eht_multi_link_control_ext_mld_capa,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(ctl_tree,
                        hf_ieee80211_eht_multi_link_control_bitmap_reserved,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    hf_index = hf_ieee80211_eht_multi_link_type_0_link_count;
  } else if (multi_link_type == PROBE_MULTI_LINK) {
    proto_item_append_text(control, " Probe Request");
    proto_tree_add_item(ctl_tree,
                        hf_ieee80211_eht_multi_link_control_probe_mld_id_present,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(ctl_tree,
                        hf_ieee80211_eht_multi_link_control_probe_reserved,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    hf_index = hf_ieee80211_eht_multi_link_type_1_link_count;
  } else if (multi_link_type == RECONFIGURATION_MULTI_LINK) {
    proto_item_append_text(control, " Reconfiguration");
    proto_tree_add_item(ctl_tree,
                        hf_ieee80211_eht_multi_link_control_reconfig_mld_mac,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(ctl_tree,
                        hf_ieee80211_eht_multi_link_control_reconfig_eml_capa,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(ctl_tree,
                        hf_ieee80211_eht_multi_link_control_reconfig_mld_capa_oper,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(ctl_tree,
                        hf_ieee80211_eht_multi_link_control_reconfig_reserved,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    hf_index = hf_ieee80211_eht_multi_link_type_2_link_count;
  } else if (multi_link_type == TDLS_MULTI_LINK) {
    proto_item_append_text(control, " TDLS");
    /* Presence bitmap is reserved */
    proto_tree_add_item(ctl_tree,
                        hf_ieee80211_eht_multi_link_control_tdls_reserved, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
    hf_index = hf_ieee80211_eht_multi_link_type_3_link_count;
  } else if (multi_link_type == PRIORITY_ACCESS_MULTI_LINK) {
    proto_item_append_text(control, " Priority Access");
    proto_tree_add_item(ctl_tree,
                        hf_ieee80211_eht_multi_link_control_prio_access_reserved,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    hf_index = hf_ieee80211_eht_multi_link_type_4_link_count;
  } else {
    expert_add_info_format(pinfo, type, &ei_ieee80211_eht_invalid_multi_link,
                           "Invalid Multi-Link Control type, value is %u",
                           multi_link_type);
    return;
  }
  offset += 2;

  switch (multi_link_type) {
  case BASIC_MULTI_LINK:
    /* Handle common info for basic element */
    common_info_len = tvb_get_uint8(tvb, offset);
    common_tree = proto_tree_add_subtree(tree, tvb, offset, common_info_len,
                                         ett_eht_multi_link_common_info,
                                         NULL, "Common Info");
    proto_tree_add_item(common_tree, hf_ieee80211_eht_common_field_length, tvb,
                        offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(common_tree, hf_ieee80211_eht_common_field_mld_mac,
                        tvb, offset, 6, ENC_NA);
    offset += 6;

    if (present & EHT_LINK_ID) {
      proto_tree_add_bitmask(common_tree, tvb, offset,
                             hf_ieee80211_eht_common_field_link_id_field,
                             ett_eht_multi_link_common_info_link_id,
                             eht_link_id_hdrs, ENC_NA);
      offset += 1;
    }

    if (present & EHT_BSS_PARAMS) {
      proto_tree_add_item(common_tree,
                          hf_ieee80211_eht_common_field_bss_param_change_count,
                          tvb, offset, 1, ENC_NA);
      offset += 1;
    }

    if (present & EHT_MEDIUM_SYNC) {
      proto_tree_add_bitmask(common_tree, tvb, offset,
                             hf_ieee80211_eht_common_field_medium_sync_field,
                             ett_eht_multi_link_common_info_medium_sync,
                             eht_medium_sync_delay_hdrs, ENC_LITTLE_ENDIAN);
      offset += 2;
    }

    if (present & EHT_EML_CAPA) {
      proto_tree_add_bitmask(common_tree, tvb, offset,
                             hf_ieee80211_eht_common_field_eml_capabilities,
                             ett_eht_multi_link_common_info_eml_capa,
                             eht_eml_capabilities_hdrs, ENC_LITTLE_ENDIAN);
      offset += 2;
    }

    if (present & EHT_MLD_CAPA) {
      proto_tree_add_bitmask(common_tree, tvb, offset,
                             hf_ieee80211_eht_common_field_mld_capabilities,
                             ett_eht_multi_link_common_info_mld_capa,
                             eht_mld_capabilities_hdrs, ENC_LITTLE_ENDIAN);
      offset += 2;
    }

    if (present & EHT_MLD_ID) {
      proto_tree_add_item(common_tree, hf_ieee80211_eht_common_field_mld_id,
                          tvb, offset, 1, ENC_NA);
      offset += 1;
    }

    if (present & EHT_EXT_MLD_CAPA) {
      proto_tree_add_bitmask(common_tree, tvb, offset,
                             hf_ieee80211_eht_common_field_ext_mld_capabilities,
                             ett_eht_multi_link_common_info_ext_mld_capa,
                             eht_ext_mld_capabilities_hdrs, ENC_LITTLE_ENDIAN);
      offset += 2;
    }
    break;
  case PROBE_MULTI_LINK:
    /* Handle common info for probe request element */
    common_info_len = tvb_get_uint8(tvb, offset);
    common_tree = proto_tree_add_subtree(tree, tvb, offset, common_info_len,
                                         ett_eht_multi_link_common_info,
                                         NULL, "Common Info");
    proto_tree_add_item(common_tree, hf_ieee80211_eht_common_field_length, tvb,
                        offset, 1, ENC_NA);
    offset += 1;

    if (present & EHT_PML_MLD_ID) {
      proto_tree_add_item(common_tree, hf_ieee80211_eht_common_field_mld_id,
                          tvb, offset, 1, ENC_NA);
      offset += 1;
    }
    break;
  case RECONFIGURATION_MULTI_LINK:
    common_info_len = tvb_get_uint8(tvb, offset);
    common_tree = proto_tree_add_subtree(tree, tvb, offset, common_info_len,
                                         ett_eht_multi_link_common_info,
                                         NULL, "Common Info");
    proto_tree_add_item(common_tree, hf_ieee80211_eht_common_field_length, tvb,
                        offset, 1, ENC_NA);
    offset += 1;

    if (present & EHT_RECONF_MLD_MAC) {
      proto_tree_add_item(common_tree, hf_ieee80211_eht_common_field_mld_mac,
                          tvb, offset, 6, ENC_NA);
      offset += 6;
    }

    if (present & EHT_RECONF_EML_CAPA) {
      proto_tree_add_bitmask(common_tree, tvb, offset,
                             hf_ieee80211_eht_common_field_eml_capabilities,
                             ett_eht_multi_link_common_info_eml_capa,
                             eht_eml_capabilities_hdrs, ENC_LITTLE_ENDIAN);
      offset += 2;
    }

    if (present & EHT_RECONF_MLD_CAPA) {
      proto_tree_add_bitmask(common_tree, tvb, offset,
                             hf_ieee80211_eht_common_field_mld_capabilities,
                             ett_eht_multi_link_common_info_mld_capa,
                             eht_mld_capabilities_hdrs, ENC_LITTLE_ENDIAN);
      offset += 2;
    }
    break;
  case TDLS_MULTI_LINK:
    common_info_len = tvb_get_uint8(tvb, offset);
    common_tree = proto_tree_add_subtree(tree, tvb, offset, common_info_len,
                                         ett_eht_multi_link_common_info,
                                         NULL, "Common Info");
    proto_tree_add_item(common_tree, hf_ieee80211_eht_common_field_length, tvb,
                        offset, 1, ENC_NA);
    offset += 1;
    proto_tree_add_item(common_tree, hf_ieee80211_eht_common_field_ap_mld_mac,
                        tvb, offset, 6, ENC_NA);
    offset += 6;
    break;
  case PRIORITY_ACCESS_MULTI_LINK:
    common_info_len = tvb_get_uint8(tvb, offset);
    common_tree = proto_tree_add_subtree(tree, tvb, offset, common_info_len,
                                         ett_eht_multi_link_common_info,
                                         NULL, "Common Info");
    proto_tree_add_item(common_tree, hf_ieee80211_eht_common_field_length, tvb,
                        offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(common_tree,
                        hf_ieee80211_eht_common_field_ap_mld_mac, tvb,
                        offset, 6, ENC_NA);
    offset += 6;
    break;
  default:
    /* We should not reach here as we filtered out non-valid values above */
    DISSECTOR_ASSERT_NOT_REACHED();
  }

  /* Handle the link info. It is 0 or more subelements */
  while (tvb_reported_length_remaining(tvb, offset)) {
    uint8_t tag, subelt_len;
    int link_id = -1;

    if (tvb_reported_length_remaining(tvb, offset) < 2) {
      expert_add_info_format(pinfo, tree, &ei_ieee80211_eht_invalid_subelement,
                  "Per-STA Profile subelements must contain at least 2 bytes");
      return;
    }

    tag = tvb_get_uint8(tvb, offset);
    subelt_len = tvb_get_uint8(tvb, offset + 1);

    tvbuff_t *new_tvb;
    int overhead = 0;
    int full_subelt_len;

    switch (tag) {
    case 0:
      /*
       * We have to assemble the sub-elt if there is a continuations. And
       * it will have to be a composite TVB etc.
       */
      new_tvb = get_subelt_tvb(tvb, pinfo, offset, &overhead);
      full_subelt_len = tvb_captured_length_remaining(new_tvb, 0);

      proto_tree_add_item(tree,
                          hf_ieee80211_eht_multi_link_subelt_tag, tvb,
                          offset, 1, ENC_NA);
      offset += 1;
      if (full_subelt_len <= 255) {
        proto_tree_add_item(tree,
                            hf_ieee80211_eht_multi_link_subelt_len, tvb,
                            offset, 1, ENC_NA);
      } else {
        proto_tree_add_uint(tree, hf_ieee80211_eht_multi_link_subelt_len, tvb,
                            0, 0, full_subelt_len);
      }
      offset += 1;

      subelt_tree = proto_tree_add_subtree_format(tree, new_tvb, 0,
                                       full_subelt_len,
                                       ett_eht_multi_link_subelt,
                                       NULL, "Per-STA Profile %d", elt + 1);
      /*
       * There might be some per-STA elements that do not contain link IDs.
       */

      /*
       * We use the sta profile num here. But we need to ensure it is not
       * seen as NULL and we send it in zero based. Will be incremented
       * before use.
       */

      offset += dissect_multi_link_per_sta(new_tvb, pinfo, subelt_tree,
                                           multi_link_type, &link_id);

      offset += overhead; /* Account for the overhead in the subelt */
      if (link_id != -1) {
        local_link_ids[elt] = link_id;
      }
      break;
    case 221:
      /* Add an expert info saying there are none so far? */
      offset += subelt_len + 2;
      break;
    default:
      offset += subelt_len + 2;
      break;
    }
    if (link_id != -1) {
      elt++;
    }
  }
  proto_tree_add_uint(tree, hf_index, tvb, 0, 0, elt);

  if (elt) {
    char link_id_list[128];
    int i, ret, n = 0;
    for (i = 0; i < elt; i++) {
      if (local_link_ids[i] != -1) {
        ret = snprintf(link_id_list + n, 128 - n,
                         (i == 0) ? "%d" : "_%d", local_link_ids[i]);
        n += ret;
      }
    }
    proto_tree_add_string(tree, hf_ieee80211_eht_multi_link_link_id_list, tvb,
                          0, 0, link_id_list);
  }
}

static int * const eht_operation_hdrs[] = {
  &hf_ieee80211_eht_operation_info_present,
  &hf_ieee80211_eht_operation_subchannel_bitmap_present,
  &hf_ieee80211_eht_operation_default_pe_duration,
  &hf_ieee80211_eht_operation_group_addressed_bu_indication_limit,
  &hf_ieee80211_eht_operation_group_addressed_bu_indication_exp,
  &hf_ieee80211_eht_operation_reserved,
  NULL
};

static int *const eht_op_control_hdrs[] = {
  &hf_ieee80211_eht_operation_control_chan_width,
  &hf_ieee80211_eht_operation_control_reserved,
  NULL
};

static const value_string eht_operation_control_chan_wid_vals[] = {
  { 0, "20 MHz EHT BSS bandwidth" },
  { 1, "40 MHz EHT BSS bandwidth" },
  { 2, "80 MHz EHT BSS bandwidth" },
  { 3, "160 MHz EHT BSS bandwidth" },
  { 4, "320 MHz EHT BSS bandwidth" },
  { 5, "Reserved" },
  { 6, "Reserved" },
  { 7, "Reserved" },
  { 0, NULL },
};

static void
dissect_eht_operation(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,
                      int offset, int len _U_)
{
  uint8_t params = tvb_get_uint8(tvb, offset);

  proto_tree_add_bitmask(tree, tvb, offset,
                         hf_ieee80211_eht_operation_parameters,
                         ett_eht_operation_params, eht_operation_hdrs,
                         ENC_LITTLE_ENDIAN);
  offset++;

  if (len < 5) {
    expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length,
                           "This IE appears to conform to an earlier draft than D2.0 and lacks the Basic EHT MCS And MSS Set, len=%d", len);
    return;

  } else {
    proto_tree_add_item(tree, hf_ieee80211_eht_basic_eht_mcs_nss_set, tvb,
                        offset, 4, ENC_LITTLE_ENDIAN);

    offset += 4;
  }

  if (params & 0x01) { /* EHT Operations Info present */
    proto_tree_add_bitmask(tree, tvb, offset,
                           hf_ieee80211_eht_operation_control,
                           ett_eht_operation_control,
                           eht_op_control_hdrs,
                           ENC_NA);
    offset++;

    proto_tree_add_item(tree, hf_ieee80211_eht_operation_ccfs0, tvb, offset, 1,
                        ENC_NA);
    offset++;

    proto_tree_add_item(tree, hf_ieee80211_eht_operation_ccfs1, tvb, offset, 1,
                        ENC_NA);
    offset++;
  }

  if (params & 0x02) { /* Disabled subchannel bitmap present */
    proto_tree_add_item(tree, hf_ieee80211_eht_operation_disabled_bitmap, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
  }
}

static const value_string eht_link_adaptation_vals[] = {
  { 0, "No feedback" },
  { 1, "Reserved" },
  { 2, "Unsolicited" },
  { 3, "Solicited and unsolicited" },
  { 0, NULL },
};

static int * const eht_mac_capa_hdrs[] = {
  &hf_ieee80211_eht_mac_capa_epcs_prio_access_support,
  &hf_ieee80211_eht_mac_capa_eht_om_control_support,
  &hf_ieee80211_eht_mac_capa_trig_txop_sharing_mode_1_support,
  &hf_ieee80211_eht_mac_capa_trig_txop_sharing_mode_2_support,
  &hf_ieee80211_eht_mac_capa_restricted_twt_support,
  &hf_ieee80211_eht_mac_capa_scs_traffic_description_support,
  &hf_ieee80211_eht_mac_capa_maximum_mpdu_length,
  &hf_ieee80211_eht_mac_capa_maximum_ampdu_length_exp_ext,
  &hf_ieee80211_eht_mac_capa_eht_trs_support,
  &hf_ieee80211_eht_mac_capa_txop_return_support_txop_sha_mode,
  &hf_ieee80211_eht_mac_capa_two_bqrs_support,
  &hf_ieee80211_eht_mac_capa_eht_link_adaptation_support,
  &hf_ieee80211_eht_mac_capa_reserved,
  NULL
};

static int * const eht_phy_bits_0_15[] = {
  &hf_ieee80211_eht_phy_bits_0_15_reserved,
  &hf_ieee80211_eht_phy_bits_0_15_320_mhz_in_6ghz,
  &hf_ieee80211_eht_phy_bits_0_15_242_tone_ru_bw_wider_20mhz,
  &hf_ieee80211_eht_phy_bits_0_15_ndp_and_3_2_us_gi,
  &hf_ieee80211_eht_phy_bits_0_15_partial_bw_ul_mu_mimo,
  &hf_ieee80211_eht_phy_bits_0_15_su_beamformer,
  &hf_ieee80211_eht_phy_bits_0_15_su_beamformee,
  &hf_ieee80211_eht_phy_bits_0_15_su_beamformee_le_80mhz,
  &hf_ieee80211_eht_phy_bits_0_15_su_beamformee_eq_160mhz,
  &hf_ieee80211_eht_phy_bits_0_15_su_beamformee_eq_320mhz,
  NULL
};

static int * const eht_phy_bits_16_31[] = {
  &hf_ieee80211_eht_phy_bits_16_31_num_sounding_dims_lt_80mhz,
  &hf_ieee80211_eht_phy_bits_16_31_num_sounding_dims_eq_160mhz,
  &hf_ieee80211_eht_phy_bits_16_31_num_sounding_dims_eq_320mhz,
  &hf_ieee80211_eht_phy_bits_16_31_num_ng_eq_16_su_feedback,
  &hf_ieee80211_eht_phy_bits_16_31_num_ng_eq_16_mu_feedback,
  &hf_ieee80211_eht_phy_bits_16_31_codebook_size_4_2_su_fbck,
  &hf_ieee80211_eht_phy_bits_16_31_codebook_size_7_5_mu_fbck,
  &hf_ieee80211_eht_phy_bits_16_31_triggered_su_beemform_fbck,
  &hf_ieee80211_eht_phy_bits_16_31_triggered_mu_beemform_p_bw_fbck,
  &hf_ieee80211_eht_phy_bits_16_31_triggered_cqi_feedback,
  NULL
};

static int * const eht_phy_bits_32_39[] = {
  &hf_ieee80211_eht_phy_bits_32_39_partial_bw_dl_mu_mimo,
  &hf_ieee80211_eht_phy_bits_32_39_eht_psr_based_sr_support,
  &hf_ieee80211_eht_phy_bits_32_39_power_boost_factor_support,
  &hf_ieee80211_eht_phy_bits_32_39_eht_mu_ppdu_w_4x_eht_ltf_08_gi,
  &hf_ieee80211_eht_phy_bits_32_39_max_nc,
  NULL
};

static int * const eht_phy_bits_40_63[] = {
  &hf_ieee80211_eht_phy_bits_40_63_non_triggered_cqi_fbck,
  &hf_ieee80211_eht_phy_bits_40_63_tx_1024_4096_qam_lt_242_ru_support,
  &hf_ieee80211_eht_phy_bits_40_63_rx_1024_4096_qam_lt_242_ru_support,
  &hf_ieee80211_eht_phy_bits_40_63_ppe_thresholds_present,
  &hf_ieee80211_eht_phy_bits_40_63_common_nominal_packet_padding,
  &hf_ieee80211_eht_phy_bits_40_63_max_num_supported_eht_ltfs,
  &hf_ieee80211_eht_phy_bits_40_63_support_of_mcx_15,
  &hf_ieee80211_eht_phy_bits_40_63_support_of_eht_dup_in_6_ghz,
  &hf_ieee80211_eht_phy_bits_40_63_support_20_mhz_sta_ndp_wide_bw,
  &hf_ieee80211_eht_phy_bits_40_63_non_ofdma_ul_mu_bw_le_80_mhz,
  &hf_ieee80211_eht_phy_bits_40_63_non_ofdma_ul_mu_bw_eq_160_mhz,
  &hf_ieee80211_eht_phy_bits_40_63_non_ofdma_ul_mu_bw_eq_320_mhz,
  &hf_ieee80211_eht_phy_bits_40_63_mu_beamformer_bw_le_80_mhz,
  &hf_ieee80211_eht_phy_bits_40_63_mu_beamformer_bw_eq_160_mhz,
  &hf_ieee80211_eht_phy_bits_40_63_mu_beamformer_bw_eq_320_mhz,
  &hf_ieee80211_eht_phy_bits_40_63_tb_sounding_feedback_rate_limit,
  NULL
};

static int * const eht_phy_bits_64_71[] = {
  &hf_ieee80211_eht_phy_bits_64_71_rx_1024_qam_wid_bw_dl_ofdma_sup,
  &hf_ieee80211_eht_phy_bits_64_71_rx_4096_qam_wid_bw_dl_ofdma_sup,
  &hf_ieee80211_eht_phy_bits_64_71_reserved,
  NULL
};

static int * const eht_mcs_20mhz_map_hdrs[] = {
  &hf_ieee80211_eht_rx_max_nss_20mhz_0_7,
  &hf_ieee80211_eht_tx_max_nss_20mhz_0_7,
  &hf_ieee80211_eht_rx_max_nss_20mhz_8_9,
  &hf_ieee80211_eht_tx_max_nss_20mhz_8_9,
  &hf_ieee80211_eht_rx_max_nss_20mhz_10_11,
  &hf_ieee80211_eht_tx_max_nss_20mhz_10_11,
  &hf_ieee80211_eht_rx_max_nss_20mhz_12_13,
  &hf_ieee80211_eht_tx_max_nss_20mhz_12_13,
  NULL
};

static void
dissect_eht_capabilities(tvbuff_t *tvb, packet_info *pinfo _U_,
                         proto_tree *tree, int offset, int len _U_)
{
  proto_tree *eht_phy_capa = NULL, *eht_mcs_nss = NULL;
  bool ch_320mhz_in_6ghz = false;
  bool ppe_thresholds_present = false;

  proto_tree_add_bitmask(tree, tvb, offset, hf_ieee80211_eht_mac_capabilities,
                         ett_eht_mac_capa, eht_mac_capa_hdrs,
                         ENC_LITTLE_ENDIAN);
  offset += 2;

  ch_320mhz_in_6ghz = tvb_get_uint8(tvb, offset) & 0x02;

  eht_phy_capa = proto_tree_add_subtree(tree, tvb, offset, 9,
                                        ett_eht_phy_capa, NULL,
                                        "EHT PHY Capabilities Information");
  proto_tree_add_bitmask_with_flags(eht_phy_capa, tvb, offset,
                                    hf_ieee80211_eht_phy_bits_0_15,
                                    ett_eht_phy_bits_0_15, eht_phy_bits_0_15,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;

  proto_tree_add_bitmask_with_flags(eht_phy_capa, tvb, offset,
                                    hf_ieee80211_eht_phy_bits_16_31,
                                    ett_eht_phy_bits_16_31, eht_phy_bits_16_31,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;

  proto_tree_add_bitmask_with_flags(eht_phy_capa, tvb, offset,
                                    hf_ieee80211_eht_phy_bits_32_39,
                                    ett_eht_phy_bits_32_39, eht_phy_bits_32_39,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  ppe_thresholds_present = tvb_get_uint8(tvb, offset) & 0x08;
  proto_tree_add_bitmask_with_flags(eht_phy_capa, tvb, offset,
                                    hf_ieee80211_eht_phy_bits_40_63,
                                    ett_eht_phy_bits_40_63, eht_phy_bits_40_63,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 3;

  proto_tree_add_bitmask_with_flags(eht_phy_capa, tvb, offset,
                                    hf_ieee80211_eht_phy_bits_64_71,
                                    ett_eht_phy_bits_64_71, eht_phy_bits_64_71,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  /*
   * We need to figure out the channel width set and frequency for this but it
   * is only possible if we got the frequency info and the channel width set
   * was added to the pinfo. If we don't have that simply add the rest as
   * uninterpreted bytes.
   */
  eht_mcs_nss = proto_tree_add_subtree(tree, tvb, offset,
                               tvb_captured_length_remaining(tvb, offset),
                               ett_eht_phy_mcs_nss, NULL,
                               "Supported EHT-MCS and NSS Set");

  if (pinfo->pseudo_header->ieee_802_11.has_frequency) {
    unsigned *p_channel_width_set =
      (unsigned *)p_get_proto_data(wmem_file_scope(), pinfo, proto_wlan,
                                HE_CHANNEL_WIDTH_KEY);
    unsigned channel_width_set = 0;
    /*
     * If we got it, we can handle the rest, otherwise not. Note,
     * we can determine if it was ever set by checking for non-zero because
     * we set at least one bit when saving it..
     */
    if (p_channel_width_set) {
      bool is_ap = GPOINTER_TO_UINT(p_get_proto_data(wmem_file_scope(),
                                                         pinfo, proto_wlan,
                                                         IS_AP_KEY));
      channel_width_set = GPOINTER_TO_UINT(p_channel_width_set);

      /* Distinguish between the AP and the non-AP cases as the logis is easier
       * even if that means some duplicate code.
       */
      if (is_ap) {
        /* The EHT-MCS and NSS set for BW <= 80MHz Ap etc */
        if (tvb_captured_length_remaining(tvb, offset) < 3) {
          expert_add_info_format(pinfo, eht_mcs_nss, &ei_ieee80211_bad_length,
                           "Insufficient bytes for EHT Capabilities. Need 3. "
                           "Perhaps the EHT Capabilities field is malformed.");
          return;
        }
        proto_tree_add_bitmask(eht_mcs_nss, tvb, offset,
                               hf_ieee80211_eht_mcs_and_nss_le_80mhz,
                               ett_eht_phy_mcs_nss_set,
                               eht_le_80_mcs_map_hdrs,
                               ENC_LITTLE_ENDIAN);
        offset += 3;

        if (channel_width_set & 0x04) { /* B2 is set */
          if (tvb_captured_length_remaining(tvb, offset) < 3) {
            expert_add_info_format(pinfo, eht_mcs_nss, &ei_ieee80211_bad_length,
                           "Insufficient bytes for EHT Capabilities. Need 3 for AP 160MHz. "
                           "Perhaps the EHT Capabilities field is malformed.");
            return;
          }
          proto_tree_add_bitmask(eht_mcs_nss, tvb, offset,
                                 hf_ieee80211_eht_mcs_and_nss_eq_160mhz,
                                 ett_eht_phy_mcs_nss_set,
                                 eht_160_mcs_map_hdrs,
                                 ENC_LITTLE_ENDIAN);
          offset += 3;
        }
        if (ch_320mhz_in_6ghz &&
            IS_6_GHZ(pinfo->pseudo_header->ieee_802_11.frequency)) {
          if (tvb_captured_length_remaining(tvb, offset) < 3) {
            expert_add_info_format(pinfo, eht_mcs_nss, &ei_ieee80211_bad_length,
                           "Insufficient bytes for EHT Capabilities. Need 3. "
                           "Perhaps the EHT Capabilities field is malformed.");
            return;
          }
          proto_tree_add_bitmask(eht_mcs_nss, tvb, offset,
                                 hf_ieee80211_eht_mcs_and_nss_eq_320mhz,
                                 ett_eht_phy_mcs_nss_set,
                                 eht_320_mcs_map_hdrs,
                                 ENC_LITTLE_ENDIAN);
          offset += 3;
        }
      } else {
        /* Add the info for a 20MHz-Only Non-AP. But have to check both
         * frequency sets for some cases */
        if ((channel_width_set & 0x07) == 0) {
          if (tvb_captured_length_remaining(tvb, offset) < 4) {
            expert_add_info_format(pinfo, eht_mcs_nss, &ei_ieee80211_bad_length,
                           "Insufficient bytes for EHT Capabilities. Need 4. "
                           "Perhaps the EHT Capabilities field is malformed.");
           return;
          }
          proto_tree_add_bitmask(eht_mcs_nss, tvb, offset,
                                 hf_ieee80211_eht_mcs_and_nss_non_ap,
                                 ett_eht_phy_mcs_nss_set,
                                 eht_mcs_20mhz_map_hdrs,
                                 ENC_LITTLE_ENDIAN);
          offset += 4;
        }
        /* Now, the next set BW <= 80MHz except ...
         * If 2.4GHz and B0 is 1, or 5GHz or 6GHz and B1 */
        if ((IS_2_4_GHZ(pinfo->pseudo_header->ieee_802_11.frequency) &&
             channel_width_set & 0x01) ||
            (channel_width_set & 0x02)) {
          if (tvb_captured_length_remaining(tvb, offset) < 3) {
            expert_add_info_format(pinfo, eht_mcs_nss, &ei_ieee80211_bad_length,
                           "Insufficient bytes for EHT Capabilities. Need 3 for le 80MHz. "
                           "Perhaps the EHT Capabilities field is malformed.");
            return;
          }
          proto_tree_add_bitmask(eht_mcs_nss, tvb, offset,
                                 hf_ieee80211_eht_mcs_and_nss_le_80mhz,
                                 ett_eht_phy_mcs_nss_set,
                                 eht_le_80_mcs_map_hdrs,
                                 ENC_LITTLE_ENDIAN);
          offset += 3;

        }
        if (!IS_2_4_GHZ(pinfo->pseudo_header->ieee_802_11.frequency) &&
            channel_width_set & 0x04) { /* B2 is set */
          if (tvb_captured_length_remaining(tvb, offset) < 3) {
            expert_add_info_format(pinfo, eht_mcs_nss, &ei_ieee80211_bad_length,
                           "Insufficient bytes for EHT Capabilities. Need 3 for 160MHz. "
                           "Perhaps the EHT Capabilities field is malformed.");
            return;
          }
          proto_tree_add_bitmask(eht_mcs_nss, tvb, offset,
                                 hf_ieee80211_eht_mcs_and_nss_eq_160mhz,
                                 ett_eht_phy_mcs_nss_set,
                                 eht_160_mcs_map_hdrs,
                                 ENC_LITTLE_ENDIAN);
          offset += 3;
        }
        if (ch_320mhz_in_6ghz &&
            IS_6_GHZ(pinfo->pseudo_header->ieee_802_11.frequency)) {
          if (tvb_captured_length_remaining(tvb, offset) < 3) {
            expert_add_info_format(pinfo, eht_mcs_nss, &ei_ieee80211_bad_length,
                           "Insufficient bytes for EHT Capabilities. Need 3 for 320MHz. "
                           "Perhaps the EHT Capabilities field is malformed.");
            return;
          }
          proto_tree_add_bitmask(eht_mcs_nss, tvb, offset,
                                 hf_ieee80211_eht_mcs_and_nss_eq_320mhz,
                                 ett_eht_phy_mcs_nss_set,
                                 eht_320_mcs_map_hdrs,
                                 ENC_LITTLE_ENDIAN);
          offset += 3;
        }
      }
    } else {
      proto_tree_add_item(eht_mcs_nss, hf_ieee80211_eht_supported_mcs_nss_bytes,
                          tvb, offset,
                          tvb_captured_length_remaining(tvb, offset), ENC_NA);
      offset += tvb_captured_length_remaining(tvb, offset);
    }
  }

  /*
   * If the PPE thresholds are present, add them.
   */
  if (ppe_thresholds_present) {
    proto_tree_add_item(tree, hf_ieee80211_eht_ppe_thresholds, tvb, offset,
                        tvb_captured_length_remaining(tvb, offset), ENC_NA);
  }
}

static const value_string tid_to_link_mapping_dirn_vals[] = {
  { 0, "Uplink" },
  { 1, "Downlink" },
  { 2, "Bidirectional link" },
  { 0, NULL }
};

static const value_string ttl_link_mapping_size_vals[] = {
  { 0, "2 octets" },
  { 1, "1 octet" },
  { 0, NULL }
};

static int * const eht_ttl_mapping_control_hdrs[] = {
  &hf_ieee80211_eht_ttl_mapping_direction,
  &hf_ieee80211_eht_ttl_default_link_mapping,
  &hf_ieee80211_eht_ttl_mapping_switch_time_pres,
  &hf_ieee80211_eht_ttl_expected_dura_pres,
  &hf_ieee80211_eht_ttl_link_mapping_size,
  &hf_ieee80211_eht_ttl_mapping_reserved,
  NULL
};

static void
dissect_tid_to_link_mapping(tvbuff_t *tvb, packet_info *pinfo _U_,
                            proto_tree *tree, int offset, int len _U_)
{
  proto_item *control = NULL;
  uint8_t presence;
  uint8_t control_byte = tvb_get_uint8(tvb, offset);
  uint8_t map_size = 2;
  int hf_array[8] = {hf_ieee80211_eht_ttl_mapping_tid_0_link_mapping,
                     hf_ieee80211_eht_ttl_mapping_tid_1_link_mapping,
                     hf_ieee80211_eht_ttl_mapping_tid_2_link_mapping,
                     hf_ieee80211_eht_ttl_mapping_tid_3_link_mapping,
                     hf_ieee80211_eht_ttl_mapping_tid_4_link_mapping,
                     hf_ieee80211_eht_ttl_mapping_tid_5_link_mapping,
                     hf_ieee80211_eht_ttl_mapping_tid_6_link_mapping,
                     hf_ieee80211_eht_ttl_mapping_tid_7_link_mapping};
  int hf_index = 0;

  /*
   * If the Default Link Mapping bit is set, we only have 1 byte, otherwise 2
   */
  control = proto_tree_add_bitmask_with_flags(tree, tvb, offset,
              hf_ieee80211_eht_ttl_mapping_control,
              ett_eht_ttl_mapping,
              eht_ttl_mapping_control_hdrs,
              ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  if (len == 1) {
    return;
  }

  presence = tvb_get_uint8(tvb, offset);

  proto_tree_add_item(control, hf_ieee80211_eht_ttl_mapping_presence, tvb,
                      offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  if (control_byte & 0x08) {
      proto_tree_add_item(tree, hf_ieee80211_eht_ttl_mapping_switch_time, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
  }

  if (control_byte & 0x10) {
      proto_tree_add_item(tree, hf_ieee80211_eht_ttl_mapping_expected_duration, tvb,
                          offset, 3, ENC_LITTLE_ENDIAN);
      offset += 3;
  }

  if (control_byte & 0x20) {
    map_size = 1;
  }
  while (presence) {
    if (presence & 0x01) {
      proto_tree_add_item(tree, hf_array[hf_index], tvb,
                          offset, map_size, ENC_LITTLE_ENDIAN);
      offset += map_size;
    }
    hf_index++;
    presence = presence >> 1;
  }
}

static int * const ml_traffic_control_hdrs[] = {
  &hf_ieee80211_eht_multi_link_tc_bitmap_size,
  &hf_ieee80211_eht_multi_link_tc_aid_offset,
  &hf_ieee80211_eht_multi_link_tc_reserved,
  NULL
};

static void
dissect_multi_link_traffic(tvbuff_t *tvb, packet_info *pinfo _U_,
                           proto_tree *tree, int offset, int len _U_)
{
  proto_tree_add_bitmask(tree, tvb, offset,
                         hf_ieee80211_eht_multi_link_traffic_control,
                         ett_eht_eht_multi_link_tc,
                         ml_traffic_control_hdrs,
                         ENC_LITTLE_ENDIAN);
  offset += 2;
  len -= 2;

  /* If there is nothing more, bail. */
  if (len <= 0)
    return;

  /* Now, add the traffic indication list as a byte string for the moment */
  proto_tree_add_item(tree, hf_ieee80211_eht_multi_link_traffic_indication,
                      tvb, offset, tvb_captured_length_remaining(tvb, offset),
                      ENC_NA);
}

#define MAX_MSDU_SIZE_PRESENT           0x0001
#define SERVICE_START_TIME_PRESENT      0x0002
#define SERVICE_START_TIME_LID_PRESENT  0x0004
#define MEAN_DATA_RATE_PRESENT          0x0008
#define BURST_SIZE_PRESENT              0x0010
#define MSDU_LIFETIME_PRESENT           0x0020
#define MSDU_DELIVERY_INFO_PRESENT      0x0040
#define MEDIUM_TIME_PRESENT             0x0080

static const value_string qos_chars_dirn_vals[] = {
  { 0, "Uplink" },
  { 1, "Downlink" },
  { 2, "Direct link" },
  { 3, "Reserved" },
  { 0, NULL }
};

static void
dissect_qos_characteristics(tvbuff_t *tvb, packet_info *pinfo _U_,
                            proto_tree *tree, int offset, int len _U_)
{
  proto_tree *control_tree = NULL;
  uint16_t presence_bitmap = (tvb_get_letohl(tvb, offset) >> 9) & 0xFFFF;

  control_tree = proto_tree_add_subtree(tree, tvb, offset, 4,
                                        ett_eht_qos_characteristics,
                                        NULL, "Control Info");

  proto_tree_add_item(control_tree, hf_ieee80211_eht_qos_chars_dirn, tvb,
                      offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(control_tree, hf_ieee80211_eht_qos_chars_tid, tvb,
                      offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(control_tree, hf_ieee80211_eht_qos_chars_user_prio, tvb,
                      offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(control_tree, hf_ieee80211_eht_qos_chars_bitmap, tvb,
                      offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(control_tree, hf_ieee80211_eht_qos_chars_linkid, tvb,
                      offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(control_tree, hf_ieee80211_eht_qos_chars_resrvd, tvb,
                      offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  /* Now add the fields, including the optional ones. */
  proto_tree_add_item(tree, hf_ieee80211_eht_qos_chars_min_svc_interval, tvb,
                      offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_eht_qos_chars_max_svc_interval, tvb,
                      offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_eht_qos_chars_min_data_rate, tvb,
                      offset, 3, ENC_LITTLE_ENDIAN);
  offset += 3;

  proto_tree_add_item(tree, hf_ieee80211_eht_qos_chars_delay_bound, tvb,
                      offset, 3, ENC_LITTLE_ENDIAN);
  offset += 3;

  /* Now the optional ones */
  if (presence_bitmap & MAX_MSDU_SIZE_PRESENT) {
    proto_tree_add_item(tree, hf_ieee80211_eht_qos_chars_max_msdu_size, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }

  if (presence_bitmap & SERVICE_START_TIME_PRESENT) {
    proto_tree_add_item(tree, hf_ieee80211_eht_qos_chars_service_start_time,
                        tvb, offset, 4, ENC_LITTLE_ENDIAN);
    offset += 4;
  }

  if (presence_bitmap & SERVICE_START_TIME_LID_PRESENT) {
    proto_tree_add_item(tree, hf_ieee80211_eht_qos_chars_service_start_time_linkid,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
  }

  if (presence_bitmap & MEAN_DATA_RATE_PRESENT) {
    proto_tree_add_item(tree, hf_ieee80211_eht_qos_chars_mean_data_rate, tvb,
                        offset, 3, ENC_LITTLE_ENDIAN);
    offset += 3;
  }

  if (presence_bitmap & BURST_SIZE_PRESENT) {
    proto_tree_add_item(tree, hf_ieee80211_eht_qos_chars_burst_size, tvb,
                        offset, 4, ENC_LITTLE_ENDIAN);
    offset += 4;
  }

  if (presence_bitmap & MSDU_LIFETIME_PRESENT) {
    proto_tree_add_item(tree, hf_ieee80211_eht_qos_chars_msdu_lifetime, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }

  if (presence_bitmap & MSDU_DELIVERY_INFO_PRESENT) {
    proto_tree_add_item(tree, hf_ieee80211_eht_qos_chars_msdu_delivery_ratio,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_ieee80211_eht_qos_chars_msdu_count_exponent,
                        tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
  }

  if (presence_bitmap & MEDIUM_TIME_PRESENT) {
    proto_tree_add_item(tree, hf_ieee80211_eht_qos_chars_medium_time, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
  }
}

static void
dissect_akm_suite_selector(tvbuff_t *tvb, packet_info *pinfo _U_,
                           proto_tree *tree, int offset, int len _U_)
{
  proto_tree_add_item(tree, hf_ieee80211_rsn_akms_oui, tvb, offset, 3, ENC_BIG_ENDIAN);
  if (tvb_get_ntoh24(tvb, offset) == OUI_RSN)
  {
    proto_tree_add_item(tree, hf_ieee80211_rsn_akms_80211_type, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);
  } else {
    proto_tree_add_item(tree, hf_ieee80211_rsn_akms_type, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);
  }
}

static void
dissect_mlo_link_information(tvbuff_t *tvb, packet_info *pinfo _U_,
                             proto_tree *tree, int offset, int len _U_)
{
  proto_tree_add_item(tree, hf_ieee80211_eht_link_id_bitmap, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
}

static int * const ieee80211_eht_aid_bmapctl[] = {
  &hf_ieee80211_eht_aid_bitmap_control_reserved,
  &hf_ieee80211_eht_aid_bitmap_control_offset,
  NULL
};

static void
dissect_aid_bitmap(tvbuff_t *tvb, packet_info *pinfo _U_,
                   proto_tree *tree, int offset, int len _U_)
{
  unsigned aid, pab_len, n1, i, j, byte;

  pab_len = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_eht_aid_bitmap_length, tvb, offset, 1,
                      ENC_LITTLE_ENDIAN);
  offset += 1;

  n1 = tvb_get_uint8(tvb, offset) & 0xFE;
  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_eht_aid_bitmap_control,
                                    ett_eht_aid_bmapctl_tree,
                                    ieee80211_eht_aid_bmapctl,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_eht_aid_bitmap_partial_aid_bitmap,
                      tvb, offset, pab_len, ENC_NA);
  for (i = 0; i < pab_len; i++) {
    byte = tvb_get_uint8(tvb, offset + i);
    for (j = 0; j < 8; j++) {
      if (byte & (1 << j)) {
        aid = 8*n1 + 8*i + j;
        proto_tree_add_uint(tree, hf_ieee80211_eht_aid_bitmap_aid, tvb,
                            offset + i, 1, aid);
      }
    }
  }
}

static int *const eht_bw_indi_param_hdrs[] = {
  &hf_ieee80211_eht_bw_indi_param_reserved,
  &hf_ieee80211_eht_bw_indi_param_disabled_subchan_bitmap,
  &hf_ieee80211_eht_bw_indi_param_reserved1,
  NULL
};

static void
dissect_bandwidth_indication(tvbuff_t *tvb, packet_info *pinfo _U_,
                             proto_tree *tree, int offset, int len _U_)
{
  uint8_t params;

  params = tvb_get_uint8(tvb, offset);
  proto_tree_add_bitmask(tree, tvb, offset,
                         hf_ieee80211_eht_bw_indi_param,
                         ett_eht_bw_indication_param,
                         eht_bw_indi_param_hdrs,
                         ENC_NA);
  offset++;

  proto_tree_add_bitmask(tree, tvb, offset,
                         hf_ieee80211_eht_operation_control,
                         ett_eht_operation_control,
                         eht_op_control_hdrs,
                         ENC_NA);
  offset++;

  proto_tree_add_item(tree, hf_ieee80211_eht_operation_ccfs0, tvb, offset, 1,
                      ENC_NA);
  offset++;

  proto_tree_add_item(tree, hf_ieee80211_eht_operation_ccfs1, tvb, offset, 1,
                      ENC_NA);
  offset++;

  if (params & 0x02) { /* Disabled subchannel bitmap present */
    proto_item *item;
    int8_t i;
    char bitmap_binary[32];
    uint16_t bitmap = tvb_get_uint16(tvb, offset, ENC_LITTLE_ENDIAN);
    item = proto_tree_add_item(tree, hf_ieee80211_eht_bw_indi_diabled_bitmap, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
    memset(bitmap_binary, 0 ,sizeof(bitmap_binary));
    for (i = 15; i >= 0; i--) {
      if (bitmap & (1 << i))
        bitmap_binary[15-i] = '1';
      else
        bitmap_binary[15-i] = '0';
    }
    proto_item_append_text(item, " (%s)", bitmap_binary);
  }
}

static void
add_min_max_time_between_measurements(proto_item *item, tvbuff_t *tvb, packet_info *pinfo, int offset, int sub_length)
{
  uint64_t ntb_specific, min, max;

  if (sub_length < 6) {
      return;
  }

  ntb_specific = tvb_get_int48(tvb, offset, ENC_LITTLE_ENDIAN);

  min = (ntb_specific >> 1) & GENMASK(22, 0);
  max = (ntb_specific >> 24) & GENMASK(19, 0);

  /* convert to microseconds */
  min *= 100; /* min time is in units of 100 microseconds */
  max *= 10 * 1000; /* max time is in units of 10 milliseconds */

  float minf = (float)(min / 1E6);
  float maxf = (float)(max / 1E6);

  proto_item_append_text(item, " (Min=%.6gs, Max=%.6gs)", minf, maxf);
  col_append_fstr(pinfo->cinfo, COL_INFO, ", Min=%.6gs, Max=%.6gs", minf, maxf);
}

static void
dissect_ntb_specific(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int sub_length)
{
  static int * const nontb_fields[] = {
    &hf_ieee80211_tag_ranging_ntb_reserved1,
    &hf_ieee80211_tag_ranging_ntb_min_time_msmts,
    &hf_ieee80211_tag_ranging_ntb_max_time_msmts,
    &hf_ieee80211_tag_ranging_ntb_r2i_tx_power,
    &hf_ieee80211_tag_ranging_ntb_i2r_tx_power,
    &hf_ieee80211_tag_ranging_ntb_reserved2,
    NULL};
  proto_tree *item;

  item = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_ranging_ntb,
                                           ett_tag_ranging_ntb, nontb_fields,
                                           ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  col_append_str(pinfo->cinfo, COL_INFO, ", NTB");
  add_min_max_time_between_measurements(item, tvb, pinfo, offset, sub_length);
}

static const range_string ranging_subelt_types[] = {
  { 0, 0, "Non-TB specific" },
  { 1, 1, "TB-specific" },
  { 2, 220, "Reserved" },
  { 221, 221, "Vendor Specific" },
  { 222, 255, "Reserved" },
  { 0, 0, NULL }
};

static int
dissect_tb_specific(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
    int offset, int sub_length _U_)
{

    /* Now add the extra 32-bits of items */
    proto_tree_add_item(tree, hf_ieee80211_tag_ranging_aid_rsid, tvb,
                        offset, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_ieee80211_tag_ranging_device_class, tvb,
                        offset, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_ieee80211_tag_ranging_full_bw_ul_mu_mimo, tvb,
                        offset, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_ieee80211_tag_ranging_trigger_frame_paddur,
                        tvb, offset, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_ieee80211_tag_ranging_max_sess_exp, tvb,
                        offset, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_ieee80211_tag_ranging_passive_tb_ranging, tvb,
                        offset, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_ieee80211_tag_ranging_tb_specific_reserved,
                        tvb, offset, 4, ENC_LITTLE_ENDIAN);
    offset += 4;

    offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);

    return offset;
}

static void
dissect_ranging_parameters(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int len)
{
  int tag_len = tvb_reported_length(tvb);
  static int * const ranging_params_fields[] = {
    &hf_ieee80211_tag_ranging_status_indication,
    &hf_ieee80211_tag_ranging_value,
    &hf_ieee80211_tag_ranging_i2r_lmr_feedback,
    &hf_ieee80211_tag_ranging_secure_ltf_required,
    &hf_ieee80211_tag_ranging_secure_ltf_support,
    &hf_ieee80211_tag_ranging_ranging_priority,
    &hf_ieee80211_tag_ranging_r2i_toa_type,
    &hf_ieee80211_tag_ranging_i2r_toa_type,
    &hf_ieee80211_tag_ranging_r2i_aoa_requested,
    &hf_ieee80211_tag_ranging_i2r_aoa_requested,
    &hf_ieee80211_tag_ranging_format_and_bandwidth,
    &hf_ieee80211_tag_ranging_immediate_r2i_feedback,
    &hf_ieee80211_tag_ranging_immediate_i2r_feedback,
    &hf_ieee80211_tag_ranging_max_i2r_repetition,
    &hf_ieee80211_tag_ranging_max_r2i_repetition,
    &hf_ieee80211_tag_ranging_reserved1,
    &hf_ieee80211_tag_ranging_reserved2,
    &hf_ieee80211_tag_ranging_max_r2i_sts_le_80_mhz,
    &hf_ieee80211_tag_ranging_max_r2i_sts_gt_80_mhz,
    &hf_ieee80211_tag_ranging_max_r2i_ltf_total,
    &hf_ieee80211_tag_ranging_max_i2r_ltf_total,
    &hf_ieee80211_tag_ranging_max_i2r_sts_le_80_mhz,
    &hf_ieee80211_tag_ranging_max_i2r_sts_gt_80_mhz,
    &hf_ieee80211_tag_ranging_bss_color_info,
    NULL};
  static const value_string short_status[] = {
    { 0, "Reserved" },
    { 1, "Successful" },
    { 2, "Request incapable" },
    { 3, "Request failed" },
    { 0, NULL }
  };

  if (len < 6) {
    expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length,
                           "Ranging Parameters must be at least 6 octets long");
    return;
  }

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_ranging_parameters,
                                    ett_tag_ranging, ranging_params_fields,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  uint8_t status = tvb_get_uint8(tvb, offset) & GENMASK(1, 0);
  if (status != 0) {
    col_append_fstr(pinfo->cinfo, COL_INFO, ", Status=%d (%s)", status,
                    val_to_str_const(status, short_status, "Unknown"));
  }

  offset += 7;

  while (offset < len) {
    uint8_t sub_id, sub_length;
    proto_item *sub_elt_len, *rsti;
    proto_tree *sub_tree;
    unsigned subelt = 0;
    unsigned start_offset = offset;

    sub_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                        ett_ranging_subelement_tree, &rsti,
                        "Ranging Subelement %d", subelt);


    sub_id = tvb_get_uint8(tvb, offset);
    proto_item_append_text(sub_tree, ": %s",
                           rval_to_str_const(sub_id, ranging_subelt_types, "Reserved"));
    proto_tree_add_item(sub_tree, hf_ieee80211_tag_ranging_subelt_tag, tvb,
                        offset, 1, ENC_NA);
    offset += 1;

    sub_length = tvb_get_uint8(tvb, offset);
    sub_elt_len = proto_tree_add_item(sub_tree,
                                      hf_ieee80211_tag_ranging_subelt_len,
                                      tvb, offset, 1, ENC_NA);
    offset += 1;

    if (offset + sub_length > tag_len) {
      expert_add_info_format(pinfo, sub_elt_len, &ei_ieee80211_tag_length,
          "Subelement length (%u) exceeds remaining tag length (%u)",
          sub_length, tvb_captured_length_remaining(tvb, offset));
      proto_item_set_len(rsti, offset - start_offset);
      return;
    }

    switch (sub_id) {
      case 0:  /* non-TB specific */
        dissect_ntb_specific(tvb, pinfo, tree, offset, sub_length);
        break;
      case 1: /* Ranging SUB_TB_SPECIFIC */
        /* TODO: Specify the acceptable tagged elements */
        offset = dissect_tb_specific(tvb, pinfo, tree, offset, sub_length);
        break;
      default:  /* skip unknown elements which may be defined in the future */
        break;
    }

    offset += sub_length;
    subelt++;
    proto_item_set_len(rsti, offset - start_offset);
  }
}

static int * const aoa_results_fields[] = {
  &hf_ieee80211_tag_ftm_aoa_results_aoa_azimuth,
  &hf_ieee80211_tag_ftm_aoa_results_aoa_elevation,
  &hf_ieee80211_tag_ftm_aoa_results_aoa_azimuth_accuracy,
  &hf_ieee80211_tag_ftm_aoa_results_aoa_elevation_accuracy,
  &hf_ieee80211_tag_ftm_aoa_results_best_awv_id,
  &hf_ieee80211_tag_ftm_aoa_results_aoa_reference,
  &hf_ieee80211_tag_ftm_aoa_results_reserved,
  NULL
};

static const true_false_string aoa_reference_tfs = {
  "Earth coordinates",
  "STA-relative coordinated"
};

static void
aoa_azimuth_custom(char *result, uint32_t aoa_azimuth)
{
  float az = aoa_azimuth * (360.0f / 2048.0f);

  snprintf(result, ITEM_LABEL_LENGTH, "%f7.3", az);
}

static void
aoa_elevation_custom(char *result, uint32_t aoa_elevation)
{
  float el = (aoa_elevation - 512) * (180.0f / 1024.0f);

  snprintf(result, ITEM_LABEL_LENGTH, "%f7.3", el);
}

static void
aoa_accuracy_custom(char *result, uint32_t aoa_accuracy)
{
  float ac = aoa_accuracy * (360.0f / 1024.0f);

  if (aoa_accuracy == 127) {
    snprintf(result, ITEM_LABEL_LENGTH, "No ability to estimate accuracy");
  } else if (aoa_accuracy == 126) {
    snprintf(result, ITEM_LABEL_LENGTH, "No measurement");
  } else if (aoa_accuracy == 125) {
    snprintf(result, ITEM_LABEL_LENGTH, "Larger than %7.3f", ac);
  } else {
    snprintf(result, ITEM_LABEL_LENGTH, "%f7.3", ac);
  }
}

static void
dissect_direction_measurement_results(tvbuff_t *tvb, packet_info *pinfo _U_,
                                      proto_tree *tree, int offset, int len _U_)
{
  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_tag_dirn_meas_results_aoa_results,
                                    ett_tag_direct_meas_results,
                                    aoa_results_fields,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
}

/* ************************************************************************* */
/*           Dissect and add tagged (optional) fields to proto tree          */
/* ************************************************************************* */

static int
ieee80211_tag_ssid(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  /* 7.3.2.1 SSID element (0) */
  char ssid[MAX_SSID_LEN]; /* The SSID may consist of arbitrary bytes */
  int ssid_len;

  if (beacon_padding != 0) /* padding bug */
    return offset;

  if (tag_len > MAX_SSID_LEN) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "SSID length (%u) greater than maximum (%u)",
                           tag_len, MAX_SSID_LEN);
  }

  /*
   * XXX - the 802.11 specs aren't particularly clear on how the SSID
   * is to be interpreted.
   *
   * IEEE Std 802.11-1999, section 7.3.2.2 "Service Set Identity (SSID)
   * element" says just
   *
   *    The length of the SSID information field is between 0 and 32
   *    octets. A 0 length information field indicates the broadcast SSID.
   *
   * with no indication that those octets encode a string.
   *
   * IEEE Std 802.11-2012, section 8.4.2.2 "SSID element", says that *but*
   * says after it
   *
   *    When the UTF-8 SSID subfield of the Extended Capabilities element
   *    is equal to 1 in the frame that includes the SSID element, the
   *    SSID is interpreted using UTF-8 encoding.
   *
   *    NOTE -- This is true for Beacon and Probe Response frames when the
   *    MLME-START.request primitive was issued with the SSIDEncoding
   *    parameter equal to UTF-8.
   *
   * and the SSIDEncoding parameter can either be UNSPECIFIED or UTF-8.
   *
   * IEEE Std 802.11-2020, section 9.4.2.2 "SSID element" changes the
   * wording to:
   *
   *    When the UTF-8 SSID subfield of the Extended Capabilities element is
   *    equal to 1 in the frame that includes the SSID element, or the Extended
   *    Capabilities of the source of the SSID information is known to include
   *    the UTF-8 SSID capability based on a previously received Extended
   *    Capabilities element, the SSID is a sequence of UTF-8 encoded code
   *    points. Otherwise, the character encoding of the octets in this SSID
   *    element is unspecified.
   *
   *    NOTE—If the SSID is a sequence of UTF-8 encoded code points, a
   *    terminating null might or might not be present.
   *
   * So I *guess* that means that, if the UTF-8 SSID subfield isn't
   * equal to 1, the SSID is, in theory, just a bunch of octets, but
   * in practice, *probably* UTF-8 as that's the typical convention,
   * and, if it is equal to 1, it's a possibly null-terminated UTF-8
   * string.  (Of course, a host can put anything there it wants to,
   * so we shouldn't just assume that it's *valid* ASCII or *valid* UTF-8.)
   *
   * So we really should extract it as an array of ssid_len bytes,
   * pass those bytes to Dot11DecryptSetLastSSID(), and:
   *
   *    If the UTF-8 SSID subfield isn't set to 1, put the SSID in
   *    a FT_BYTES as BASE_SHOW_UTF_8_PRINTABLE;
   *
   *    If the UTF-8 SSID subfield is set to 1, put it in as an
   *    ENC_UTF_8 string;
   *
   * XXX: Note that the Extended Capabilities tagged parameter is specified
   * to come *after* the SSID parameter (and "Fields and elements appear
   * in the specified, relative order" per 9.3.3.1 of IEEE 802.11 2020),
   * isn't sent with Response frames, and isn't guaranteed to appear with
   * Request frames (if none of the bits would be set, then it isn't
   * mandatory). We could store the bit if it appears in the conversation
   * data, which would handle Response frames and subsequent passes, but
   * for the first pass we don't know the value of the subfield until later.
   * We could store the proto_item with the ssid and add the string version
   * later, or add the string always as a hidden item and make it visible
   * later, or something else.
   *
   * Addendum: 802.11 2012 points out that a Zero-length SSID means
   * the Wildcard SSID. Make it so. From 8.4.2.2 of 802.11 2012:
   *
   * "The length of the SSID field is between 0 and 32 octets. A SSID
   *  field of length 0 is used within Probe Request management frames to
   *  indicate the wildcard SSID. The wildcard SSID is also used in
   *  Beacon and Probe Response frames transmitted by mesh STAs."
   *
   * Also, we have to return a non-zero value here to prevent an ugly
   * undissected field warning. Since this code is only called from
   * one place and is used in call to dissector_try_uint_new, it is
   * OK to do so.
   */
  ssid_len = tvb_get_raw_bytes_as_string(tvb_new_subset_length(tvb, offset, tag_len), offset, ssid, MAX_SSID_LEN);
  if (ssid_len == (int)tag_len) {
    Dot11DecryptSetLastSSID(&dot11decrypt_ctx, (char *) ssid, ssid_len);
  }
  char *s;
  /* XXX: 802.11-2020 9.4.2.2 notes that it might or might not include
   * a terminating null when the UTF-8 SSID bit is set; if we handle
   * that properly and add it as a ENC_UTF_8 FT_STRING, that will work,
   * but the FT_BYTES BASE_SHOW_*_PRINTABLE doesn't handle an optional
   * terminating null. (Maybe it should?) */
  proto_tree_add_item_ret_display_string(tree, hf_ieee80211_tag_ssid, tvb,
        offset, tag_len, ENC_NA, pinfo->pool, &s);

  if (ssid_len > 0) {
    proto_item_append_text(field_data->item_tag, ": %s", s);
    col_append_fstr(pinfo->cinfo, COL_INFO, ", SSID=%s", s);

    /* Wlan Stats */
    memcpy(wlan_stats.ssid, ssid, MIN(ssid_len, MAX_SSID_LEN));
    wlan_stats.ssid_len = ssid_len;
  } else {
    proto_item_append_text(field_data->item_tag, ": Wildcard SSID");

    col_append_str(pinfo->cinfo, COL_INFO, ", SSID=Wildcard (Broadcast)");
    offset += 1; // Make sure we return non-zero
  }

  beacon_padding += 1; /* padding bug */

  return offset + tag_len;
}

static void
dissect_he_capabilities(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,
  int offset, int len);

static void
dissect_he_operation(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,
  int offset, int len _U_);

static int
dissect_neighbor_report(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  uint8_t sub_tag_id;
  uint32_t sub_tag_len;
  const char *sub_tag_name;
  proto_item *parent_item;
  proto_tree *bssid_info_subtree, *bssid_info_cap_subtree, *sub_tag_tree;
  tvbuff_t *sub_tag_tvb = NULL;

  if (tag_len < 13) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "Neighbor Report length %u wrong, must be > 13", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_neighbor_report_bssid, tvb, offset, 6, ENC_NA);
  offset += 6;

  /*** Begin: BSSID Information ***/

  parent_item = proto_tree_add_item(tree, hf_ieee80211_tag_neighbor_report_bssid_info, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  bssid_info_subtree = proto_item_add_subtree(parent_item, ett_tag_neighbor_report_bssid_info_tree);

  proto_tree_add_item(bssid_info_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_reachability, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_security, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_key_scope, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  parent_item = proto_tree_add_item(bssid_info_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_capability, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  bssid_info_cap_subtree = proto_item_add_subtree(parent_item, ett_tag_neighbor_report_bssid_info_capability_tree);
  proto_tree_add_item(bssid_info_cap_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_capability_spec_mng, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_cap_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_capability_qos, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_cap_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_capability_apsd, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_cap_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_capability_radio_msnt, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_cap_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_capability_dback, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_cap_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_capability_iback, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_mobility_domain, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_high_throughput, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_very_high_throughput, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_ftm, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_high_efficiency, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_er_bss, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_colocated_ap, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_unsolicited_probe_responses_active, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_ess_with_colocated_ap, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_oct_supported_with_reporting_ap, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_colocated_6ghz_ap, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_eht, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(bssid_info_subtree, hf_ieee80211_tag_neighbor_report_bssid_info_reserved, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_tag_neighbor_report_ope_class, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_tag_neighbor_report_channel_number, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_tag_neighbor_report_phy_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  /* The Optional Subelements field format contains zero or more subelements */
  if (tag_len == 13){ /* tag_len == 13 => no Subelements */
    return tvb_captured_length(tvb);
  }

  while (offset < tag_len)
  {
    sub_tag_id = tvb_get_uint8(tvb, offset);
    sub_tag_len = tvb_get_uint8(tvb, offset + 1);
    sub_tag_name = val_to_str_const(sub_tag_id, ieee80211_neighbor_report_subelement_id_vals, "Unknown");

    sub_tag_tree = proto_tree_add_subtree_format(tree, tvb, offset, sub_tag_len + 2, ett_tag_neighbor_report_subelement_tree, NULL, "Subelement: %s", sub_tag_name);

    proto_tree_add_item(sub_tag_tree, hf_ieee80211_tag_neighbor_report_subelement_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(sub_tag_tree, hf_ieee80211_tag_neighbor_report_subelement_length, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    sub_tag_tvb = tvb_new_subset_length(tvb, offset, sub_tag_len);

    switch (sub_tag_id) {
      case NR_SUB_ID_TSF_INFO:
        proto_tree_add_item(sub_tag_tree, hf_ieee80211_tag_neighbor_report_subelement_tsf_offset, tvb, offset, 2, ENC_NA);
        proto_tree_add_item(sub_tag_tree, hf_ieee80211_tag_neighbor_report_subelement_beacon_interval, tvb, offset + 2, 2, ENC_NA);
        break;
      case NR_SUB_ID_MEASUREMENT_PILOT_INFO:
        dissect_measurement_pilot_trans_ie(sub_tag_tvb, pinfo, sub_tag_tree, data);
        break;
      case NR_SUB_ID_CON_COU_STR:
        proto_tree_add_item(sub_tag_tree, hf_ieee80211_tag_neighbor_report_subelement_country_code, tvb, offset, 2, ENC_ASCII | ENC_NA);
        break;
      case NR_SUB_ID_BSS_TRN_CAN_PREF:
        proto_tree_add_item(sub_tag_tree, hf_ieee80211_tag_neighbor_report_subelement_bss_trn_can_pref, tvb, offset, 1, ENC_NA);
        break;
      case NR_SUB_ID_BSS_TER_DUR:
        proto_tree_add_item(sub_tag_tree, hf_ieee80211_tag_neighbor_report_subelement_bss_ter_tsf, tvb, offset, 8, ENC_NA);
        proto_tree_add_item(sub_tag_tree, hf_ieee80211_tag_neighbor_report_subelement_bss_dur, tvb, offset + 8, 2, ENC_NA);
        break;
      case NR_SUB_ID_HT_CAPABILITIES:
        dissect_ht_capability_ie_common(sub_tag_tvb, pinfo, sub_tag_tree, 0, sub_tag_len, field_data->item_tag_length, false);
        break;
      case NR_SUB_ID_HT_OPERATION:
        dissect_ht_info_ie_1_1(sub_tag_tvb, pinfo, sub_tag_tree, data);
        break;
      case NR_SUB_ID_SEC_CHANNEL_OFFSET:
        dissect_secondary_channel_offset_ie(sub_tag_tvb, pinfo, sub_tag_tree, data);
        break;
      case NR_SUB_ID_HT_MULTIPLE_BSSID:
        dissect_multiple_bssid_ie(sub_tag_tvb, pinfo, sub_tag_tree, data);
        break;
      case NR_SUB_ID_HE_CAPABILITIES:
        dissect_he_capabilities(sub_tag_tvb, pinfo, sub_tag_tree, 0, sub_tag_len);
        break;
      case NR_SUB_ID_HE_OPERATION:
        dissect_he_operation(sub_tag_tvb, pinfo, sub_tag_tree, 0, sub_tag_len);
        break;
      case NR_SUB_ID_EHT_CAPABILITIES:
        dissect_eht_capabilities(sub_tag_tvb, pinfo, sub_tag_tree, 0, sub_tag_len);
        break;
      case NR_SUB_ID_EHT_OPERATION:
        dissect_eht_operation(sub_tag_tvb, pinfo, sub_tag_tree, 0, sub_tag_len);
        break;
      case NR_SUB_ID_BASIC_MULTI_LINK:
        dissect_multi_link(sub_tag_tvb, pinfo, sub_tag_tree, 0, sub_tag_len);
        break;
      case NR_SUB_ID_VENDOR_SPECIFIC:
      default:
        proto_tree_add_item(sub_tag_tree, hf_ieee80211_tag_neighbor_report_subelement_data, tvb, offset, sub_tag_len, ENC_NA);
        break;
    }

    offset += sub_tag_len;
  }

  return offset;
}

static int
ieee80211_tag_supp_rates(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  /* 7.3.2.2 Supported Rates element (1) */
  if (tag_len < 1) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "Tag length %u too short, must be greater than 0",
                           tag_len);
    return offset;
  }

  while (offset < tag_len) {
    proto_tree_add_item(tree, hf_ieee80211_tag_supp_rates, tvb, offset, 1,
                        ENC_LITTLE_ENDIAN);
    proto_item_append_text(field_data->item_tag, " %s,",
                           val_to_str_ext_const(tvb_get_uint8(tvb, offset),
                                                &ieee80211_supported_rates_vals_ext,
                                                "Unknown Rate"));
    offset += 1;
  }

  proto_item_append_text(field_data->item_tag, " [Mbit/sec]");

  return offset;
}

static int
ieee80211_tag_fh_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  /* 7.3.2.3 FH Parameter Set element (2) */
  if (tag_len < 5) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "Tag length %u too short, must be >= 5", tag_len);
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_fh_dwell_time,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_tag_fh_hop_set,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_tag_fh_hop_pattern,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_tag_fh_hop_index,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  return offset;
}

static int
ieee80211_tag_ds_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  /* 7.3.2.4 DS Parameter Set element (3) */
  if (tag_len != 1) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
        "Tag length %u wrong, must be = 1", tag_len);
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_ds_param_channel,
        tvb, offset, 1, ENC_LITTLE_ENDIAN);

  proto_item_append_text(field_data->item_tag, ": Current Channel: %u",
                         tvb_get_uint8(tvb, offset));

  wlan_stats.channel = tvb_get_uint8(tvb, offset);
  offset += 1;

  return offset;
}

static int
ieee80211_tag_cf_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  /* 7.3.2.5 CF Parameter Set element (4) */
  if (tag_len != 6) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "Tag length %u wrong, must be = 6", tag_len);
    return offset;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_cfp_count,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, ": CFP count %u", tvb_get_uint8(tvb, offset));
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_tag_cfp_period,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, ": CFP Period %u", tvb_get_uint8(tvb, offset));
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_tag_cfp_max_duration,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, ": CFP Max Duration %u",
                         tvb_get_letohs(tvb, offset));
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_tag_cfp_dur_remaining,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, ": CFP Dur Remaining %u",
                         tvb_get_letohs(tvb, offset));
  offset += 1;

  return offset;
}

static int
dissect_pvb_encoded_block_bitmap(tvbuff_t *tvb, packet_info *pinfo _U_,
                                 proto_tree *tree, int offset,
                                 bool inverse_bm _U_,
                                 uint8_t block_offset _U_,
                                 uint8_t page_index _U_)
{
  uint8_t block_bitmap = tvb_get_uint8(tvb, offset);
  proto_tree *bb_tree;
  proto_item *bbi;
  proto_item *bb;
  int start_offset = offset;
  uint8_t subblock = 0;

  /*
   * Walk the block bitmap to figure out how many subblocks there are an
   * handle each of them.
   */
  bb_tree = proto_tree_add_subtree(tree, tvb, offset, -1,
                                   ett_s1g_pvb_block_bitmap_tree, &bbi,
                                   "Block Bitmap");

  bb = proto_tree_add_item(bb_tree, hf_ieee80211_s1g_block_bitmap, tvb, offset,
                           1, ENC_NA);
  offset += 1;

  while (block_bitmap) {
    bool subblock_present = block_bitmap & 0x01;
    proto_tree *sb_tree;
    uint8_t bit_pos = 0;

    if (subblock_present) {
      uint8_t subblock_val = tvb_get_uint8(tvb, offset);

      sb_tree = proto_tree_add_subtree_format(bb_tree, tvb, offset, 1,
                                              ett_s1g_pvb_subblock_tree, NULL,
                                              "Subblock %u", subblock);
      while (subblock_val) {

        if (subblock_val & 0x01) {
          proto_item_append_text(bb, ", Subblock %d present", bit_pos);
          uint16_t aid13 = (page_index << 11) | (block_offset << 6) |
                          (subblock << 3) | bit_pos;
          proto_tree_add_uint_bits_format_value(sb_tree,
                                hf_ieee80211_s1g_block_bitmap_sta_aid13,
                                tvb, offset * 8 + (7 - bit_pos), 1, 1,
                                ENC_BIG_ENDIAN, " 0x%0x", aid13);
        }

        bit_pos += 1;
        subblock_val = subblock_val >> 1;
      }

      offset += 1;
    }

    block_bitmap = block_bitmap >> 1;
    subblock += 1;
  }

  proto_item_set_len(bbi, offset - start_offset);
  return offset;
}

static int
dissect_pvb_encoded_single_aid(tvbuff_t *tvb, packet_info *pinfo _U_,
                                 proto_tree *tree, int offset,
                                 bool inverse_bm _U_,
                                 uint8_t block_offset,
                                 uint8_t page_index)
{
  uint8_t single_aid = tvb_get_uint8(tvb, offset);
  uint16_t aid13 = (page_index << 11) | (block_offset << 6) |
                  (single_aid & 0x3F);

  proto_tree_add_uint_format(tree, hf_ieee80211_s1g_block_bitmap_single_aid,
                             tvb, offset, 1, single_aid,
                             "Single AID13: 0x%0x", aid13);
  offset += 1;

  return offset;
}

static int
dissect_pvb_encoded_olb(tvbuff_t *tvb, packet_info *pinfo _U_,
                        proto_tree *tree, int offset,
                        bool inverse_bm _U_,
                        uint8_t block_offset _U_,
                        uint8_t page_index _U_)
{
  uint8_t length = tvb_get_uint8(tvb, offset);
  proto_tree *olb_tree;
  int k;

  olb_tree = proto_tree_add_subtree(tree, tvb, offset, length + 1,
                                    ett_s1g_pvb_olb_tree, NULL,
                                    "OLB Mode");

  proto_tree_add_item(olb_tree, hf_ieee80211_s1g_block_bitmap_olb_length,
                      tvb, offset, 1, ENC_NA);
  offset += 1;

  for (k = 0; k < length; k++) {
    uint8_t subblock_val = tvb_get_uint8(tvb, offset);
    proto_tree *sb_tree;
    uint8_t bit_pos = 0;

    sb_tree = proto_tree_add_subtree_format(olb_tree, tvb, offset, 1,
                                            ett_s1g_pvb_olb_subblock, NULL,
                                            "Subblock %u", k);
    while (subblock_val) {

      if (subblock_val & 0x01) {
        uint16_t aid13 = (page_index << 11) | (block_offset << 6) |
                        (k << 3) | bit_pos;
        proto_tree_add_uint_bits_format_value(sb_tree,
                              hf_ieee80211_s1g_block_bitmap_sta_aid13,
                              tvb, offset * 8 + (7 - bit_pos), 1, 1,
                              ENC_BIG_ENDIAN, " 0x%0x", aid13);
      }

      bit_pos += 1;
      subblock_val = subblock_val >> 1;
    }

    offset += 1;
  }

  offset += length;

  return offset;
}

static int
dissect_pvb_encoded_ade(tvbuff_t *tvb, packet_info *pinfo _U_,
                        proto_tree *tree, int offset,
                        bool inverse_bm _U_,
                        uint8_t block_offset _U_,
                        uint8_t page_index _U_)
{
  uint8_t ade_control = tvb_get_uint8(tvb, offset);
  uint8_t ewl = (ade_control & 0x03) + 1;
  uint8_t ade_bytes = ade_control >> 3;
  proto_tree *ade_tree;
  proto_item *cntl_item;
  proto_tree *cntl_tree;

  ade_tree = proto_tree_add_subtree(tree, tvb, offset, ade_bytes + 1,
                                    ett_s1g_pvb_ade_tree, NULL,
                                    "ADE Mode");

  cntl_item = proto_tree_add_item(ade_tree, hf_ieee80211_s1g_block_bitmap_ade,
                                  tvb, offset, 1, ENC_NA);

  cntl_tree = proto_item_add_subtree(cntl_item, ett_s1g_pvb_ade_control);

  proto_tree_add_uint_bits_format_value(cntl_tree,
                                        hf_ieee80211_s1g_block_bitmap_ewl,
                                        tvb, offset *8, 3, ewl,
                                        ENC_BIG_ENDIAN, "EWL: %u", ewl);
  proto_tree_add_uint_bits_format_value(cntl_tree,
                                        hf_ieee80211_s1g_block_bitmap_len,
                                        tvb, offset * 8 + 3, 5, ade_bytes,
                                        ENC_BIG_ENDIAN, "Length: %u", ade_bytes);
  offset += 1;

  /* TODO: Add each subblock */
  proto_tree_add_item(ade_tree, hf_ieee80211_s1g_block_bitmap_ade_bytes, tvb,
                      offset, ade_bytes, ENC_NA);

  offset += ade_bytes;

  return offset;
}

static int * const s1g_pvb_encoded_block_control[] = {
  &hf_ieee80211_s1g_pvb_encoding_mode,
  &hf_ieee80211_s1g_pvb_inverse_bitmap,
  &hf_ieee80211_s1g_pvb_block_offset,
  NULL
};

#define PVB_BLOCK_BITMAP 0x0
#define PVB_SINGLE_AID   0x1
#define PVB_OLB          0x2
#define PVB_ADE          0x3

static const value_string s1g_block_control_encoding_mode_vals[] = {
  { 0, "Block Bitmap" },
  { 1, "Single AID" },
  { 2, "OLB" },
  { 3, "ADE" },
  { 0, NULL }
};

static int
dissect_pvb_encoded_block(tvbuff_t *tvb, packet_info *pinfo,
                          proto_tree *tree, int offset, int idx,
                          uint8_t page_index)
{
  uint8_t block_control = tvb_get_uint8(tvb, offset);
  uint8_t enc_mode = block_control & 0x03;
  uint8_t inverse_bm = (enc_mode >> 2) & 0x01;
  uint8_t block_offset = block_control >> 3;
  proto_tree *eb_tree;
  proto_item *ebti;

  eb_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,
                                          ett_s1g_pvb_eb_tree, &ebti,
                                          "Encoded Block %d", idx);

  proto_tree_add_bitmask_with_flags(eb_tree, tvb, offset,
                                    hf_ieee80211_s1g_pvb_block_control_byte,
                                    ett_s1g_pvb_block_control_byte,
                                    s1g_pvb_encoded_block_control,
                                    ENC_NA, BMT_NO_APPEND);
  offset += 1;

  /*
   * If there are no bytes, add an EI and get out of here
   */
  switch (enc_mode) {
    case PVB_BLOCK_BITMAP:
      offset = dissect_pvb_encoded_block_bitmap(tvb, pinfo, eb_tree, offset,
                                                inverse_bm, block_offset,
                                                page_index);
      break;
    case PVB_SINGLE_AID:
      offset = dissect_pvb_encoded_single_aid(tvb, pinfo, eb_tree, offset,
                                              inverse_bm, block_offset,
                                              page_index);
      break;
    case PVB_OLB:
      offset = dissect_pvb_encoded_olb(tvb, pinfo, eb_tree, offset,
                                       inverse_bm, block_offset, page_index);
      break;
    case PVB_ADE:
      offset = dissect_pvb_encoded_ade(tvb, pinfo, eb_tree, offset, inverse_bm,
                                       block_offset, page_index);
      break;
  }

  return offset;
}

static int
dissect_partial_virtual_bitmap(tvbuff_t *tvb, packet_info *pinfo,
                               proto_tree *tree, int offset, int pvb_len,
                               uint8_t page_index)
{
  proto_tree *pvb_tree;
  int idx = 0;

  pvb_tree = proto_tree_add_subtree(tree, tvb, offset, pvb_len,
                                    ett_s1g_pvb_tree, NULL,
                                    "Partial Virtual Bitmap");

  while (tvb_reported_length_remaining(tvb, offset) > 0) {
    offset = dissect_pvb_encoded_block(tvb, pinfo, pvb_tree, offset, idx,
                                       page_index);
    idx++;
  }

  return offset;
}

static int
ieee80211_tag_tim(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  unsigned aid, pvb_len, n1, i, j, byte;
  bool is_s1g = sta_is_s1g(pinfo);
  static int * const ieee80211_tim_bmapctl[] = {
    &hf_ieee80211_tim_bmapctl_mcast,
    &hf_ieee80211_tim_bmapctl_offset,
    NULL
  };
  static int * const ieee80211_s1g_bmapctl[] = {
    &hf_ieee80211_s1g_tim_bmapctl_traffic_indicator,
    &hf_ieee80211_s1g_tim_page_slice_number,
    &hf_ieee80211_s1g_tim_page_index,
    NULL
  };

  /*
   * 802.11-2012: 8.4.2.7 TIM element (5), however, if this is an S1G frame
   * then it is different. S1G TIM elements can be 2, 3, or longer bytes.
   */
  if (is_s1g) {
    if (tag_len < 2) {
      expert_add_info_format(pinfo, field_data->item_tag_length,
                             &ei_ieee80211_tag_length,
                            "Tag length %u too short for S1G frame, must be >= 3",
                            tag_len);
      return tag_len;
    }
  } else {
    if (tag_len < 4) {
      expert_add_info_format(pinfo, field_data->item_tag_length,
                             &ei_ieee80211_tag_length,
                            "Tag length %u too short for Non-S1G frame, must be >= 4",
                            tag_len);
      return tag_len;
    }
  }

  proto_tree_add_item(tree, hf_ieee80211_tim_dtim_count,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, ": DTIM %u of",
                         tvb_get_uint8(tvb, offset));
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_tim_dtim_period,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, " %u bitmap",
                      tvb_get_uint8(tvb, offset));
  offset += 1;

  if (offset >= tag_len)
    return offset;

  if (is_s1g) {
    unsigned bitmap_len = 0;

    if (tag_len >= 3) {
      uint8_t page_index = tvb_get_uint8(tvb, offset) >> 6;

      proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                        hf_ieee80211_s1g_tim_bmapctrl,
                                        ett_tag_bmapctl_tree,
                                        ieee80211_s1g_bmapctl,
                                        ENC_NA, BMT_NO_APPEND);
      offset += 1;
      bitmap_len = tvb_reported_length_remaining(tvb, offset);
      if (bitmap_len > 0) {
        offset = dissect_partial_virtual_bitmap(tvb, pinfo, tree, offset,
                                                bitmap_len, page_index);
      }
    }
  } else {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                      hf_ieee80211_tim_bmapctl,
                                      ett_tag_bmapctl_tree,
                                      ieee80211_tim_bmapctl,
                                      ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    pvb_len = tag_len - 3;
    n1 = tvb_get_uint8(tvb, offset) & 0xFE;
    offset += 1;
    proto_tree_add_item(tree, hf_ieee80211_tim_partial_virtual_bitmap,
                        tvb, offset, pvb_len, ENC_NA);
    /* FIXME: Handles dot11MgmtOptionMultiBSSIDActivated = false only */
    for (i = 0; i < pvb_len; i++) {
      byte = tvb_get_uint8(tvb, offset + i);
      for (j = 0; j < 8; j++) {
        if (byte & (1 << j)) {
          aid = 8*n1 + 8*i + j;
          proto_tree_add_uint(tree, hf_ieee80211_tim_aid, tvb, offset + i,
                              1, aid);
        }
      }
    }
    offset += pvb_len;
  }

  return offset;
}

static int
ieee80211_tag_ibss_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  /* 7.3.2.7 IBSS Parameter Set element (6) */

  if (tag_len != 2) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "Tag length %u wrong, must be = 2", tag_len);
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_ibss_atim_window,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, ": ATIM window 0x%x",
                         tvb_get_letohs(tvb, offset));
  offset += 2;

  return offset;
}

/* IEEE 802.11-2020, C.3 MIB detail, dot11CountryString */
static const value_string environment_vals[] = {
  { 0x1, "Operating classes in the United States" }, /* Table E-1 */
  { 0x2, "Operating classes in Europe" }, /* Table E-2 */
  { 0x3, "Operating classes in Japan" }, /* Table E-3 */
  { 0x4, "Global operating classes" }, /* Table E-4 */
  { 0x5, "S1G operating classes" }, /* Table E-5 */
  { 0x6, "Operating classes in China" }, /* Table E-6 */
  { ' ', "All" }, /* All environments for this band */
  { 'I', "Indoor" },
  { 'O', "Outdoor" },
  { 'X', "Non Country Entity" },
  { 0,    NULL }
};

static int
ieee80211_tag_country_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  /* 7.3.2.9 Country information element (7) */
  proto_tree *sub_tree;
  proto_item *sub_item;
  const uint8_t* country_code;

  if (tag_len < 6) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "Tag length %u too short, must be >= 6", tag_len);
    return 1;
  }

  /* FIXME: If environment is 'X', the only allowed CC is "XX" */
  proto_tree_add_item_ret_string(tree, hf_ieee80211_tag_country_info_code,
                      tvb, offset, 2, ENC_ASCII|ENC_NA, pinfo->pool, &country_code);
  proto_item_append_text(field_data->item_tag, ": Country Code %s", country_code);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_tag_country_info_env,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, ", Environment %s",
                         val_to_str(tvb_get_uint8(tvb, offset),
                                    environment_vals, "0x%02x"));
  offset += 1;

  while (offset < tag_len) {
    /* Padding ? */
    if ((tag_len - offset) < 3) {
      proto_tree_add_item(tree, hf_ieee80211_tag_country_info_pad,
                          tvb, offset, 1, ENC_NA);
      offset += 1;
      continue;
    }
    if (tvb_get_uint8(tvb, offset) <= 200) { /* 802.11d */
      sub_item = proto_tree_add_item(tree, hf_ieee80211_tag_country_info_fnm,
                                     tvb, offset, 3, ENC_NA);
      sub_tree = proto_item_add_subtree(sub_item, ett_tag_country_fnm_tree);

      proto_tree_add_item(sub_tree, hf_ieee80211_tag_country_info_fnm_fcn,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      proto_item_append_text(sub_item, ": First Channel Number: %u",
                             tvb_get_uint8(tvb, offset));
      offset += 1;
      proto_tree_add_item(sub_tree, hf_ieee80211_tag_country_info_fnm_nc,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      proto_item_append_text(sub_item, ", Number of Channels: %u",
                             tvb_get_uint8(tvb, offset));
      offset += 1;
      proto_tree_add_item(sub_tree, hf_ieee80211_tag_country_info_fnm_mtpl,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      proto_item_append_text(sub_item,
                             ", Maximum Transmit Power Level: %d dBm",
                             tvb_get_uint8(tvb, offset));
      offset += 1;
    } else { /* 802.11j */
      sub_item = proto_tree_add_item(tree, hf_ieee80211_tag_country_info_rrc,
                                     tvb, offset, 3, ENC_NA);
      sub_tree = proto_item_add_subtree(sub_item, ett_tag_country_rcc_tree);

      proto_tree_add_item(sub_tree, hf_ieee80211_tag_country_info_rrc_oei,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      proto_item_append_text(sub_item,
                             ": Operating Extension Identifier: %u",
                             tvb_get_uint8(tvb, offset));
      offset += 1;
      proto_tree_add_item(sub_tree, hf_ieee80211_tag_country_info_rrc_oc,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      proto_item_append_text(sub_item, ", Operating Class: %u",
                             tvb_get_uint8(tvb, offset));
      offset += 1;
      proto_tree_add_item(sub_tree, hf_ieee80211_tag_country_info_rrc_cc,
                          tvb, offset, 1, ENC_LITTLE_ENDIAN);
      proto_item_append_text(sub_item, ", Coverage Class: %u",
                             tvb_get_uint8(tvb, offset));
      offset += 1;
    }
  }

  return offset;
}

static int
ieee80211_tag_fh_hopping_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  /* 7.3.2.10 Hopping Pattern Parameters information element (8) */
  if (tag_len < 2) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "Tag length %u too short, must be >= 2", tag_len);
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_fh_hopping_parameter_prime_radix,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, ": Prime Radix: %u", tvb_get_uint8(tvb, offset));
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_tag_fh_hopping_parameter_nb_channels,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, ", Number of Channels: %u",
                         tvb_get_uint8(tvb, offset));
  offset += 1;

  return offset;
}

static int
ieee80211_tag_fh_hopping_table(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  /* 7.3.2.11 Hopping Pattern Table information element (9) */
  if (tag_len < 4) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "Tag length %u too short, must be >= 4", tag_len);
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_fh_hopping_table_flag,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_tag_fh_hopping_table_number_of_sets,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_tag_fh_hopping_table_modulus,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_tag_fh_hopping_table_offset,
                      tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  while (offset < tag_len) {
    proto_tree_add_item(tree, hf_ieee80211_tag_fh_hopping_random_table,
                        tvb, offset, 2, ENC_BIG_ENDIAN);
    offset += 2;
  }

  return offset;
}

int
add_tagged_field(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int offset, int ftype,
                 const uint8_t *valid_element_ids, unsigned valid_element_ids_count,
                 association_sanity_check_t *association_sanity_check)
{
  return add_tagged_field_with_validation(pinfo, tree, tvb, offset, ftype, valid_element_ids,
    valid_element_ids_count, false, NULL, 0, false, association_sanity_check);
}

/*
 * Build a composite TVB from the current TVB and the next ones that are
 * fragment elements.
 *
 * We also add the fragments to the tree. And add an expert info if there are
 * problems.
 *
 * When called we know we have two fragments, at least.
 */
static tvbuff_t *
build_defrag_tvb(packet_info *pinfo _U_, proto_tree *tree _U_, tvbuff_t *tvb,
                 int offset, uint32_t *tag_len, uint32_t *tag_overhead)
{
  tvbuff_t *new_tvb = tvb_new_composite();
  tvbuff_t *tmp_tvb = NULL;
  uint32_t new_len = 0, overhead = 0;
  uint8_t frag_len = 0;

  /*
   * We come in here pointing to the first fragment and on each iteration
   * We are pointing to the next fragment
   */
  do {
    offset += 1;
    frag_len = tvb_get_uint8(tvb, offset);
    offset += 1;
    tmp_tvb = tvb_new_subset_length(tvb, offset, frag_len);
    /* Insert this fragment ... */
    tvb_composite_append(new_tvb, tmp_tvb);
    new_len += frag_len;
    offset += frag_len;
    overhead += 2;
  } while (frag_len == 255 &&
           tvb_captured_length_remaining(tvb, offset) > 2 &&
           tvb_get_uint8(tvb, offset) == TAG_FRAGMENT);

  *tag_len = new_len;
  *tag_overhead = overhead;
  tvb_composite_finalize(new_tvb);

  return new_tvb;
}

int
add_tagged_field_with_validation(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int offset, int ftype,
                 const uint8_t *element_ids, unsigned element_ids_count, bool element_ids_assume_invalid,
                 const uint8_t *ext_element_ids, unsigned ext_element_ids_count, bool ext_element_ids_assume_invalid,
                 association_sanity_check_t *association_sanity_check)
{
  tvbuff_t     *tag_tvb;
  uint32_t      tag_no, tag_len, tag_overhead;
  uint32_t      ext_tag_no = 0;
  proto_tree   *orig_tree = tree;
  proto_item   *ti        = NULL;
  proto_item   *ti_len, *ti_tag;
  ieee80211_tagged_field_data_t field_data;
  bool          isDMG;

  isDMG = GPOINTER_TO_INT(p_get_proto_data(wmem_file_scope(), pinfo, proto_wlan, IS_DMG_KEY));

  tag_no  = tvb_get_uint8(tvb, offset);
  tag_len = tvb_get_uint8(tvb, offset + 1);
  save_tag_for_dot11decrypt(tvb, pinfo, offset);

  /*
   * If we have element fragmentation, construct a composite TVB with the
   * fragments. Rules are:
   * 1. Must be in the one MMPDU (so cannot exceed the TVB we are given.)
   * 2. If the next element is a fragment, this one must have a length of 255.
   * 3. We don't care about extensions here.
   * 4. The fragment element has an id of 254.
   */
  if (tag_len == 255 &&
      tvb_captured_length_remaining(tvb, offset) > (255 + 2) &&
      tvb_get_uint8(tvb, offset + 255 + 2) == TAG_FRAGMENT) {
        tag_tvb = build_defrag_tvb(pinfo, tree, tvb, offset, &tag_len,
                                   &tag_overhead);
        add_new_data_source(pinfo, tag_tvb, "Reassembled IE");
  } else {
    tag_tvb = tvb_new_subset_length(tvb, offset+2, tag_len);
    tag_overhead = 2;
  }

  if (tree) {
    if (tag_no == TAG_ELEMENT_ID_EXTENSION) {
      ext_tag_no  = tvb_get_uint8(tvb, offset + 2);
      ti = proto_tree_add_item(orig_tree, hf_ieee80211_ext_tag, tvb, offset + 2, tag_len + tag_overhead - 2, ENC_NA);
      proto_item_append_text(ti, ": %s", val_to_str_ext(ext_tag_no, &tag_num_vals_eid_ext_ext, "Unknown (%d)"));
    } else {
      ti = proto_tree_add_item(orig_tree, hf_ieee80211_tag, tvb, offset, 2 + tag_len + tag_overhead - 2, ENC_NA);
      proto_item_append_text(ti, ": %s", val_to_str_ext(tag_no, &tag_num_vals_ext, "Unknown (%d)"));
    }

    tree = proto_item_add_subtree(ti, ett_80211_mgt_ie);

  }

  if (tag_no == TAG_ELEMENT_ID_EXTENSION) {
    ti_len = proto_tree_add_uint(tree, hf_ieee80211_ext_tag_length, tvb, offset + 1, 1, tag_len - 1);
    ti_tag = proto_tree_add_item(tree, hf_ieee80211_ext_tag_number, tvb, offset + 2, 1, ENC_LITTLE_ENDIAN);
    proto_item_append_text(ti_len, " (Tag len: %u)", tag_len);
  } else {
    ti_tag = proto_tree_add_item(tree, hf_ieee80211_tag_number, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    ti_len = proto_tree_add_uint(tree, hf_ieee80211_tag_length, tvb, offset + 1, 1, tag_len);
  }
  if (tag_len > (unsigned)tvb_reported_length_remaining(tvb, offset)) {
    expert_add_info_format(pinfo, ti_len, &ei_ieee80211_tag_length,
                           "Tag Length is longer than remaining payload");
  }

  /* If the list enumerates valid element IDs, require the Element ID to be
   * present in that list, otherwise, if the list enumerates invalid element IDs,
   * check the Element ID is not in the list. If either check fails, stop decoding
   * the value to prevent possible infinite recursions due to unexpected elements. */
  if (element_ids_count) {
    bool current_tag_no = false;
    unsigned i;

    for (i = 0; i < element_ids_count; i++) {
      current_tag_no = element_ids[i] == tag_no;
      if (current_tag_no)
        break;
    }

    if ((!current_tag_no && !element_ids_assume_invalid && !(ext_tag_no && ext_element_ids_count)) ||
          (current_tag_no && element_ids_assume_invalid)) {
      expert_add_info_format(pinfo, ti_tag, &ei_ieee80211_tag_number,
          "Unexpected Element ID %d", tag_no);
        return tag_len + 1 + 1;
    }
  }

  /* Same as above, but for Extended Element IDs */
  if (ext_tag_no && ext_element_ids_count) {
    bool current_ext_tag_no = false;
    unsigned i;

    for (i = 0; i < ext_element_ids_count; i++) {
      current_ext_tag_no = ext_element_ids[i] == ext_tag_no;
      if (current_ext_tag_no)
        break;
    }

    if ((!current_ext_tag_no && !ext_element_ids_assume_invalid) ||
          (current_ext_tag_no && ext_element_ids_assume_invalid)) {
      expert_add_info_format(pinfo, ti_tag, &ei_ieee80211_tag_number,
          "Unexpected Extended Element ID %d", ext_tag_no);
        return tag_len + tag_overhead;
    }
  }

  field_data.sanity_check = association_sanity_check;
  field_data.ftype = ftype;
  field_data.isDMG = isDMG;
  field_data.item_tag = ti;
  field_data.item_tag_length = ti_len;
  if (!dissector_try_uint_new(tagged_field_table, tag_no, tag_tvb, pinfo, tree, false, &field_data))
  {
      proto_tree_add_item(tree, hf_ieee80211_tag_data, tvb, offset + 2, tag_len, ENC_NA);
      expert_add_info_format(pinfo, ti_tag, &ei_ieee80211_tag_data,
                             "Dissector for 802.11 IE Tag"
                             " (%s) code not implemented, Contact"
                             " Wireshark developers if you want this supported", val_to_str_ext(tag_no,
                                            &tag_num_vals_ext, "(%d)"));
      proto_item_append_text(ti, ": Undecoded");
  }

  return tag_len + tag_overhead;
}

/* 7.3.2.12 Request information element (10) */
static int
ieee80211_tag_request(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int tag_len = tvb_reported_length(tvb);
  int offset = 0;

  while (offset < tag_len)
  {
    proto_tree_add_item(tree, hf_ieee80211_tag_request, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
  }
  return ((tag_len > 0) ? tag_len : 1);
}

/* 7.3.2.28 BSS Load element (11) */
/* 8.4.2.30 in 802.11-2012 */
static int
ieee80211_tag_qbss_load(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if ((tag_len < 4) || (tag_len > 5))
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 4 or 5", tag_len);
    return tvb_captured_length(tvb);
  }

  if (tag_len == 4)
  {
    /* QBSS Version 1 */
    proto_item_append_text(field_data->item_tag, " Cisco QBSS Version 1 - non CCA");

    /* Extract Values */
    proto_tree_add_uint(tree, hf_ieee80211_qbss_version, tvb, offset, tag_len, 1);
    proto_tree_add_item(tree, hf_ieee80211_qbss_scount, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_ieee80211_qbss_cu, tvb, offset + 2, 1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_ieee80211_qbss_adc, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);
  }
  else if (tag_len == 5)
  {
    proto_item *base_item;

    /* QBSS Version 2 */
    proto_item_append_text(field_data->item_tag, " 802.11e CCA Version");

    /* Extract Values */
    proto_tree_add_uint(tree, hf_ieee80211_qbss_version, tvb, offset, tag_len, 2);
    proto_tree_add_item(tree, hf_ieee80211_qbss_scount, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    base_item = proto_tree_add_item(tree, hf_ieee80211_qbss_cu, tvb, offset + 2, 1, ENC_LITTLE_ENDIAN);
    proto_item_append_text(base_item, " (%d%%)", 100*tvb_get_uint8(tvb, offset + 2)/255);
    base_item = proto_tree_add_item(tree, hf_ieee80211_qbss_adc, tvb, offset + 3, 2, ENC_LITTLE_ENDIAN);
    proto_item_append_text(base_item, " (%d us/s)", tvb_get_letohs(tvb, offset + 3)*32);
  }

  return tvb_captured_length(tvb);
}

/* 8.4.2.31 in 802-11-2012 */
static int
ieee80211_tag_edca_param_set(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if ((tag_len != 18))
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 18", tag_len);
    return tvb_captured_length(tvb);
  }

  decode_qos_parameter_set(tree, tvb, pinfo, offset, field_data->ftype);

  return tvb_captured_length(tvb);
}

/* TSPEC element (13) */
static int
ieee80211_tag_tspec(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if (field_data->isDMG == false && tag_len != 55)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 55", tag_len);
    return tvb_captured_length(tvb);
  }
  if (field_data->isDMG == true && tag_len != 57)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 57", tag_len);
    return tvb_captured_length(tvb);
  }

  add_ff_qos_ts_info(tree, tvb, pinfo, offset);
  offset += 3;

  proto_tree_add_item(tree, hf_ieee80211_tspec_nor_msdu, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_tspec_max_msdu, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_tspec_min_srv, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_tspec_max_srv, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_tspec_inact_int, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_tspec_susp_int, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_tspec_srv_start, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_tspec_min_data, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_tspec_mean_data, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_tspec_peak_data, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_tspec_burst_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_tspec_delay_bound, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_tspec_min_phy, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_tspec_surplus, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_tspec_medium, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  if(field_data->isDMG == true) {
    proto_tree_add_item(tree, hf_ieee80211_tspec_dmg, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    /*offset +=2;*/
  }

  return tvb_captured_length(tvb);
}

/* 7.3.2.31 TCLAS element (14) */
static const range_string user_prio_rvals[] = {
  { 0,  7,  "The User Priority value of an MSDU" },
  { 8,  8,  "The AC value of an MPDU is AC-VO" },
  { 9,  9,  "The AC value of an MPDU is AC-VI" },
  { 10, 10, "The AC value of an MPDU is AC-BE" },
  { 11, 11, "The AC value of an MPDU is AC-BK" },
  { 0, 0, NULL }
};

static int * const ieee80211_tclas_class_mask0[] = {
  &hf_ieee80211_tclas_class_mask0_src_addr,
  &hf_ieee80211_tclas_class_mask0_dst_addr,
  &hf_ieee80211_tclas_class_mask0_type,
  NULL
};

static int * const ieee80211_tclas_class_mask1[] = {
  &hf_ieee80211_tclas_class_mask1_ver,
  &hf_ieee80211_tclas_class_mask1_src_ip,
  &hf_ieee80211_tclas_class_mask1_dst_ip,
  &hf_ieee80211_tclas_class_mask1_src_port,
  &hf_ieee80211_tclas_class_mask1_dst_port,
  &hf_ieee80211_tclas_class_mask1_ipv6_flow,
  NULL
};

static int * const ieee80211_tclas_class_mask1_4[] = {
  &hf_ieee80211_tclas_class_mask1_ver,
  &hf_ieee80211_tclas_class_mask1_src_ip,
  &hf_ieee80211_tclas_class_mask1_dst_ip,
  &hf_ieee80211_tclas_class_mask1_src_port,
  &hf_ieee80211_tclas_class_mask1_dst_port,
  &hf_ieee80211_tclas_class_mask1_ipv4_dscp,
  &hf_ieee80211_tclas_class_mask1_ipv4_proto,
  &hf_ieee80211_tclas_class_mask1_reserved,
  NULL
};

static int * const ieee80211_tclas_class_mask2[] = {
  &hf_ieee80211_tclas_class_mask2_tci,
  NULL
};

static int * const ieee80211_tclas_class_mask4_4[] = {
  &hf_ieee80211_tclas_class_mask4_ver,
  &hf_ieee80211_tclas_class_mask4_4_src_ip,
  &hf_ieee80211_tclas_class_mask4_4_dst_ip,
  &hf_ieee80211_tclas_class_mask4_src_port,
  &hf_ieee80211_tclas_class_mask4_dst_port,
  &hf_ieee80211_tclas_class_mask4_dscp,
  &hf_ieee80211_tclas_class_mask4_ipv4_proto,
  &hf_ieee80211_tclas_class_mask4_reserved,
  NULL
};

static int * const ieee80211_tclas_class_mask4_6[] = {
  &hf_ieee80211_tclas_class_mask4_ver,
  &hf_ieee80211_tclas_class_mask4_6_src_ip,
  &hf_ieee80211_tclas_class_mask4_6_dst_ip,
  &hf_ieee80211_tclas_class_mask4_src_port,
  &hf_ieee80211_tclas_class_mask4_dst_port,
  &hf_ieee80211_tclas_class_mask4_dscp,
  &hf_ieee80211_tclas_class_mask4_next_hdr,
  &hf_ieee80211_tclas_class_mask4_flow_label,
  NULL
};

static int * const ieee80211_tclas_class_mask5[] = {
  &hf_ieee80211_tclas_class_mask5_up_prio,
  &hf_ieee80211_tclas_class_mask5_dei,
  &hf_ieee80211_tclas_class_mask5_vid,
  &hf_ieee80211_tclas_class_mask5_reserved,
  NULL
};

/*
 * Two control bits in the next few. Lower bit specifies if the classifier
 * uses the field (the match value is present, upper bit specifies is a
 * mask is present.
 */
static const value_string frame_control_mask_vals[] = {
  { 0x0 , "Frame Control is not included in the Classifier" },
  { 0x1 , "Frame Control is included in the Classifier. A Match Spec is not included" },
  { 0x2 , "Invalid Frame Control Classifier Mask Control value" },
  { 0x3 , "Frame Control is included in the Classifier. A Match Spec is included" },
  { 0,    NULL }
};

static const value_string duration_id_mask_vals[] = {
  { 0x0 , "Duration/ID is not included in the Classifier" },
  { 0x1 , "Duration/ID is included in the Classifier. A Match Spec is not included" },
  { 0x2 , "Invalid Duration/ID Classifier Mask Control value" },
  { 0x3 , "Duration/ID is included in the Classifier. A Match Spec is included" },
  { 0,    NULL }
};

static const value_string address_1_mask_vals[] = {
  { 0x0 , "Address 1 is not included in the Classifier" },
  { 0x1 , "Address 1 is included in the Classifier. A Match Spec is not included" },
  { 0x2 , "Invalid Address 1 Classifier Mask Control value" },
  { 0x3 , "Address 1 is included in the Classifier. A Match Spec is included" },
  { 0,    NULL }
};

static const value_string address_2_mask_vals[] = {
  { 0x0 , "Address 2 is not included in the Classifier" },
  { 0x1 , "Address 2 is included in the Classifier. A Match Spec is not included" },
  { 0x2 , "Invalid Address 2 Classifier Mask Control value" },
  { 0x3 , "Address 2 is included in the Classifier. A Match Spec is included" },
  { 0,    NULL }
};

static const value_string address_3_mask_vals[] = {
  { 0x0 , "Address 3 is not included in the Classifier" },
  { 0x1 , "Address 3 is included in the Classifier. A Match Spec is not included" },
  { 0x2 , "Invalid Address 3 Classifier Mask Control value" },
  { 0x3 , "Address 3 is included in the Classifier. A Match Spec is included" },
  { 0,    NULL }
};

static const value_string sequence_control_mask_vals[] = {
  { 0x0 , "Sequence Control is not included in the Classifier" },
  { 0x1 , "Sequence Control is included in the Classifier. A Match Spec is not included" },
  { 0x2 , "Invalid Sequence Control Classifier Mask Control value" },
  { 0x3 , "Sequence Control is included in the Classifier. A Match Spec is included" },
  { 0,    NULL }
};

static const value_string address_4_mask_vals[] = {
  { 0x0 , "Address 4 is not included in the Classifier" },
  { 0x1 , "Address 4 is included in the Classifier. A Match Spec is not included" },
  { 0x2 , "Invalid Address 4 Classifier Mask Control value" },
  { 0x3 , "Address 4 is included in the Classifier. A Match Spec is included" },
  { 0,    NULL }
};

static const value_string qos_control_mask_vals[] = {
  { 0x0 , "QoS Control is not included in the Classifier" },
  { 0x1 , "QoS Control is included in the Classifier. A Match Spec is not included" },
  { 0x2 , "Invalid QoS Control Classifier Mask Control value" },
  { 0x3 , "QoS Control is included in the Classifier. A Match Spec is included" },
  { 0,    NULL }
};

static const value_string ht_control_mask_vals[] = {
  { 0x0 , "HT Control is not included in the Classifier" },
  { 0x1 , "HT Control is included in the Classifier. A Match Spec is not included" },
  { 0x2 , "Invalid HT Control Classifier Mask Control value" },
  { 0x3 , "HT Control is included in the Classifier. A Match Spec is included" },
  { 0,    NULL }
};

static const value_string address_1_sid_mask_vals[] = {
  { 0x0 , "Address 1 (SID) is not included in the Classifier" },
  { 0x1 , "Address 1 (SID) is included in the Classifier. A Match Spec is not included" },
  { 0x2 , "Invalid Address 1 (SID) Classifier Mask Control value" },
  { 0x3 , "Address 1 (SID) is included in the Classifier. A match spec is included" },
  { 0,    NULL }
};

static const value_string address_1_bssid_mask_vals[] = {
  { 0x0 , "Address 1 (BSSID) is not included in the Classifier" },
  { 0x1 , "Address 1 (BSSID) is included in the Classifier. A Match Spec is not included" },
  { 0x2 , "Invalid Address 1 (SID) Classifier Mask Control value" },
  { 0x3 , "Address 1 (BSSID) is included in the Classifier. A match spec is included" },
  { 0,    NULL }
};

static int * const ieee80211_tclas_class_mask6[] = {
  &hf_ieee80211_tclas_class_mask6_frame_control_match_spec,
  &hf_ieee80211_tclas_class_mask6_duration_id_match_spec,
  &hf_ieee80211_tclas_class_mask6_address_1_match_spec,
  &hf_ieee80211_tclas_class_mask6_address_2_match_spec,
  &hf_ieee80211_tclas_class_mask6_address_3_match_spec,
  &hf_ieee80211_tclas_class_mask6_sequence_control_spec,
  &hf_ieee80211_tclas_class_mask6_address_4_match_spec,
  &hf_ieee80211_tclas_class_mask6_qos_control_spec,
  &hf_ieee80211_tclas_class_mask6_ht_control_spec,
  &hf_ieee80211_tclas_class_mask6_reserved,
  NULL
};

static int * const ieee80211_tclas_class_mask7[] = {
  &hf_ieee80211_tclas_class_mask7_frame_control_match_spec,
  &hf_ieee80211_tclas_class_mask7_address_1_sid_match_spec,
  &hf_ieee80211_tclas_class_mask7_address_2_match_spec,
  &hf_ieee80211_tclas_class_mask7_sequence_control_spec,
  &hf_ieee80211_tclas_class_mask7_address_3_match_spec,
  &hf_ieee80211_tclas_class_mask7_address_4_match_spec,
  &hf_ieee80211_tclas_class_mask7_reserved,
  NULL
};

static int * const ieee80211_tclas_class_mask8[] = {
  &hf_ieee80211_tclas_class_mask8_frame_control_match_spec,
  &hf_ieee80211_tclas_class_mask8_address_1_bssid_match_spec,
  &hf_ieee80211_tclas_class_mask8_address_2_sid_match_spec,
  &hf_ieee80211_tclas_class_mask8_sequence_control_spec,
  &hf_ieee80211_tclas_class_mask8_address_3_match_spec,
  &hf_ieee80211_tclas_class_mask8_address_4_match_spec,
  &hf_ieee80211_tclas_class_mask8_reserved,
  NULL
};

/* TODO: the masks for these items are clearly wrong! */
static int * const ieee80211_tclas_class_mask9[] = {
  &hf_ieee80211_tclas_class_mask9_frame_control_match_spec,
  &hf_ieee80211_tclas_class_mask9_address_1_match_spec,
  &hf_ieee80211_tclas_class_mask9_address_2_match_spec,
  &hf_ieee80211_tclas_class_mask9_sequence_control_spec,
  &hf_ieee80211_tclas_class_mask9_reserved,
  NULL
};

static int
ieee80211_frame_classifier(tvbuff_t *tvb, packet_info *pinfo _U_,
                           proto_tree *tree, int offset, int tag_len)
{
  uint8_t type;
  uint8_t version;
  uint8_t filter_field_len;
  uint32_t class_mask;

  type = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_tclas_class_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  switch (type)
  {
  case 0:
    proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tclas_class_mask,
                                    ett_tag_tclas_mask_tree, ieee80211_tclas_class_mask0,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset++;

    proto_tree_add_item(tree, hf_ieee80211_tclas_src_mac_addr, tvb, offset, 6, ENC_NA);
    offset += 6;

    proto_tree_add_item(tree, hf_ieee80211_tclas_dst_mac_addr, tvb, offset, 6, ENC_NA);
    offset += 6;

    proto_tree_add_item(tree, hf_ieee80211_tclas_ether_type, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    /*offset += 2;*/
    break;

  case 1:
    version = tvb_get_uint8(tvb, offset+1);
    if (version == 4) {
      proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tclas_class_mask,
                                    ett_tag_tclas_mask_tree, ieee80211_tclas_class_mask1_4,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    } else {
      proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tclas_class_mask,
                                    ett_tag_tclas_mask_tree, ieee80211_tclas_class_mask1,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    }
    offset += 1;

    proto_tree_add_item(tree, hf_ieee80211_tclas_version, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    if (version == 4)
    {
      proto_tree_add_item(tree, hf_ieee80211_tclas_ipv4_src, tvb, offset, 4, ENC_BIG_ENDIAN);
      offset += 4;
      proto_tree_add_item(tree, hf_ieee80211_tclas_ipv4_dst, tvb, offset, 4, ENC_BIG_ENDIAN);
      offset += 4;
      proto_tree_add_item(tree, hf_ieee80211_tclas_src_port, tvb, offset, 2, ENC_BIG_ENDIAN);
      offset += 2;
      proto_tree_add_item(tree, hf_ieee80211_tclas_dst_port, tvb, offset, 2, ENC_BIG_ENDIAN);
      offset += 2;
      proto_tree_add_item(tree, hf_ieee80211_tclas_dscp, tvb, offset, 1, ENC_NA);
      offset += 1;
      proto_tree_add_item(tree, hf_ieee80211_tclas_protocol, tvb, offset, 1, ENC_NA);
      /*offset += 1;*/
    }
    else if (version == 6)
    {
      proto_tree_add_item(tree, hf_ieee80211_tclas_ipv6_src, tvb, offset, 16, ENC_NA);
      offset += 16;
      proto_tree_add_item(tree, hf_ieee80211_tclas_ipv6_dst, tvb, offset, 16, ENC_NA);
      offset += 16;
      proto_tree_add_item(tree, hf_ieee80211_tclas_src_port, tvb, offset, 2, ENC_BIG_ENDIAN);
      offset += 2;
      proto_tree_add_item(tree, hf_ieee80211_tclas_dst_port, tvb, offset, 2, ENC_BIG_ENDIAN);
      offset += 2;
      proto_tree_add_item(tree, hf_ieee80211_tclas_flow, tvb, offset, 3, ENC_BIG_ENDIAN);
      /*offset += 3;*/
    }
    break;

  case 2:
    proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tclas_class_mask,
                                    ett_tag_tclas_mask_tree, ieee80211_tclas_class_mask2,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset++;

    proto_tree_add_item(tree, hf_ieee80211_tclas_tag_type, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    /*offset += 2;*/
    break;

  case 3:
    proto_tree_add_item(tree, hf_ieee80211_tclas_mask_reserved, tvb, offset,
                        1, ENC_NA);
    offset += 1;

    proto_tree_add_item(tree, hf_ieee80211_tclas_filter_offset, tvb, offset,
                        2, ENC_LITTLE_ENDIAN);
    offset += 2;

    filter_field_len = (tag_len - 4) / 2;

    proto_tree_add_item(tree, hf_ieee80211_tclas_filter_value, tvb, offset,
                        filter_field_len, ENC_NA);
    offset += filter_field_len;

    proto_tree_add_item(tree, hf_ieee80211_tclas_filter_mask, tvb, offset,
                        filter_field_len, ENC_NA);
    /*offset += filter_field_len;*/
    break;

  case 4:
    version = tvb_get_uint8(tvb, offset+1);
    if (version == 4) {
      proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_tclas_class_mask,
                                    ett_tag_tclas_mask_tree,
                                    ieee80211_tclas_class_mask4_4,
                                    ENC_BIG_ENDIAN, BMT_NO_APPEND);
    } else if (version == 6) {
      proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_tclas_class_mask,
                                    ett_tag_tclas_mask_tree,
                                    ieee80211_tclas_class_mask4_6,
                                    ENC_BIG_ENDIAN, BMT_NO_APPEND);
    } else {
      proto_tree_add_item(tree, hf_ieee80211_tclas_class_mask, tvb, offset, 1,
                          ENC_NA);
      offset += 1;

      proto_tree_add_item(tree, hf_ieee80211_tclas_reserved_bytes, tvb, offset,
                          tag_len - offset + 1, ENC_NA);
      break;
    }

    offset += 1;

    proto_tree_add_item(tree, hf_ieee80211_tclas4_version, tvb, offset, 1, ENC_NA);
    offset += 1;

    if (version == 4)
    {
      proto_tree_add_item(tree, hf_ieee80211_tclas4_ipv4_src, tvb, offset, 4, ENC_BIG_ENDIAN);
      offset += 4;
      proto_tree_add_item(tree, hf_ieee80211_tclas4_ipv4_dst, tvb, offset, 4, ENC_BIG_ENDIAN);
      offset += 4;
      proto_tree_add_item(tree, hf_ieee80211_tclas4_src_port, tvb, offset, 2, ENC_BIG_ENDIAN);
      offset += 2;
      proto_tree_add_item(tree, hf_ieee80211_tclas4_dst_port, tvb, offset, 2, ENC_BIG_ENDIAN);
      offset += 2;
      proto_tree_add_item(tree, hf_ieee80211_tclas4_dscp, tvb, offset, 1, ENC_NA);
      offset += 1;
      proto_tree_add_item(tree, hf_ieee80211_tclas4_protocol, tvb, offset, 1, ENC_NA);
      offset += 1;
      proto_tree_add_item(tree, hf_ieee80211_tclas4_reserved, tvb, offset, 1, ENC_NA);
      /*offset += 1;*/
    }
    else if (version == 6)
    {
      proto_tree_add_item(tree, hf_ieee80211_tclas4_ipv6_src, tvb, offset, 16, ENC_NA);
      offset += 16;
      proto_tree_add_item(tree, hf_ieee80211_tclas4_ipv6_dst, tvb, offset, 16, ENC_NA);
      offset += 16;
      proto_tree_add_item(tree, hf_ieee80211_tclas4_src_port, tvb, offset, 2, ENC_BIG_ENDIAN);
      offset += 2;
      proto_tree_add_item(tree, hf_ieee80211_tclas4_dst_port, tvb, offset, 2, ENC_BIG_ENDIAN);
      offset += 2;
      proto_tree_add_item(tree, hf_ieee80211_tclas4_dscp, tvb, offset, 1, ENC_NA);
      offset += 1;
      proto_tree_add_item(tree, hf_ieee80211_tclas4_next_hdr, tvb, offset, 1, ENC_NA);
      proto_tree_add_item(tree, hf_ieee80211_tclas4_flow, tvb, offset, 3, ENC_BIG_ENDIAN);
      /*offset += 3;*/
    }
    break;

  case 5:
    /* Note, BIG Endian where more than one byte. */
    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_tclas_class_mask,
                                    ett_tag_tclas_mask_tree,
                                    ieee80211_tclas_class_mask5,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset++;

    proto_tree_add_item(tree, hf_ieee80211_tclas_tclas_8021d_up_pcp, tvb,
                        offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(tree, hf_ieee80211_tclas_8021q_dei, tvb, offset, 1,
                        ENC_NA);
    offset += 1;

    proto_tree_add_item(tree, hf_ieee80211_tclas_8021q_vid, tvb, offset, 2,
                        ENC_BIG_ENDIAN);
    break;

  case 6:
    class_mask = tvb_get_letoh24(tvb, offset);
    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_tclas_class_mask6_a_above,
                                    ett_tag_tclas_mask_tree,
                                    ieee80211_tclas_class_mask6,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 3;

    /* Is the Frame Control info there? */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas6_frame_control_spec, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;

      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas6_frame_control_mask, tvb,
                            offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Duration info there? */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas6_duration_spec, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;

      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas6_duration_mask, tvb,
                            offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Address 1 info there? */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas6_address_1_spec, tvb,
                          offset, 6, ENC_NA);
      offset += 6;

      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas6_address_1_mask, tvb,
                            offset, 6, ENC_LITTLE_ENDIAN);
        offset += 6;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Address 2 info there? */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas6_address_2_spec, tvb,
                          offset, 6, ENC_NA);
      offset += 6;

      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas6_address_2_mask, tvb,
                            offset, 6, ENC_LITTLE_ENDIAN);
        offset += 6;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Address 3 info there? */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas6_address_3_spec, tvb,
                          offset, 6, ENC_NA);
      offset += 6;

      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas6_address_3_mask, tvb,
                            offset, 6, ENC_LITTLE_ENDIAN);
        offset += 6;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Sequence Control info there? */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas6_sequence_control_spec, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;

      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas6_sequence_control_mask,
                            tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Address 4 info there? */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas6_address_4_spec, tvb,
                          offset, 6, ENC_NA);
      offset += 6;

      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas6_address_4_mask, tvb,
                            offset, 6, ENC_LITTLE_ENDIAN);
        offset += 6;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the QoS Control info there? */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas6_qos_control_spec, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;

      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas6_qos_control_mask, tvb,
                            offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the HT Control info there? */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas6_ht_control_spec, tvb,
                          offset, 4, ENC_LITTLE_ENDIAN);
      offset += 4;

      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas6_ht_control_mask, tvb,
                            offset, 4, ENC_LITTLE_ENDIAN);
      }
    }
    /* class_mask = class_mask >> 2; Get the next two bits */

    break;

  case 7:
    class_mask = tvb_get_letohs(tvb, offset);
    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_tclas_class_mask6_a_above,
                                    ett_tag_tclas_mask_tree,
                                    ieee80211_tclas_class_mask7,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 3;

    /* Is the Frame Control info there */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas7_frame_control_spec, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas7_frame_control_mask, tvb,
                            offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Address 1 (SID) info there */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas7_address_1_sid_spec, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas7_address_1_sid_mask, tvb,
                            offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Address 2 info there */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas7_address_2_spec, tvb,
                          offset, 6, ENC_NA);
      offset += 6;
      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas7_address_2_mask, tvb,
                            offset, 6, ENC_LITTLE_ENDIAN);
        offset += 6;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Sequence Control info there */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas7_sequence_control_spec, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas7_sequence_control_mask,
                            tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Address 3 info there */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas7_address_3_spec, tvb,
                          offset, 6, ENC_NA);
      offset += 6;
      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas7_address_3_mask, tvb,
                            offset, 6, ENC_LITTLE_ENDIAN);
        offset += 6;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Address 4 info there */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas7_address_4_spec, tvb,
                          offset, 6, ENC_NA);
      offset += 6;
      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas7_address_4_mask, tvb,
                            offset, 6, ENC_LITTLE_ENDIAN);
      }
    }
    /*class_mask = class_mask >> 2; Get the next two bits */

    break;

  case 8:
    class_mask = tvb_get_letohs(tvb, offset);
    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_tclas_class_mask6_a_above,
                                    ett_tag_tclas_mask_tree,
                                    ieee80211_tclas_class_mask8,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 3;

    /* Is the Frame Control info there */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas8_frame_control_spec, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas8_frame_control_mask, tvb,
                            offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Address 1 (BSSID) info there */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas8_address_1_bssid_spec, tvb,
                          offset, 6, ENC_NA);
      offset += 6;
      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas8_address_1_bssid_mask, tvb,
                            offset, 6, ENC_LITTLE_ENDIAN);
        offset += 6;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Address 2 (SID) info there */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas8_address_2_sid_spec, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas8_address_2_sid_mask, tvb,
                            offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Sequence Control info there */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas8_sequence_control_spec, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas8_sequence_control_mask,
                            tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Address 3 info there */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas8_address_3_spec, tvb,
                          offset, 6, ENC_NA);
      offset += 6;
      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas8_address_3_mask, tvb,
                            offset, 6, ENC_LITTLE_ENDIAN);
        offset += 6;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Address 4 info there */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas8_address_4_spec, tvb,
                          offset, 6, ENC_NA);
      offset += 6;
      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas8_address_4_mask, tvb,
                            offset, 6, ENC_LITTLE_ENDIAN);
      }
    }
    /* class_mask = class_mask >> 2; Get the next two bits */

    break;

  case 9:
    class_mask = tvb_get_letohs(tvb, offset);
    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_tclas_class_mask6_a_above,
                                    ett_tag_tclas_mask_tree,
                                    ieee80211_tclas_class_mask9,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 3;

    /* Is the Frame Control info there */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas9_frame_control_spec, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas9_frame_control_mask, tvb,
                            offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Address 1 info there */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas9_address_1_spec, tvb,
                          offset, 6, ENC_NA);
      offset += 6;
      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas9_address_1_mask, tvb,
                            offset, 6, ENC_LITTLE_ENDIAN);
        offset += 6;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Address 2 info there */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas9_address_2_spec, tvb,
                          offset, 6, ENC_NA);
      offset += 6;
      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas9_address_2_mask, tvb,
                            offset, 6, ENC_LITTLE_ENDIAN);
        offset += 6;
      }
    }
    class_mask = class_mask >> 2; /* Get the next two bits */

    /* Is the Sequence Control info there */
    if (class_mask & 0x01) {
      proto_tree_add_item(tree, hf_ieee80211_tclas9_sequence_control_spec, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
      if (class_mask & 0x02) {
        proto_tree_add_item(tree, hf_ieee80211_tclas9_sequence_control_mask,
                            tvb, offset, 2, ENC_LITTLE_ENDIAN);
      }
    }
    /* class_mask = class_mask >> 2; Get the next two bits */

    break;

  case 0x0A:
    proto_tree_add_item(tree, hf_ieee80211_tclas10_protocol_instance, tvb,
                        offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(tree, hf_ieee80211_tclas10_protocol_num_next_hdr, tvb,
                        offset, 1, ENC_NA);
    offset += 1;

    filter_field_len = (tag_len - 4) / 2;

    proto_tree_add_item(tree, hf_ieee80211_tclas_filter_value, tvb, offset,
                        filter_field_len, ENC_NA);
    offset += filter_field_len;

    proto_tree_add_item(tree, hf_ieee80211_tclas_filter_mask, tvb, offset,
                        filter_field_len, ENC_NA);
    /*offset += filter_field_len;*/
    break;

  default:
    break;
  }

  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_tclas(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if (tag_len < 5)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag length %u too short, must be >= 5", tag_len);
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_tclas_up, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;

  return ieee80211_frame_classifier(tvb, pinfo, tree, offset, tag_len);
}

/* 7.3.2.34 Schedule element (15) */
static int
ieee80211_tag_schedule(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  if (tag_len != 14)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 14", tag_len);
    return 1;
  }

  add_ff_schedule_info(tree, tvb, pinfo, offset);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_sched_srv_start, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_sched_srv_int, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  proto_tree_add_item(tree, hf_ieee80211_sched_spec_int, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

/* 7.3.2.8 Challenge Text element (16) */
static int
ieee80211_tag_challenge_text(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int tag_len = tvb_reported_length(tvb);
  int offset = 0;

  proto_tree_add_item(tree, hf_ieee80211_tag_challenge_text, tvb, offset, tag_len, ENC_NA);

  return ((tag_len > 0) ? tag_len : 1);
}

/* 7.3.2.15 Power Constraint element (32) */
static int
ieee80211_tag_power_constraint(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  if (tag_len != 1)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 1", tag_len);
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_power_constraint_local, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, ": %d", tvb_get_uint8(tvb, offset));
  return tvb_captured_length(tvb);
}

/* 7.3.2.16 Power Capability element (33) */
static int
ieee80211_tag_power_capability(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  if (tag_len != 2)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 2", tag_len);
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_power_capability_min, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, " Min: %d", tvb_get_int8(tvb, offset));
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_tag_power_capability_max, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, ", Max: %d", tvb_get_int8(tvb, offset));
  return tvb_captured_length(tvb);
}

/* 7.3.2.18 TPC Request element (34) */
static int
ieee80211_tag_tpc_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree _U_, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  if (tag_len != 0)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 0", tag_len);
    return 1; /* Even with no data, we can't return 0 */
  }

  return 1; /* Even with no data, we can't return 0 */
}

/* TPC Report element (35)
 * 7.3.2.18 (Std 802.11-2007), 8.4.2.19 (Std 802.11-2012),
 * 9.4.2.17 (Std 802.11-2016), 9.4.2.16 (Std 802.11-2020)
 */
static int
ieee80211_tag_tpc_report(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if (tag_len != 2)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 2", tag_len);
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_tpc_report_trsmt_pow, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, " Transmit Power: %d dBm", tvb_get_uint8(tvb, offset));
  offset += 1;

  /*
   * "The Link Margin field is reserved when a TPC Report element is
   * included in a Beacon frame or Probe Response frame." - 2012 and later
   */

  uint32_t ftype = GPOINTER_TO_UINT(p_get_proto_data(wmem_file_scope(),
                                                     pinfo, proto_wlan,
                                                     FRAME_TYPE_KEY));

  if (ftype == MGT_BEACON || ftype == MGT_PROBE_RESP) {
    proto_tree_add_item(tree, hf_ieee80211_tag_tpc_report_reserved, tvb, offset, 1, ENC_NA);
  } else {
    proto_tree_add_item(tree, hf_ieee80211_tag_tpc_report_link_mrg, tvb, offset, 1, ENC_LITTLE_ENDIAN);

    proto_item_append_text(field_data->item_tag, ", Link Margin: %d dBm", tvb_get_uint8(tvb, offset));
  }
  return tvb_captured_length(tvb);
}

/* 7.3.2.19 Supported Channels element (36) */
static int
ieee80211_tag_supported_channels(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  proto_item *chan_item;
  proto_tree *chan_tree;
  unsigned    i = 1;

  if (tag_len % 2 == 1) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag length %u must be even", tag_len);
    return tvb_captured_length(tvb);
  }

  while (offset < tag_len)
  {
    chan_item = proto_tree_add_item(tree, hf_ieee80211_tag_supported_channels, tvb, offset, 2, ENC_NA);
    proto_item_append_text(chan_item, " #%d", i);
    i += 1;

    chan_tree = proto_item_add_subtree(chan_item , ett_tag_supported_channels);

    proto_tree_add_item(chan_tree, hf_ieee80211_tag_supported_channels_first, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    proto_item_append_text(chan_item, " First: %d", tvb_get_uint8(tvb, offset));
    offset += 1;

    proto_tree_add_item(chan_tree, hf_ieee80211_tag_supported_channels_range, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    proto_item_append_text(chan_item, ", Range: %d ", tvb_get_uint8(tvb, offset));
    offset += 1;

  }
  return tvb_captured_length(tvb);
}

/* 7.3.2.20 Channel Switch Announcement element (37) */
static int
ieee80211_tag_switch_ann(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  if (tag_len != 3)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 3", tag_len);
    return 1;
  }

  proto_tree_add_item(tree, hf_ieee80211_csa_channel_switch_mode, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, " Mode: %d", tvb_get_uint8(tvb, offset));
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_csa_new_channel_number, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, ", Number: %d ", tvb_get_uint8(tvb, offset));
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_csa_channel_switch_count, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, ", Count: %d ", tvb_get_uint8(tvb, offset));
  return tvb_captured_length(tvb);
}

/* 7.3.2.21 Measurement Request element (38) with update from 802.11k-2008 */
static int
ieee80211_tag_measure_req(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  uint8_t request_type;
  proto_item *parent_item;
  proto_tree *sub_tree;
  static int * const ieee80211_tag_measure_request_mode[] = {
    &hf_ieee80211_tag_measure_request_mode_parallel,
    &hf_ieee80211_tag_measure_request_mode_enable,
    &hf_ieee80211_tag_measure_request_mode_request,
    &hf_ieee80211_tag_measure_request_mode_report,
    &hf_ieee80211_tag_measure_request_mode_duration_mandatory,
    &hf_ieee80211_tag_measure_request_mode_reserved,
    NULL
  };

  if (tag_len < 3)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag length %u too short, must be >= 3", tag_len);
    return tvb_captured_length(tvb);
  }
  proto_tree_add_item(tree, hf_ieee80211_tag_measure_request_token, tvb, offset, 1, ENC_NA);
  offset += 1;

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_measure_request_mode,
                                    ett_tag_measure_request_mode_tree, ieee80211_tag_measure_request_mode,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  parent_item = proto_tree_add_item(tree, hf_ieee80211_tag_measure_request_type, tvb, offset, 1, ENC_NA);
  sub_tree = proto_item_add_subtree(parent_item, ett_tag_measure_request_type_tree);
  request_type = tvb_get_uint8(tvb, offset);
  offset += 1;

  switch (request_type) {
    case 0: /* Basic Request */
    case 1: /* Clear channel assessment (CCA) request */
    case 2: /* Receive power indication (RPI) histogram request */
    {
      proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_channel_number, tvb, offset, 1, ENC_NA);
      offset += 1;

      proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_start_time, tvb, offset, 8, ENC_LITTLE_ENDIAN);
      offset += 8;

      proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
      break;
    }
    case 3: /* Channel Load Request */
    {
      proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_operating_class, tvb, offset, 1, ENC_NA);
      offset += 1;

      proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_channel_number, tvb, offset, 1, ENC_NA);
      offset += 1;

      proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_randomization_interval, tvb, offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;

      proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;

      while (offset < tag_len)
      {
        uint8_t sub_id;
        proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_channel_load_sub_id, tvb, offset, 1, ENC_NA);
        sub_id = tvb_get_uint8(tvb, offset);
        offset += 1;

        proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_subelement_length, tvb, offset, 1, ENC_NA);
        offset += 1;

        switch (sub_id) {
          case MEASURE_REQ_CHANNEL_LOAD_SUB_REPORTING_INFO: /* Channel Load Reporting Information (1) */
            proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_channel_load_sub_reporting_condition, tvb, offset, 1, ENC_NA);
            offset += 1;
            proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_channel_load_sub_reporting_ref, tvb, offset, 1, ENC_NA);
            offset += 1;
            break;
          default:
            /* no default action */
            break;
          }
     }
     break;
   }
   case 4: /* Noise Histogram Request */
   {
     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_operating_class, tvb, offset, 1, ENC_NA);
     offset += 1;

     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_channel_number, tvb, offset, 1, ENC_NA);
     offset += 1;

     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_randomization_interval, tvb, offset, 2, ENC_LITTLE_ENDIAN);
     offset += 2;

     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
     offset += 2;

     while (offset < tag_len)
     {
       uint8_t sub_id;
       proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_noise_histogram_sub_id, tvb, offset, 1, ENC_NA);
       sub_id = tvb_get_uint8(tvb, offset);
       offset += 1;

       proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_subelement_length, tvb, offset, 1, ENC_NA);
       offset += 1;

       switch (sub_id) {
         case MEASURE_REQ_NOISE_HISTOGRAM_SUB_REPORTING_INFO: /* Noise Histogram Reporting Information (1) */
           proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_noise_histogram_sub_reporting_condition, tvb, offset, 1, ENC_NA);
           offset += 1;
           proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_noise_histogram_sub_reporting_anpi_ref, tvb, offset, 1, ENC_NA);
           offset += 1;
           break;
         default:
           /* no default action */
           break;
       }
     }
     break;
   }
   case 5: /* Beacon Request */
   {
     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_operating_class, tvb, offset, 1, ENC_NA);
     offset += 1;

     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_channel_number, tvb, offset, 1, ENC_NA);
     offset += 1;

     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_randomization_interval, tvb, offset, 2, ENC_LITTLE_ENDIAN);
     offset += 2;

     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
     offset += 2;

     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_measurement_mode, tvb, offset, 1, ENC_NA);
     offset += 1;

     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_bssid, tvb, offset, 6, ENC_NA);
     offset += 6;

     while (offset < tag_len)
     {
       uint8_t sub_id, sub_length, sub_tag_end;
       proto_item *sub_elem_item, *sub_elem_len_item;
       proto_tree *sub_elem_tree;

       sub_elem_item = proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_beacon_sub_id, tvb, offset, 1, ENC_NA);
       sub_id = tvb_get_uint8(tvb, offset);
       offset += 1;

       sub_elem_tree = proto_item_add_subtree(sub_elem_item, ett_tag_measure_request_sub_element_tree);

       sub_elem_len_item = proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_request_subelement_length,
                                               tvb, offset, 1, ENC_NA);
       sub_length = tvb_get_uint8(tvb, offset);
       offset += 1;
       sub_tag_end = offset + sub_length;

       if (sub_tag_end > tag_len)
       {
         expert_add_info_format(pinfo, sub_elem_len_item, &ei_ieee80211_tag_length, "Sub Element length exceed Tag length");
         return tvb_captured_length(tvb);
       }

       switch (sub_id) {
         case MEASURE_REQ_BEACON_SUB_SSID: /* SSID (0) */
           proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_request_beacon_sub_ssid, tvb, offset, sub_length, ENC_ASCII);
           offset += sub_length;
           break;
         case MEASURE_REQ_BEACON_SUB_BRI: /* Beacon Reporting Information (1) */
           proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_request_beacon_sub_bri_reporting_condition, tvb, offset, 1, ENC_LITTLE_ENDIAN);
           offset += 1;
           proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_request_beacon_sub_bri_threshold_offset, tvb, offset, 1, ENC_LITTLE_ENDIAN);
           offset += 1;
           break;
         case MEASURE_REQ_BEACON_SUB_RD: /* Reporting Detail (2) */
           proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_request_beacon_sub_reporting_detail, tvb, offset, 1, ENC_LITTLE_ENDIAN);
           offset += 1;
           break;
         case MEASURE_REQ_BEACON_SUB_REQUEST: /* Request (10) */
         {
           tvbuff_t *sub_tvb = tvb_new_subset_length(tvb, offset, sub_length);
           offset += ieee80211_tag_request(sub_tvb, pinfo, sub_elem_tree, NULL);
           break;
         }
         case MEASURE_REQ_BEACON_SUB_REQUEST_EXT: /* Extended Request (11) */
           dissect_extended_request(tvb, pinfo, sub_elem_tree, offset, sub_length);
           offset += sub_length;
           break;
         case MEASURE_REQ_BEACON_SUB_APCP: /* AP Channel Report (51) */
         {
           tvbuff_t *sub_tvb = tvb_new_subset_length(tvb, offset, sub_length);
           ieee80211_tagged_field_data_t sub_data = {
             .ftype = 0,
             .sanity_check = NULL,
             .isDMG = false,
             .item_tag_length = sub_elem_len_item,
             .item_tag = sub_elem_item};
           offset += dissect_ap_channel_report(sub_tvb, pinfo, sub_elem_tree, &sub_data);
           break;
         }
         case MEASURE_REQ_BEACON_SUB_WIDE_BW_CHANNEL_SWITCH:
         {
           tvbuff_t *sub_tvb = tvb_new_subset_length(tvb, offset, sub_length);
           offset += dissect_wide_bw_channel_switch(sub_tvb, pinfo, sub_elem_tree, NULL);
           break;
         }
         case MEASURE_REQ_BEACON_SUB_LAST_REPORT_REQ:
           proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_request_beacon_sub_last_report_indication_request,
                               tvb, offset, 1, ENC_LITTLE_ENDIAN);
           offset += 1;
           break;
         default:
           /* no default action */
           break;
       }
       if (offset < sub_tag_end)
       {
         proto_item *tix;
         tix = proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_request_beacon_unknown, tvb, offset, sub_tag_end - offset, ENC_NA);
         expert_add_info(pinfo, tix, &ei_ieee80211_tag_measure_request_beacon_unknown);
         offset = sub_tag_end;
       }
     }

     break;
   }
   case 6: /* Frame Request */
   {
     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_operating_class, tvb, offset, 1, ENC_NA);
     offset += 1;

     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_channel_number, tvb, offset, 1, ENC_NA);
     offset += 1;

     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_randomization_interval, tvb, offset, 2, ENC_LITTLE_ENDIAN);
     offset += 2;

     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
     offset += 2;

     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_frame_request_type, tvb, offset, 1, ENC_NA);
     offset += 1;

     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_mac_address, tvb, offset, 6, ENC_NA);
     offset += 6;

     /* TODO Add Optional Subelements */
     break;
   }
   case 7: /* BSTA Statistics Request */
   {
     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_peer_mac_address, tvb, offset, 6, ENC_NA);
     offset += 6;

     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_randomization_interval, tvb, offset, 2, ENC_LITTLE_ENDIAN);
     offset += 2;

     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
     offset += 2;

     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_group_id, tvb, offset, 1, ENC_NA);
     offset += 1;

     /* TODO Add Optional Subelements */
     break;
   }
   case 8: /* Location Configuration Indication (LCI) Request */
     proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_location_subject, tvb, offset, 1, ENC_NA);
     offset += 1;

     /* TODO Add Optional Subelements */
     break;
   case 9: /* Transmit Stream Measurement Request */
    /* TODO */
   case 10: /* Multicast Diagnostics Request */
    /* TODO */
   case 11: /* Location Civic Request */
      proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_location_subject, tvb, offset, 1, ENC_NA);
      offset += 1;

      proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_civic_location_type, tvb, offset, 1, ENC_NA);
      offset += 1;

      proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_location_service_interval_units, tvb, offset, 1, ENC_NA);
      offset += 1;

      proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_location_service_interval, tvb, offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;
     /* TODO Add Optional Subelements */
      break;
   case 12: /* Location Identifier Request */
    /* TODO */
   case 13: /* Directional Channel Quality Request */
    /* TODO */
   case 14: /* Directional Measurement Request */
    /* TODO */
   case 15: /* Directional Statistics Request */
    /* TODO */
   case 16: /* Fine Timing Measurement Range Request */
    /* TODO */
   case 255: /* Measurement Pause Request */
    /* TODO */
   default: /* unknown */
    break;
  }
  if (offset < tag_len)
  {
    proto_item *tix;
    tix = proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_request_unknown, tvb, offset, tag_len - offset, ENC_NA);
    expert_add_info(pinfo, tix, &ei_ieee80211_tag_measure_request_unknown);
  }

  return tvb_captured_length(tvb);
}

/* 7.3.2.22 Measurement Report element (39) with update from 802.11k-2008 */
static int
ieee80211_tag_measure_rep(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  proto_item *parent_item;
  proto_tree *sub_tree;
  uint8_t report_type;
  static int * const ieee80211_tag_measure_report_mode[] = {
    &hf_ieee80211_tag_measure_report_mode_late,
    &hf_ieee80211_tag_measure_report_mode_incapable,
    &hf_ieee80211_tag_measure_report_mode_refused,
    &hf_ieee80211_tag_measure_report_mode_reserved,
    NULL
  };
  static int * const ieee80211_tag_measure_map_field[] = {
    &hf_ieee80211_tag_measure_map_field_bss,
    &hf_ieee80211_tag_measure_map_field_ofdm,
    &hf_ieee80211_tag_measure_map_field_unident_signal,
    &hf_ieee80211_tag_measure_map_field_radar,
    &hf_ieee80211_tag_measure_map_field_unmeasured,
    &hf_ieee80211_tag_measure_map_field_reserved,
    NULL
  };
  static int * const ieee80211_tag_measure_report_frame_info[] = {
    &hf_ieee80211_tag_measure_report_frame_info_phy_type,
    &hf_ieee80211_tag_measure_report_frame_info_frame_type,
    NULL
  };

  if (tag_len < 3)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag length %u too short, must be >= 3", tag_len);
    return tvb_captured_length(tvb);
  }
  proto_tree_add_item(tree, hf_ieee80211_tag_measure_report_measurement_token, tvb, offset, 1, ENC_NA);
  offset += 1;

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_measure_report_mode,
                                    ett_tag_measure_report_mode_tree, ieee80211_tag_measure_report_mode,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  report_type = tvb_get_uint8(tvb, offset);
  parent_item = proto_tree_add_item(tree, hf_ieee80211_tag_measure_report_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  sub_tree = proto_item_add_subtree(parent_item, ett_tag_measure_report_type_tree);
  offset += 1;

  if (tag_len == 3)
    return tvb_captured_length(tvb);

  switch (report_type) {
  case 0: /* Basic Report */
  {
    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_channel_number, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_start_time, tvb, offset, 8, ENC_LITTLE_ENDIAN);
    offset += 8;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_measure_basic_map_field,
                                    ett_tag_measure_report_basic_map_tree, ieee80211_tag_measure_map_field,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    break;
  }
  case 1: /* Clear channel assessment (CCA) report */
    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_channel_number, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_start_time, tvb, offset, 8, ENC_LITTLE_ENDIAN);
    offset += 8;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_cca_busy_fraction, tvb, offset, 1, ENC_NA);
    offset += 1;
    break;
  case 2: /* Receive power indication (RPI) histogram report */
    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_channel_number, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_start_time, tvb, offset, 8, ENC_LITTLE_ENDIAN);
    offset += 8;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    parent_item = proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_rpi_histogram_report, tvb, offset, 8, ENC_NA);
    sub_tree = proto_item_add_subtree(parent_item, ett_tag_measure_report_rpi_tree);

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_rpi_histogram_report_0, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_rpi_histogram_report_1, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_rpi_histogram_report_2, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_rpi_histogram_report_3, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_rpi_histogram_report_4, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_rpi_histogram_report_5, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_rpi_histogram_report_6, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_rpi_histogram_report_7, tvb, offset, 1, ENC_NA);
    offset += 1;
    break;
  case 3: /* Channel Load Report */
  {
    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_operating_class, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_channel_number, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_start_time, tvb, offset, 8, ENC_LITTLE_ENDIAN);
    offset += 8;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_channel_load, tvb, offset, 1, ENC_NA);
    offset += 1;

    /* TODO Add Optional Subelements */
    break;
  }
  case 4: /* Noise Histogram Report */
    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_operating_class, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_channel_number, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_start_time, tvb, offset, 8, ENC_LITTLE_ENDIAN);
    offset += 8;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_ant_id, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_anpi, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_ipi_density_0, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_ipi_density_1, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_ipi_density_2, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_ipi_density_3, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_ipi_density_4, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_ipi_density_5, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_ipi_density_6, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_ipi_density_7, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_ipi_density_8, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_ipi_density_9, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_ipi_density_10, tvb, offset, 1, ENC_NA);
    offset += 1;

    /* TODO Add Optional Subelements */
    break;
  case 5: /* Beacon Report */
  {
    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_operating_class, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_channel_number, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_start_time, tvb, offset, 8, ENC_LITTLE_ENDIAN);
    offset += 8;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    proto_tree_add_bitmask_with_flags(sub_tree, tvb, offset, hf_ieee80211_tag_measure_report_frame_info,
                                      ett_tag_measure_report_frame_tree, ieee80211_tag_measure_report_frame_info,
                                      ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_rcpi, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_rsni, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_bssid, tvb, offset, 6, ENC_NA);
    offset += 6;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_ant_id, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_parent_tsf, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    offset += 4;

    while (offset < tag_len)
    {
      uint8_t sub_id, sub_length, sub_tag_end;
      proto_item *sub_elem_item, *sub_elem_len_item;
      proto_tree *sub_elem_tree;

      sub_elem_item = proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_beacon_sub_id,
                                          tvb, offset, 1, ENC_NA);
      sub_id = tvb_get_uint8(tvb, offset);
      offset += 1;

      sub_elem_tree = proto_item_add_subtree(sub_elem_item, ett_tag_measure_report_sub_element_tree);

      sub_elem_len_item = proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_report_subelement_length,
                                              tvb, offset, 1, ENC_NA);
      sub_length = tvb_get_uint8(tvb, offset);
      offset += 1;
      sub_tag_end = offset + sub_length;

      if (sub_tag_end > tag_len)
      {
        expert_add_info_format(pinfo, sub_elem_len_item, &ei_ieee80211_tag_length, "Sub Element length exceed Tag length");
        return tvb_captured_length(tvb);
      }

      switch (sub_id) {
        case MEASURE_REP_BEACON_SUB_REPORTED_FRAME_BODY: /* Reported Frame Body (1) */
        {
          proto_tree *rep_tree;
          bool fixed_fields = true;

          rep_tree = proto_tree_add_subtree(sub_elem_tree, tvb, offset, sub_length,
                                            ett_tag_measure_reported_frame_tree, NULL, "Reported Frame Body");

          /* If reported frame body fragment ID sub element is present and this is not
             the first fragment then there are no fixed size fields */
          if (((tag_len - sub_tag_end) >= 4) &&
              (tvb_get_uint8(tvb, sub_tag_end) == MEASURE_REP_BEACON_SUB_REPORTED_FRAME_BODY_FRAG_ID) &&
              ((tvb_get_uint8(tvb, sub_tag_end + 3) & 0x7f) > 0))
            fixed_fields = false;

          if (fixed_fields) {
            add_ff_timestamp(rep_tree, tvb, pinfo, offset);
            offset += 8;
            add_ff_beacon_interval(rep_tree, tvb, pinfo, offset);
            offset += 2;
            add_ff_cap_info(rep_tree, tvb, pinfo, offset);
            offset += 2;
            sub_length -= 12;
          }

          ieee_80211_add_tagged_parameters(tvb, offset, pinfo, rep_tree, sub_length, MGT_PROBE_RESP, NULL);
          offset += sub_length;
          break;
        }
        case MEASURE_REP_BEACON_SUB_REPORTED_FRAME_BODY_FRAG_ID:
        {
          static int * const ieee80211_tag_measure_reported_frame_frag_id[] = {
            &hf_ieee80211_tag_measure_reported_frame_frag_rep_id,
            &hf_ieee80211_tag_measure_reported_frame_frag_number,
            &hf_ieee80211_tag_measure_reported_frame_frag_more,
            NULL
          };
          proto_tree_add_bitmask_with_flags(sub_elem_tree, tvb, offset,
                                            hf_ieee80211_tag_measure_reported_frame_frag_id,
                                            ett_tag_measure_reported_frame_frag_id_tree,
                                            ieee80211_tag_measure_reported_frame_frag_id,
                                            ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
          offset += 2;
          break;
        }
        case MEASURE_REP_BEACON_SUB_WIDE_BW_CHANNEL_SWITCH:
        {
          tvbuff_t *sub_tvb = tvb_new_subset_length(tvb, offset, sub_length);
          offset += dissect_wide_bw_channel_switch(sub_tvb, pinfo, sub_elem_tree, NULL);
          break;
        }
        case MEASURE_REP_BEACON_SUB_LAST_REPORT_INDICATION:
          proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_report_beacon_sub_last_report_indication,
                              tvb, offset, 1, ENC_LITTLE_ENDIAN);
          offset += 1;
          break;
        default:
          /* no default action */
          break;
      }

      if (offset < sub_tag_end)
      {
        proto_item *tix;
        tix = proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_report_beacon_unknown,
                                  tvb, offset, sub_tag_end - offset, ENC_NA);
        expert_add_info(pinfo, tix, &ei_ieee80211_tag_measure_report_beacon_unknown);
        offset = sub_tag_end;
      }
    }
    break;
  }
  case 6: /* Frame Report */
    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_operating_class, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_channel_number, tvb, offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_start_time, tvb, offset, 8, ENC_LITTLE_ENDIAN);
    offset += 8;

    proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    /* TODO Add Optional Subelements */
    break;
  case 7: /* BSTA Statistics Report */
    /* TODO */
  case 8: /* Location Configuration Information Report element */
    //proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_parent_tsf, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    //offset += 4;

    while (offset < tag_len)
    {
      uint8_t sub_id, sub_length, sub_tag_end;
      proto_item *sub_elem_item, *sub_elem_len_item;
      proto_tree *sub_elem_tree;

      sub_elem_item = proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_lci_sub_id,
                                          tvb, offset, 1, ENC_NA);
      sub_id = tvb_get_uint8(tvb, offset);
      offset += 1;

      sub_elem_tree = proto_item_add_subtree(sub_elem_item, ett_tag_measure_report_sub_element_tree);

      sub_elem_len_item = proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_report_subelement_length,
                                              tvb, offset, 1, ENC_NA);
      sub_length = tvb_get_uint8(tvb, offset);
      offset += 1;
      sub_tag_end = offset + sub_length;

      if (sub_tag_end > tag_len)
      {
        expert_add_info_format(pinfo, sub_elem_len_item, &ei_ieee80211_tag_length, "Sub Element length exceed Tag length");
        return tvb_captured_length(tvb);
      }

      switch (sub_id) {
        case MEASURE_REP_LCI_SUB_REPORTED_LCI: /* Location Configuration Information (0) */
        {
          proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_report_lci_lci,
                              tvb, offset, 16, ENC_NA);
          offset += 16;
          break;
        }
        case MEASURE_REP_LCI_SUB_REPORTED_Z: /* Z (4) */
        {
          static int * const ieee80211_tag_measure_reported_lci_z_sta_floor_info[] = {
            &hf_ieee80211_tag_measure_report_lci_z_sta_floor_info_expected_to_move,
            &hf_ieee80211_tag_measure_report_lci_z_sta_floor_info_sta_floor_number,
            NULL
          };
          proto_tree_add_bitmask_with_flags(sub_elem_tree, tvb, offset,
                                            hf_ieee80211_tag_measure_report_lci_z_sta_floor_info,
                                            ett_tag_measure_reported_lci_z_tree,
                                            ieee80211_tag_measure_reported_lci_z_sta_floor_info,
                                            ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
          offset += 2;

          proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_report_lci_z_sta_height_above_floor,
                              tvb, offset, 3, ENC_LITTLE_ENDIAN);
          offset += 3;

          proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_report_lci_z_sta_height_above_floor_uncertainty,
                              tvb, offset, 1, ENC_LITTLE_ENDIAN);
          offset += 1;
          break;
        }
        case MEASURE_REP_LCI_SUB_REPORTED_URP: /* Usage Rules/Policy (6) */
        {
          static int * const ieee80211_tag_measure_reported_lci_urp[] = {
            &hf_ieee80211_tag_measure_report_lci_urp_retransmission_allowed,
            &hf_ieee80211_tag_measure_report_lci_urp_retention_expires_relative_present,
            &hf_ieee80211_tag_measure_report_lci_urp_sta_location_policy,
            &hf_ieee80211_tag_measure_report_lci_urp_reserved,
            NULL
          };
          proto_tree_add_bitmask_with_flags(sub_elem_tree, tvb, offset,
                                            hf_ieee80211_tag_measure_report_lci_urp,
                                            ett_tag_measure_reported_lci_urp_tree,
                                            ieee80211_tag_measure_reported_lci_urp,
                                            ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
          offset += 1;

          /* Retention Expires Relative (optional) */
          if ((sub_tag_end - 1) == 2 ) {
            proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_report_lci_urp_retention_expires_relative,
                                  tvb, offset, 2, ENC_NA);
            offset += 1;
          }
          break;
        }
        default:
          /* no default action */
          break;
      }

      if (offset < sub_tag_end)
      {
        proto_item *tix;
        tix = proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_report_lci_unknown,
                                  tvb, offset, sub_tag_end - offset, ENC_NA);
        expert_add_info(pinfo, tix, &ei_ieee80211_tag_measure_report_lci_unknown);
        offset = sub_tag_end;
      }
    }
    break;
  case 9: /* Transmit Stream Measurement Report */
    /* TODO */
  case 10: /* Multicast Diagnostics Report */
    /* TODO */
  case 11: /* Location Civic Report */
      proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_civic_location_type, tvb, offset, 1, ENC_NA);
      offset += 1;

    while (offset < tag_len)
    {
      uint8_t sub_id, sub_length, sub_tag_end;
      proto_item *sub_elem_item, *sub_elem_len_item;
      proto_tree *sub_elem_tree;

      sub_elem_item = proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_civic_sub_id,
                                          tvb, offset, 1, ENC_NA);
      sub_id = tvb_get_uint8(tvb, offset);
      offset += 1;

      sub_elem_tree = proto_item_add_subtree(sub_elem_item, ett_tag_measure_report_sub_element_tree);

      sub_elem_len_item = proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_report_subelement_length,
                                              tvb, offset, 1, ENC_NA);
      sub_length = tvb_get_uint8(tvb, offset);
      offset += 1;
      sub_tag_end = offset + sub_length;

      if (sub_tag_end > tag_len)
      {
        expert_add_info_format(pinfo, sub_elem_len_item, &ei_ieee80211_tag_length, "Sub Element length exceed Tag length");
        return tvb_captured_length(tvb);
      }

      switch (sub_id) {
        case MEASURE_REP_CIVIC_SUB_REPORTED_LOCATION_CIVIC: /* Location Civic (0) */
        {
          uint32_t length;
          proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_report_location_civic_country,
                              tvb, offset, 2, ENC_ASCII);
          offset += 2;

          proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_report_location_civic_type,
                              tvb, offset, 1, ENC_ASCII);
          offset += 1;

          proto_tree_add_item_ret_uint(sub_elem_tree, hf_ieee80211_tag_measure_report_location_civic_length,
                              tvb, offset, 1, ENC_LITTLE_ENDIAN, &length);
          offset += 1;

          proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_report_location_civic,
                              tvb, offset, length, ENC_ASCII);
          offset += length;
          break;
        }
        default:
          /* no default action */
          break;
      }

      if (offset < sub_tag_end)
      {
        proto_item *tix;
        tix = proto_tree_add_item(sub_elem_tree, hf_ieee80211_tag_measure_report_lci_unknown,
                                  tvb, offset, sub_tag_end - offset, ENC_NA);
        expert_add_info(pinfo, tix, &ei_ieee80211_tag_measure_report_lci_unknown);
        offset = sub_tag_end;
      }
    }
    break;
  case 12: /* Location Identifier Report */
    /* TODO */
  case 13: /* Directional Channel Quality Report */
    /* TODO */
  case 14: /* Directional Measurement Report */
    /* TODO */
  case 15: /* Directional Statistics Report */
    /* TODO */
  case 16: /* Fine Timing Measurement range Report */
    /* TODO */
  default: /* unknown */
    break;
  }
  if (offset < tag_len)
  {
    proto_item *tix;
    tix = proto_tree_add_item(sub_tree, hf_ieee80211_tag_measure_report_unknown, tvb, offset, tag_len - offset, ENC_NA);
    expert_add_info(pinfo, tix, &ei_ieee80211_tag_measure_report_unknown);
  }
  return tvb_captured_length(tvb);
}

/* 7.3.2.23 Quiet element (40) */
static int
ieee80211_tag_quiet(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  if (tag_len != 6)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 6", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_quiet_count, tvb, offset, 1, ENC_NA);
  proto_item_append_text(field_data->item_tag, " Count: %d", tvb_get_uint8(tvb, offset));
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_tag_quiet_period, tvb, offset, 1, ENC_NA);
  proto_item_append_text(field_data->item_tag, " Period: %d", tvb_get_uint8(tvb, offset));
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_tag_quiet_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, " Duration: %d", tvb_get_letohs(tvb, offset));
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_tag_quiet_offset, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, " Offset: %d", tvb_get_letohs(tvb, offset));

  return tvb_captured_length(tvb);
}

/* 7.3.2.24 IBSS DFS element (41) */
static int
ieee80211_tag_ibss_dfs(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  proto_item *ti_sup_map;
  proto_tree *sub_map_tree;
  if (tag_len < 7)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be >= 7", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_dfs_owner, tvb, offset, 6, ENC_NA);
  proto_item_append_text(field_data->item_tag, " Owner: %s", tvb_ether_to_str(pinfo->pool, tvb, offset));
  offset += 6;

  proto_tree_add_item(tree, hf_ieee80211_tag_dfs_recovery_interval, tvb, offset, 1, ENC_NA);
  offset += 1;

  while (offset < tag_len)
  {
    ti_sup_map = proto_tree_add_item(tree, hf_ieee80211_tag_dfs_channel_map, tvb, offset, 2, ENC_NA);
    sub_map_tree = proto_item_add_subtree(ti_sup_map, ett_tag_dfs_map_tree);
    proto_tree_add_item(sub_map_tree, hf_ieee80211_tag_dfs_channel_number, tvb, offset, 1, ENC_NA);
    proto_tree_add_item(sub_map_tree, hf_ieee80211_tag_dfs_map, tvb, offset, 1, ENC_NA);
    offset += 2;
  }
  return tvb_captured_length(tvb);
}

/* 7.3.2.13 ERP Information element (42) */
static int
ieee80211_tag_erp_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  static int * const ieee80211_tag_erp_info_flags[] = {
    &hf_ieee80211_tag_erp_info_erp_present,
    &hf_ieee80211_tag_erp_info_use_protection,
    &hf_ieee80211_tag_erp_info_barker_preamble_mode,
    &hf_ieee80211_tag_erp_info_reserved,
    NULL
  };

  if (tag_len != 1)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 1", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_erp_info,
                                    ett_tag_erp_info_tree, ieee80211_tag_erp_info_flags,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);

  return tvb_captured_length(tvb);
}

/* 7.3.2.32 TS Delay element (43) */
static int
ieee80211_tag_ts_delay(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  if (tag_len != 4)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 4", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item(tree, hf_ieee80211_ts_delay, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, " : %d", tvb_get_ntohl(tvb, offset));
  return tvb_captured_length(tvb);
}

/* 7.3.2.33 TCLAS Processing element (44) */
static int
ieee80211_tag_tclas_process(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  if (tag_len != 1)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 1", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item(tree, hf_ieee80211_tclas_process, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, " : %s", val_to_str(tvb_get_uint8(tvb, offset), ieee80211_tclas_process_flag, "Unknown %d"));
  return tvb_captured_length(tvb);
}

/* 802.11-2012 8.4.2.37 QoS Capability element (46) */
static int
ieee80211_tag_qos_capability(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  if (tag_len != 1)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 1", tag_len);
    return tvb_captured_length(tvb);
  }
  dissect_qos_capability(tree, tvb, pinfo, offset, field_data->ftype);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_rsn_ie(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  if (tag_len < 2)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be >= 2", tag_len);
    return tvb_captured_length(tvb);
  }

  dissect_rsn_ie(pinfo, tree, tvb, offset, tag_len, field_data->sanity_check);
  return tvb_captured_length(tvb);
}

/* 7.3.2.14 Extended Supported Rates element (50) */
static int
ieee80211_tag_ext_supp_rates(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  if (tag_len < 1)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag length %u too short, must be greater than 0", tag_len);
    return tvb_captured_length(tvb);
  }

  while (offset < tag_len)
  {
    proto_tree_add_item(tree, hf_ieee80211_tag_ext_supp_rates, tvb, offset, 1, ENC_NA);
    proto_item_append_text(field_data->item_tag, " %s,", val_to_str_ext_const(tvb_get_uint8(tvb, offset), &ieee80211_supported_rates_vals_ext, "Unknown Rate"));
    offset += 1;
  }
  proto_item_append_text(field_data->item_tag, " [Mbit/sec]");
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_cisco_ccx1_ckip(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  /* From WCS manual:
   * If Aironet IE support is enabled, the access point sends an Aironet
   * IE 0x85 (which contains the access point name, load, number of
   * associated clients, and so on) in the beacon and probe responses of
   * this WLAN, and the controller sends Aironet IEs 0x85 and 0x95
   * (which contains the management IP address of the controller and
   * the IP address of the access point) in the reassociation response
   * if it receives Aironet IE 0x85 in the reassociation request.
   */

  if (tag_len < 26)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u too short, must be >= 26", tag_len);
    return tvb_captured_length(tvb);
  }
  proto_tree_add_item(tree, hf_ieee80211_tag_cisco_ccx1_unknown, tvb, offset, 10, ENC_NA);
  offset += 10;

  /* The Name of the sending device starts at offset 10 and is up to
     15 or 16 bytes in length, \0 padded */
  proto_tree_add_item(tree, hf_ieee80211_tag_cisco_ccx1_name, tvb, offset, 16, ENC_ASCII);
  offset += 16;

  /* Total number off associated clients and repeater access points */
  proto_tree_add_item(tree, hf_ieee80211_tag_cisco_ccx1_clients, tvb, offset, 1, ENC_NA);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_cisco_ccx1_unknown2, tvb, offset, 3, ENC_NA);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_vendor_specific_ie(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  uint32_t tag_vs_len = tag_len;
  uint32_t      oui;

  if (tag_len < 3)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be >= 3", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item_ret_uint(tree, hf_ieee80211_tag_oui, tvb, offset, 3, ENC_BIG_ENDIAN, &oui);
  proto_item_append_text(field_data->item_tag, ": %s", uint_get_manuf_name_if_known(oui));

  offset += 3;
  tag_vs_len -= 3;

  if (tag_len > 0) {
    proto_tree_add_item(field_data->item_tag, hf_ieee80211_tag_vendor_oui_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  }

  switch (oui) {
    /* 802.11 specific vendor ids */
    case OUI_WPAWME:
      dissect_vendor_ie_wpawme(tree, tvb, pinfo, offset, tag_vs_len, field_data->ftype);
      break;
    case OUI_RSN:
      dissect_vendor_ie_rsn(field_data->item_tag, tree, tvb, offset, tag_vs_len, pinfo);
      break;
    case OUI_PRE11N:
      dissect_vendor_ie_ht(tvb, pinfo, tree, offset, field_data->item_tag, field_data->item_tag_length, tag_vs_len);
      break;
    case OUI_WFA:
      dissect_vendor_ie_wfa(pinfo, field_data->item_tag, tvb);
      break;

    /* Normal IEEE vendor ids (from oui.h) */
    case OUI_CISCOWL:  /* Cisco Wireless (Aironet) */
      dissect_vendor_ie_aironet(field_data->item_tag, tree, tvb, offset, tag_vs_len);
      break;
    case OUI_MARVELL:
      dissect_vendor_ie_marvell(field_data->item_tag, tree, tvb, offset, tag_vs_len);
      break;
    case OUI_ATHEROS:
      dissect_vendor_ie_atheros(field_data->item_tag, tree, tvb, offset, tag_vs_len, pinfo, field_data->item_tag_length);
      break;
    case OUI_EXTREME_MESH:
      dissect_vendor_ie_extreme_mesh(field_data->item_tag, tree, tvb, offset, tag_vs_len, pinfo, field_data->item_tag_length);
      break;
    case OUI_ARUBA:
      dissect_vendor_ie_aruba(field_data->item_tag, tree, tvb, offset, tag_vs_len, pinfo);
      break;
    case OUI_NINTENDO:
      dissect_vendor_ie_nintendo(field_data->item_tag, tree, tvb, offset, tag_vs_len);
      break;
    case OUI_ROUTERBOARD:
      dissect_vendor_ie_routerboard(field_data->item_tag, tree, tvb, offset, tag_vs_len, pinfo);
      break;
    case OUI_MERU:
      dissect_vendor_ie_meru(field_data->item_tag, tree, tvb, offset, tag_vs_len, pinfo);
      break;
    case OUI_ZEBRA_EXTREME:
      dissect_vendor_ie_extreme(field_data->item_tag, tree, tvb, offset, tag_vs_len, pinfo);
      break;
    case OUI_AEROHIVE:
      dissect_vendor_ie_aerohive(field_data->item_tag, tree, tvb, offset, tag_vs_len, pinfo);
      break;
    case OUI_MIST:
      dissect_vendor_ie_mist(field_data->item_tag, tree, tvb, offset, tag_vs_len, pinfo);
      break;
    case OUI_RUCKUS:
      dissect_vendor_ie_ruckus(field_data->item_tag, tree, tvb, offset, tag_vs_len, pinfo);
      break;
    case OUI_ALCATEL_LUCENT:
      dissect_vendor_ie_alcatel(field_data->item_tag, tree, tvb, offset, tag_vs_len, pinfo);
      break;
    case OUI_SGDSN:
      dissect_vendor_ie_sgdsn(field_data->item_tag, tree, tvb, offset, tag_vs_len, pinfo);
      break;
    case OUI_FORTINET:
      dissect_vendor_ie_fortinet(field_data->item_tag, tree, tvb, offset, tag_vs_len, pinfo);
      break;
    case OUI_MOJO_ARISTA:
      dissect_vendor_ie_arista(field_data->item_tag, tree, tvb, offset, tag_vs_len, pinfo);
      break;
    case OUI_WISUN:
      dissect_vendor_ie_wisun(field_data->item_tag, tree, tvb, offset, tag_vs_len, pinfo);
      break;
    default:
      proto_tree_add_item(tree, hf_ieee80211_tag_vendor_data, tvb, offset, tag_vs_len, ENC_NA);
      break;
  }

  return tvb_captured_length(tvb);
}

static void
dissect_symbol_proprietary_ie_extreme(proto_item *item _U_, proto_tree *ietree,
                                      tvbuff_t *tvb, int offset, uint32_t tag_len _U_,
                                      packet_info *pinfo _U_)
{
  proto_tree_add_item(ietree, hf_ieee80211_symbp_extreme_assoc_clients, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(ietree, hf_ieee80211_symbp_extreme_load_kbps, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(ietree, hf_ieee80211_symbp_extreme_load_pps, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(ietree, hf_ieee80211_symbp_extreme_client_tx_power, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(ietree, hf_ieee80211_symbp_extreme_timestamp, tvb, offset, 4, ENC_TIME_SECS|ENC_LITTLE_ENDIAN);
}

static int
ieee80211_tag_symbol_proprietary_ie(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  uint32_t tag_vs_len = tag_len;
  uint32_t      oui;

  if (tag_len < 3)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be >= 3", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item_ret_uint(tree, hf_ieee80211_tag_symbol_proprietary_oui, tvb, offset, 3, ENC_BIG_ENDIAN, &oui);
  proto_item_append_text(field_data->item_tag, ": %s", uint_get_manuf_name_if_known(oui));

  offset += 3;
  tag_vs_len -= 3;

  switch (oui) {
    /* 802.11 specific vendor ids */
    case OUI_ZEBRA_EXTREME:
      dissect_symbol_proprietary_ie_extreme(field_data->item_tag, tree, tvb, offset, tag_vs_len, pinfo);
      break;
    default:
      proto_tree_add_item(tree, hf_ieee80211_tag_symbol_proprietary_data, tvb, offset, tag_vs_len, ENC_NA);
      break;
  }

  return tvb_captured_length(tvb);
}

#define HE_HTC_HE_SUPPORT                0x00000001
#define HE_DYNAMIC_FRAGMENTATION_SUPPORT 0x00000018
#define HE_ALL_ACK_SUPPORT               0x00000200
#define HE_UMRS_SUPPORT                  0x00000400
#define HE_BSR_SUPPORT                   0x00000800

static const val64_string he_dynamic_fragmentation_support_vals[] = {
  { 0, "No support for dynamic fragmentation" },
  { 1, "Level 1 dynamic fragmentation support" },
  { 2, "Level 2 dynamic fragmentation support" },
  { 3, "Level 3 dynamic fragmentation support" },
  { 0, NULL }
};

static const val64_string he_minimum_fragmentation_size_vals[] = {
  { 0, "No restriction on minimum payload size" },
  { 1, "Minimum payload size of 128 bytes" },
  { 2, "Minimum payload size of 256 bytes" },
  { 3, "Minimum payload size of 512 bytes" },
  { 0, NULL }
};

static const val64_string he_trigger_mac_padding_dur_vals[] = {
  { 0, "0" },
  { 1, "8 uS" },
  { 2, "16 uS" },
  { 3, "Reserved" },
  { 0, NULL }
};

static void
max_frag_msdus_base_custom(char *result, uint32_t max_frag_msdus_value)
{
  if (max_frag_msdus_value == 7)
    snprintf(result, ITEM_LABEL_LENGTH, "No restriction");
  else
    snprintf(result, ITEM_LABEL_LENGTH, "%u", 1 << max_frag_msdus_value);
}

static const val64_string he_link_adaptation_support_vals[] = {
  { 0, "No feedback if the STA does not provide HE MFB" },
  { 1, "Reserved" },
  { 2, "Unsolicited if the STA can receive and provide only unsolicited HE MFB" },
  { 3, "Both" },
  { 0, NULL }
};

static const val64_string he_mimo_cntrl_nc_index_vals[] = {
  {0x00, "1 Column"},
  {0x01, "2 Columns"},
  {0x02, "3 Columns"},
  {0x03, "4 Columns"},
  {0x04, "5 Columns"},
  {0x05, "6 Columns"},
  {0x06, "7 Columns"},
  {0x07, "8 Columns"},
  {0, NULL}
};

static const val64_string he_mimo_cntrl_nr_index_vals[] = {
  {0x00, "1 Row"},
  {0x01, "2 Rows"},
  {0x02, "3 Rows"},
  {0x03, "4 Rows"},
  {0x04, "5 Rows"},
  {0x05, "6 Rows"},
  {0x06, "7 Rows"},
  {0x07, "8 Rows"},
  {0, NULL}
};

static const val64_string he_mimo_cntrl_grouping_flags[] = {
  { 0x00, "Carrier Groups of 4" },
  { 0x01, "Carrier Groups of 16" },
  { 0, NULL }
};

static const val64_string he_mimo_cntrl_feedback_vals[] = {
  { 0x00, "SU" },
  { 0x01, "MU" },
  { 0x02, "CQI feedback" },
  { 0x03, "Reserved" },
  { 0, NULL }
};

static int * const he_phy_first_byte_headers[] = {
  &hf_ieee80211_he_phy_cap_reserved_b0,
  NULL,
};

static int * const he_phy_b8_to_b23_headers[] = {
  &hf_ieee80211_he_phy_cap_punctured_preamble_rx,
  &hf_ieee80211_he_phy_cap_device_class,
  &hf_ieee80211_he_phy_cap_ldpc_coding_in_payload,
  &hf_ieee80211_he_phy_cap_he_su_ppdu_1x_he_ltf_08us,
  &hf_ieee80211_he_phy_cap_midamble_tx_rx_max_nsts,
  &hf_ieee80211_he_phy_cap_ndp_with_4x_he_ltf_32us,
  &hf_ieee80211_he_phy_cap_stbc_tx_lt_80mhz,
  &hf_ieee80211_he_phy_cap_stbc_rx_lt_80mhz,
  &hf_ieee80211_he_phy_cap_doppler_tx,
  &hf_ieee80211_he_phy_cap_doppler_rx,
  &hf_ieee80211_he_phy_cap_full_bw_ul_mu_mimo,
  &hf_ieee80211_he_phy_cap_partial_bw_ul_mu_mimo,
  NULL
};

static int * const he_phy_b24_to_b39_headers[] = {
  &hf_ieee80211_he_phy_cap_dcm_max_constellation_tx,
  &hf_ieee80211_he_phy_cap_dcm_max_nss_tx,
  &hf_ieee80211_he_phy_cap_dcm_max_constellation_rx,
  &hf_ieee80211_he_phy_cap_dcm_max_nss_rx,
  &hf_ieee80211_he_phy_cap_rx_partial_bw_su_20mhz_he_mu_ppdu,
  &hf_ieee80211_he_phy_cap_su_beamformer,
  &hf_ieee80211_he_phy_cap_su_beamformee,
  &hf_ieee80211_he_phy_cap_mu_beamformer,
  &hf_ieee80211_he_phy_cap_beamformee_sts_lte_80mhz,
  &hf_ieee80211_he_phy_cap_beamformee_sts_gt_80mhz,
  NULL
};

static int * const he_phy_b40_to_b55_headers[] = {
  &hf_ieee80211_he_phy_cap_number_of_sounding_dims_lte_80,
  &hf_ieee80211_he_phy_cap_number_of_sounding_dims_gt_80,
  &hf_ieee80211_he_phy_cap_ng_eq_16_su_fb,
  &hf_ieee80211_he_phy_cap_ng_eq_16_mu_fb,
  &hf_ieee80211_he_phy_cap_codebook_size_eq_4_2_fb,
  &hf_ieee80211_he_phy_cap_codebook_size_eq_7_5_fb,
  &hf_ieee80211_he_phy_cap_triggered_su_beamforming_fb,
  &hf_ieee80211_he_phy_cap_triggered_mu_beamforming_fb,
  &hf_ieee80211_he_phy_cap_triggered_cqi_fb,
  &hf_ieee80211_he_phy_cap_partial_bw_extended_range,
  &hf_ieee80211_he_phy_cap_partial_bw_dl_mu_mimo,
  &hf_ieee80211_he_phy_cap_ppe_threshold_present,
  NULL
};

static int * const he_phy_b56_to_b71_headers[] = {
  &hf_ieee80211_he_phy_cap_psr_based_sr_support,
  &hf_ieee80211_he_phy_cap_power_boost_factor_ar_support,
  &hf_ieee80211_he_phy_cap_he_su_ppdu_etc_gi,
  &hf_ieee80211_he_phy_cap_max_nc,
  &hf_ieee80211_he_phy_cap_stbc_tx_gt_80_mhz,
  &hf_ieee80211_he_phy_cap_stbc_rx_gt_80_mhz,
  &hf_ieee80211_he_phy_cap_he_er_su_ppdu_4xxx_gi,
  &hf_ieee80211_he_phy_cap_20mhz_in_40mhz_24ghz_band,
  &hf_ieee80211_he_phy_cap_20mhz_in_160_80p80_ppdu,
  &hf_ieee80211_he_phy_cap_80mgz_in_160_80p80_ppdu,
  &hf_ieee80211_he_phy_cap_he_er_su_ppdu_1xxx_gi,
  &hf_ieee80211_he_phy_cap_midamble_tx_rx_2x_xxx_ltf,
  &hf_ieee80211_he_phy_cap_dcm_max_ru,
  NULL
};

static int * const he_phy_b72_to_b87_headers[] = {
  &hf_ieee80211_he_phy_cap_longer_than_16_he_sigb_ofdm_symbol_support,
  &hf_ieee80211_he_phy_cap_non_triggered_cqi_feedback,
  &hf_ieee80211_he_phy_cap_tx_1024_qam_242_tone_ru_support,
  &hf_ieee80211_he_phy_cap_rx_1024_qam_242_tone_ru_support,
  &hf_ieee80211_he_phy_cap_rx_full_bw_su_using_he_muppdu_w_compressed_sigb,
  &hf_ieee80211_he_phy_cap_rx_full_bw_su_using_he_muppdu_w_non_compressed_sigb,
  &hf_ieee80211_he_phy_cap_nominal_packet_padding,
  &hf_ieee80211_he_phy_cap_he_mu_ppdu_ru_rx_max,
  &hf_ieee80211_he_phy_cap_b81_b87_reserved,
  NULL
};

static int * const he_mcs_map_80_rx_headers [] = {
  &hf_ieee80211_he_mcs_max_he_mcs_80_rx_1_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80_rx_2_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80_rx_3_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80_rx_4_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80_rx_5_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80_rx_6_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80_rx_7_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80_rx_8_ss,
  NULL
};

static int * const he_mcs_map_80_tx_headers [] = {
  &hf_ieee80211_he_mcs_max_he_mcs_80_tx_1_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80_tx_2_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80_tx_3_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80_tx_4_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80_tx_5_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80_tx_6_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80_tx_7_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80_tx_8_ss,
  NULL
};

static int * const he_mcs_map_80p80_rx_headers [] = {
  &hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_1_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_2_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_3_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_4_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_5_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_6_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_7_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_8_ss,
  NULL
};

static int * const he_mcs_map_80p80_tx_headers [] = {
  &hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_1_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_2_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_3_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_4_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_5_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_6_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_7_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_8_ss,
  NULL
};

static int * const he_mcs_map_160_rx_headers [] = {
  &hf_ieee80211_he_mcs_max_he_mcs_160_rx_1_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_160_rx_2_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_160_rx_3_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_160_rx_4_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_160_rx_5_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_160_rx_6_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_160_rx_7_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_160_rx_8_ss,
  NULL
};

static int * const he_mcs_map_160_tx_headers [] = {
  &hf_ieee80211_he_mcs_max_he_mcs_160_tx_1_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_160_tx_2_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_160_tx_3_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_160_tx_4_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_160_tx_5_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_160_tx_6_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_160_tx_7_ss,
  &hf_ieee80211_he_mcs_max_he_mcs_160_tx_8_ss,
  NULL
};

static const value_string ru_alloc_vals[] = {
  { 0, "242" },
  { 1, "484" },
  { 2, "996" },
  { 3, "2x996" },
  { 0, NULL }
};

static const value_string constellation_vals[] = {
  { 0, "BPSK" },
  { 1, "QPSK" },
  { 2, "16-QAM" },
  { 3, "64-QAM" },
  { 4, "256-QAM" },
  { 5, "1024-QAM" },
  { 6, "Reserved" },
  { 7, "None" },
  { 0, NULL }
};

#define HE_CHANNEL_WIDTH_SET_B2 0x04
#define HE_CHANNEL_WIDTH_SET_B3 0x08

static void
dissect_he_capabilities(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,
  int offset, int len)
{
  int *he_mac_headers[] = {
    &hf_ieee80211_he_htc_he_support,                           /* 0 */
    &hf_ieee80211_he_twt_requester_support,                    /* 1 */
    &hf_ieee80211_he_twt_responder_support,                    /* 2 */
    &hf_ieee80211_he_dynamic_fragmentation_support,            /* 3 */
    &hf_ieee80211_he_max_number_fragmented_msdus,              /* 4 */
    &hf_ieee80211_he_min_fragment_size,                        /* 5 */
    &hf_ieee80211_he_trigger_frame_mac_padding_dur,            /* 6 */
    &hf_ieee80211_he_multi_tid_aggregation_rx_support,         /* 7 */
    &hf_ieee80211_he_he_link_adaptation_support,               /* 8 */
    &hf_ieee80211_he_all_ack_support,                          /* 9 */
    &hf_ieee80211_he_trs_support,                              /* 10 */
    &hf_ieee80211_he_bsr_support,                              /* 11 */
    &hf_ieee80211_he_broadcast_twt_support,                    /* 12 */
    &hf_ieee80211_he_32_bit_ba_bitmap_support,                 /* 13 */
    &hf_ieee80211_he_mu_cascading_support,                     /* 14 */
    &hf_ieee80211_he_ack_enabled_aggregation_support,          /* 15 */
    &hf_ieee80211_he_reserved_b24,                             /* 16 */
    &hf_ieee80211_he_om_control_support,                       /* 17 */
    &hf_ieee80211_he_ofdma_ra_support,                         /* 18 */
    &hf_ieee80211_he_max_a_mpdu_length_exponent_ext,           /* 19 */
    &hf_ieee80211_he_a_msdu_fragmentation_support,             /* 20 */
    &hf_ieee80211_he_flexible_twt_schedule_support,            /* 21 */
    &hf_ieee80211_he_rx_control_frame_to_multibss,             /* 22 */
    &hf_ieee80211_he_bsrp_bqrp_a_mpdu_aggregation,             /* 23 */
    &hf_ieee80211_he_qtp_support,                              /* 24 */
    &hf_ieee80211_he_bqr_support,                              /* 25 */
    &hf_ieee80211_he_psr_responder,                            /* 26 */
    &hf_ieee80211_he_ndp_feedback_report_support,              /* 27 */
    &hf_ieee80211_he_ops_support,                              /* 28 */
    &hf_ieee80211_he_a_msdu_in_a_mpdu_support,                 /* 29 */
    &hf_ieee80211_he_multi_tid_aggregation_tx_support,         /* 30 */
    &hf_ieee80211_he_subchannel_selective_trans_support,       /* 31 */
    &hf_ieee80211_he_2_996_tone_ru_support,                    /* 32 */
    &hf_ieee80211_he_om_control_ul_mu_data_disable_rx_support, /* 33 */
    &hf_ieee80211_he_dynamic_sm_power_save,                    /* 34 */
    &hf_ieee80211_he_punctured_sounding_support,               /* 35 */
    &hf_ieee80211_he_ht_and_vht_trigger_frame_rx_support,      /* 36 */
    NULL
  };
  int * he_phy_channel_width_set_headers[] = {
    &hf_ieee80211_he_40mhz_channel_2_4ghz,
    &hf_ieee80211_he_40_and_80_mhz_5ghz,
    &hf_ieee80211_he_160_mhz_5ghz,
    &hf_ieee80211_he_160_80_plus_80_mhz_5ghz,
    &hf_ieee80211_he_242_tone_rus_in_2_4ghz,
    &hf_ieee80211_he_242_tone_rus_in_5ghz,
    &hf_ieee80211_he_chan_width_reserved,
    NULL
  };

  uint64_t he_mac_caps = tvb_get_letoh40(tvb, offset);
  uint8_t phy_channel_width_set = 0;
  proto_tree *phy_cap_tree = NULL;
  unsigned he_mcs_and_nss_len = 4;
  proto_tree *sup_he_mcs_and_nss_tree = NULL;
  proto_tree *rx_tx_he_mcs_map_80 = NULL;
  proto_tree *rx_tx_he_mcs_map_160 = NULL;
  proto_tree *rx_tx_he_mcs_map_80_80 = NULL;

  /* Is this 2.4GHz or 5GHz? */
  if (pinfo->pseudo_header->ieee_802_11.has_frequency) {
    if (IS_2_4_GHZ(pinfo->pseudo_header->ieee_802_11.frequency)) {
        he_phy_channel_width_set_headers[1] = &hf_ieee80211_he_24ghz_b1_reserved;
        he_phy_channel_width_set_headers[2] = &hf_ieee80211_he_24ghz_b2_reserved;
        he_phy_channel_width_set_headers[3] = &hf_ieee80211_he_24ghz_b3_reserved;
        he_phy_channel_width_set_headers[5] = &hf_ieee80211_he_24ghz_b5_reserved;
    } else {
        he_phy_channel_width_set_headers[0] = &hf_ieee80211_he_5ghz_b0_reserved;
        he_phy_channel_width_set_headers[4] = &hf_ieee80211_he_5ghz_b4_reserved;
    }
  }

  /* Change some header fields depending on HE_HTC_HE_SUPPORT and FRAGMENTATION */
  if (!(he_mac_caps & HE_HTC_HE_SUPPORT)) {
    he_mac_headers[8]  = &hf_ieee80211_he_reserved_bits_15_16;
    he_mac_headers[10] = &hf_ieee80211_he_reserved_bit_18;
    he_mac_headers[11] = &hf_ieee80211_he_reserved_bit_19;
    he_mac_headers[17] = &hf_ieee80211_he_reserved_bit_25;
    he_mac_headers[25] = &hf_ieee80211_he_reserved_bit_34;
  }
  if (!(he_mac_caps & HE_DYNAMIC_FRAGMENTATION_SUPPORT)) {
    he_mac_headers[4]  = &hf_ieee80211_he_reserved_bits_5_7;
    he_mac_headers[5]  = &hf_ieee80211_he_reserved_bits_8_9;
    he_mac_headers[20] = &hf_ieee80211_he_reserved_bit_29;
  }

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_he_mac_capabilities,
                        ett_he_mac_capabilities, he_mac_headers,
                        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 6;

  /* Get and isolate the phy channel width set */
  phy_channel_width_set = tvb_get_uint8(tvb, offset) >> 1;
  /* Save this info so we can refer to it later. It might need to be global */
  p_add_proto_data(wmem_file_scope(), pinfo, proto_wlan, HE_CHANNEL_WIDTH_KEY,
                   GINT_TO_POINTER(phy_channel_width_set | (1<<31)));

  phy_cap_tree = proto_tree_add_subtree(tree, tvb, offset, 11, ett_he_phy_capabilities,
                        NULL,
                        "HE PHY Capabilities Information");

  proto_tree_add_bitmask_with_flags(phy_cap_tree, tvb, offset,
                        hf_ieee80211_he_phy_reserved_b0, ett_he_phy_cap_first_byte,
                        he_phy_first_byte_headers, ENC_NA, BMT_NO_APPEND);
  proto_tree_add_bitmask_with_flags(phy_cap_tree, tvb, offset,
                        hf_ieee80211_he_phy_chan_width_set, ett_he_phy_cap_chan_width_set,
                        he_phy_channel_width_set_headers, ENC_NA, BMT_NO_APPEND);
  offset++;
  proto_tree_add_bitmask_with_flags(phy_cap_tree, tvb, offset,
                        hf_ieee80211_he_phy_b8_to_b23, ett_he_phy_cap_b8_to_b23,
                        he_phy_b8_to_b23_headers, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;
  proto_tree_add_bitmask_with_flags(phy_cap_tree, tvb, offset,
                        hf_ieee80211_he_phy_b24_to_b39, ett_he_phy_cap_b24_to_b39,
                        he_phy_b24_to_b39_headers, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;
  proto_tree_add_bitmask_with_flags(phy_cap_tree, tvb, offset,
                        hf_ieee80211_he_phy_b40_to_b55, ett_he_phy_cap_b40_to_b55,
                        he_phy_b40_to_b55_headers, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;
  proto_tree_add_bitmask_with_flags(phy_cap_tree, tvb, offset,
                        hf_ieee80211_he_phy_b56_to_b71, ett_he_phy_cap_b56_to_b71,
                        he_phy_b56_to_b71_headers, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;
  proto_tree_add_bitmask_with_flags(phy_cap_tree, tvb, offset,
                        hf_ieee80211_he_phy_b72_to_b87, ett_he_phy_cap_b72_to_b87,
                        he_phy_b72_to_b87_headers, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;

  if (tvb_reported_length_remaining(tvb, offset) < 2) {
    expert_add_info_format(pinfo, phy_cap_tree, &ei_ieee80211_tag_length,
                           "Insufficient bytes for Phy Capabilities "
                           "Rx and Tx Maps 80MHz!");
    return;
  }

  /* Need the length first */
  if (phy_channel_width_set & HE_CHANNEL_WIDTH_SET_B2)
    he_mcs_and_nss_len += 4;

  if (phy_channel_width_set & HE_CHANNEL_WIDTH_SET_B3)
    he_mcs_and_nss_len += 4;

  sup_he_mcs_and_nss_tree = proto_tree_add_subtree(tree, tvb, offset,
                        he_mcs_and_nss_len, ett_he_mcs_and_nss_set, NULL,
                        "Supported HE-MCS and NSS Set");
  rx_tx_he_mcs_map_80 = proto_tree_add_subtree(sup_he_mcs_and_nss_tree, tvb,
                        offset, 4, ett_he_rx_tx_he_mcs_map_lte_80, NULL,
                        "Rx and Tx MCS Maps <= 80 MHz");
  proto_tree_add_bitmask_with_flags(rx_tx_he_mcs_map_80, tvb, offset,
                        hf_ieee80211_he_rx_he_mcs_map_lte_80,
                        ett_he_rx_mcs_map_lte_80, he_mcs_map_80_rx_headers,
                        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;

  if (tvb_reported_length_remaining(tvb, offset) < 2) {
    expert_add_info_format(pinfo, phy_cap_tree, &ei_ieee80211_tag_length,
                           "Insufficient bytes for Phy Capabilities "
                           "Tx Maps 80MHz!");
    return;
  }

  proto_tree_add_bitmask_with_flags(rx_tx_he_mcs_map_80, tvb, offset,
                        hf_ieee80211_he_tx_he_mcs_map_lte_80,
                        ett_he_tx_mcs_map_lte_80, he_mcs_map_80_tx_headers,
                        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;

  if (phy_channel_width_set & HE_CHANNEL_WIDTH_SET_B2) {
    if (tvb_reported_length_remaining(tvb, offset) < 2) {
      expert_add_info_format(pinfo, phy_cap_tree, &ei_ieee80211_tag_length,
                             "Insufficient bytes for Phy Capabilities "
                             "Rx and Tx MCS Maps 160MHz!");
      return;
    }
    rx_tx_he_mcs_map_160 = proto_tree_add_subtree(sup_he_mcs_and_nss_tree,
                        tvb, offset, 4, ett_he_rx_tx_he_mcs_map_160, NULL,
                        "Rx and Tx MCS Maps 160 MHz");
    proto_tree_add_bitmask_with_flags(rx_tx_he_mcs_map_160, tvb, offset,
                        hf_ieee80211_he_rx_he_mcs_map_160,
                        ett_he_rx_mcs_map_160, he_mcs_map_160_rx_headers,
                        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 2;

    if (tvb_reported_length_remaining(tvb, offset) < 2) {
      expert_add_info_format(pinfo, phy_cap_tree, &ei_ieee80211_tag_length,
                             "Insufficient bytes for Phy Capabilities "
                             "Tx MCS Maps 160MHz!");
      return;
    }

    proto_tree_add_bitmask_with_flags(rx_tx_he_mcs_map_160, tvb, offset,
                        hf_ieee80211_he_tx_he_mcs_map_160,
                        ett_he_tx_mcs_map_160, he_mcs_map_160_tx_headers,
                        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 2;
  }

  if (phy_channel_width_set & HE_CHANNEL_WIDTH_SET_B3) {
    if (tvb_reported_length_remaining(tvb, offset) < 2) {
      expert_add_info_format(pinfo, phy_cap_tree, &ei_ieee80211_tag_length,
                             "Insufficient bytes for Phy Capabilities "
                             "Rx and Tx MCS Maps 80+80 MHz!");
      return;
    }

    rx_tx_he_mcs_map_80_80 = proto_tree_add_subtree(sup_he_mcs_and_nss_tree,
                        tvb, offset, 4, ett_he_rx_tx_he_mcs_map_80_80, NULL,
                        "Rx and Tx MCS Maps 80+80 MHz");
    proto_tree_add_bitmask_with_flags(rx_tx_he_mcs_map_80_80, tvb, offset,
                        hf_ieee80211_he_rx_he_mcs_map_80_80,
                        ett_he_rx_mcs_map_80_80, he_mcs_map_80p80_rx_headers,
                        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 2;
    proto_tree_add_bitmask_with_flags(rx_tx_he_mcs_map_80_80, tvb, offset,
                        hf_ieee80211_he_tx_he_mcs_map_80_80,
                        ett_he_tx_mcs_map_80_80, he_mcs_map_80p80_tx_headers,
                        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 2;
  }

  if (offset < len) {
    uint8_t ppe_thresholds_field = tvb_get_uint8(tvb, offset);
    uint8_t nss_count = ppe_thresholds_field & 0x07, nss_index = 0;
    uint8_t ru_index_bitmask = (ppe_thresholds_field >> 3) & 0x0F;
    proto_tree *ppe_tree = NULL;
    int i = 0;
    int bit_offset = 7;  /* How many bits we are into the bytes */

    ppe_tree = proto_tree_add_subtree(tree, tvb, offset, len - offset + 1,
                        ett_he_ppe_threshold, NULL,
                        "PPE Thresholds");
    proto_tree_add_item(ppe_tree, hf_ieee80211_he_ppe_thresholds_nss, tvb, offset,
                        1, ENC_NA);
    proto_tree_add_item(ppe_tree, hf_ieee80211_he_ppe_thresholds_ru_index_bitmask, tvb,
                        offset, 1, ENC_NA);

    /*
     * Now, for each of the nss values, add a sub-tree with its thresholds.
     * The actual count is one more than the number in the first three bits.
     */
    while (nss_index < nss_count + 1) {
      int start_offset = 0;
      proto_tree *nss_tree = NULL;
      proto_item *nssti = NULL;
      uint8_t l_ru_bitmask = ru_index_bitmask;

      nss_tree = proto_tree_add_subtree_format(ppe_tree, tvb, offset, -1,
                        ett_he_ppe_nss, &nssti, "NSS %d", nss_index);
      start_offset = offset;

      for (i = 0; i < 4; i++) {
        if (l_ru_bitmask & 0x01) {
          int bits_avail = 8 - bit_offset, bits_needed = 6 - bits_avail;
          uint8_t the_bits = 0;
          int ru_start_offset = offset;
          proto_tree *ru_alloc_tree = NULL;
          proto_item *rualti = NULL;

          ru_alloc_tree = proto_tree_add_subtree_format(nss_tree, tvb, offset,
                                        -1, ett_he_ppe_ru_alloc, &rualti,
                                        "RU allocation: %s",
                                        val_to_str_const(i, ru_alloc_vals, "Unk"));

          /*
           * Assemble the bits we require ... we need 6, or 2x3
           */
          if (bits_avail >= 6) { /* We can use the current byte */
            the_bits = (tvb_get_uint8(tvb, offset) >> bit_offset) & 0x3F;
          } else { /* We need two adjacent bytes */
            the_bits = (tvb_get_uint8(tvb, offset) >> bit_offset);
            offset++;
            the_bits = the_bits |
                        ((tvb_get_uint8(tvb, offset) &
                                ((1 << bits_needed) - 1)) << bits_avail);
          }
          /*
           * Now we have two three bit fields, use them.
           */
          proto_tree_add_uint(ru_alloc_tree, hf_ieee80211_he_ppe_ppet16, tvb, ru_start_offset,
                              offset - ru_start_offset + 1, the_bits & 0x07);
          proto_tree_add_uint(ru_alloc_tree, hf_ieee80211_he_ppe_ppet8, tvb, ru_start_offset,
                              offset - ru_start_offset + 1, the_bits >> 3);

          bit_offset = (bit_offset + 6) % 8;
          proto_item_set_len(rualti, offset - ru_start_offset + 1);
        }
        l_ru_bitmask = l_ru_bitmask >> 1;
      }


      proto_item_set_len(nssti, offset - start_offset);
      nss_index++;
    }
  }

  /* Add an Expert Info about extra bytes ... */

}

static int * const he_operation_headers[] = {
  &hf_ieee80211_he_operation_default_pe_duration,
  &hf_ieee80211_he_operation_twt_required,
  &hf_ieee80211_he_operation_txop_duration_rts_threshold,
  &hf_ieee80211_he_operation_vht_operation_information_present,
  &hf_ieee80211_he_operation_co_hosted_bss,
  &hf_ieee80211_he_operation_er_su_disable,
  &hf_ieee80211_he_operation_6ghz_operation_information_present,
  &hf_ieee80211_he_operation_reserved_b16_b23,
  NULL
};

static int * const he_bss_color_info_headers[] = {
  &hf_ieee80211_he_bss_color_info_bss_color,
  &hf_ieee80211_he_bss_color_partial_bss_color,
  &hf_ieee80211_he_bss_color_bss_color_disabled,
  NULL
};

static int * const he_operation_6ghz_control[] = {
  &hf_ieee80211_he_operation_6ghz_control_channel_width,
  &hf_ieee80211_he_operation_6ghz_control_duplicate_beacon,
  &hf_ieee80211_he_operation_6ghz_control_regulatory_info,
  &hf_ieee80211_he_operation_6ghz_control_reserved,
  NULL
};

static const value_string he_mcs_map_vals[] = {
  { 0, "Support for HE-MCS 0-7" },
  { 1, "Support for HE-MCS 0-9" },
  { 2, "Support for HE-MCS 0-11" },
  { 3, "Not supported for HE PPDUs" },
  { 0, NULL }
};

static int * const he_basic_he_mcs_header[] = {
  &hf_ieee80211_he_oper_max_he_mcs_for_1_ss,
  &hf_ieee80211_he_oper_max_he_mcs_for_2_ss,
  &hf_ieee80211_he_oper_max_he_mcs_for_3_ss,
  &hf_ieee80211_he_oper_max_he_mcs_for_4_ss,
  &hf_ieee80211_he_oper_max_he_mcs_for_5_ss,
  &hf_ieee80211_he_oper_max_he_mcs_for_6_ss,
  &hf_ieee80211_he_oper_max_he_mcs_for_7_ss,
  &hf_ieee80211_he_oper_max_he_mcs_for_8_ss,
  NULL
};

#define VHT_OPERATION_INFORMATION_PRESENT    0x004000
#define CO_HOSTED_BSS                        0x008000
#define SIXGHZ_OPERATION_INFORMATION_PRESENT 0x020000

static const value_string channel_width_vals[] = {
  { 0, "20 MHz or 40 MHz BSS Bandwidth" },
  { 1, "80 MHz, 160 MHz or 80+80 MHz BSS Bandwidth" },
  { 2, "160 MHz BSS Bandwidth (deprecated)" },
  { 3, "Non-contiguous 80+80 MHz BSS Bandwidth (deprecated)" },
  { 0, NULL }
};

static void
dissect_he_operation(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,
  int offset, int len _U_)
{
    uint32_t op_params = tvb_get_letoh24(tvb, offset);

    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                        hf_ieee80211_he_operation_parameter, ett_he_operation_params,
                        he_operation_headers, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 3;

    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                        hf_ieee80211_he_bss_color_information, ett_he_bss_color_information,
                        he_bss_color_info_headers, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 1;

    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                        hf_ieee80211_he_operation_basic_mcs, ett_he_oper_basic_mcs,
                        he_basic_he_mcs_header, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 2;

    if (op_params & VHT_OPERATION_INFORMATION_PRESENT) {
      proto_tree *vht_op_info = NULL;

      vht_op_info = proto_tree_add_subtree(tree, tvb, offset, 3,
                        ett_he_operation_vht_op_info, NULL,
                        "VHT Operation Information");
      proto_tree_add_item(vht_op_info, hf_ieee80211_he_operation_channel_width, tvb,
                        offset, 1, ENC_NA);
      offset++;

      proto_tree_add_item(vht_op_info, hf_ieee80211_he_operation_channel_center_freq_0,
                        tvb, offset, 1, ENC_NA);
      offset++;

      proto_tree_add_item(vht_op_info, hf_ieee80211_he_operation_channel_center_freq_1,
                        tvb, offset, 1, ENC_NA);
      offset++;
    }

    if (op_params & CO_HOSTED_BSS) {
      proto_tree_add_item(tree, hf_ieee80211_he_operation_max_co_hosted_bssid_indicator,
                        tvb, offset, 1, ENC_NA);
      offset++;
    }

    if (op_params & SIXGHZ_OPERATION_INFORMATION_PRESENT) {
      proto_tree *sixghz_tree = NULL;

      sixghz_tree = proto_tree_add_subtree(tree, tvb, offset, 5,
                        ett_he_operation_6ghz, NULL,
                        "6 GHz Operation Information");
      proto_tree_add_item(sixghz_tree, hf_ieee80211_he_operation_6ghz_primary_channel, tvb,
                          offset, 1, ENC_NA);
      offset++;

      proto_tree_add_bitmask_with_flags(sixghz_tree, tvb, offset,
                          hf_ieee80211_he_operation_6ghz_control, ett_he_operation_6ghz_control,
                          he_operation_6ghz_control, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
      offset++;

      proto_tree_add_item(sixghz_tree, hf_ieee80211_he_operation_6ghz_channel_center_freq_0,
                          tvb, offset, 1, ENC_NA);
      offset++;

      proto_tree_add_item(sixghz_tree, hf_ieee80211_he_operation_6ghz_channel_center_freq_1,
                          tvb, offset, 1, ENC_NA);
      offset++;

      proto_tree_add_item(sixghz_tree, hf_ieee80211_he_operation_6ghz_minimum_rate,
                          tvb, offset, 1, ENC_NA);
      offset++;
    }
}

static int * const uora_headers[] = {
  &hf_ieee80211_he_uora_eocwmin,
  &hf_ieee80211_he_uora_owcwmax,
  &hf_ieee80211_he_uora_reserved,
  NULL
};

static void
dissect_uora_parameter_set(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,
  int offset)
{
  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                        hf_ieee80211_he_uora_field, ett_he_uora_tree, uora_headers,
                        ENC_NA, BMT_NO_APPEND);
  offset++;
}

static int * const muac_aci_aifsn_headers[] = {
  &hf_ieee80211_he_muac_aifsn,
  &hf_ieee80211_he_muac_acm,
  &hf_ieee80211_he_muac_aci,
  &hf_ieee80211_he_muac_reserved,
  NULL
};

static int
dissect_muac_param_record(tvbuff_t *tvb, proto_tree *tree, int offset)
{
  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                        hf_ieee80211_he_muac_aci_aifsn, ett_he_aic_aifsn,
                        muac_aci_aifsn_headers, ENC_NA, BMT_NO_APPEND);
  offset++;

  proto_tree_add_item(tree, hf_ieee80211_he_muac_ecwmin_ecwmax, tvb, offset, 1, ENC_NA);
  offset++;

  proto_tree_add_item(tree, hf_ieee80211_he_mu_edca_timer, tvb, offset, 1, ENC_NA);
  offset++;

  return offset;
}

static int
dissect_mu_edca_parameter_set(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,
  int offset, int len _U_)
{
  proto_tree *param_tree = NULL;

  /* Is this from an AP or an STA? */
  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ff_qos_info_ap,
                                    ett_ff_qos_info, ieee80211_ff_qos_info_ap_fields,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset++;

  param_tree = proto_tree_add_subtree(tree, tvb, offset, 3, ett_he_mu_edca_param,
                        NULL, "MUAC_BE Parameter Record");
  offset = dissect_muac_param_record(tvb, param_tree, offset);

  param_tree = proto_tree_add_subtree(tree, tvb, offset, 3, ett_he_mu_edca_param,
                        NULL, "MUAC_BK Parameter Record");
  offset = dissect_muac_param_record(tvb, param_tree, offset);

  param_tree = proto_tree_add_subtree(tree, tvb, offset, 3, ett_he_mu_edca_param,
                        NULL, "MUAC_VI Parameter Record");
  offset = dissect_muac_param_record(tvb, param_tree, offset);

  param_tree = proto_tree_add_subtree(tree, tvb, offset, 3, ett_he_mu_edca_param,
                        NULL, "MUAC_VO Parameter Record");
  offset = dissect_muac_param_record(tvb, param_tree, offset);

  return offset;
}

#define SRP_DISALLOWED                     0x01
#define NON_SRG_OBSS_PD_SR_DISALLOWED      0x02
#define NON_SRG_OFFSET_PRESENT             0x04
#define SRG_INFORMATION_PRESENT            0x08
#define HESIGA_SPATIAL_REUSE_VAL15_ALLOWED 0x10

static int * const sr_control_field_headers[] = {
  &hf_ieee80211_he_srp_disallowed,
  &hf_ieee80211_he_non_srg_obss_pd_sr_disallowed,
  &hf_ieee80211_he_non_srg_offset_present,
  &hf_ieee80211_he_srg_information_present,
  &hf_ieee80211_he_hesiga_spatial_reuse_value15_allowed,
  &hf_ieee80211_he_sr_control_reserved,
  NULL
};

static int
dissect_spatial_reuse_parameter_set(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, int len _U_)
{
  uint8_t sr_control = tvb_get_uint8(tvb, offset);

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_he_spatial_reuse_sr_control,
                                    ett_he_spatial_reuse_control,
                                    sr_control_field_headers,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset++;

  if (sr_control & NON_SRG_OFFSET_PRESENT) {
    proto_tree_add_item(tree, hf_ieee80211_he_spatial_non_srg_obss_pd_max_offset,
                        tvb, offset, 1, ENC_NA);
    offset++;
  }

  if (sr_control & SRG_INFORMATION_PRESENT) {
    proto_tree_add_item(tree, hf_ieee80211_he_spatial_srg_obss_pd_min_offset, tvb,
                        offset, 1, ENC_NA);
    offset++;
    proto_tree_add_item(tree, hf_ieee80211_he_spatial_srg_obss_pd_max_offset, tvb,
                        offset, 1, ENC_NA);
    offset++;
    proto_tree_add_item(tree, hf_ieee80211_he_spatial_srg_bss_color_bitmap, tvb,
                        offset, 8, ENC_NA);
    offset += 8;
    proto_tree_add_item(tree, hf_ieee80211_he_spatial_srg_partial_bssid_bitmap,
                        tvb, offset, 8, ENC_NA);
    offset += 8;
  }

  return offset;
}

static void
dissect_ndp_feedback_report_set(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, int len _U_)
{
  proto_tree_add_item(tree, hf_ieee80211_he_resource_request_buffer_thresh, tvb, offset,
                        1, ENC_NA);
}

static int * const bss_new_color_headers[] = {
  &hf_ieee80211_he_new_bss_color_info_color,
  &hf_ieee80211_he_new_bss_color_info_reserved,
  NULL
};

static void
dissect_bss_color_change(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, int len _U_)
{
  proto_tree_add_item(tree, hf_ieee80211_he_bss_color_change_switch_countdown, tvb, offset,
                        1, ENC_NA);
  offset++;

  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                hf_ieee80211_he_bss_color_change_new_color_info,
                                ett_he_bss_new_color_info, bss_new_color_headers,
                                ENC_NA, BMT_NO_APPEND);
}

static int * const ess_info_field_headers[] = {
  &hf_ieee80211_he_ess_report_planned_ess,
  &hf_ieee80211_he_ess_report_edge_of_ess,
  NULL
};

static void
dissect_ess_report(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, int len _U_)
{
  uint8_t bss_trans_thresh = tvb_get_uint8(tvb, offset) >> 2;


  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_he_ess_report_info_field,
                                    ett_he_ess_report_info_field,
                                    ess_info_field_headers,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  if (bss_trans_thresh == 63)
    proto_tree_add_int_format(tree, hf_ieee80211_he_ess_report_recommend_transition_thresh,
                        tvb, offset, 1, bss_trans_thresh,
                        "Recommended BSS Transition Threshold: %d (No recommendation)",
                        bss_trans_thresh);
  else
    proto_tree_add_int_format(tree, hf_ieee80211_he_ess_report_recommend_transition_thresh, tvb,
                        offset, 1, bss_trans_thresh,
                        "Recommended BSS Transition Threshold: %d (%ddBm)",
                        bss_trans_thresh, -100 + bss_trans_thresh);
}

static void
dissect_ops(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, int len _U_)
{
  proto_tree_add_item(tree, hf_ieee80211_he_ops_duration, tvb, offset, 1,
                      ENC_NA);
}

static void
dissect_max_channel_switch_time(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, int len _U_)
{
  proto_tree_add_item(tree, hf_ieee80211_max_channel_switch_time, tvb, offset,
                      3, ENC_LITTLE_ENDIAN);
}

static void
dissect_oci(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, int len _U_)
{
  proto_tree_add_item(tree, hf_ieee80211_oci_operating_class, tvb, offset,
                      1, ENC_NA);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_oci_primary_channel_number, tvb,
                      offset, 1, ENC_NA);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_oci_frequency_segment_1, tvb,
                      offset, 1, ENC_NA);
  offset += 1;

  /* Does it have the OCT fields? */
  if (len > 3) {
    if (len != 6) {
      expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length,
                             "OCI element with OCT field length must be 6 bytes");
    }

    proto_tree_add_item(tree, hf_ieee80211_oci_oct_operating_class, tvb,
                        offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(tree, hf_ieee80211_oci_oct_primary_channel_number, tvb,
                        offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(tree, hf_ieee80211_oci_oct_frequency_segment_1, tvb,
                        offset, 1, ENC_NA);
  }
}

static void
dissect_multiple_bssid_configuration(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, int len _U_)
{

  proto_tree_add_item(tree, hf_ieee80211_multiple_bssid_configuration_bssid_count, tvb, offset, 1, ENC_NA);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_multiple_bssid_configuration_full_set_rx_periodicity, tvb, offset, 1, ENC_NA);
  /*offset += 1;*/

}

static void
dissect_non_inheritance(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, int len _U_)
{
  proto_tree *element_id_list = NULL;
  proto_tree *element_id_ext_list = NULL;

  uint8_t element_id_list_length = tvb_get_uint8(tvb, offset);

  element_id_list = proto_tree_add_subtree(tree, tvb, offset, element_id_list_length + 1,
                                           ett_non_inheritance_element_id_list,
                                           NULL, "Element ID List");

  proto_tree_add_item(element_id_list, hf_ieee80211_non_inheritance_element_id_list_length,
    tvb, offset, 1, ENC_NA);
  offset += 1;

  while (element_id_list_length > 0) {
    proto_tree_add_item(element_id_list, hf_ieee80211_non_inheritance_element_id_list_element_id,
      tvb, offset, 1, ENC_NA);
    element_id_list_length--;
    offset++;
  }

  uint8_t element_id_ext_list_length = tvb_get_uint8(tvb, offset);

  element_id_ext_list = proto_tree_add_subtree(tree, tvb, offset, element_id_ext_list_length + 1,
                                           ett_non_inheritance_element_id_ext_list,
                                           NULL, "Element ID Extension List");

  proto_tree_add_item(element_id_ext_list, hf_ieee80211_non_inheritance_element_id_ext_list_length,
    tvb, offset, 1, ENC_NA);
  offset += 1;

  while (element_id_ext_list_length > 0) {
    proto_tree_add_item(element_id_ext_list, hf_ieee80211_non_inheritance_element_id_ext_list_element_id_ext,
      tvb, offset, 1, ENC_NA);
    element_id_ext_list_length--;
    offset++;
  }
}

static void
dissect_known_bssid(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, int len)
{

  proto_tree_add_item(tree, hf_ieee80211_known_bssid_bitmap, tvb, offset, len, ENC_NA);

}

static void
dissect_short_ssid(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, int len _U_)
{

  while(len > 0){

    proto_tree_add_item(tree, hf_ieee80211_short_ssid, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    offset += 4;
    len -=4;
  }
}

static int
dissect_password_identifier(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, int len _U_)
{
  proto_tree_add_item(tree, hf_ieee80211_sae_password_identifier, tvb, offset,
                      len, ENC_NA|ENC_ASCII);
  offset += len;

  return offset;
}

#define SCS_ADD    0
#define SCS_REMOVE 1
#define SCS_CHANGE 2

static const range_string scs_request_type_rvals[] = {
  { SCS_ADD,    SCS_ADD,      "Add" },
  { SCS_REMOVE, SCS_REMOVE,   "Remove" },
  { SCS_CHANGE, SCS_CHANGE,   "Change" },
  { 3,          255, "Reserved" },
  { 0,          0, NULL }
};

static int * const user_prio_bitmap_headers[] = {
  &hf_ieee80211_user_prio_bitmap_bit0,
  &hf_ieee80211_user_prio_bitmap_bit1,
  &hf_ieee80211_user_prio_bitmap_bit2,
  &hf_ieee80211_user_prio_bitmap_bit3,
  &hf_ieee80211_user_prio_bitmap_bit4,
  &hf_ieee80211_user_prio_bitmap_bit5,
  &hf_ieee80211_user_prio_bitmap_bit6,
  &hf_ieee80211_user_prio_bitmap_bit7,
  NULL
};

static void
dissect_mscs_descriptor_element(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, int len _U_)
{
  uint8_t request_type = tvb_get_uint8(tvb, offset);

  proto_tree_add_item(tree, hf_ieee80211_mscs_descriptor_type, tvb, offset, 1,
                      ENC_NA);
  offset += 1;

  if (request_type == SCS_REMOVE) {
    proto_tree_add_item(tree, hf_ieee80211_mscs_user_prio_control_reserved,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  } else {
    proto_tree *user_prio_tree = NULL;

    user_prio_tree = proto_tree_add_subtree(tree, tvb, offset, 2,
                                            ett_mscs_user_prio, NULL,
                                            "User Priority Control");
    proto_tree_add_bitmask_with_flags(user_prio_tree, tvb, offset,
                                      hf_ieee80211_user_prio_bitmap,
                                      ett_ieee80211_user_prio_bitmap,
                                      user_prio_bitmap_headers,
                                      ENC_NA, BMT_NO_APPEND);
    offset += 1;

    proto_tree_add_item(user_prio_tree, hf_ieee80211_user_prio_limit, tvb,
                        offset, 1, ENC_NA);
    proto_tree_add_item(user_prio_tree, hf_ieee80211_user_prio_reserved, tvb,
                        offset, 1, ENC_NA);
    offset += 1;
  }

  if (request_type == SCS_REMOVE) {
    proto_tree_add_item(tree, hf_ieee80211_stream_timeout_reserved, tvb,
                        offset, 4, ENC_LITTLE_ENDIAN);
  } else {
    proto_tree_add_item(tree, hf_ieee80211_stream_timeout, tvb,
                        offset, 4, ENC_LITTLE_ENDIAN);
  }
  offset += 4;

  /*
   * If there is nothing more in the TVB we are done.
   */
  if (tvb_reported_length_remaining(tvb, offset) == 0)
    return;

  /*
   * There may be tclas elements following and optional MSCS elements.
   * A TCLAS Mask element will start with 0xFF <len> 0x89
   */
  while (tvb_reported_length_remaining(tvb, offset) &&
         tvb_get_uint8(tvb, offset) == 0xFF) {
    offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
  }

  /*
   * Any optional MSCS elements come next. Should be 1 byte ID, 1 byte len
   * and len bytes.
   */
  if (offset < len) {
    uint8_t sub_elt_len;

    proto_tree_add_item(tree, hf_ieee80211_mscs_subelement_id, tvb, offset, 1,
                        ENC_NA);
    offset += 1;

    sub_elt_len = tvb_get_uint8(tvb, offset);
    proto_tree_add_item(tree, hf_ieee80211_mscs_subelement_len, tvb, offset, 1,
                        ENC_NA);
    offset += 1;

    proto_tree_add_item(tree, hf_ieee80211_mscs_subelement_data, tvb, offset,
                        sub_elt_len, ENC_NA);
  }
}

static void
dissect_tclas_mask_element(tvbuff_t *tvb, packet_info *pinfo _U_,
                           proto_tree *tree, int offset, int len _U_)
{
  ieee80211_frame_classifier(tvb, pinfo, tree, offset, len);
}

static int * const intra_access_prio_headers[] = {
  &hf_ieee80211_intra_access_prio_user_prio,
  &hf_ieee80211_intra_access_prio_alt_queue,
  &hf_ieee80211_intra_access_prio_drop_elig,
  &hf_ieee80211_intra_access_prio_reserved,
  NULL
};

static int
ieee80211_tag_intra_access_cat_prio(tvbuff_t *tvb, packet_info *pinfo,
                                    proto_tree *tree, void *data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t *)data;
  int offset = 0;

  if (tag_len != 1) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be 1", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_intra_access_prio,
                                    ett_ieee80211_intra_access_prio,
                                    intra_access_prio_headers,
                                    ENC_NA, BMT_NO_APPEND);

  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_scs_descriptor(tvbuff_t *tvb, packet_info *pinfo,
                             proto_tree *tree, void *data _U_)
{
  int offset = 0;
  uint8_t request_type = tvb_get_uint8(tvb, offset + 1);

  proto_tree_add_item(tree, hf_ieee80211_scs_descriptor_scsid, tvb, offset, 1,
                      ENC_NA);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_scs_descriptor_type, tvb, offset, 1,
                      ENC_NA);
  offset += 1;

  if (request_type == SCS_ADD || request_type == SCS_CHANGE) {
    /* There will only be one intra access priority */
    offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);

    /* There will be at least one tclass element ... */
    while ((tvb_captured_length_remaining(tvb, offset) > 0) &&
           tvb_get_uint8(tvb, offset) == TAG_TCLAS) {
      offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
    }
    /* There could be a TCLAS PROCESS element ... */
    if ((tvb_captured_length_remaining(tvb, offset) > 0) &&
        tvb_get_uint8(tvb, offset) == TAG_TCLAS_PROCESS) {
      add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
    }

    /* There could be one QoS Char element ... */
    if ((tvb_captured_length_remaining(tvb, offset) > 0) &&
        tvb_get_uint8(tvb, offset) == TAG_ELEMENT_ID_EXTENSION &&
        tvb_get_uint8(tvb, offset+2) == ETAG_QOS_CHARACTERISTICS) {
      offset += add_tagged_field(pinfo, tree, tvb, offset, 0, NULL, 0, NULL);
    }

    /* There can be zero or one TSPEC elements */
    if (tvb_captured_length_remaining(tvb, offset) > 0) {
      static const uint8_t ids[] = { TAG_TSPEC };
      if(add_tagged_field(pinfo, tree, tvb, offset, 0, ids, G_N_ELEMENTS(ids), NULL) == 0){
        /* Add an expert info */
      }
    }

  }

  /* There could be Optional subelements here too ... */

  return tvb_captured_length(tvb);
}

/*
 * Just a list of finite cyclic group numbers as 16-bit uints.
 */
static void
dissect_rejected_groups(tvbuff_t *tvb, packet_info *pinfo _U_,
                         proto_tree *tree, int offset, int len _U_)
{
  while (tvb_reported_length_remaining(tvb, offset)) {
    proto_tree_add_item(tree, hf_ieee80211_rejected_groups_group, tvb, offset,
                        2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }
}

/*
 * Just a string of bytes
 */
static void
dissect_anti_clogging_token(tvbuff_t *tvb, packet_info *pinfo _U_,
                            proto_tree *tree, int offset, int len)
{
  proto_tree_add_item(tree, hf_ieee80211_sae_anti_clogging_token, tvb, offset,
                      len, ENC_NA);
}

/*
 * There will be from 1 to 4 24-bit fields in the order of AC=BK, AC=BE,
 * AC=VI and AC=VO.
 */

static int * const esp_headers[] = {
  &hf_ieee80211_esp_access_category,
  &hf_ieee80211_esp_reserved,
  &hf_ieee80211_esp_data_format,
  &hf_ieee80211_esp_ba_windows_size,
  &hf_ieee80211_esp_est_air_time_frac,
  &hf_ieee80211_esp_data_ppdu_duration_target,
  NULL
};

static const value_string esp_access_category_vals[] = {
  { 0, "AC=BK" },
  { 1, "AC=BE" },
  { 2, "AC=VI" },
  { 3, "AC=VO" },
  { 0, NULL }
};

static const value_string esp_data_format_vals[] = {
  { 0, "No aggregation is expected to be performed" },
  { 1, "A-MSDU aggregation is expected but not A-MPDUs when type is data" },
  { 2, "A-MSDU aggregation is NOT expected but A-MPDUs aggregation is when type is data" },
  { 3, "A-MSDU aggregation is expected and A-MPDU aggregation is when type is data" },
  { 0, NULL }
};

static const value_string esp_ba_window_size_vals[] = {
  { 0, "Block Ack not expected to be used" },
  { 1, "2" },
  { 2, "4" },
  { 3, "6" },
  { 4, "8" },
  { 5, "16" },
  { 6, "32" },
  { 7, "64" },
  { 0, NULL }
};

static int
dissect_estimated_service_params(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, int len)
{
  while (len > 0) {
    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                        hf_ieee80211_estimated_service_params, ett_ieee80211_esp,
                        esp_headers, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 3;
    len -= 3;
  }

  return offset;
}

static int
dissect_future_channel_guidance(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, int len _U_)
{
  proto_tree_add_item(tree, hf_ieee80211_fcg_new_channel_number, tvb, offset,
                        4, ENC_LITTLE_ENDIAN);
  offset += 4;

  if (len - 4 > 0) {
    proto_tree_add_item(tree, hf_ieee80211_fcg_extra_info, tvb, offset, len - 4,
                        ENC_NA);
    offset += len - 4;
  }

  return offset;
}

/* IANA, "Transform Type 4 - Diffie-Hellman Group Transform IDs" */
static const value_string owe_dh_parameter_group_vals[] = {
  { 0, "None" },
  { 1, "768-bit MODP Group" },
  { 2, "1024-bit MODP Group" },
  { 5, "1536-bit MODP Group" },
  { 14, "2048-bit MODP Group"},
  { 15, "3072-bit MODP Group"},
  { 16, "4096-bit MODP Group"},
  { 17, "6144-bit MODP Group"},
  { 18, "8192-bit MODP Group"},
  { 19, "256-bit random ECP group"},
  { 20, "384-bit random ECP group"},
  { 21, "521-bit random ECP group"},
  { 22, "1024-bit MODP Group with 160-bit Prime Order Subgroup"},
  { 23, "2048-bit MODP Group with 224-bit Prime Order Subgroup"},
  { 24, "2048-bit MODP Group with 256-bit Prime Order Subgroup"},
  { 25, "192-bit Random ECP Group"},
  { 26, "224-bit Random ECP Group"},
  { 27, "brainpoolP224r1"},
  { 28, "brainpoolP256r1"},
  { 29, "brainpoolP384r1"},
  { 30, "brainpoolP512r1"},
  { 31, "Curve25519"},
  { 32, "Curve448"},
  { 0, NULL }
};

static int
dissect_owe_dh_parameter(tvbuff_t *tvb, packet_info *pinfo,
  proto_tree *tree, int offset, int len _U_, association_sanity_check_t* sanity_check)
{
  if (len < 2) {
    expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length,
                           "OWE: Diffie-Hellman Parameter must be at least 2 "
                           "octets long");
    return offset + len;
  }

  ieee80211_packet_data_t *packet_data = get_or_create_packet_data(pinfo);
  packet_data->owe_group = tvb_get_uint16(tvb, offset, ENC_LITTLE_ENDIAN);
  if (sanity_check != NULL) {
    sanity_check->owe_group = tvb_get_uint16(tvb, offset, ENC_LITTLE_ENDIAN);
  }

  proto_tree_add_item(tree, hf_ieee80211_owe_dh_parameter_group, tvb, offset,
                        2, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tree, hf_ieee80211_owe_dh_parameter_public_key, tvb, offset + 2,
                        len - 2, ENC_NA);
  offset += len;

  return offset;
}

static int * const ieee80211_twt_ctrl_field[] = {
  &hf_ieee80211_tag_twt_ndp_paging_indicator,
  &hf_ieee80211_tag_twt_responder_pm_mode,
  &hf_ieee80211_tag_twt_neg_type,
  &hf_ieee80211_tag_twt_info_frame_disabled,
  &hf_ieee80211_tag_twt_wake_duration_unit,
  &hf_ieee80211_tag_twt_link_id_bitmap_present,
  &hf_ieee80211_tag_twt_aligned_twt,
  NULL,
};

static int * const ieee80211_twt_req_type_field[] = {
  &hf_ieee80211_tag_twt_req_type_req,
  &hf_ieee80211_tag_twt_req_type_setup_cmd,
  &hf_ieee80211_tag_twt_req_type_trigger,
  &hf_ieee80211_tag_twt_req_type_implicit,
  &hf_ieee80211_tag_twt_req_type_flow_type,
  &hf_ieee80211_tag_twt_req_type_flow_id,
  &hf_ieee80211_tag_twt_req_type_wake_int_exp,
  &hf_ieee80211_tag_twt_req_type_prot,
  NULL,
};

static int * const ieee80211_bcst_twt_req_type_field[] = {
  &hf_ieee80211_tag_twt_req_type_req,
  &hf_ieee80211_tag_twt_req_type_setup_cmd,
  &hf_ieee80211_tag_twt_req_type_trigger,
  &hf_ieee80211_tag_twt_req_type_last_bcst_parm_set,
  &hf_ieee80211_tag_twt_req_type_flow_type,
  &hf_ieee80211_tag_twt_req_type_bcst_twt_recom,
  &hf_ieee80211_tag_twt_req_type_wake_int_exp,
  &hf_ieee80211_tag_twt_req_type_aligned,
  NULL,
};

static int * const ieee80211_twt_ndp_paging_field[] = {
  &hf_ieee80211_tag_twt_ndp_paging_p_id,
  &hf_ieee80211_tag_twt_ndp_max_ndp_paging_period,
  &hf_ieee80211_tag_twt_ndp_partial_tsf_offset,
  &hf_ieee80211_tag_twt_ndp_action,
  &hf_ieee80211_tag_twt_ndp_min_sleep_duration,
  &hf_ieee80211_tag_twt_ndp_reserved,
  NULL
};

static int * const ieee80211_twt_broadcast_info_field[] = {
  &hf_ieee80211_tag_twt_bcast_info_persistence,
  &hf_ieee80211_tag_twt_bcast_info_id,
  &hf_ieee80211_tag_twt_bcast_info_rtwt_sche_info,
  &hf_ieee80211_tag_twt_bcast_info_rtwt_traffic_present,
  NULL
};

static int * const ieee80211_twt_traffic_info_control_field[] = {
  &hf_ieee80211_tag_twt_traffic_info_dl_bitmap_valid,
  &hf_ieee80211_tag_twt_traffic_info_ul_bitmap_valid,
  &hf_ieee80211_tag_twt_traffic_info_reserved,
  NULL
};

static const value_string twt_ndp_action_vals[] = {
  { 0, "Send a PD-Poll or uplink trigger frame" },
  { 1, "Wake up at the time indicated by Min Sleep Duration" },
  { 2, "Wake up to receive the Beacon" },
  { 3, "Wake up to receive the DTIM Beacon" },
  { 4, "Wake up at the time indicated by the sum of the Min Sleep Duration and the ASD" },
  { 5, "Reserved" },
  { 6, "Reserved" },
  { 7, "Reserved" },
  { 0, NULL }
};

static int
ieee80211_tag_twt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len;
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  proto_item *item = NULL;
  bool twt_requester;
  uint8_t setup_command;
  uint8_t ctrl_field;
  uint16_t req_type;
  uint8_t neg_type;
  bool last_bcast = false;

  ctrl_field = tvb_get_uint8(tvb, offset);
  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_tag_twt_control_field,
                                    ett_twt_control_field_tree,
                                    ieee80211_twt_ctrl_field,
                                    ENC_LITTLE_ENDIAN, BMT_NO_FALSE);
  offset += 1;
  neg_type = (ctrl_field & 0xc) >> 2;

  while (!last_bcast) {
    tag_len = tvb_captured_length_remaining(tvb, offset);
    if (tag_len < 2) {
      expert_add_info(pinfo, item ? item : tree,
                      &ei_ieee80211_twt_bcast_info_no_term);
        return tvb_captured_length(tvb);
    }
    req_type = tvb_get_uint16(tvb, offset, ENC_LITTLE_ENDIAN);
    if (neg_type & 0x2) { /* If a bcast TWT */
      // 2 bytes - request type
      // 2 bytes - target wake time
      // 1 byte  - nominal minimum interval TWT wake duration
      // 2 bytes - TWT wake interval mantissa
      // 2 byte  - Broadcast TWT info
      // total: 10 bytes.
      if (tag_len < 9) {
        expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
            "Tag Length %u wrong, must be >= 9", tag_len);
        return tvb_captured_length(tvb);
      }
      item = proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_tag_twt_req_type_field,
                                    ett_twt_req_type_tree,
                                    ieee80211_bcst_twt_req_type_field,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
      last_bcast = (req_type & 0x20) >> 5;
    } else {
      // 2 bytes - request type
      // 8 bytes - target wake time
      // 1 byte  - nominal minimum interval TWT wake duration
      // 2 bytes - TWT wake interval mantissa
      // 1 byte  - channel
      // total: 14 bytes.
      if (tag_len < 14) {
        expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
            "Tag Length %u wrong, must be >= 14", tag_len);
        return tvb_captured_length(tvb);
      }
      item = proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                    hf_ieee80211_tag_twt_req_type_field,
                                    ett_twt_req_type_tree,
                                    ieee80211_twt_req_type_field,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
      last_bcast = true;
    }

    twt_requester = req_type & 0x1;
    setup_command = (req_type & 0xe) >> 1;

    switch (setup_command) {
      case REQUEST_TWT:
      case SUGGEST_TWT:
      case DEMAND_TWT:
        // we must be TWT requester
        if (!twt_requester) {
          expert_add_info_format(pinfo, item,
                         &ei_ieee80211_twt_setup_bad_command,
                         "Command %d is not allowed if TWT Request is not set",
                         setup_command);
          return tvb_captured_length(tvb);
        }
        break;
      case TWT_GROUPING:
        // TODO: There are more tests needed here
        //       Fall through since we can't be requester here as well.
      case ACCEPT_TWT:
      case ALTERNATE_TWT:
        // we can't be TWT requester
        if (twt_requester) {
          expert_add_info_format(pinfo, item,
                         &ei_ieee80211_twt_setup_bad_command,
                         "Command %d is not allowed if TWT Request is set",
                         setup_command);
          return tvb_captured_length(tvb);
        }
        break;
      case DICTATE_TWT:
      case REJECT_TWT:
        // TODO: Unclear what to do here. Looks like we can't be Requester, OTOH
        //       the spec doesn't say anything
        break;
      default:
        break;
    }

    offset += 2;

    if (neg_type & 0x2) { /* If a bcast TWT */
      uint16_t twt_info;

      proto_tree_add_item(tree, hf_ieee80211_tag_twt_target_wake_time_short,
                          tvb, offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;

      proto_tree_add_item(tree, hf_ieee80211_tag_twt_nom_min_twt_wake_dur, tvb,
                          offset, 1, ENC_NA);
      offset += 1;

      proto_tree_add_item(tree, hf_ieee80211_tag_twt_wake_interval_mantissa,
                          tvb, offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;

      twt_info = tvb_get_uint16(tvb, offset, ENC_LITTLE_ENDIAN);
      proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                        hf_ieee80211_tag_twt_broadcast_info,
                                        ett_twt_broadcast_info_tree,
                                        ieee80211_twt_broadcast_info_field,
                                        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
      offset += 2;
      if (twt_info & 0x01) { /* RTWT Traffic Info */
        proto_tree *info_tree;
        info_tree = proto_tree_add_subtree(tree, tvb, offset, 3, ett_twt_traffic_info_tree,
                                           NULL, "Restricted TWT Traffic Info");
        proto_tree_add_bitmask_with_flags(info_tree, tvb, offset,
                                          hf_ieee80211_tag_twt_traffic_info_control,
                                          ett_twt_traffic_info_control_tree,
                                          ieee80211_twt_traffic_info_control_field,
                                          ENC_LITTLE_ENDIAN, BMT_NO_FALSE);
        offset += 1;

        proto_tree_add_item(info_tree, hf_ieee80211_tag_twt_traffic_info_rtwt_dl_bitmap,
                            tvb, offset, 1, ENC_NA);
        offset += 1;

        proto_tree_add_item(info_tree, hf_ieee80211_tag_twt_traffic_info_rtwt_ul_bitmap,
                            tvb, offset, 1, ENC_NA);
        offset += 1;
      }
    } else {
      proto_tree_add_item(tree, hf_ieee80211_tag_twt_target_wake_time, tvb,
                          offset, 8, ENC_LITTLE_ENDIAN);
      offset += 8;

      proto_tree_add_item(tree, hf_ieee80211_tag_twt_nom_min_twt_wake_dur, tvb,
                          offset, 1, ENC_NA);
      offset += 1;

      item = proto_tree_add_item(tree,
                                 hf_ieee80211_tag_twt_wake_interval_mantissa,
                                 tvb, offset, 2, ENC_LITTLE_ENDIAN);
      offset += 2;

      proto_tree_add_item(tree, hf_ieee80211_tag_twt_channel, tvb, offset, 1,
                          ENC_NA);
      offset += 1;

      if (ctrl_field & 0x01) { /* NDP Paging */
        proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                                        hf_ieee80211_tag_twt_ndp_paging_field,
                                        ett_twt_ndp_paging_field_tree,
                                        ieee80211_twt_ndp_paging_field,
                                        ENC_LITTLE_ENDIAN, BMT_NO_FALSE);
        offset += 4;
      }

      if (ctrl_field & 0x40) { /* Link ID Bitmap */
        proto_tree_add_item(tree, hf_ieee80211_tag_twt_link_id_bitmap, tvb, offset, 2,
                            ENC_LITTLE_ENDIAN);
        offset += 2;
      }

      if (ctrl_field & 0x80) { /* Aligned TWT Link Bitmap */
        proto_tree_add_item(tree, hf_ieee80211_tag_twt_aligned_twt_link_bitmap, tvb, offset, 2,
                            ENC_LITTLE_ENDIAN);
        offset += 2;
      }
    }
  }

  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_rsnx(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  proto_item *octet;
  static int * const octet1[] = {
    &hf_ieee80211_tag_rsnx_length,
    &hf_ieee80211_tag_rsnx_protected_twt_operations_support,
    &hf_ieee80211_tag_rsnx_sae_hash_to_element,
    &hf_ieee80211_tag_rsnx_sae_pk,
    &hf_ieee80211_tag_rsnx_protected_wur_frame_support,
    NULL
  };
  static int * const octet2[] = {
    &hf_ieee80211_tag_rsnx_secure_ltf_support,
    &hf_ieee80211_tag_rsnx_secure_rtt_supported,
    &hf_ieee80211_tag_rsnx_urnm_mfpr_x20,
    &hf_ieee80211_tag_rsnx_protected_announce_support,
    &hf_ieee80211_tag_rsnx_pbac,
    &hf_ieee80211_tag_rsnx_extended_s1g_action_protection,
    &hf_ieee80211_tag_rsnx_spp_amsdu_capable,
    &hf_ieee80211_tag_rsnx_urnm_mfpr,
    NULL
  };

  if (tag_len < 1) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be >= 1", tag_len);
    return 0;
  }
  proto_item_append_text(field_data->item_tag, " (%u octet%s)", tag_len, plurality(tag_len, "", "s"));

  /* octet 1 */
  octet = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_rsnx, ett_tag_rsnx_octet1, octet1, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  proto_item_append_text(octet, " (octet %d)", offset + 1);

  offset += 1;
  if (offset >= tag_len) {
      return offset;
  }

  /* octet 2 */
  octet = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_tag_rsnx, ett_tag_rsnx_octet2, octet2, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  proto_item_append_text(octet, " (octet %d)", offset + 1);

  offset += 1;
  if (offset >= tag_len) {
      return offset;
  }

  /* all rest of payload is reserved... */
  while (offset < tag_len) {
    proto_tree_add_item(tree, hf_ieee80211_tag_rsnx_reserved, tvb, offset, 1,
                        ENC_LITTLE_ENDIAN);
    offset += 1;
  }

  return offset;
}

static int
ieee80211_tag_fils_indication(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  uint16_t info;
  uint8_t nr_realm, nr_pk, i, len;
  proto_item *item;
  proto_tree *subtree;

  if (tag_len < 2)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be >= 2", tag_len);
    return tvb_captured_length(tvb);
  }

  static int * const ieee80211_tag_fils_indication_info[] = {
    &hf_ieee80211_tag_fils_indication_info_nr_pk,
    &hf_ieee80211_tag_fils_indication_info_nr_realm,
    &hf_ieee80211_tag_fils_indication_info_ip_config,
    &hf_ieee80211_tag_fils_indication_info_cache_id_included,
    &hf_ieee80211_tag_fils_indication_info_hessid_included,
    &hf_ieee80211_tag_fils_indication_info_ska_without_pfs,
    &hf_ieee80211_tag_fils_indication_info_ska_with_pfs,
    &hf_ieee80211_tag_fils_indication_info_pka,
    &hf_ieee80211_tag_fils_indication_info_reserved,
    NULL
  };

  info = tvb_get_uint16(tvb, offset, ENC_LITTLE_ENDIAN);
  proto_tree_add_bitmask_list(tree, tvb, offset, 2, ieee80211_tag_fils_indication_info, ENC_LITTLE_ENDIAN);
  offset += 2;

  nr_pk = info & 0x07;
  nr_realm = (info >> 3) & 0x07;

  /* Cache identifier */
  if (info & (1 << 7)) {
    proto_tree_add_item(tree, hf_ieee80211_tag_fils_indication_cache_identifier, tvb, offset, 2, ENC_NA);
    offset += 2;
  }

  /* HESSID */
  if (info & (1 << 8)) {
    proto_tree_add_item(tree, hf_ieee80211_tag_fils_indication_hessid, tvb, offset, 6, ENC_NA);
    offset += 6;
  }

  /* Realm identifiers */
  if (nr_realm > 0) {
    item = proto_tree_add_item(tree, hf_ieee80211_tag_fils_indication_realm_list, tvb, offset, nr_realm * 2, ENC_NA);
    subtree = proto_item_add_subtree(item, ett_fils_indication_realm_list);
    proto_item_append_text(item, ": %u", nr_realm);

    for (i = 0; i < nr_realm; i++) {
      proto_tree_add_item(subtree, hf_ieee80211_tag_fils_indication_realm_identifier, tvb, offset, 2, ENC_NA);
      offset += 2;
    }
  }

  /* PK identifiers */
  if (nr_pk > 0) {
    item = proto_tree_add_item(tree, hf_ieee80211_tag_fils_indication_public_key_list, tvb, offset, tag_len - offset, ENC_NA);
    subtree = proto_item_add_subtree(item, ett_fils_indication_public_key_list);
    proto_item_append_text(item, ": %u", nr_pk);

    for (i = 0; i < nr_pk; i++) {
      proto_tree_add_item(subtree, hf_ieee80211_tag_fils_indication_public_key_type, tvb, offset, 1, ENC_NA);
      offset += 1;

      proto_tree_add_item(subtree, hf_ieee80211_tag_fils_indication_public_key_length, tvb, offset, 1, ENC_NA);
      len = tvb_get_uint8(tvb, offset);
      offset += 1;

      proto_tree_add_item(subtree, hf_ieee80211_tag_fils_indication_public_key_indicator, tvb, offset, len, ENC_NA);
      offset += len;
    }
  }

  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_element_id_extension(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  int ext_tag_len;
  uint8_t ext_tag_no;

  if (tag_len < 1)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be >= 1", tag_len);
    return tvb_captured_length(tvb);
  }
  ext_tag_no = tvb_get_uint8(tvb, offset++);
  ext_tag_len = tag_len - 1;

  switch (ext_tag_no) {
    case ETAG_FILS_REQ_PARAMS:
      dissect_fils_req_params(tree, pinfo, tvb, offset, ext_tag_len);
      break;
    case ETAG_FILS_SESSION:
      proto_tree_add_item(tree, hf_ieee80211_fils_session, tvb, offset, ext_tag_len, ENC_NA);
      if (field_data->sanity_check != NULL) {
        field_data->sanity_check->has_fils_session = true;
      }
      break;
    case ETAG_FILS_WRAPPED_DATA:
      dissect_wrapped_data(tree, pinfo, tvb, offset, ext_tag_len);
      break;
    case ETAG_FILS_NONCE:
      proto_tree_add_item(tree, hf_ieee80211_fils_nonce, tvb, offset, ext_tag_len, ENC_NA);
      break;
    case ETAG_ESTIMATED_SERVICE_PARAM:
      dissect_estimated_service_params(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_FUTURE_CHANNEL_GUIDANCE:
      dissect_future_channel_guidance(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_OWE_DH_PARAMETER:
      dissect_owe_dh_parameter(tvb, pinfo, tree, offset, ext_tag_len, field_data->sanity_check);
      break;
    case ETAG_PASSWORD_IDENTIFIER:
      dissect_password_identifier(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_HE_CAPABILITIES:
      dissect_he_capabilities(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_HE_OPERATION:
      dissect_he_operation(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_UORA_PARAMETER_SET:
      dissect_uora_parameter_set(tvb, pinfo, tree, offset);
      break;
    case ETAG_MU_EDCA_PARAMETER_SET:
      dissect_mu_edca_parameter_set(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_SPATIAL_REUSE_PARAMETER_SET:
      dissect_spatial_reuse_parameter_set(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_NDP_FEEDBACK_REPORT_PARAMETER_SET:
      dissect_ndp_feedback_report_set(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_BSS_COLOR_CHANGE_ANNOUNCEMENT:
      dissect_bss_color_change(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_QUIET_TIME_PERIOD_SETUP:
      dissect_quiet_time_period(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_ESS_REPORT:
      dissect_ess_report(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_OPS:
      dissect_ops(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_MAX_CHANNEL_SWITCH_TIME:
      dissect_max_channel_switch_time(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_OCI:
      dissect_oci(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_MULTIPLE_BSSID_CONFIGURATION:
      dissect_multiple_bssid_configuration(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_NON_INHERITANCE:
      dissect_non_inheritance(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_KNOWN_BSSID:
      dissect_known_bssid(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_SHORT_SSID:
      dissect_short_ssid(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_MSCS_DESCRIPTOR_ELEMENT:
      dissect_mscs_descriptor_element(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_TCLAS_MASK:
      dissect_tclas_mask_element(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_REJECTED_GROUPS:
      dissect_rejected_groups(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_ANTI_CLOGGING_TOKEN:
      dissect_anti_clogging_token(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_EXTENDED_REQUEST:
      dissect_extended_request(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_HE_6GHZ_BAND_CAPABILITIES:
      dissect_he_6ghz_band_capabilities(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_RANGING_PARAMETERS:
      dissect_ranging_parameters(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_DIRECTION_MEASUREMENT_RESULTS:
      dissect_direction_measurement_results(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_FTM_SYNC_INFO:
      proto_tree_add_item(tree, hf_ieee80211_tag_ftm_tsf_sync_info, tvb, offset, ext_tag_len, ENC_NA);
      break;
    case ETAG_SECURE_LTF_PARAMETERS:
      dissect_secure_ltf_parameters(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_ISTA_AVAILABILITY_WINDOW:
      dissect_ista_availability_window(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_RSTA_AVAILABILITY_WINDOW:
      dissect_rsta_availability_window(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_PASN_PARAMETERS:
      dissect_pasn_parameters(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_MULTI_LINK:
      dissect_multi_link(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_EHT_OPERATION:
      dissect_eht_operation(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_EHT_CAPABILITIES:
      dissect_eht_capabilities(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_TID_TO_LINK_MAPPING:
      dissect_tid_to_link_mapping(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_MULTI_LINK_TRAFFIC:
      dissect_multi_link_traffic(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_QOS_CHARACTERISTICS:
      dissect_qos_characteristics(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_AKM_SUITE_SELECTOR:
      dissect_akm_suite_selector(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_MLO_LINK_INFORMATION:
      dissect_mlo_link_information(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_AID_BITMAP:
      dissect_aid_bitmap(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    case ETAG_BANDWIDTH_INDICATION:
      dissect_bandwidth_indication(tvb, pinfo, tree, offset, ext_tag_len);
      break;
    default:
      proto_tree_add_item(tree, hf_ieee80211_ext_tag_data, tvb, offset, ext_tag_len, ENC_NA);
      expert_add_info_format(pinfo, field_data->item_tag, &ei_ieee80211_tag_data,
                             "Dissector for 802.11 Extension Tag"
                             " (%s) code not implemented, Contact"
                             " Wireshark developers if you want this supported", val_to_str_ext(ext_tag_no,
                                            &tag_num_vals_eid_ext_ext, "%d"));
      proto_item_append_text(field_data->item_tag, ": Undecoded");
      break;
  }

  return tvb_captured_length(tvb);
}

/* Conflict: WAPI Vs. IEEE */
static int
ieee80211_tag_ie_68_conflict(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  if (tag_len >= 20) { /* It Might be WAPI*/
    dissect_wapi_param_set(tvb, pinfo, tree, 0, tag_len, field_data->item_tag_length, field_data->item_tag, field_data->ftype);
  }
  else { /* BSS AC Access Delay (68) */
     dissect_bss_ac_access_delay_ie(tvb, pinfo, tree, 0, tag_len, field_data->item_tag_length);
  }
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_mesh_peering_mgmt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int tag_len = tvb_reported_length(tvb);
  int offset = 0;
  int ampe_frame = 0;

  proto_tree_add_item(tree, hf_ieee80211_mesh_peering_proto, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;
  proto_tree_add_item(tree, hf_ieee80211_mesh_peering_local_link_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  if (field_data && field_data->sanity_check)
    ampe_frame = field_data->sanity_check->ampe_frame;

  switch (ampe_frame)
  {                                         /* Self-protected action field */
    case SELFPROT_ACTION_MESH_PEERING_OPEN:
      break;

    case SELFPROT_ACTION_MESH_PEERING_CONFIRM:
      proto_tree_add_item(tree, hf_ieee80211_mesh_peering_peer_link_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);
      break;

    case SELFPROT_ACTION_MESH_PEERING_CLOSE:
      if ((tag_len == 8) || (tag_len == 24))
      {
        proto_tree_add_item(tree, hf_ieee80211_mesh_peering_peer_link_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
      }
      add_ff_reason_code(tree, tvb, pinfo, offset);
      break;

      /* unexpected values */
    default:
      proto_tree_add_expert(tree, pinfo, &ei_ieee80211_mesh_peering_unexpected , tvb, offset, tag_len);
      break;
  }
  if (tag_len - offset == 16)
  {
    proto_tree_add_item(tree, hf_ieee80211_rsn_pmkid, tvb, offset, 16, ENC_NA);
  }
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_mesh_configuration(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{

  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int tag_len = tvb_reported_length(tvb);
  if (tag_len != 7)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 7", tag_len);
    return tvb_captured_length(tvb);
  }

  int offset = 0;
  proto_item *item;
  proto_tree *subtree;
  static int * const ieee80211_mesh_config_cap[] = {
    &hf_ieee80211_mesh_config_cap_accepting,
    &hf_ieee80211_mesh_config_cap_mcca_support,
    &hf_ieee80211_mesh_config_cap_mcca_enabled,
    &hf_ieee80211_mesh_config_cap_forwarding,
    &hf_ieee80211_mesh_config_cap_mbca_enabled,
    &hf_ieee80211_mesh_config_cap_tbtt_adjusting,
    &hf_ieee80211_mesh_config_cap_power_save_level,
    &hf_ieee80211_mesh_config_cap_reserved,
    NULL
  };

  proto_tree_add_item(tree, hf_ieee80211_mesh_config_path_sel_protocol, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tree, hf_ieee80211_mesh_config_path_sel_metric, tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tree, hf_ieee80211_mesh_config_congestion_control, tvb, offset + 2, 1, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tree, hf_ieee80211_mesh_config_sync_method, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tree, hf_ieee80211_mesh_config_auth_protocol, tvb, offset + 4, 1, ENC_LITTLE_ENDIAN);
  item = proto_tree_add_item(tree, hf_ieee80211_mesh_config_formation_info, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);
  subtree = proto_item_add_subtree(item, ett_mesh_formation_info_tree);
  proto_tree_add_item(subtree, hf_ieee80211_mesh_form_info_conn_to_mesh_gate, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(subtree, hf_ieee80211_mesh_form_info_num_of_peerings, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(subtree, hf_ieee80211_mesh_form_info_conn_to_as, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);

  proto_tree_add_bitmask_with_flags(tree, tvb, offset + 6, hf_ieee80211_mesh_config_capability,
                                    ett_mesh_config_cap_tree, ieee80211_mesh_config_cap,
                                    ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_mesh_id(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int offset = 0;
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int tag_len = tvb_reported_length(tvb);
  const uint8_t* mesh_id;

  proto_tree_add_item_ret_string(tree, hf_ieee80211_mesh_id, tvb, offset, tag_len, ENC_ASCII|ENC_NA, pinfo->pool, &mesh_id);
  if (tag_len > 0) {
    char* s = format_text(pinfo->pool, mesh_id, tag_len);
    col_append_fstr(pinfo->cinfo, COL_INFO, ", MESHID=%s", s);
    proto_item_append_text(field_data->item_tag, ": %s", s);
  }
  /* Make sure dissector is accepted */
  return ((tag_len > 0) ? tag_len : 1);
}

static int
ieee80211_tag_beacon_timing(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  uint32_t value;
  proto_item *item;
  proto_tree *subtree;

  static int * const ieee80211_beacon_timing_rctrl_byte[] = {
    &hf_ieee80211_bcn_timing_rctrl_more,
    &hf_ieee80211_bcn_timing_rctrl_element_num,
    &hf_ieee80211_bcn_timing_rctrl_status_num,
    NULL,
  };

  /* Beacon timing element (120) */
  if (tag_len < 1) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "Tag length %u too short, must be greater than 1", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_bcn_timing_rctrl,
                      ett_bcn_timing_rctrl_tree, ieee80211_beacon_timing_rctrl_byte,
                      ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  while (offset < tag_len) {
    item = proto_tree_add_item(tree, hf_ieee80211_bcn_timing_info, tvb, offset, 6, ENC_NA);
    subtree = proto_item_add_subtree(item, ett_bcn_timing_info_tree);
    proto_item_append_text(item, " %u", ((offset / 6) + 1));

    proto_tree_add_item_ret_uint(subtree, hf_ieee80211_bcn_timing_info_nsta_id, tvb, offset, 1, ENC_LITTLE_ENDIAN, &value);
    proto_item_append_text(item, ": STA ID: %u", value);
    offset += 1;

    proto_tree_add_item_ret_uint(subtree, hf_ieee80211_bcn_timing_info_nsta_tbtt, tvb, offset, 3, ENC_LITTLE_ENDIAN, &value);
    proto_item_append_text(item, ", STA TBTT: %u", value);
    offset += 3;

    proto_tree_add_item_ret_uint(subtree, hf_ieee80211_bcn_timing_info_nsta_bi, tvb, offset, 2, ENC_LITTLE_ENDIAN, &value);
    proto_item_append_text(item, ", STA BI: %u", value);
    offset += 2;
  }

  proto_item_append_text(field_data->item_tag, " (%d entr%s)", offset / 6, plurality(offset / 6, "y", "ies"));

  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_gann(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  static int * const ieee80211_gann_flags_byte[] = {
    &hf_ieee80211_gann_flags_reserved,
    NULL,
  };

  /* Gate Announcement (125) */
  if (tag_len != 15) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "Tag length %u wrong, must be = 15", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_gann_flags,
                      ett_gann_flags_tree, ieee80211_gann_flags_byte,
                      ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_gann_hop_count, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_gann_elem_ttl, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_gann_mesh_gate_addr, tvb, offset, 6, ENC_NA);
  offset += 6;
  proto_tree_add_item(tree, hf_ieee80211_gann_seq_num, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;
  proto_tree_add_item(tree, hf_ieee80211_gann_interval, tvb, offset, 2, ENC_LITTLE_ENDIAN);

  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_mesh_preq(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;

  uint32_t flags;
  uint8_t targs, i;

  proto_tree_add_item_ret_uint(tree, hf_ieee80211_ff_hwmp_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN, &flags);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_hopcount, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_ttl, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_pdid, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_orig_sta, tvb, offset, 6, ENC_NA);
  offset += 6;
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_orig_sn, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  if (flags & (1<<6)) {
    proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_orig_ext, tvb, offset, 6, ENC_NA);
    offset += 6;
  }
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_lifetime, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_metric, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_targ_count, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  targs = tvb_get_uint8(tvb, offset);
  offset += 1;
  for (i = 0; i < targs; i++) {
    static int * const targ_flags[] = {
      &hf_ieee80211_ff_hwmp_targ_to_flags,
      &hf_ieee80211_ff_hwmp_targ_usn_flags,
      NULL
    };

    proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_ff_hwmp_targ_flags,
                                   ett_hwmp_targ_flags_tree, targ_flags, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);

    offset += 1;
    proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_targ_sta, tvb, offset, 6, ENC_NA);
    offset += 6;
    proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_targ_sn, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    offset += 4;
  }

  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_mesh_prep(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;

  uint32_t flags;
  proto_tree_add_item_ret_uint(tree, hf_ieee80211_ff_hwmp_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN, &flags);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_hopcount, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_ttl, tvb, offset , 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_targ_sta, tvb, offset, 6, ENC_NA);
  offset += 6;
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_targ_sn, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;
  if (flags & (1<<6)) {
    proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_targ_ext, tvb, offset, 6, ENC_NA);
    offset += 6;
  }
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_lifetime, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_metric, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_orig_sta, tvb, offset, 6, ENC_NA);
  offset += 6;
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_orig_sn, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_mesh_perr(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  uint8_t targs, i;

  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_ttl, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_targ_count, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  targs = tvb_get_uint8(tvb, offset);
  offset += 1;
  for (i = 0; i < targs; i++) {
    uint8_t flags = tvb_get_uint8(tvb, offset);

    proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_targ_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_targ_sta, tvb, offset, 6, ENC_NA);
    offset += 6;
    proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_targ_sn, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    offset += 4;
    if (flags & (1<<6)) {
      proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_targ_ext, tvb, offset, 6, ENC_NA);
      offset += 6;
    }
    offset += add_ff_reason_code(tree, tvb, pinfo, offset);
  }
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_pxu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  uint32_t pxu_count = 0, i, proxy_info_len;
  uint8_t pxu_flag;
  proto_item *item;
  proto_tree *subtree;

  static int * const ieee80211_pxu_proxy_info_flags_byte[] = {
    &hf_ieee80211_pxu_proxy_info_flags_delete,
    &hf_ieee80211_pxu_proxy_info_flags_orig_is_proxy,
    &hf_ieee80211_pxu_proxy_info_flags_lifetime,
    &hf_ieee80211_pxu_proxy_info_flags_reserved,
    NULL,
  };

  /* PXU element (137) */
  if (tag_len < 8) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "Tag length %u wrong, must be at least 8", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item(tree, hf_ieee80211_pxu_pxu_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_pxu_pxu_origin_mac, tvb, offset, 6, ENC_NA);
  offset += 6;
  proto_tree_add_item_ret_uint(tree, hf_ieee80211_pxu_no_proxy_info, tvb, offset, 1, ENC_LITTLE_ENDIAN, &pxu_count);
  offset += 1;

  for (i = 0; i < pxu_count; i++) {
    pxu_flag = tvb_get_uint8(tvb, offset);
    proxy_info_len = 1 + 6 + 4 + ((pxu_flag & 0x2) ? 0 : 6) + ((pxu_flag & 0x4) ? 4 : 0);

    item = proto_tree_add_item(tree, hf_ieee80211_pxu_proxy_info, tvb, offset, proxy_info_len, ENC_NA);
    subtree = proto_item_add_subtree(item, ett_pxu_proxy_info_tree);
    proto_item_append_text(item, " #%u", (i + 1));

    proto_tree_add_bitmask_with_flags(subtree, tvb, offset, hf_ieee80211_pxu_proxy_info_flags,
        ett_pxu_proxy_info_flags_tree, ieee80211_pxu_proxy_info_flags_byte,
        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    offset += 1;

    proto_tree_add_item(subtree, hf_ieee80211_pxu_proxy_info_ext_mac, tvb, offset, 6, ENC_NA);
    offset += 6;

    proto_tree_add_item(subtree, hf_ieee80211_pxu_proxy_info_seq_num, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    offset += 4;

    if (!(pxu_flag & 0x2)) {
      proto_tree_add_item(subtree, hf_ieee80211_pxu_proxy_info_proxy_mac, tvb, offset, 6, ENC_NA);
      offset += 6;
    }

    if (pxu_flag & 0x4) {
      proto_tree_add_item(subtree, hf_ieee80211_pxu_proxy_info_lifetime, tvb, offset, 4, ENC_LITTLE_ENDIAN);
      offset += 4;
    }
  }

  proto_item_append_text(field_data->item_tag, " (%d entr%s)", pxu_count, plurality(pxu_count, "y", "ies"));
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_pxuc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  /* PXUC element (138) */
  if (tag_len != 7) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "Tag length %u wrong, must be = 7", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item(tree, hf_ieee80211_pxuc_pxu_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_pxuc_pxu_recip_mac, tvb, offset, 6, ENC_NA);

  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_mic(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;

  if (tag_len != 16)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
                           "MIC Tag Length %u wrong, must be = 16", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item(tree, hf_ieee80211_mesh_mic, tvb, 0, 16, ENC_NA);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_rann(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)
{
  int offset = 0;
  proto_tree_add_item(tree, hf_ieee80211_rann_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_hopcount, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_ttl, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_rann_root_sta, tvb, offset, 6, ENC_NA);
  offset += 6;
  proto_tree_add_item(tree, hf_ieee80211_rann_sn, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;
  proto_tree_add_item(tree, hf_ieee80211_rann_interval, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;
  proto_tree_add_item(tree, hf_ieee80211_ff_hwmp_metric, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

/* Mesh Channel Switch Parameters (118) */
static int
ieee80211_tag_mesh_channel_switch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  static int * const ieee80211_mesh_chswitch_flag[] = {
    &hf_ieee80211_mesh_chswitch_flag_initiator,
    &hf_ieee80211_mesh_chswitch_flag_txrestrict,
    NULL
  };

  if (tag_len != 6)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 6", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item(tree, hf_ieee80211_mesh_channel_switch_ttl, tvb, offset, 1, ENC_LITTLE_ENDIAN);
  proto_item_append_text(field_data->item_tag, " TTL: %d", tvb_get_uint8(tvb, offset));
  offset += 1;

  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_ieee80211_mesh_channel_switch_flag,
                                   ett_mesh_chswitch_flag_tree, ieee80211_mesh_chswitch_flag, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 1;

  proto_tree_add_item(tree, hf_ieee80211_mesh_channel_switch_reason_code, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;

  proto_tree_add_item(tree, hf_ieee80211_mesh_channel_switch_precedence_value, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

/* Mesh Awake Window Parameters (119) */
static int
ieee80211_tag_mesh_awake_window(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if (tag_len != 2) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length,
        "Tag length %u wrong, must be = 2", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item(tree, hf_ieee80211_mesh_awake_window, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_channel_switch_announcement(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  if (tag_len != 4)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 4", tag_len);
    return tvb_captured_length(tvb);
  }

  add_ff_extended_channel_switch_announcement(tree, tvb, pinfo, offset);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_supported_operating_classes(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  proto_item* item = NULL;
  uint8_t i;
  uint8_t field_len = 0;
  uint8_t alt_op_class_field[256];

  if (tag_len < 2) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be >= 2", tag_len);
    return tvb_captured_length(tvb);
  } else if (tag_len > 255) {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, uint8 <= 255", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_supported_ope_classes_current, tvb, offset++, 1, ENC_NA);

  for (i = offset; i < tag_len; i++) {
    uint8_t op_class =  tvb_get_uint8(tvb, i);
    /* Field terminates immediately before OneHundredAndThirty or Zero delimiter */
    if (op_class == 130 || op_class == 0) {
      break;
    }
    alt_op_class_field[field_len++] = op_class;
  }
  if (field_len) {
    item = proto_tree_add_item(tree, hf_ieee80211_tag_supported_ope_classes_alternate, tvb, offset, field_len, ENC_NA);
  }
  for (i = 0; i < field_len; i++) {
    proto_item_append_text(item, i == 0 ? ": %d":", %d", alt_op_class_field[i]);
  }

  /* TODO parse optional Current Operating Class Extension Sequence field */
  /* TODO parse optional Operating Class Duple Sequence field */
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_bss_parameter_change(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  bool size;
  if (tag_len != 7)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 7", tag_len);
    return tvb_captured_length(tvb);
  }
  size = (tvb_get_uint8(tvb, offset) & 0x02) >> 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_move, tvb, offset, 1, ENC_NA);
  proto_tree_add_item(tree, hf_ieee80211_tag_size, tvb, offset, 1, ENC_NA);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_tbtt_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;
  if(size == true) { /* if size bit is 0, the field is reserved. */
    proto_tree_add_item(tree, hf_ieee80211_tag_bi_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  }
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_dmg_capabilities(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  static int * const ieee80211_tag_dmg_cap1[] = {
    &hf_ieee80211_tag_reverse_direction,
    &hf_ieee80211_tag_hlts,
    &hf_ieee80211_tag_tpc,
    &hf_ieee80211_tag_spsh,
    &hf_ieee80211_tag_rx_antenna,
    &hf_ieee80211_tag_fast_link,
    &hf_ieee80211_tag_num_sectors,
    &hf_ieee80211_tag_rxss_length,
    &hf_ieee80211_tag_reciprocity,
    &hf_ieee80211_tag_max_ampdu_exp,
    NULL
  };

  static int * const ieee80211_tag_dmg_cap2[] = {
    &hf_ieee80211_tag_min_mpdu_spacing,
    &hf_ieee80211_tag_ba_flow_control,
    &hf_ieee80211_tag_max_sc_rx_mcs,
    &hf_ieee80211_tag_max_ofdm_rx_mcs,
    &hf_ieee80211_tag_max_sc_tx_mcs,
    &hf_ieee80211_tag_max_ofdm_tx_mcs,
    NULL
  };

  static int * const ieee80211_tag_dmg_cap3[] = {
    &hf_ieee80211_tag_low_power_supported,
    &hf_ieee80211_tag_code_rate,
    &hf_ieee80211_tag_dtp,
    &hf_ieee80211_tag_appdu_supp,
    &hf_ieee80211_tag_heartbeat,
    &hf_ieee80211_tag_other_aid,
    &hf_ieee80211_tag_pattern_recip,
    &hf_ieee80211_tag_heartbeat_elapsed,
    &hf_ieee80211_tag_grant_ack_supp,
    &hf_ieee80211_tag_RXSSTxRate_supp,
    NULL
  };

  static int * const ieee80211_tag_dmg_cap4[] = {
    &hf_ieee80211_tag_pcp_tddti,
    &hf_ieee80211_tag_pcp_PSA,
    &hf_ieee80211_tag_pcp_handover,
    &hf_ieee80211_tag_pcp_max_assoc,
    &hf_ieee80211_tag_pcp_power_src,
    &hf_ieee80211_tag_pcp_decenter,
    &hf_ieee80211_tag_pcp_forwarding,
    &hf_ieee80211_tag_pcp_center,
    NULL
  };

  static int * const ieee80211_tag_dmg_cap5[] = {
    &hf_ieee80211_tag_ext_sc_mcs_max_tx,
    &hf_ieee80211_tag_ext_sc_mcs_tx_code_7_8,
    &hf_ieee80211_tag_ext_sc_mcs_max_rx,
    &hf_ieee80211_tag_ext_sc_mcs_rx_code_7_8,
    NULL
  };

  /*
   * Plenty of devices still do not conform to the older version of this
   * field. So, it must be at least 17 bytes in length.
   */
  if (tag_len < 17)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must contain at least 17 bytes", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_dmg_capa_sta_addr, tvb, offset, 6, ENC_NA);
  offset += 6;
  proto_tree_add_item(tree, hf_ieee80211_tag_dmg_capa_aid, tvb, offset, 1, ENC_NA);
  offset += 1;
  proto_tree_add_bitmask_list(tree, tvb, offset, 3, ieee80211_tag_dmg_cap1, ENC_LITTLE_ENDIAN);
  offset += 3;
  proto_tree_add_bitmask_list(tree, tvb, offset, 3, ieee80211_tag_dmg_cap2, ENC_LITTLE_ENDIAN);
  offset += 3;
  proto_tree_add_bitmask_list(tree, tvb, offset, 2, ieee80211_tag_dmg_cap3, ENC_LITTLE_ENDIAN);
  offset += 2;
  proto_tree_add_bitmask_list(tree, tvb, offset, 2, ieee80211_tag_dmg_cap4, ENC_LITTLE_ENDIAN);
  offset += 2;

  /*
   * There are many captures out there that do not conform to the 2016
   * version, so give them a malformed IE message now after we have dissected
   * the above
   */
  if (tag_len != 22)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u does not conform to IEEE802.11-2016, should contain 22 bytes", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_item(tree, hf_ieee80211_tag_sta_beam_track, tvb, offset, 2, ENC_NA);
  offset += 2;
  proto_tree_add_bitmask_list(tree, tvb, offset, 1, ieee80211_tag_dmg_cap5, ENC_LITTLE_ENDIAN);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_max_basic_sf_amsdu, tvb, offset, 1, ENC_NA);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_max_short_sf_amsdu, tvb, offset, 1, ENC_NA);

  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_dmg_operation(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  static int * const ieee80211_tag_dmg_operation_flags[] = {
    &hf_ieee80211_tag_pcp_tddti,
    &hf_ieee80211_tag_pcp_PSA,
    &hf_ieee80211_tag_pcp_handover,
    NULL
  };

  if (tag_len != 10)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 10", tag_len);
    return tvb_captured_length(tvb);
  }
  proto_tree_add_bitmask_list(tree, tvb, offset, 1, ieee80211_tag_dmg_operation_flags, ENC_LITTLE_ENDIAN);
  offset += 2;
  proto_tree_add_item(tree, hf_ieee80211_tag_PSRSI, tvb, offset, 1, ENC_NA);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_min_BHI_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;
  proto_tree_add_item(tree, hf_ieee80211_tag_brdct_sta_info_dur, tvb, offset, 1, ENC_NA);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_assoc_resp_confirm_time, tvb, offset, 1, ENC_NA);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_min_pp_duration, tvb, offset, 1, ENC_NA);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_SP_idle_timeout, tvb, offset, 1, ENC_NA);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_max_lost_beacons, tvb, offset, 1, ENC_NA);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_antenna_section_id(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  static int * const ieee80211_tag_antenna[] = {
    &hf_ieee80211_tag_type,
    &hf_ieee80211_tag_tap1,
    &hf_ieee80211_tag_state1,
    &hf_ieee80211_tag_tap2,
    &hf_ieee80211_tag_state2,
    NULL
  };

  if (tag_len != 4)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 4", tag_len);
    return tvb_captured_length(tvb);
  }
  proto_tree_add_bitmask_list(tree, tvb, offset, 4, ieee80211_tag_antenna, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_extended_schedule(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  int i;
  bool isGrant;
  proto_tree * alloc_tree;
  if ((tag_len%15) != 0)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be N*15 where 0<=N<=17", tag_len);
    return tvb_captured_length(tvb);
  }
  isGrant = ((field_data->ftype==CTRL_GRANT)||(field_data->ftype==CTRL_GRANT_ACK));
  for(i=0; i < tag_len; i+=15) {
    alloc_tree = proto_tree_add_subtree_format(tree, tvb, offset, 15, ett_allocation_tree, NULL, "Allocation %d", i/15);
    proto_tree_add_item(alloc_tree, hf_ieee80211_tag_allocation_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(alloc_tree, hf_ieee80211_tag_allocation_type, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(alloc_tree, hf_ieee80211_tag_pseudo_static, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(alloc_tree, hf_ieee80211_tag_truncatable, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(alloc_tree, hf_ieee80211_tag_extendable, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(alloc_tree, hf_ieee80211_tag_pcp_active, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(alloc_tree, hf_ieee80211_tag_lp_sc_used, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    offset += add_ff_beamforming_ctrl(alloc_tree, tvb, pinfo, offset, isGrant);
    proto_tree_add_item(alloc_tree, hf_ieee80211_tag_src_aid, tvb, offset, 1, ENC_NA);
    offset += 1;
    proto_tree_add_item(alloc_tree, hf_ieee80211_tag_dest_aid, tvb, offset, 1, ENC_NA);
    offset += 1;
    proto_tree_add_item(alloc_tree, hf_ieee80211_tag_alloc_start, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    offset += 4;
    proto_tree_add_item(alloc_tree, hf_ieee80211_tag_alloc_block_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    proto_tree_add_item(alloc_tree, hf_ieee80211_tag_num_blocks, tvb, offset, 1, ENC_NA);
    offset += 1;
    proto_tree_add_item(alloc_tree, hf_ieee80211_tag_alloc_block_period, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_sta_availability(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  int i;
  proto_tree * sta_info_tree;
  if ((tag_len%2) != 0)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be N*2 where N>=0", tag_len);
    return tvb_captured_length(tvb);
  }
  for(i=0; i < tag_len; i+=2) {
    sta_info_tree = proto_tree_add_subtree_format(tree, tvb, offset, 2, ett_sta_info, NULL, "STA Info %d", i/2);
    proto_tree_add_item(sta_info_tree, hf_ieee80211_tag_aid, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(sta_info_tree, hf_ieee80211_tag_cbap, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(sta_info_tree, hf_ieee80211_tag_pp_avail, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_next_dmg_ati(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  if (tag_len != 6)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be = 6", tag_len);
    return tvb_captured_length(tvb);
  }
  proto_tree_add_item(tree, hf_ieee80211_tag_next_ati_start_time, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;
  proto_tree_add_item(tree, hf_ieee80211_tag_next_ati_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_nextpcp_list(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  int i;
  if (tag_len < 1)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be at least 1", tag_len);
    return tvb_captured_length(tvb);
  }
  proto_tree_add_item(tree, hf_ieee80211_tag_nextpcp_token, tvb, offset, 1, ENC_NA);
  offset += 1;
  for(i=0; i < tag_len-1; i+=1) {
    proto_tree_add_item(tree, hf_ieee80211_tag_nextpcp_list, tvb, offset, 1, ENC_NA);
    offset += 1;
  }
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_pcp_handover(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  if (tag_len != 13)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be 13", tag_len);
    return tvb_captured_length(tvb);
  }
  proto_tree_add_item(tree, hf_ieee80211_tag_old_bssid, tvb, offset, 6, ENC_NA);
  offset += 6;
  proto_tree_add_item(tree, hf_ieee80211_tag_new_pcp_addr, tvb, offset, 6, ENC_NA);
  offset += 6;
  proto_tree_add_item(tree, hf_ieee80211_tag_reamaining_BI, tvb, offset, 1, ENC_NA);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_beamlink_maintenance(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  if (tag_len != 1)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be 1", tag_len);
    return tvb_captured_length(tvb);
  }
  add_ff_beamformed_link(tree, tvb, pinfo, offset);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_quiet_period_res(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  if (tag_len != 10)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be 10", tag_len);
    return tvb_captured_length(tvb);
  }
  proto_tree_add_item(tree, hf_ieee80211_tag_request_token, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;
  proto_tree_add_item(tree, hf_ieee80211_tag_bssid, tvb, offset, 6, ENC_NA);
  offset += 6;
  add_ff_sta_address(tree, tvb, pinfo, offset);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_relay_transfer_param(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if (tag_len != 8)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be 8", tag_len);
    return tvb_captured_length(tvb);
  }
  proto_tree_add_item(tree, hf_ieee80211_tag_duplex_relay, tvb, offset, 1, ENC_NA);
  proto_tree_add_item(tree, hf_ieee80211_tag_cooperation_relay, tvb, offset, 1, ENC_NA);
  proto_tree_add_item(tree, hf_ieee80211_tag_tx_mode, tvb, offset, 1, ENC_NA);
  proto_tree_add_item(tree, hf_ieee80211_tag_link_change_interval, tvb, offset+1, 1, ENC_NA);
  proto_tree_add_item(tree, hf_ieee80211_tag_data_sensing_time, tvb, offset+2, 1, ENC_NA);
  proto_tree_add_item(tree, hf_ieee80211_tag_first_period, tvb, offset+3, 2, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(tree, hf_ieee80211_tag_second_period, tvb, offset+5, 2, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_dmg_beam_refinement(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  static int * const ieee80211_dmg_beam_refinement_fields[] = {
    &hf_ieee80211_tag_initiator,
    &hf_ieee80211_tag_tx_train_res,
    &hf_ieee80211_tag_rx_train_res,
    &hf_ieee80211_tag_tx_trn_ok,
    &hf_ieee80211_tag_txss_fbck_req,
    &hf_ieee80211_tag_bs_fbck,
    &hf_ieee80211_tag_bs_fbck_antenna_id,
    &hf_ieee80211_tag_snr_requested,
    &hf_ieee80211_tag_channel_measurement_requested,
    &hf_ieee80211_tag_number_of_taps_requested,
    &hf_ieee80211_tag_sector_id_order_req,
    &hf_ieee80211_tag_snr_present,
    &hf_ieee80211_tag_channel_measurement_present,
    &hf_ieee80211_tag_tap_delay_present,
    &hf_ieee80211_tag_number_of_taps_present,
    &hf_ieee80211_tag_number_of_measurement,
    &hf_ieee80211_tag_sector_id_order_present,
    &hf_ieee80211_tag_number_of_beams,
    &hf_ieee80211_tag_mid_extension,
    &hf_ieee80211_tag_capability_request,
    &hf_ieee80211_tag_beam_refine_reserved,
    NULL
  };

  if (tag_len != 5)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be 5", tag_len);
    return tvb_captured_length(tvb);
  }

  proto_tree_add_bitmask_list(tree, tvb, offset, 5, ieee80211_dmg_beam_refinement_fields, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_wakeup_schedule_ad(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if (tag_len != 8)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be 8", tag_len);
    return tvb_captured_length(tvb);
  }
  proto_tree_add_item(tree, hf_ieee80211_tag_bi_start_time, tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;
  proto_tree_add_item(tree, hf_ieee80211_tag_sleep_cycle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;
  proto_tree_add_item(tree, hf_ieee80211_tag_num_awake_bis, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_dmg_tspec(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  bool isGrant;
  int num_constraints;
  if (tag_len < 14)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be at least 14", tag_len);
    return tvb_captured_length(tvb);
  }
  static int * const ieee80211_tag_tspec_flags[] = {
    &hf_ieee80211_tag_tspec_allocation_id,
    &hf_ieee80211_tag_tspec_allocation_type,
    &hf_ieee80211_tag_tspec_allocation_format,
    &hf_ieee80211_tag_tspec_pseudo_static,
    &hf_ieee80211_tag_tspec_truncatable,
    &hf_ieee80211_tag_tspec_extendable,
    &hf_ieee80211_tag_tspec_lp_sc_used,
    &hf_ieee80211_tag_tspec_up,
    &hf_ieee80211_tag_tap2,
    &hf_ieee80211_tag_tspec_dest_aid,
    NULL
  };

  proto_tree_add_bitmask_list(tree, tvb, offset, 3, ieee80211_tag_tspec_flags, ENC_LITTLE_ENDIAN);
  offset += 3;
  isGrant = ((field_data->ftype==CTRL_GRANT)||(field_data->ftype==CTRL_GRANT_ACK));
  offset += add_ff_beamforming_ctrl(tree, tvb, pinfo, 2, isGrant);
  proto_tree_add_item(tree, hf_ieee80211_tag_tspec_allocation_period, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;
  proto_tree_add_item(tree, hf_ieee80211_tag_tspec_min_allocation, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;
  proto_tree_add_item(tree, hf_ieee80211_tag_tspec_max_allocation, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;
  proto_tree_add_item(tree, hf_ieee80211_tag_tspec_min_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
  offset += 2;
  num_constraints = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_tag_tspec_num_of_constraints, tvb, offset, 1, ENC_NA);
  offset += 1;
  while(num_constraints > 0) {
    proto_tree_add_item(tree, hf_ieee80211_tag_tspec_tsconst_start_time, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    offset += 4;
    proto_tree_add_item(tree, hf_ieee80211_tag_tspec_tsconst_duration, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    proto_tree_add_item(tree, hf_ieee80211_tag_tspec_tsconst_period, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    proto_tree_add_item(tree, hf_ieee80211_tag_tspec_tsconst_interferer_mac, tvb, offset, 2, ENC_NA);
    offset += 6;
    num_constraints--;
  }
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_channel_measurement_fb(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  int num_measurement;
  if (tag_len%5 != 0)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be multiple of 5", tag_len);
    return tvb_captured_length(tvb);
  }
  num_measurement = tvb_get_uint8(tvb, offset+1);
  offset += 2;
  while(num_measurement > 0) {
    proto_tree_add_item(tree, hf_ieee80211_ff_snr, tvb, offset, 1, ENC_NA);
    offset += 1;
    proto_tree_add_item(tree, hf_ieee80211_tag_channel_measurement_feedback_relative_I, tvb, offset, 1, ENC_NA);
    offset += 1;
    proto_tree_add_item(tree, hf_ieee80211_tag_channel_measurement_feedback_relative_Q, tvb, offset, 1, ENC_NA);
    offset += 1;
    proto_tree_add_item(tree, hf_ieee80211_tag_channel_measurement_feedback_tap_delay, tvb, offset, 1, ENC_NA);
    offset += 1;
    proto_tree_add_item(tree, hf_ieee80211_tag_channel_measurement_feedback_sector_id, tvb, offset, 1, ENC_NA);
    proto_tree_add_item(tree, hf_ieee80211_tag_channel_measurement_feedback_antenna_id, tvb, offset, 1, ENC_NA);
    offset += 1;
    num_measurement--;
  }
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_awake_window(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;

  if (tag_len != 2)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be 2", tag_len);
  }
  else
  {
    proto_tree_add_item(tree, hf_ieee80211_tag_awake_window, tvb, 0, 2, ENC_LITTLE_ENDIAN);
  }
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_addba_ext(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;

  if (tag_len != 1)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be 1", tag_len);
  }
  else
  {
    proto_tree_add_item(tree, hf_ieee80211_tag_addba_ext_no_frag, tvb, 0, 1, ENC_NA);
    proto_tree_add_item(tree, hf_ieee80211_tag_addba_ext_he_fragmentation_operation, tvb, 0, 1, ENC_NA);
    proto_tree_add_item(tree, hf_ieee80211_tag_addba_ext_reserved, tvb, 0, 1, ENC_NA);
    proto_tree_add_item(tree, hf_ieee80211_tag_addba_ext_buffer_size, tvb, 0, 1, ENC_NA);
  }
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_multi_band(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  bool chiper_present, addr_present;
  static int * const ieee80211_tag_multi_band_ctrl[] = {
    &hf_ieee80211_tag_multi_band_ctrl_sta_role,
    &hf_ieee80211_tag_multi_band_ctrl_addr_present,
    &hf_ieee80211_tag_multi_band_ctrl_cipher_present,
    NULL
  };
  static int * const ieee80211_tag_multi_band_conn[] = {
    &hf_ieee80211_tag_multi_band_conn_ap,
    &hf_ieee80211_tag_multi_band_conn_pcp,
    &hf_ieee80211_tag_multi_band_conn_dls,
    &hf_ieee80211_tag_multi_band_conn_tdls,
    &hf_ieee80211_tag_multi_band_conn_ibss,
    NULL
  };

  if (tag_len < 22)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be at least 22", tag_len);
    return tvb_captured_length(tvb);
  }
  chiper_present = (tvb_get_letohs(tvb, offset) & 0x08) >> 3;
  addr_present = (tvb_get_letohs(tvb, offset) & 0x10) >> 4;
  proto_tree_add_bitmask_list(tree, tvb, offset, 1, ieee80211_tag_multi_band_ctrl, ENC_NA);
  offset += 1;
  offset += add_ff_band_id(tree, tvb, pinfo, 1);
  proto_tree_add_item(tree, hf_ieee80211_tag_multi_band_oper_class, tvb, offset, 1, ENC_NA);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_multi_band_channel_number, tvb, offset, 1, ENC_NA);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_bssid, tvb, offset, 6, ENC_NA);
  offset += 6;
  offset += add_ff_beacon_interval(tree, tvb, pinfo, 2);
  proto_tree_add_item(tree, hf_ieee80211_tag_multi_band_tsf_offset, tvb, offset, 8, ENC_LITTLE_ENDIAN);
  offset += 8;

  proto_tree_add_bitmask_list(tree, tvb, offset, 1, ieee80211_tag_multi_band_conn, ENC_NA);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_multi_band_fst_timeout, tvb, offset, 1, ENC_NA);
  offset += 1;
  if(addr_present)
  {
    proto_tree_add_item(tree, hf_ieee80211_tag_multi_band_sta_mac, tvb, offset, 6, ENC_NA);
    offset += 6;
  }
  if(chiper_present)
  {
    proto_item *rsn_pcs_count, *rsn_pcs_item, *rsn_sub_pcs_item;
    proto_tree *rsn_pcs_tree, *rsn_sub_pcs_tree;
    int ii;
    uint16_t    pcs_count;
    int tag_end = tvb_reported_length(tvb);
    rsn_pcs_count = proto_tree_add_item(tree, hf_ieee80211_rsn_pcs_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    pcs_count = tvb_get_letohs(tvb, offset);
    offset += 2;

    if (offset + (pcs_count * 4) > tag_end)
    {
        expert_add_info_format(pinfo, rsn_pcs_count, &ei_ieee80211_rsn_pcs_count,
        "Pairwise Cipher Suite Count too large, 4*%u > %d", pcs_count, tag_end - offset);
        pcs_count = (tag_end - offset) / 4;
    }

    rsn_pcs_item = proto_tree_add_item(tree, hf_ieee80211_rsn_pcs_list, tvb, offset, pcs_count * 4, ENC_NA);
    rsn_pcs_tree = proto_item_add_subtree(rsn_pcs_item, ett_rsn_pcs_tree);
    for (ii = 0; ii < pcs_count; ii++)
    {
      rsn_sub_pcs_item = proto_tree_add_item(rsn_pcs_tree, hf_ieee80211_rsn_pcs, tvb, offset, 4, ENC_BIG_ENDIAN);
      rsn_sub_pcs_tree = proto_item_add_subtree(rsn_sub_pcs_item, ett_rsn_sub_pcs_tree);
      proto_tree_add_item(rsn_sub_pcs_tree, hf_ieee80211_rsn_pcs_oui, tvb, offset, 3, ENC_BIG_ENDIAN);

      /* Check if OUI is 00:0F:AC (ieee80211) */
      if (tvb_get_ntoh24(tvb, offset) == OUI_RSN)
      {
        proto_tree_add_item(rsn_sub_pcs_tree, hf_ieee80211_rsn_pcs_80211_type, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);
        proto_item_append_text(rsn_pcs_item, " %s", rsn_pcs_return(pinfo->pool, tvb_get_ntohl(tvb, offset)));
      } else {
        proto_tree_add_item(rsn_sub_pcs_tree, hf_ieee80211_rsn_pcs_type, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);
      }
      offset += 4;
    }
  }

  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_dmg_link_margin(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if (tag_len != 8)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be 8", tag_len);
    return tvb_captured_length(tvb);
  }
  proto_tree_add_item(tree, hf_ieee80211_tag_activity, tvb, offset, 1, ENC_NA);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_dmg_link_adapt_mcs, tvb, offset, 1, ENC_NA);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_dmg_link_adapt_link_margin, tvb, offset, 1, ENC_NA);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_ff_snr, tvb, offset, 1, ENC_NA);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_ref_timestamp, tvb, offset, 3, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_dmg_link_adaption_ack(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;

  if (tag_len != 5)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be 5", tag_len);
    return tvb_captured_length(tvb);
  }
  proto_tree_add_item(tree, hf_ieee80211_tag_activity, tvb, offset, 1, ENC_NA);
  offset += 1;
  proto_tree_add_item(tree, hf_ieee80211_tag_ref_timestamp, tvb, offset, 3, ENC_LITTLE_ENDIAN);
  return tvb_captured_length(tvb);
}

static int
ieee80211_tag_switching_stream(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int tag_len = tvb_reported_length(tvb);
  ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data;
  int offset = 0;
  static int * const ieee80211_tag_switching_stream_flags[] = {
    &hf_ieee80211_tag_switching_stream_old_tid,
    &hf_ieee80211_tag_switching_stream_old_direction,
    &hf_ieee80211_tag_switching_stream_new_tid,
    &hf_ieee80211_tag_switching_stream_new_direction,
    &hf_ieee80211_tag_switching_stream_new_valid_id,
    &hf_ieee80211_tag_switching_stream_llt_type,
    NULL
  };

  int param_num;
  if (tag_len < 4)
  {
    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, "Tag Length %u wrong, must be at least 4", tag_len);
    return tvb_captured_length(tvb);
  }
  offset += add_ff_band_id(tree, tvb, pinfo, 1);
  offset += add_ff_band_id(tree, tvb, pinfo, 1);
  proto_tree_add_item(tree, hf_ieee80211_tag_switching_stream_non_qos, tvb, offset, 1, ENC_NA);
  offset += 1;
  param_num = tvb_get_letohs(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_tag_switching_stream_param_num, tvb, offset, 1, ENC_NA);
  offset += 1;
  while(param_num > 0)
  {
    proto_tree_add_bitmask_list(tree, tvb, offset, 1, ieee80211_tag_switching_stream_flags, ENC_NA);
    param_num--;
    offset += 2;
  }
  return tvb_captured_length(tvb);
}

static void
ieee_80211_add_tagged_parameters(tvbuff_t *tvb, int offset, packet_info *pinfo,
                                  proto_tree *tree, int tagged_parameters_len, int ftype,
                                  association_sanity_check_t *association_sanity_check)
{
  int next_len;
  beacon_padding = 0; /* this is for the beacon padding confused with ssid fix */
  while (tagged_parameters_len > 0) {
    uint8_t tag_no = tvb_get_uint8(tvb, offset);

    /* TODO make callers optionally specify the list of valid IE IDs? */
    if ((next_len=add_tagged_field (pinfo, tree, tvb, offset, ftype, NULL, 0, association_sanity_check)) == 0)
      break;
    if (next_len > tagged_parameters_len) {
      /* XXX - flag this as an error? */
      next_len = tagged_parameters_len;
    }
    offset                += next_len;
    tagged_parameters_len -= next_len;

    /* If FILS is used, all data after the FILS Session tag in a (re)association message is encrypted */
    if (association_sanity_check != NULL && association_sanity_check->has_fils_session) {
      proto_tree_add_item(tree, hf_ieee80211_fils_encrypted_data, tvb, offset, tagged_parameters_len, ENC_NA);
      break;
    }

    /* In an AMPE frame the data following the MIC element is encrypted */
    if ((tag_no == TAG_MIC) && (association_sanity_check != NULL) && association_sanity_check->ampe_frame) {
      proto_tree_add_item(tree, hf_ieee80211_mesh_ampe_encrypted_data, tvb, offset, tagged_parameters_len, ENC_NA);
      break;
    }
  }
}

static void
ieee_80211_do_association_sanity_check(packet_info *pinfo, association_sanity_check_t *sanity_check)
{
  /* Given a [re-]association request frame, consider it in its totality and
     add expert information as appropriate */

  if (sanity_check->association_has_mobility_domain_element) {
    /* This is an FT association, warn about any non-FT AKM suites */
    if (sanity_check->has_non_ft_akm_suite) {
      expert_add_info_format(pinfo, sanity_check->rsn_first_non_ft_akm_suite, &ei_ieee80211_mismatched_akm_suite,
                             "Non-FT AKM suite is prohibited for FT association request");
    }
  } else {
    /* This is a non-FT association, warn about any FT AKM suites */
    if (sanity_check->has_ft_akm_suite) {
      expert_add_info_format(pinfo, sanity_check->rsn_first_ft_akm_suite, &ei_ieee80211_mismatched_akm_suite,
                             "FT AKM suite is prohibited for non-FT association request");
    }
  }
}

static conversation_t *find_or_create_wlan_conversation(packet_info *pinfo)
{
  /* HACK to avoid collision with conversation in EAP dissector */
  pinfo->srcport = GPOINTER_TO_UINT(
    p_get_proto_data(wmem_file_scope(), pinfo, proto_wlan, ASSOC_COUNTER_KEY));
  pinfo->destport = pinfo->srcport;
  return find_or_create_conversation(pinfo);
}

static ieee80211_conversation_data_t* get_or_create_conversation_data(conversation_t *conversation) {
  ieee80211_conversation_data_t *conversation_data = (ieee80211_conversation_data_t*)conversation_get_proto_data(conversation, proto_wlan);
  if (!conversation_data) {
    conversation_data = wmem_new(wmem_file_scope(), ieee80211_conversation_data_t);
    conversation_add_proto_data(conversation, proto_wlan, conversation_data);
  }
  memset(conversation_data, 0, sizeof(ieee80211_conversation_data_t));
  return conversation_data;
}

/* ************************************************************************* */
/*                     Dissect 802.11 management frame                       */
/* ************************************************************************* */
static void dissect_mgt_action(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, unsigned offset, association_sanity_check_t *sanity_check)
{
  proto_item *lcl_fixed_hdr;
  proto_tree *lcl_fixed_tree;
  proto_tree *tagged_tree;
  int         tagged_parameter_tree_len;

  lcl_fixed_tree = proto_tree_add_subtree(tree, tvb, 0, 0, ett_fixed_parameters, &lcl_fixed_hdr, "Fixed parameters");
  offset += add_ff_action(lcl_fixed_tree, tvb, pinfo, 0, sanity_check);

  proto_item_set_len(lcl_fixed_hdr, offset);
  if (ieee80211_tvb_invalid)
    return; /* Buffer not available for further processing */
  tagged_parameter_tree_len = tvb_reported_length_remaining(tvb, offset);
  if (tagged_parameter_tree_len > 0) {
    tagged_tree = get_tagged_parameter_tree(tree, tvb, offset,
                                            tagged_parameter_tree_len);
    ieee_80211_add_tagged_parameters(tvb, offset, pinfo, tagged_tree,
                                     tagged_parameter_tree_len, MGT_ACTION,
                                     sanity_check);
    }
}

static void
dissect_ieee80211_mgt(uint16_t fcf, tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
{
  proto_item *ti;
  proto_tree *mgt_tree;
  proto_tree *fixed_tree;
  proto_tree *tagged_tree;
  int         offset = 0;
  int         tagged_parameter_tree_len;
  bool        is_s1g = sta_is_s1g(pinfo);

  conversation_t *conversation;
  ieee80211_conversation_data_t *conversation_data;

  association_sanity_check_t association_sanity_check;
  memset(&association_sanity_check, 0, sizeof(association_sanity_check));


  ieee80211_tvb_invalid = false;

  ti = proto_tree_add_item(tree, hf_ieee80211_mgt, tvb, 0, -1, ENC_NA);
  mgt_tree = proto_item_add_subtree(ti, ett_80211_mgt);
  /*
   * Add the frame type to the pinfo for those cases where it is needed
   * to determine other things.
   * XXX - Is there any reason why this is file scoped? Couldn't this
   * be pinfo->pool?
   */
  p_add_proto_data(wmem_file_scope(), pinfo, proto_wlan, FRAME_TYPE_KEY, GINT_TO_POINTER(COMPOSE_FRAME_TYPE(fcf)));

  switch (COMPOSE_FRAME_TYPE(fcf))
  {

    case MGT_ASSOC_REQ:
      fixed_tree = get_fixed_parameter_tree(mgt_tree, tvb, 0, 4, false);
      add_ff_cap_info(fixed_tree, tvb, pinfo, 0);
      add_ff_listen_ival(fixed_tree, tvb, pinfo, 2);
      offset = 4;  /* Size of fixed fields */

      tagged_parameter_tree_len =
          tvb_reported_length_remaining(tvb, offset);
      tagged_tree = get_tagged_parameter_tree(mgt_tree, tvb, offset,
                 tagged_parameter_tree_len);
      ieee_80211_add_tagged_parameters(tvb, offset, pinfo, tagged_tree,
          tagged_parameter_tree_len, MGT_ASSOC_REQ, &association_sanity_check);
      ieee_80211_do_association_sanity_check(pinfo, &association_sanity_check);

      if (!pinfo->fd->visited) {
        association_counter++;
        p_add_proto_data(wmem_file_scope(), pinfo, proto_wlan, ASSOC_COUNTER_KEY,
                         GUINT_TO_POINTER(association_counter));
      }
      conversation = find_or_create_wlan_conversation(pinfo);
      conversation_data = get_or_create_conversation_data(conversation);
      set_conversation_last_akm_suite(conversation_data,
                                      association_sanity_check.last_akm_suite);
      conversation_data->owe_group = association_sanity_check.owe_group;
      break;


    case MGT_ASSOC_RESP:
      fixed_tree = get_fixed_parameter_tree(mgt_tree, tvb, 0, is_s1g ? 4 : 6,
                                            false);
      add_ff_cap_info(fixed_tree, tvb, pinfo, 0);
      add_ff_status_code(fixed_tree, tvb, pinfo, 2);
      if (!is_s1g) {
        add_ff_assoc_id(fixed_tree, tvb, pinfo, 4);
        offset = 6;  /* Size of fixed fields */
      } else {
        offset = 4;
      }

      tagged_parameter_tree_len =
          tvb_reported_length_remaining(tvb, offset);
      tagged_tree = get_tagged_parameter_tree(mgt_tree, tvb, offset,
                 tagged_parameter_tree_len);
      ieee_80211_add_tagged_parameters(tvb, offset, pinfo, tagged_tree,
          tagged_parameter_tree_len, MGT_ASSOC_RESP, &association_sanity_check);
      break;


    case MGT_REASSOC_REQ:
      fixed_tree = get_fixed_parameter_tree(mgt_tree, tvb, 0, 10, false);
      add_ff_cap_info(fixed_tree, tvb, pinfo, 0);
      add_ff_listen_ival(fixed_tree, tvb, pinfo, 2);
      add_ff_current_ap_addr(fixed_tree, tvb, pinfo, 4);
      offset = 10;  /* Size of fixed fields */

      tagged_parameter_tree_len =
          tvb_reported_length_remaining(tvb, offset);
      tagged_tree = get_tagged_parameter_tree(mgt_tree, tvb, offset,
                 tagged_parameter_tree_len);
      ieee_80211_add_tagged_parameters(tvb, offset, pinfo, tagged_tree,
          tagged_parameter_tree_len, MGT_REASSOC_REQ, &association_sanity_check);
      ieee_80211_do_association_sanity_check(pinfo, &association_sanity_check);

      if (!pinfo->fd->visited) {
        association_counter++;
        p_add_proto_data(wmem_file_scope(), pinfo, proto_wlan, ASSOC_COUNTER_KEY,
                         GUINT_TO_POINTER(association_counter));
      }
      conversation = find_or_create_wlan_conversation(pinfo);
      conversation_data = get_or_create_conversation_data(conversation);
      set_conversation_last_akm_suite(conversation_data,
                                      association_sanity_check.last_akm_suite);
      conversation_data->owe_group = association_sanity_check.owe_group;
      break;

    case MGT_REASSOC_RESP:
      fixed_tree = get_fixed_parameter_tree(mgt_tree, tvb, 0, 6, false);
      add_ff_cap_info(fixed_tree, tvb, pinfo, 0);
      add_ff_status_code(fixed_tree, tvb, pinfo, 2);
      if (!is_s1g) {
        add_ff_assoc_id(fixed_tree, tvb, pinfo, 4);
        offset = 6;  /* Size of fixed fields */
      } else {
        offset = 4;
      }

      tagged_parameter_tree_len =
          tvb_reported_length_remaining(tvb, offset);
      tagged_tree = get_tagged_parameter_tree(mgt_tree, tvb, offset,
                 tagged_parameter_tree_len);
      ieee_80211_add_tagged_parameters(tvb, offset, pinfo, tagged_tree,
          tagged_parameter_tree_len, MGT_REASSOC_RESP, &association_sanity_check);
      break;


    case MGT_PROBE_REQ:
      offset = 0;
      tagged_parameter_tree_len =
          tvb_reported_length_remaining(tvb, offset);
      tagged_tree = get_tagged_parameter_tree(mgt_tree, tvb, offset,
                 tagged_parameter_tree_len);
      ieee_80211_add_tagged_parameters(tvb, offset, pinfo, tagged_tree,
          tagged_parameter_tree_len, MGT_PROBE_REQ, NULL);
      break;

    case MGT_PROBE_RESP:
    {
      fixed_tree = get_fixed_parameter_tree(mgt_tree, tvb, 0, 12, false);
      add_ff_timestamp(fixed_tree, tvb, pinfo, 0);
      add_ff_beacon_interval(fixed_tree, tvb, pinfo, 8);
      add_ff_cap_info(fixed_tree, tvb, pinfo, 10);
      offset = 12;  /* Size of fixed fields */

      tagged_parameter_tree_len = tvb_reported_length_remaining(tvb, offset);
      tagged_tree = get_tagged_parameter_tree(mgt_tree, tvb, offset, tagged_parameter_tree_len);
      ieee_80211_add_tagged_parameters(tvb, offset, pinfo, tagged_tree, tagged_parameter_tree_len, MGT_PROBE_RESP, NULL);
      break;
    }
    case MGT_MEASUREMENT_PILOT:
    {
      fixed_tree = get_fixed_parameter_tree(mgt_tree, tvb, 0, 12, false);
      offset += add_ff_timestamp(fixed_tree, tvb, pinfo, offset);
      offset += add_ff_measurement_pilot_int(fixed_tree, tvb, pinfo, offset);
      offset += add_ff_beacon_interval(fixed_tree, tvb, pinfo, offset);
      offset += add_ff_cap_info(fixed_tree, tvb, pinfo, offset);
      offset += add_ff_country_str(fixed_tree, tvb, pinfo, offset);
      offset += add_ff_max_reg_pwr(fixed_tree, tvb, pinfo, offset);
      offset += add_ff_max_tx_pwr(fixed_tree, tvb, pinfo, offset);
      offset += add_ff_tx_pwr_used(fixed_tree, tvb, pinfo, offset);
      offset += add_ff_transceiver_noise_floor(fixed_tree, tvb, pinfo, offset);
      /* TODO DS Parameter Set ??? */

      tagged_parameter_tree_len = tvb_reported_length_remaining(tvb, offset);
      tagged_tree = get_tagged_parameter_tree(mgt_tree, tvb, offset, tagged_parameter_tree_len);
      ieee_80211_add_tagged_parameters(tvb, offset, pinfo, tagged_tree, tagged_parameter_tree_len, MGT_MEASUREMENT_PILOT, NULL);
      break;
    }
    case MGT_BEACON:    /* Dissect protocol payload fields  */
      fixed_tree = get_fixed_parameter_tree(mgt_tree, tvb, 0, 12, false);
      add_ff_timestamp(fixed_tree, tvb, pinfo, 0);
      add_ff_beacon_interval(fixed_tree, tvb, pinfo, 8);
      add_ff_cap_info(fixed_tree, tvb, pinfo, 10);
      offset = 12;  /* Size of fixed fields */

      tagged_parameter_tree_len =
          tvb_reported_length_remaining(tvb, offset);
      tagged_tree = get_tagged_parameter_tree(mgt_tree, tvb, offset,
      tagged_parameter_tree_len);
      ieee_80211_add_tagged_parameters(tvb, offset, pinfo, tagged_tree,
      tagged_parameter_tree_len, MGT_BEACON, NULL);
      break;

    case MGT_ATIM:
      break;

    case MGT_DISASS:
      fixed_tree = get_fixed_parameter_tree(mgt_tree, tvb, 0, 2, false);
      add_ff_reason_code(fixed_tree, tvb, pinfo, 0);
      offset = 2; /* Size of fixed fields */
      tagged_parameter_tree_len = tvb_reported_length_remaining(tvb, offset);
      if (tagged_parameter_tree_len > 0) {
        tagged_tree = get_tagged_parameter_tree(mgt_tree, tvb, offset,
                                                tagged_parameter_tree_len);
        ieee_80211_add_tagged_parameters(tvb, offset, pinfo, tagged_tree,
                                         tagged_parameter_tree_len, MGT_DISASS, NULL);
      }

      conversation = find_wlan_conversation_pinfo(pinfo);
      if (conversation) {
        conversation_delete_proto_data(conversation, proto_wlan);
      }
      break;

    case MGT_AUTHENTICATION:
      offset = 6;  /* Size of fixed fields */

      fixed_tree = get_fixed_parameter_tree(mgt_tree, tvb, 0, offset, true);
      offset = dissect_auth_frame(fixed_tree, pinfo, tvb);
      proto_item_append_text(fixed_tree, " (%d bytes)", offset);
      proto_item_set_len(fixed_tree, offset);

      tagged_parameter_tree_len =
        tvb_reported_length_remaining(tvb, offset);
      if (tagged_parameter_tree_len > 0)
      {
        tagged_tree = get_tagged_parameter_tree(mgt_tree,
            tvb,
            offset,
            tagged_parameter_tree_len);
        ieee_80211_add_tagged_parameters(tvb, offset, pinfo, tagged_tree,
        tagged_parameter_tree_len, MGT_AUTHENTICATION, NULL);
      }
      break;

    case MGT_DEAUTHENTICATION:
      fixed_tree = get_fixed_parameter_tree(mgt_tree, tvb, 0, 2, false);
      add_ff_reason_code(fixed_tree, tvb, pinfo, 0);
      offset = 2; /* Size of fixed fields */
      tagged_parameter_tree_len = tvb_reported_length_remaining(tvb, offset);
      if (tagged_parameter_tree_len > 0) {
        tagged_tree = get_tagged_parameter_tree(mgt_tree, tvb, offset,
                                                tagged_parameter_tree_len);
        ieee_80211_add_tagged_parameters(tvb, offset, pinfo, tagged_tree,
                                         tagged_parameter_tree_len, MGT_DEAUTHENTICATION, NULL);
      }

      conversation = find_wlan_conversation_pinfo(pinfo);
      if (conversation) {
        conversation_delete_proto_data(conversation, proto_wlan);
      }
      break;

    case MGT_ACTION:
      dissect_mgt_action(tvb, pinfo, mgt_tree, offset, &association_sanity_check);
      break;

    case MGT_ACTION_NO_ACK:
    {
      proto_item *lcl_fixed_hdr;
      proto_tree *lcl_fixed_tree;
      lcl_fixed_tree = proto_tree_add_subtree(mgt_tree, tvb, 0, 0, ett_fixed_parameters, &lcl_fixed_hdr, "Fixed parameters");

      offset += add_ff_action(lcl_fixed_tree, tvb, pinfo, 0, NULL);

      proto_item_set_len(lcl_fixed_hdr, offset);
      if (ieee80211_tvb_invalid)
        break; /* Buffer not available for further processing */
      tagged_parameter_tree_len = tvb_reported_length_remaining(tvb, offset);
      if (tagged_parameter_tree_len > 0)
      {
        tagged_tree = get_tagged_parameter_tree(mgt_tree, tvb, offset,
          tagged_parameter_tree_len);
        ieee_80211_add_tagged_parameters(tvb, offset, pinfo, tagged_tree,
          tagged_parameter_tree_len, MGT_ACTION_NO_ACK, NULL);
      }
      break;
    }
    case MGT_ARUBA_WLAN:
    {
      proto_tree *aruba_tree;
      uint16_t type;
      type = tvb_get_ntohs(tvb, offset);

      aruba_tree = proto_tree_add_subtree(mgt_tree, tvb, 0, 0, ett_fixed_parameters, NULL, "Aruba Management");

      proto_tree_add_item(aruba_tree, hf_ieee80211_aruba, tvb, offset, 2, ENC_BIG_ENDIAN);
      offset += 2;
      switch(type){
        case 0x0003: /* MTU Size */
          proto_tree_add_item(aruba_tree, hf_ieee80211_aruba_mtu, tvb, offset, 2, ENC_BIG_ENDIAN);
        break;
        case 0x0005: /* HeartBeat Sequence */
          proto_tree_add_item(aruba_tree, hf_ieee80211_aruba_hb_seq, tvb, offset, 8, ENC_BIG_ENDIAN);
        break;
      }
      break;
    }
  }
}

/*
 * Dissect a Block Ack request (which is also used in Trigger frames).
 */
static int * const block_ack_control_headers[] = {
  &hf_ieee80211_block_ack_control_ack_policy,
  &hf_ieee80211_block_ack_control_type,
  &hf_ieee80211_block_ack_control_reserved,
  &hf_ieee80211_block_ack_control_tid_info,
  NULL
};

static int * const multi_sta_aid_tid_headers[] = {
  &hf_ieee80211_block_ack_multi_sta_aid11,
  &hf_ieee80211_block_ack_multi_sta_ack_type,
  &hf_ieee80211_block_ack_multi_sta_tid,
 NULL
};

/*
 * These bits are shown in reverse order in the spec.
 */
#define BASIC_BLOCK_ACK               0x0
#define EXTENDED_COMPRESSED_BLOCK_ACK 0x1
#define COMPRESSED_BLOCK_ACK          0x2
#define MULTI_TID_BLOCK_ACK           0x3
#define GCR_BLOCK_ACK                 0x6
#define GLK_GCR_BLOCK_ACK             0xA
#define MULTI_STA_BLOCK_ACK           0xB

static const value_string block_ack_type_vals[] = {
  { BASIC_BLOCK_ACK,               "Basic BlockAck" },
  { EXTENDED_COMPRESSED_BLOCK_ACK, "Extended Compressed BlockAck" },
  { COMPRESSED_BLOCK_ACK,          "Compressed BlockAck" },
  { MULTI_TID_BLOCK_ACK,           "Multi-TID BlockAck" },
  { GCR_BLOCK_ACK,                 "GCR BlockAck" },
  { GLK_GCR_BLOCK_ACK,             "GLK-GCR BlockAck" },
  { MULTI_STA_BLOCK_ACK,           "Multi-STA BlockAck" },
  { 0, NULL }
};

static int
dissect_ieee80211_block_ack_details(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, bool isDMG, bool is_req, bool has_fcs)
{
  proto_item     *pi;
  uint16_t        ba_control;
  uint8_t         block_ack_type;
  proto_tree     *ba_tree;
  uint8_t         tid_count, frag_num;
  unsigned        i;
  proto_tree     *ba_mtid_tree, *ba_mtid_sub_tree;
  uint16_t        ssn;
  uint64_t        bmap;
  int             f;
  proto_item     *ba_bitmap_item;
  proto_tree     *ba_bitmap_tree;
  uint16_t        aid_tid;
  proto_tree     *ba_multi_sta_tree;
  int             ba_start = offset;

  ba_control = tvb_get_letohs(tvb, offset);
  block_ack_type = (ba_control & 0x001E) >> 1;
  ba_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1, ett_block_ack,
                        &pi, is_req ? "%s Request" : "%s Response",
                        val_to_str(block_ack_type, block_ack_type_vals,
                                "Reserved (%d)"));
  proto_tree_add_bitmask_with_flags(ba_tree, tvb, offset,
                        hf_ieee80211_block_ack_control,
                        ett_block_ack_request_control,
                        block_ack_control_headers,
                        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;

  switch (block_ack_type) {
  case BASIC_BLOCK_ACK:
    if (isDMG == true) {
      expert_add_info_format(pinfo, ba_tree, &ei_ieee80211_dmg_subtype,
                        "DMG STAs shouldn't transmit BlockAckReq frames "
                        "with Basic BlockAckReqs");
    }

    /* Both request and response have an SSC */
    offset += add_ff_block_ack_ssc(ba_tree, tvb, pinfo, offset);

    if (!is_req) {
      proto_tree_add_item(ba_tree, hf_ieee80211_block_ack_bitmap, tvb, offset,
                        128, ENC_NA);
      offset += 128;
    }
    break;

  case COMPRESSED_BLOCK_ACK:
    /*
     * FIXME: For 802.11ax, the block ack bitmap can be 8 or 32 bytes
     * depending on the values of the fragment number subfield in the
     * SSC! All values other that 0 and 2 in bits B1 & B2 are reserved.
     *
     *  802.11be allows the block ack bitmap to be 64 or 128 bytes as well.
     */
    ssn = tvb_get_letohs(tvb, offset);
    frag_num = ssn & 0x0F;
    ssn >>= 4;
    offset += add_ff_block_ack_ssc(ba_tree, tvb, pinfo, offset);

    if (!is_req) {
      unsigned bytes = 0;
      if (((frag_num & 0x06) >> 1) == 2) {
        bytes = 32;
      } else if ((frag_num & 0x0f) == 0x08) {
        bytes = 64;
      } else if ((frag_num & 0x0f) == 0x0A) {
        bytes = 128;
      } else { /* Default length */
        bytes = 8;
      }

      ba_bitmap_item = proto_tree_add_item(ba_tree,
                          hf_ieee80211_block_ack_bitmap,
                          tvb, offset, bytes, ENC_NA);
      ba_bitmap_tree = proto_item_add_subtree(ba_bitmap_item,
                          ett_block_ack_bitmap);
      for (i = 0; i < (bytes * 8); i += 64) {
        bmap = tvb_get_letoh64(tvb, offset);
        for (f = 0; f < 64; f++) {
          if (bmap & (UINT64_C(1) << f))
            continue;
          proto_tree_add_uint_format_value(ba_bitmap_tree,
                          hf_ieee80211_block_ack_bitmap_missing_frame,
                          tvb, offset + (f/8), 1, ssn + f, "%u",
                          (ssn + f) & 0x0fff);
        }
      }
      offset += bytes;
    }
    break;

  case EXTENDED_COMPRESSED_BLOCK_ACK:
    if (isDMG == false) {
      expert_add_info_format(pinfo, ba_tree, &ei_ieee80211_dmg_subtype,
                        "Non-DMG STAs shouldn't transmit BlockAckReq "
                        "frames with Extended Compressed BlockAckReqs");
    }

    offset += add_ff_block_ack_ssc(ba_tree, tvb, pinfo, offset);

    if (!is_req) {
      ssn = tvb_get_letohs(tvb, offset);
      ssn >>= 4;

      bmap = tvb_get_letoh64(tvb, offset);
      ba_bitmap_item = proto_tree_add_item(ba_tree,
                        hf_ieee80211_block_ack_bitmap,
                        tvb, offset, 8, ENC_NA);
      ba_bitmap_tree = proto_item_add_subtree(ba_bitmap_item,
                        ett_block_ack_bitmap);
      for (f = 0; f < 64; f++) {
        if (bmap & (UINT64_C(1) << f))
          continue;
        proto_tree_add_uint(ba_bitmap_tree,
                        hf_ieee80211_block_ack_bitmap_missing_frame,
                        tvb, offset + (f/8), 1, ssn + f);
      }
      offset += 8;
      proto_tree_add_item(ba_tree, hf_ieee80211_block_ack_RBUFCAP, tvb, offset,
                        1, ENC_LITTLE_ENDIAN);
      offset += 1;
    }
    break;

  case MULTI_TID_BLOCK_ACK:

    if (isDMG == true) {
      expert_add_info_format(pinfo, ba_tree, &ei_ieee80211_dmg_subtype,
                        "DMG STAs shouldn't transmit BlockAckReq frames "
                        "with Multi-TID BlockAckReqs");
    }

    tid_count = ((ba_control & 0xF000) >> 12) + 1;
    if (is_req) {
      ba_mtid_tree = proto_tree_add_subtree(ba_tree, tvb, offset, tid_count*4,
                ett_block_ack, NULL, "TID List");
      for (i = 0; i < tid_count; i++) {
        uint8_t tid = tvb_get_uint8(tvb, offset) & 0x0F;
        ba_mtid_sub_tree = proto_tree_add_subtree_format(ba_mtid_tree, tvb,
                                offset, 4, ett_block_ack_tid, NULL,
                                "TID %u details", tid);

        proto_tree_add_item(ba_mtid_sub_tree,
                hf_ieee80211_block_ack_multi_tid_reserved, tvb, offset, 2,
                ENC_LITTLE_ENDIAN);
        proto_tree_add_item(ba_mtid_sub_tree,
                hf_ieee80211_block_ack_multi_tid_value, tvb, offset, 2,
                ENC_LITTLE_ENDIAN);
        offset += 2;

        offset += add_ff_block_ack_ssc(ba_mtid_sub_tree, tvb, pinfo, offset);
      }
    } else {
      ba_mtid_tree = proto_tree_add_subtree(ba_tree, tvb, offset, tid_count*4,
                ett_block_ack, NULL, "TID List");
      for (i = 0; i < tid_count; i++) {
        uint8_t tid = tvb_get_uint8(tvb, offset) & 0x0F;
        ba_mtid_sub_tree = proto_tree_add_subtree_format(ba_mtid_tree, tvb,
                                offset, 4, ett_block_ack_tid, NULL,
                                "TID %u details", tid);

        proto_tree_add_item(ba_mtid_sub_tree,
                        hf_ieee80211_block_ack_multi_tid_reserved,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(ba_mtid_sub_tree,
                        hf_ieee80211_block_ack_multi_tid_value, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;

        offset += add_ff_block_ack_ssc(ba_mtid_sub_tree, tvb, pinfo, offset);
        proto_tree_add_item(ba_mtid_sub_tree,
                        hf_ieee80211_block_ack_bitmap, tvb, offset, 8, ENC_NA);
        offset += 8;
      }
    }
    break;

  case GCR_BLOCK_ACK:
    offset += add_ff_block_ack_ssc(ba_tree, tvb, pinfo, offset);

    proto_tree_add_item(ba_tree, hf_ieee80211_block_ack_gcr_addr, tvb,
                        offset, 6, ENC_NA);
    offset += 6;

    if (!is_req) {
      proto_tree_add_item(ba_tree,
                        hf_ieee80211_block_ack_bitmap, tvb, offset, 8, ENC_NA);
      offset += 8;
    }
    break;

  case MULTI_STA_BLOCK_ACK:
    while (tvb_reported_length_remaining(tvb, offset) > (has_fcs ? 4 : 0)) {
        int start = offset;
        proto_item *msta_ti = NULL;
        aid_tid = tvb_get_letohs(tvb, offset);
        ba_multi_sta_tree = proto_tree_add_subtree_format(ba_tree, tvb, offset, -1,
                                ett_multi_sta_block_ack, &msta_ti,
                                "Per AID TID Info: 0x%0x", aid_tid & 0x07ff);
        proto_tree_add_bitmask_with_flags(ba_multi_sta_tree, tvb, offset,
                        hf_ieee80211_block_ack_multi_sta_aid_tid,
                        ett_block_ack_request_multi_sta_aid_tid,
                        multi_sta_aid_tid_headers,
                        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
        offset += 2;

        if ((aid_tid & 0x07ff) != 2045) {
          if (((aid_tid & 0x0800) == 0) && ((aid_tid & 0xf000) >> 12) <= 7) {
            unsigned bitmap_size;
            ssn = tvb_get_letohs(tvb, offset);
            frag_num = ssn & 0x0F;
            ssn >>= 4;
            offset += add_ff_block_ack_ssc(ba_multi_sta_tree, tvb, pinfo, offset);
            if ((frag_num & 0x0f) == 0x8 || (frag_num & 0x0f) == 0xA) {
              bitmap_size = (frag_num & 0x0f) == 8 ? 64 : 128;
            } else {
              bitmap_size = ((frag_num + 2) & 0x6) >> 1;  /* Turn into an exponent */
              bitmap_size = 4 << bitmap_size;  /* It goes 4, 8, 16, 32 */
            }
            ba_bitmap_item = proto_tree_add_item(ba_multi_sta_tree,
                        hf_ieee80211_block_ack_bitmap, tvb,
                        offset, bitmap_size, ENC_NA);
            ba_bitmap_tree = proto_item_add_subtree(ba_bitmap_item,
                                ett_block_ack_bitmap);
            for (i = 0; i < bitmap_size * 8; i += 64) {
              bmap = tvb_get_letoh64(tvb, offset + i/8);
              for (f = 0; f < ((bitmap_size == 4 ? 4 : 8) * 8); f++) {
                if (bmap & (UINT64_C(1) << f))
                  continue;
                proto_tree_add_uint_format_value(ba_bitmap_tree,
                              hf_ieee80211_block_ack_bitmap_missing_frame,
                              tvb, offset + ((f + i)/8), 1, ssn + f + i, "%u",
                              (ssn + f + i) & 0x0fff);
              }
            }
            offset += bitmap_size;
          }
        } else {
          offset += add_ff_block_ack_ssc(ba_multi_sta_tree, tvb, pinfo, offset);
          proto_tree_add_item(ba_multi_sta_tree, hf_ieee80211_block_ack_multi_sta_reserved,
                                tvb, offset, 2, ENC_LITTLE_ENDIAN);
          offset += 2;
          proto_tree_add_item(ba_multi_sta_tree, hf_ieee80211_block_ack_multi_sta_ra,
                                tvb, offset, 6, ENC_NA);
          offset += 6;
        }
        proto_item_set_len(msta_ti, offset - start);
    }
    break;
  }
  proto_item_set_len(pi, offset - ba_start);

  return offset;
}

static void
dissect_ieee80211_block_ack(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, bool isDMG, bool is_req, bool has_fcs)
{
  proto_tree_add_mac48_detail(&mac_ta, &mac_addr, ett_addr, tvb, tree, offset);
  offset += 6;

  dissect_ieee80211_block_ack_details(tvb, pinfo, tree, offset, isDMG, is_req, has_fcs);
}

/*
 * Dissect an 802.11ax HE Trigger frame and return the actual len including
 * padding!
 */

typedef enum he_trigger_type {
  TRIGGER_TYPE_BASIC = 0,
  TRIGGER_TYPE_BRP,
  TRIGGER_TYPE_MU_BAR,
  TRIGGER_TYPE_MU_RTS,
  TRIGGER_TYPE_BSRP,
  TRIGGER_TYPE_GCR_MU_BAR,
  TRIGGER_TYPE_BQRP,
  TRIGGER_TYPE_NFRP,
  TRIGGER_TYPE_RANGING,
  TRIGGER_TYPE_MIN_RESERVED,
} he_trigger_type_t;

typedef enum he_trigger_subtype {
  TRIGGER_SUBTYPE_POLL = 0,
  TRIGGER_SUBTYPE_SOUNDING,
  TRIGGER_SUBTYPE_SECURE_SOUNDING,
  TRIGGER_SUBTYPE_REPORT,
  TRIGGER_SUBTYPE_PASSIVE_TB_MEAS_EXCHANGE,
  TRIGGER_SUBTYPE_MIN_RESERVED,
} he_trigger_subtype_t;

static const val64_string trigger_type_vals[] = {
  { 0, "Basic" },
  { 1, "Beamforming Report Poll (BRP)" },
  { 2, "MU-BAR" },
  { 3, "MU-RTS" },
  { 4, "Buffer Status Report Poll (BSRP)" },
  { 5, "GCR MU-BAR" },
  { 6, "Bandwidth Query Report Poll (BQRP)" },
  { 7, "NDP Feedback Report Poll (NFRP)" },
  { 8, "Ranging" },
  /* 9-15 reserved */
  { 0, NULL }
};

static const val64_string bw_subfield_vals[] = {
  { 0, "20 MHz" },
  { 1, "40 MHz" },
  { 2, "80 MHz" },
  { 3, "80+80 MHz or 160 MHz" },
  { 0, NULL }
};

static const val64_string gi_and_ltf_type_subfield_vals[] = {
  { 0, "1x LTF + 1.6 us GI" },
  { 1, "2x LTF + 1.6 us GI" },
  { 2, "4x LTF + 3.2 us GI" },
  { 3, "Reserved" },
  { 0, NULL }
};

static const true_false_string mu_mimo_ltf_mode_tfs = {
  "HE masked HE LTF sequence mode",
  "HE single stream pilot HE LTF mode"
};

static int * const he_trig_frm_bar_ctrl_fields[] = {
  &hf_ieee80211_he_trigger_bar_ctrl_ba_ack_policy,
  &hf_ieee80211_he_trigger_bar_ctrl_ba_type,
  &hf_ieee80211_he_trigger_bar_ctrl_reserved,
  &hf_ieee80211_he_trigger_bar_ctrl_tid_info,
  NULL
};

static int * const he_trig_frm_bar_info_fields[] = {
  &hf_ieee80211_he_trigger_bar_info_blk_ack_seq_ctrl,
  NULL
};

#define PRE_FEC_PADDING_FACTOR 0x3
#define PE_DISAMBIGUITY 0x4

static void
ap_tx_power_custom(char *result, uint32_t ap_tx_power)
{
  if (ap_tx_power > 60)
    snprintf(result, ITEM_LABEL_LENGTH, "%s", "Reserved");
  else
    snprintf(result, ITEM_LABEL_LENGTH, "%d dBm", -20 + ap_tx_power);
}

static void
add_gcr_mu_bar_trigger_frame_common_info(proto_tree *tree, tvbuff_t *tvb,
  int offset)
{

  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                        hf_ieee80211_he_trigger_bar_ctrl,
                        ett_he_trigger_bar_ctrl,
                        he_trig_frm_bar_ctrl_fields,
                        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  offset += 2;

  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                        hf_ieee80211_he_trigger_bar_info,
                        ett_he_trigger_bar_info,
                        he_trig_frm_bar_info_fields,
                        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
}

static int * const common_info_headers[] = {
  &hf_ieee80211_he_trigger_type,
  &hf_ieee80211_he_trigger_ul_length,
  &hf_ieee80211_he_trigger_more_tf,
  &hf_ieee80211_he_trigger_cs_required,
  &hf_ieee80211_he_trigger_ul_bw,
  &hf_ieee80211_he_trigger_gi_and_ltf_type,
  &hf_ieee80211_he_trigger_mu_mimo_ltf_mode,
  &hf_ieee80211_he_trigger_num_he_ltf_syms_etc,
  &hf_ieee80211_he_trigger_ul_stbc,
  &hf_ieee80211_he_trigger_ldpc_extra_sym_seg,
  &hf_ieee80211_he_trigger_ap_tx_power,
  &hf_ieee80211_he_trigger_pre_fec_padding_factor,
  &hf_ieee80211_he_trigger_pe_disambiguity,
  &hf_ieee80211_he_trigger_ul_spatial_reuse,
  &hf_ieee80211_he_trigger_doppler,
  &hf_ieee80211_he_trigger_ul_he_sig_a_reserved,
  &hf_ieee80211_he_trigger_reserved,
  NULL
};

static int * const eht_common_info_headers[] = {
  &hf_ieee80211_eht_trigger_type,
  &hf_ieee80211_eht_trigger_ul_length,
  &hf_ieee80211_eht_trigger_more_tf,
  &hf_ieee80211_eht_trigger_cs_required,
  &hf_ieee80211_eht_trigger_ul_bw,
  &hf_ieee80211_eht_trigger_gi_and_eht_ltf_type,
  &hf_ieee80211_eht_trigger_reserved2,
  &hf_ieee80211_eht_trigger_num_he_eht_ltf_syms_etc,
  &hf_ieee80211_eht_trigger_reserved3,
  &hf_ieee80211_eht_trigger_ldpc_extra_sym_seg,
  &hf_ieee80211_eht_trigger_ap_tx_power,
  &hf_ieee80211_eht_trigger_pre_fec_padding_factor,
  &hf_ieee80211_eht_trigger_pe_disambiguity,
  &hf_ieee80211_eht_trigger_ul_spatial_reuse,
  &hf_ieee80211_eht_trigger_reserved4,
  &hf_ieee80211_eht_trigger_he_eht_p160,
  &hf_ieee80211_eht_trigger_special_user_info_flag,
  &hf_ieee80211_eht_trigger_eht_reserved,
  &hf_ieee80211_eht_trigger_reserved,
  NULL
};

static const val64_string pre_fec_padding_factor_vals[] = {
  { 0, "pre-FEC Padding Factor of 4" },
  { 1, "pre-FEC Padding Factor of 1" },
  { 2, "pre-FEC Padding Factor of 2" },
  { 3, "pre-FEC Padding Factor of 3" },
  { 0, NULL }
};

static true_false_string pe_disambiguity_tfs = {
  "PE Disambiguity ",
  "no PE Disambiguity"
 };

static int
add_trigger_common_info(proto_tree *tree, tvbuff_t *tvb, int offset,
  packet_info *pinfo _U_, uint8_t trigger_type, int *frame_len,
  proto_tree **common_tree)
{
  proto_item     *pi = NULL;
  proto_tree     *common_info = NULL;
  int            length = 0;
  int            start_offset = offset;
  uint64_t       bw_etc = tvb_get_letoh64(tvb, offset);
  bool           is_eht = ((bw_etc >> 54) & 0x03) != 0x03;

  global_he_trigger_bw = (bw_etc >> 18) & 0x03;

  common_info = proto_tree_add_subtree(tree, tvb, offset, -1,
                        ett_he_trigger_common_info, &pi, "Common Info");
  *common_tree = common_info;

  if (is_eht) {
    proto_tree_add_bitmask_with_flags(common_info, tvb, offset,
                        hf_ieee80211_eht_trigger_common_info,
                        ett_he_trigger_base_common_info,
                        eht_common_info_headers,
                        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  } else {
    proto_tree_add_bitmask_with_flags(common_info, tvb, offset,
                        hf_ieee80211_he_trigger_common_info,
                        ett_he_trigger_base_common_info,
                        common_info_headers,
                        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
  }
  offset += 8;
  length += 8;

  /*
   * Handle the trigger dependent common info
   */
  switch (trigger_type) {
    case TRIGGER_TYPE_GCR_MU_BAR: /* Actually two uint16 fields */
      add_gcr_mu_bar_trigger_frame_common_info(common_info, tvb, offset);
      offset += 4;
      length += 4;
      break;
    default: /* No other type has a trigger dependent common info subfield */
      break;
  }
  proto_item_set_len(pi, offset - start_offset);

  *frame_len += length;
  return length;
}

static const char * he_trigger_ru_allocation_region_values[] = {
  "primary 80MHz channel for 80+80 and 160MHz",
  "secondary 80MHz channel for 80+80 and 160MHz",
};

/*
 * Format the ru allocation region bit
 */
static void
he_trigger_ru_allocation_region_custom(char *result, uint32_t ru_alloc_val)
{
  if (global_he_trigger_bw == 3) {
    snprintf(result, ITEM_LABEL_LENGTH, "%s",
      he_trigger_ru_allocation_region_values[ru_alloc_val & 0x01]);
  } else {
    snprintf(result, ITEM_LABEL_LENGTH, "Not used for 20, 40 or 80MHz");
  }
}

static void
he_trigger_minus_one_custom(char *result, unsigned ss_alloc_value)
{
  snprintf(result, ITEM_LABEL_LENGTH, "%d", ss_alloc_value + 1);
}

static const true_false_string he_trigger_ul_fec_coding_type_tfs = {
  "LDPC",
  "BCC"
};

static const value_string preferred_ac_vals[] = {
  { 0, "AC_BE" },
  { 1, "AC_BK" },
  { 2, "AC_VI" },
  { 3, "AC_VO" },
  { 0, NULL }
};

static int * const basic_trigger_dependent_user_headers[] = {
  &hf_ieee80211_he_trigger_mpdu_mu_spacing,
  &hf_ieee80211_he_trigger_tid_aggregation_limit,
  &hf_ieee80211_he_trigger_dependent_reserved1,
  &hf_ieee80211_he_trigger_preferred_ac,
  NULL
};

static void
add_basic_trigger_dependent_user_info(proto_tree *tree, tvbuff_t *tvb,
  int offset)
{
  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                        hf_ieee80211_he_trigger_dep_basic_user_info,
                        ett_he_trigger_dep_basic_user_info,
                        basic_trigger_dependent_user_headers,
                        ENC_NA, BMT_NO_APPEND);
}

static void
add_brp_trigger_dependent_user_info(proto_tree *tree, tvbuff_t *tvb,
  int offset)
{
  proto_tree_add_item(tree, hf_ieee80211_he_trigger_feedback_seg_retrans_bm,
                        tvb, offset, 1, ENC_NA);
}

static int
add_mu_bar_trigger_dependent_user_info(proto_tree *tree, tvbuff_t *tvb,
  int offset, packet_info *pinfo, int *frame_len)
{
  int start_offset = offset;

  /*
   * It's a request and not DMG, I think. Also, it is only supposed to be
   * a compressed block ack or a multi-tid block ack request.
   */
  offset = dissect_ieee80211_block_ack_details(tvb, pinfo, tree, offset,
                        false, true, false);

  *frame_len += offset - start_offset;

  return offset;
}


static int * const nfrp_trigger_dependent_user_headers[] = {
  &hf_ieee80211_he_trigger_starting_aid,
  &hf_ieee80211_he_trigger_dependent_reserved2,
  &hf_ieee80211_he_trigger_feedback_type,
  &hf_ieee80211_he_trigger_dependent_reserved3,
  &hf_ieee80211_he_trigger_nfrp_target_rssi,
  &hf_ieee80211_he_trigger_multiplexing_flag,
  NULL
};

static void
add_nfrp_trigger_dependent_user_info(proto_tree *tree, tvbuff_t *tvb,
  int offset)
{
  proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                        hf_ieee80211_he_trigger_dep_nfrp_user_info,
                        ett_he_trigger_dep_nfrp_user_info,
                        nfrp_trigger_dependent_user_headers,
                        ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
}

/*
 * Dissect one of the ranging trigger types ...
 */
static int * const poll_rpt_hdrs[] = {
  &hf_ieee80211_ranging_pol_rpt_aid12_rsid12,
  &hf_ieee80211_ranging_pol_rpt_ru_alloc_region,
  &hf_ieee80211_ranging_pol_rpt_ru_alloc,
  &hf_ieee80211_ranging_pol_rpt_ul_fec_coding_type,
  &hf_ieee80211_ranging_pol_rpt_ulmcs,
  &hf_ieee80211_ranging_pol_rpt_uldcm,
  &hf_ieee80211_ranging_pol_rpt_starting_spatial_stream,
  &hf_ieee80211_ranging_pol_rpt_number_spatial_streams,
  &hf_ieee80211_ranging_pol_rpt_ul_target_rssi,
  &hf_ieee80211_ranging_pol_rpt_reserved,
  NULL
};

static int * const sounding_hdrs[] = {
  &hf_ieee80211_ranging_sounding_aid12_rsid12,
  &hf_ieee80211_ranging_sounding_reserved1,
  &hf_ieee80211_ranging_sounding_i2r_rep,
  &hf_ieee80211_ranging_sounding_reserved2,
  &hf_ieee80211_ranging_sounding_starting_spatial_stream,
  &hf_ieee80211_ranging_sounding_number_spatial_streams,
  &hf_ieee80211_ranging_sounding_ul_target_rssi,
  &hf_ieee80211_ranging_sounding_reserved3,
  NULL
};

static int * const sec_sound_hdrs[] = {
  &hf_ieee80211_ranging_sec_sound_aid12_rsid12,
  &hf_ieee80211_ranging_sec_sound_reserved1,
  &hf_ieee80211_ranging_sec_sound_i2r_rep,
  &hf_ieee80211_ranging_sec_sound_reserved2,
  &hf_ieee80211_ranging_sec_sound_starting_spatial_stream,
  &hf_ieee80211_ranging_sec_sound_number_spatial_streams,
  &hf_ieee80211_ranging_sec_sound_ul_target_rssi,
  &hf_ieee80211_ranging_sec_sound_reserved3,
  NULL
};

static int
dissect_ieee80211_ranging_trigger_variant(proto_tree *tree, tvbuff_t *tvb,
                                          int offset, packet_info *pinfo _U_,
                                          uint8_t subtype)
{
  int saved_offset = offset;

  switch (subtype) {
  case TRIGGER_SUBTYPE_POLL:
  case TRIGGER_SUBTYPE_REPORT:
    proto_tree_add_bitmask(tree, tvb, offset,
                           hf_ieee80211_he_trigger_ranging_trigger_poll_rpt,
                           ett_he_trigger_ranging_poll, poll_rpt_hdrs,
                           ENC_LITTLE_ENDIAN);
    offset += 5;
    break;
  case TRIGGER_SUBTYPE_SOUNDING: /* Sounding subvariant */
    proto_tree_add_bitmask(tree, tvb, offset,
                           hf_ieee80211_he_trigger_ranging_trigger_sounding,
                           ett_he_trigger_ranging_poll, sounding_hdrs,
                           ENC_LITTLE_ENDIAN);
    offset += 5;
    break;
  case TRIGGER_SUBTYPE_SECURE_SOUNDING:
    proto_tree_add_bitmask(tree, tvb, offset,
                           hf_ieee80211_he_trigger_ranging_trigger_sec_sound,
                           ett_he_trigger_ranging_poll, sec_sound_hdrs,
                           ENC_LITTLE_ENDIAN);
    offset += 5;

    proto_tree_add_item(tree, hf_ieee80211_he_trigger_ranging_user_info_sac,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    break;
  case TRIGGER_SUBTYPE_PASSIVE_TB_MEAS_EXCHANGE:
    /* This is much the same as SOUNDING subtype */
    proto_tree_add_bitmask(tree, tvb, offset,
                           hf_ieee80211_he_trigger_ranging_trigger_sounding,
                           ett_he_trigger_ranging_poll, sounding_hdrs,
                           ENC_LITTLE_ENDIAN);
    offset += 5;
    break;
  default:
    /* Unknown subtypes are filtered out above us. Should not get here! */
    DISSECTOR_ASSERT_NOT_REACHED();
    break;
  }

  return offset - saved_offset;
}

/*
 * Print the target RSSI field as per the spec.
 *  0->90 map to -110 to -20 dBm.
 *  127 maps to Max ransmit power for assigned MCS
 *  rest are reserved.
 */
static void
target_rssi_base_custom(char *result, uint32_t target_rssi)
{
  if (target_rssi <= 90) {
    snprintf(result, ITEM_LABEL_LENGTH, "%ddBm", -110 + target_rssi);
  } else if (target_rssi == 127) {
    snprintf(result, ITEM_LABEL_LENGTH, "Max transmit power");
  } else {
    snprintf(result, ITEM_LABEL_LENGTH, "Reserved");
  }
}

static int * const user_info_headers_no_2045[] = {
  &hf_ieee80211_he_trigger_aid12,
  &hf_ieee80211_he_trigger_ru_allocation_region,
  &hf_ieee80211_he_trigger_ru_allocation,
  &hf_ieee80211_he_trigger_ul_fec_coding_type,
  &hf_ieee80211_he_trigger_ul_mcs,
  &hf_ieee80211_he_trigger_ul_dcm,
  &hf_ieee80211_he_trigger_ru_starting_spatial_stream,
  &hf_ieee80211_he_trigger_ru_number_spatial_streams,
  &hf_ieee80211_he_trigger_ul_target_rssi,
  &hf_ieee80211_he_trigger_user_reserved,
  NULL
};

static int * const user_info_headers_2045[] = {
  &hf_ieee80211_he_trigger_aid12,
  &hf_ieee80211_he_trigger_ru_allocation_region,
  &hf_ieee80211_he_trigger_ru_allocation,
  &hf_ieee80211_he_trigger_ul_fec_coding_type,
  &hf_ieee80211_he_trigger_ul_mcs,
  &hf_ieee80211_he_trigger_ul_dcm,
  &hf_ieee80211_he_trigger_ru_number_ra_ru,
  &hf_ieee80211_he_trigger_ru_no_more_ra_ru,
  &hf_ieee80211_he_trigger_ul_target_rssi,
  &hf_ieee80211_he_trigger_user_reserved,
  NULL
};

static int * const user_info_headers_eht[] = {
  &hf_ieee80211_eht_trigger_aid12,
  &hf_ieee80211_eht_trigger_ru_allocation_region,
  &hf_ieee80211_eht_trigger_ru_allocation,
  &hf_ieee80211_eht_trigger_ul_fec_coding_type,
  &hf_ieee80211_eht_trigger_ul_eht_mcs,
  &hf_ieee80211_eht_trigger_user_info_reserved,
  &hf_ieee80211_eht_trigger_ru_starting_spatial_stream,
  &hf_ieee80211_eht_trigger_ru_number_spatial_streams,
  &hf_ieee80211_eht_trigger_ul_target_recv_power,
  &hf_ieee80211_eht_trigger_ps160,
  NULL
};

static int * const special_user_info_headers_eht[] = {
  &hf_ieee80211_eht_trigger_aid12,
  &hf_ieee80211_eht_trigger_phy_version_identifier,
  &hf_ieee80211_eht_trigger_ul_bw_extenstion,
  &hf_ieee80211_eht_trigger_eht_spatial_reuse_1,
  &hf_ieee80211_eht_trigger_eht_spatial_reuse_2,
  &hf_ieee80211_eht_trigger_disregard_u_sig_1,
  &hf_ieee80211_eht_trigger_validate_u_sig_2,
  &hf_ieee80211_eht_trigger_disregard_u_sig_2_4lsb,
  &hf_ieee80211_eht_trigger_disregard_u_sig_2_msb,
  &hf_ieee80211_eht_trigger_special_reserved,
  NULL
};

#define HE_USER_INFO      0
#define EHT_USER_INFO     1
#define SPECIAL_USER_INFO 2

static int
add_trigger_user_info(proto_tree *tree, tvbuff_t *tvb, int offset,
  packet_info *pinfo, uint8_t trigger_type, uint8_t subtype,
  uint8_t common_info_b54_55 _U_, int *frame_len, unsigned fcs_len)
{
  proto_item     *pi = NULL;
  proto_tree     *user_info = NULL;
  int            length = 0, range_len = 0;
  int            start_offset = offset;
  uint16_t        aid12_subfield = 0;
  unsigned       len_remaining = 0;
  bool           special_user_info;
  uint8_t        user_info_b39;
  bool           eht_variant = false;

  /*
   * If the AID12 subfield has the value 4095 it indicates the start of
   * the padding field.
   *
   * If the AID12 subfield has the value 2007, it indicates a special user
   * info field and combined with the common_info_b54_55 and B39 of the user
   * info field determines whether this field is an HE User Info field or an
   * EHT User Info field.
   */
  user_info = proto_tree_add_subtree(tree, tvb, offset, -1,
                        ett_he_trigger_user_info, &pi, "User Info");
  aid12_subfield = tvb_get_letohs(tvb, offset) & 0x0FFF;

  while (aid12_subfield != 4095) {
    /* Compute the special user info and EHT Variant for each one. */
    special_user_info = aid12_subfield == 2007;
    user_info_b39 = tvb_get_uint8(tvb, offset + 4) >> 7;

    /* 9.3.1.22.4 of 802.11be and table 9-45a */
    if ((common_info_b54_55 == 0x01 && special_user_info && user_info_b39) ||
        (common_info_b54_55 == 0x00 && special_user_info))
      eht_variant = true;

    switch (trigger_type) {
      case TRIGGER_TYPE_BASIC:
      case TRIGGER_TYPE_BRP:
      case TRIGGER_TYPE_MU_BAR:
      case TRIGGER_TYPE_MU_RTS:
      case TRIGGER_TYPE_BSRP:
      case TRIGGER_TYPE_GCR_MU_BAR:
      case TRIGGER_TYPE_BQRP:
        if (!eht_variant) {
          if (aid12_subfield != 0 && aid12_subfield != 2045)
            proto_tree_add_bitmask_with_flags(user_info, tvb, offset,
                                hf_ieee80211_he_trigger_user_info,
                                ett_he_trigger_base_user_info,
                                user_info_headers_no_2045,
                                ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
          else
            proto_tree_add_bitmask_with_flags(user_info, tvb, offset,
                                hf_ieee80211_he_trigger_user_info,
                                ett_he_trigger_base_user_info,
                                user_info_headers_2045,
                                ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
        } else {
          /* Is it a special user info? */
          if (special_user_info) {
            proto_tree_add_bitmask_with_flags(user_info, tvb, offset,
                                hf_ieee80211_eht_trigger_special_user_info,
                                ett_he_trigger_base_user_info,
                                special_user_info_headers_eht,
                                ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
          } else {
            proto_tree_add_bitmask_with_flags(user_info, tvb, offset,
                                hf_ieee80211_eht_trigger_user_info,
                                ett_he_trigger_base_user_info,
                                user_info_headers_eht,
                                ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
          }
        }
        offset += 5;
        length += 5;
        break;
      case TRIGGER_TYPE_NFRP:
        add_nfrp_trigger_dependent_user_info(user_info, tvb, offset);
        offset += 5;
        length += 5;
        break;
      case TRIGGER_TYPE_RANGING:
        range_len = dissect_ieee80211_ranging_trigger_variant(user_info, tvb,
                                                offset, pinfo, subtype);
        if (range_len == 0) {
          /* XXX - unknown subtype, report this somehow */
          goto out;
        }
        offset += range_len;
        length += range_len;
        break;
      default:
        /* Should never get here */
        break;
    }


    /*
     * Handle the trigger dependent user info
     */
    switch (trigger_type) {
      case TRIGGER_TYPE_BASIC:
        add_basic_trigger_dependent_user_info(user_info, tvb, offset);
        offset++;
        length++;
        break;
      case TRIGGER_TYPE_BRP:
        add_brp_trigger_dependent_user_info(user_info, tvb, offset);
        offset++;
        length++;
        break;
      case TRIGGER_TYPE_MU_BAR:
        /* This is variable length so we need it to update the length */
        offset = add_mu_bar_trigger_dependent_user_info(user_info, tvb,
                                offset, pinfo, &length);
        break;
      default:
        break;
    }

    len_remaining = tvb_reported_length_remaining(tvb, offset);
    if (len_remaining < 5)
      aid12_subfield = 4095;
    else
      aid12_subfield = tvb_get_letohs(tvb, offset) & 0xFFF;
  }

out:

  if (aid12_subfield == 4095 && len_remaining >= 5) {
    /* Show the Start of Padding field. */
    proto_tree_add_item(user_info,
                        hf_ieee80211_he_trigger_user_info_padding_start,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

  }

  proto_item_set_len(pi, offset - start_offset);

  /* Now, treat all the rest of the frame as padding */
  if (aid12_subfield == 4095 && len_remaining >= 5) {
    proto_tree_add_item(tree, hf_ieee80211_he_trigger_padding, tvb, offset,
                        tvb_reported_length_remaining(tvb, offset) - fcs_len,
                        ENC_NA);
  }

  *frame_len += length;
  return length;
}

static const range_string ranging_trigger_subtype_vals[] = {
  { 0, 0, "Poll" },
  { 1, 1, "Sounding" },
  { 2, 2, "Secured Sounding" },
  { 3, 3, "Report" },
  { 4, 4, "Passive TB Measurement Exchange" },
  { 5, 15, "Reserved" },
  { 0, 0, NULL},
};

static int * const ranging_headers1[] = {
  &hf_ieee80211_ranging_trigger_subtype1,
  &hf_ieee80211_ranging_trigger_reserved1,
  &hf_ieee80211_ranging_trigger_token,
  NULL
};

static int * const ranging_headers2[] = {
  &hf_ieee80211_ranging_trigger_subtype2,
  &hf_ieee80211_ranging_trigger_reserved2,
  &hf_ieee80211_ranging_trigger_sounding_dialog_token,
  NULL
};

static int
dissect_ieee80211_he_eht_trigger(tvbuff_t *tvb, packet_info *pinfo,
  proto_tree *tree, int offset, unsigned fcs_len)
{
  proto_tree        *common_tree = NULL;
  uint8_t           trigger_type;
  uint8_t           subtype = 0;
  int               length = 0;
  uint8_t           common_info_b54_55;
  bool              eht_trigger = true;

  proto_tree_add_mac48_detail(&mac_ta, &mac_addr, ett_addr, tvb, tree, offset);

  offset += 6;
  length += 6;

  if (tvb_captured_length_remaining(tvb, offset) < 8) {
    expert_add_info_format(pinfo, tree, &ei_ieee80211_missing_data,
                           "Invalid Trigger frame, not enough data for the "
                           "Common Info field.");
    return tvb_captured_length(tvb);
  }

  trigger_type = tvb_get_uint8(tvb, offset) & 0x0F;
  common_info_b54_55 = tvb_get_uint8(tvb, offset + 6);
  if ((common_info_b54_55 >> 6) == 0x03)
    eht_trigger = false;

  col_append_fstr(pinfo->cinfo, COL_INFO, " %s %s",
                eht_trigger ? "EHT" : "HE",
                val64_to_str(trigger_type, trigger_type_vals, "Reserved"));

  if (trigger_type >= TRIGGER_TYPE_MIN_RESERVED) {
    /* Add an Expert Info and forget it */
    proto_item *item;

    item = proto_tree_add_item(tree, hf_ieee80211_he_trigger_type, tvb, offset,
                               1, ENC_NA);
    expert_add_info_format(pinfo, item, &ei_ieee80211_inv_val,
                           "Trigger type too large: %u", trigger_type);
    return tvb_captured_length_remaining(tvb, offset) + length;
  }

  /*
   * Deal with the common Info and then any user info after that.
   */
  offset += add_trigger_common_info(tree, tvb, offset, pinfo,
                        trigger_type, &length, &common_tree);

  /*
   * If the trigger type is Ranging Trigger type, then deal with it separately.
   */
  if (trigger_type == TRIGGER_TYPE_RANGING) {
    subtype = tvb_get_uint8(tvb, offset) & 0x0f;

    col_append_fstr(pinfo->cinfo, COL_INFO, ": %s",
                    rval_to_str_const(subtype, ranging_trigger_subtype_vals, "Reserved"));

    if (subtype >= TRIGGER_SUBTYPE_MIN_RESERVED) {
      proto_item *item;

      item = proto_tree_add_item(tree, hf_ieee80211_ranging_trigger_subtype1,
                                 tvb, offset, 1, ENC_NA);
      expert_add_info_format(pinfo, item, &ei_ieee80211_inv_val,
                             "Ranging trigger subtype too large: %u", subtype);
      return tvb_captured_length_remaining(tvb, offset) + length;
    }

    switch (subtype) {
    case TRIGGER_SUBTYPE_POLL:
    case TRIGGER_SUBTYPE_SOUNDING:
    case TRIGGER_SUBTYPE_SECURE_SOUNDING:
    case TRIGGER_SUBTYPE_REPORT:
      proto_tree_add_bitmask(common_tree, tvb, offset,
                             hf_ieee80211_he_trigger_ranging_common_info_1,
                             ett_he_trigger_ranging, ranging_headers1,
                             ENC_NA);
      offset += 1;
      break;
    case TRIGGER_SUBTYPE_PASSIVE_TB_MEAS_EXCHANGE:
      proto_tree_add_bitmask(common_tree, tvb, offset,
                             hf_ieee80211_he_trigger_ranging_common_info_2,
                             ett_he_trigger_ranging, ranging_headers2,
                             ENC_NA);
      offset += 2;
      break;
    default:
      /* We should never get here! */
      DISSECTOR_ASSERT_NOT_REACHED();
      break;
    }
  }

  add_trigger_user_info(tree, tvb, offset, pinfo, trigger_type, subtype,
                        common_info_b54_55, &length, fcs_len);

  /*
   *  Padding should commence here ... TODO, deal with it.
   */

  return length;
}

static int * const tack_headers[] = {
  &hf_ieee80211_tack_next_twt,
  &hf_ieee80211_tack_flow_identifier,
  NULL
};

static int
dissect_ieee80211_s1g_tack(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, uint16_t flags)
{
  int             length = 0;

  proto_tree_add_mac48_detail(&mac_ta, &mac_addr, ett_addr, tvb, tree, offset);

  offset += 6;
  length += 6;

  proto_tree_add_item(tree, hf_ieee80211_beacon_sequence, tvb, offset, 1,
                      ENC_NA);
  offset += 1;
  length += 1;

  proto_tree_add_item(tree, hf_ieee80211_pentapartial_timestamp, tvb, offset,
                      5, ENC_NA);
  offset += 5;
  length += 5;

   if ((flags & 0xC0) == 0xC0)  {
     proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                        hf_ieee80211_tack_next_twt_info, ett_tack_info,
                        tack_headers, ENC_NA, BMT_NO_APPEND);
     length += 6;
   }

   return length;
}

/*
 * Dissect a VHT or an HE NDP accouncement frame. They differ past
 * the sounding dialog token with a bit in the SDT indicating VHT vs HE.
 */
#define NDP_ANNC_VHT_HE 0x02

static const value_string ndp_annc_variant_vals[] = {
  { 0, "VHT NDP Announcement" },
  { 1, "Ranging NDP Announcement" },
  { 2, "HE NDP Announcement" },
  { 3, "EHT NDP Announcement" },
  { 0, NULL }
};

static int * const sta_info_ranging_2008[] = {
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_aid11,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_ltf_offset,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_r2i_n_sts,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_r2i_rep,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_i2r_n_sts,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_reserved1,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_disambiguation,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_i2r_rep,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_reserved2,
  NULL
};

static int * const sta_info_ranging_2043[] = {
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2043_aid11,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2043_sac,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2043_disambiguation,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2043_reserved,
  NULL
};

static int * const sta_info_ranging_2044[] = {
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2044_aid11,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2044_partial_tsf,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2044_disambiguation,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2044_reserved,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2044_token,
  NULL
};

static int * const sta_info_ranging_2045[] = {
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2045_aid11,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2045_i2r_ndp_tx_power,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2045_r2i_ndp_target_rssi,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2045_disambiguation,
  &hf_ieee80211_vht_ndp_annc_sta_info_ranging_2045_reserved,
  NULL
};

static int
dissect_ieee80211_ranging_ndp_annc(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, bool has_fcs)
{
  uint8_t          len_fcs = 0;
  proto_tree      *sta_list;
  proto_item      *sta_info_item, *pi;
  int              saved_offset = 0;
  int              sta_index = 0;

  if (has_fcs){
    len_fcs = 4;
  }

  sta_list = proto_tree_add_subtree(tree, tvb, offset, -1,
                        ett_ndp_ranging_annc_sta_list, &pi, "STA list");
  saved_offset = offset;

  while (tvb_reported_length_remaining(tvb, offset) > len_fcs) {
    uint16_t aid11;

    sta_info_item = proto_tree_add_subtree_format(sta_list, tvb, offset, 2,
                        ett_ndp_ranging_annc_sta_info, NULL, "STA %d",
                        sta_index++);

    aid11 = tvb_get_uint16(tvb, offset, ENC_LITTLE_ENDIAN) & 0x7ff;
    if (aid11 < 2008) {
      proto_tree_add_bitmask_with_flags(sta_info_item, tvb, offset,
                            hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008,
                            ett_vht_ranging_annc, sta_info_ranging_2008,
                            ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    } else if (aid11 == 2043) {
      proto_tree_add_bitmask_with_flags(sta_info_item, tvb, offset,
                            hf_ieee80211_vht_ndp_annc_sta_info_ranging_2043,
                            ett_vht_ranging_annc, sta_info_ranging_2043,
                            ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    } else if (aid11 == 2044) {
      proto_tree_add_bitmask_with_flags(sta_info_item, tvb, offset,
                            hf_ieee80211_vht_ndp_annc_sta_info_ranging_2044,
                            ett_vht_ranging_annc, sta_info_ranging_2044,
                            ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    } else if (aid11 == 2045) {
      proto_tree_add_bitmask_with_flags(sta_info_item, tvb, offset,
                            hf_ieee80211_vht_ndp_annc_sta_info_ranging_2045,
                            ett_vht_ranging_annc, sta_info_ranging_2045,
                            ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    }
    offset += 4;
  }

  proto_item_set_len(pi, offset - saved_offset);
  return offset;
}

static int
dissect_ieee80211_vht_ndp_annc(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, bool has_fcs)
{
  uint16_t         sta_info;
  uint8_t          len_fcs = 0;
  proto_tree      *sta_list;
  proto_item      *sta_info_item, *pi;
  int              saved_offset = 0;
  int              sta_index = 0;

  if (has_fcs){
    len_fcs = 4;
  }

  sta_list = proto_tree_add_subtree(tree, tvb, offset, -1,
                        ett_ndp_vht_annc_sta_list, &pi, "STA list");
  saved_offset = offset;

  while (tvb_reported_length_remaining(tvb, offset) > len_fcs) {
    sta_info_item = proto_tree_add_subtree_format(sta_list, tvb, offset, 2,
                        ett_ndp_vht_annc_sta_info_tree, NULL, "STA %d",
                        sta_index++);

    proto_tree_add_item(sta_info_item, hf_ieee80211_vht_ndp_annc_sta_info_aid12,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(sta_info_item,
                        hf_ieee80211_vht_ndp_annc_sta_info_feedback_type,
                        tvb, offset, 2, ENC_LITTLE_ENDIAN);

    sta_info = tvb_get_letohs(tvb, offset);

    if (sta_info & 0x1000)
      proto_tree_add_uint(sta_info_item,
                          hf_ieee80211_vht_ndp_annc_sta_info_nc_index,
                          tvb, offset, 2, sta_info);
    else
      proto_tree_add_item(sta_info_item,
                          hf_ieee80211_vht_ndp_annc_sta_info_reserved,
                          tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
  }

  proto_item_set_len(pi, offset - saved_offset);
  return offset;
}

static int * const he_ndp_sta_headers[] = {
  &hf_ieee80211_he_ndp_annc_aid11,
  &hf_ieee80211_he_ndp_annc_ru_start,
  &hf_ieee80211_he_ndp_annc_ru_end,
  &hf_ieee80211_he_ndp_annc_feedback_type_and_ng,
  &hf_ieee80211_he_ndp_annc_disambiguation,
  &hf_ieee80211_he_ndp_annc_codebook_size,
  &hf_ieee80211_he_ndp_annc_nc,
  NULL
};

static int * const he_ndp_annc_2047_hdrs[] = {
  &hf_ieee80211_he_ndp_annc_aid11,
  &hf_ieee80211_he_ndp_annc_disallowed_bitmap,
  &hf_ieee80211_he_ndp_annc_reserved1,
  &hf_ieee80211_he_ndp_annc_disambiguation,
  &hf_ieee80211_he_ndp_annc_reserved2,
  NULL
};

static int
dissect_ieee80211_he_ndp_annc(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, bool has_fcs)
{
  uint8_t          len_fcs = 0;
  proto_tree      *sta_list;
  proto_item      *pi;
  int              saved_offset;
  int              sta_index = 0;

  if (has_fcs){
    len_fcs = 4;
  }

  saved_offset = offset;
  sta_list = proto_tree_add_subtree(tree, tvb, offset, -1,
                        ett_ndp_he_annc_sta_list, &pi, "STA list");

  while (tvb_reported_length_remaining(tvb, offset) > len_fcs) {
    proto_tree *sta_item;
    uint32_t sta_info = tvb_get_letohl(tvb, offset);

    sta_item = proto_tree_add_subtree_format(sta_list, tvb, offset, 4,
                        ett_ndp_he_annc_sta_item, NULL, "STA %d", sta_index++);
    if ((sta_info & 0x000007ff) < 2047) {
      proto_tree_add_bitmask_with_flags(sta_item, tvb, offset,
                        hf_ieee80211_he_ndp_annc_sta,
                        ett_ndp_he_annc_sta_info,
                        he_ndp_sta_headers, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);
    } else {
      proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                        hf_ieee80211_he_ndp_annc_sta,
                        ett_ndp_he_annc_sta_info,
                        he_ndp_annc_2047_hdrs, ENC_LITTLE_ENDIAN,
                        BMT_NO_APPEND);
    }

    offset += 4;
  }

  proto_item_set_len(pi, offset - saved_offset);
  return offset;
}

static int * const eht_ndp_annc_hdrs[] = {
  &hf_ieee80211_ndp_eht_annc_aid11,
  &hf_ieee80211_ndp_eht_annc_resolution,
  &hf_ieee80211_ndp_eht_annc_feedback_map,
  &hf_ieee80211_ndp_eht_annc_reserved1,
  &hf_ieee80211_ndp_eht_annc_nc_index,
  &hf_ieee80211_ndp_eht_annc_feedback_type,
  &hf_ieee80211_ndp_eht_annc_disambiguation,
  &hf_ieee80211_ndp_eht_annc_codebook_size,
  &hf_ieee80211_ndp_eht_annc_reserved2,
  NULL
};

static int
dissect_ieee80211_eht_ndp_annc(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, bool has_fcs)
{
  uint8_t          len_fcs = 0;
  proto_tree      *sta_list;
  proto_item      *pi;
  int              saved_offset;

  if (has_fcs){
    len_fcs = 4;
  }

  saved_offset = offset;
  sta_list = proto_tree_add_subtree(tree, tvb, offset, -1,
                        ett_ndp_eht_annc_sta_list, &pi, "STA list");

  while (tvb_reported_length_remaining(tvb, offset) > len_fcs) {

    proto_tree_add_bitmask_with_flags(sta_list, tvb, offset,
                            hf_ieee80211_ndp_eht_annc_sta_info,
                            ett_ndp_eht_annc_sta_info,
                            eht_ndp_annc_hdrs, ENC_LITTLE_ENDIAN,
                            BMT_NO_APPEND);
    offset += 4;
  }

  proto_item_set_len(pi, offset - saved_offset);
  return offset;
}

static int * const ndp_annc_headers[] = {
  &hf_ieee80211_ndp_annc_variant,
  &hf_ieee80211_ndp_annc_token_number,
  NULL
};

static int
dissect_ieee80211_ndp_annc(tvbuff_t *tvb, packet_info *pinfo _U_,
  proto_tree *tree, int offset, bool has_fcs)
{
  proto_item      *dialog;
  uint8_t          dialog_token;

  proto_tree_add_mac48_detail(&mac_ta, &mac_addr, ett_addr, tvb, tree, offset);
  offset += 6;

  dialog_token = tvb_get_uint8(tvb, offset);
  col_append_fstr(pinfo->cinfo, COL_INFO, ", Sounding Dialog Token=%d",
                  dialog_token);

  dialog = proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                        hf_ieee80211_ndp_annc_token, ett_ndp_annc,
                        ndp_annc_headers, ENC_NA, BMT_NO_APPEND);

  offset++;

  if ((dialog_token & 0x03) == 0x00) {
    proto_item_append_text(dialog, " VHT NDP Announcement");
    return dissect_ieee80211_vht_ndp_annc(tvb, pinfo, tree, offset, has_fcs);
  } else if ((dialog_token & 0x03) == 0x01) {
    proto_item_append_text(dialog, " Ranging NDP Announcement");
    return dissect_ieee80211_ranging_ndp_annc(tvb, pinfo, tree, offset,
                                              has_fcs);
  } else if ((dialog_token & 0x03) == 0x02) {
    proto_item_append_text(dialog, " HE NDP Announcement");
    return dissect_ieee80211_he_ndp_annc(tvb, pinfo, tree, offset, has_fcs);
  } else if ((dialog_token & 0x03) == 0x03) {
    proto_item_append_text(dialog, " EHT NDP Announcement");
    return dissect_ieee80211_eht_ndp_annc(tvb, pinfo, tree, offset, has_fcs);
  } else {
    DISSECTOR_ASSERT_NOT_REACHED();
  }

  return offset;
}

static void
set_src_addr_cols(packet_info *pinfo, tvbuff_t *tvb, int offset, int type)
{
  set_address_tvb(&pinfo->dl_src, type, 6, tvb, offset);
  copy_address_shallow(&pinfo->src, &pinfo->dl_src);
  // Should we call proto_tree_add_mac48_detail here?
}

static void
set_dst_addr_cols(packet_info *pinfo, tvbuff_t *tvb, int offset, int type)
{
  set_address_tvb(&pinfo->dl_dst, type, 6, tvb, offset);
  copy_address_shallow(&pinfo->dst, &pinfo->dl_dst);
  // Should we call proto_tree_add_mac48_detail here?
}

static uint32_t
crc32_802_tvb_padded(tvbuff_t *tvb, unsigned hdr_len, unsigned hdr_size, unsigned len)
{
  uint32_t c_crc;

  c_crc = crc32_ccitt_tvb(tvb, hdr_len);
  c_crc = crc32_ccitt_tvb_offset_seed(tvb, hdr_size, len, ~c_crc);

  return (c_crc);
}

/*
 * Check if the SA at offset is that of an S1G STA, and if so, and the
 * IS_S1G_KEY with true.
 */
static void
check_s1g_setting(packet_info *pinfo, tvbuff_t *tvb, int offset)
{
  uint8_t *src_addr[6];
  tvb_memcpy(tvb, src_addr, offset, 6);
  unsigned result = GPOINTER_TO_UINT(wmem_map_lookup(sta_prop_hash, &src_addr));
  if (result == STA_IS_S1G) {
    p_add_proto_data(wmem_file_scope(), pinfo, proto_wlan, IS_S1G_KEY, GINT_TO_POINTER(true));
  }
}

typedef enum {
    ENCAP_802_2,
    ENCAP_IPX,
    ENCAP_ETHERNET,
    ENCAP_EPD
} encap_t;

/*
 * Dissect a Protocol Version 1 frame
 */

static const value_string pv1_frame_type_vals[] = {
  { 0, "PV1 QoS Data - with one SID" },
  { 1, "PV1 Management" },
  { 2, "PV1 Control" } ,
  { 3, "PV1 QoS Data - no SIDs" },
  { 4, "PV1 Reserved" },
  { 5, "PV1 Reserved" },
  { 6, "PV1 Reserved" },
  { 7, "PV1 Extension (currently reserved)" },
  { 0, NULL }
};

static const value_string pv1_control_frame_type_vals[] = {
  { 0, "STACK" },
  { 1, "BAT" },
  { 2, "Reserved" },
  { 3, "Reserved" },
  { 4, "Reserved" },
  { 5, "Reserved" },
  { 6, "Reserved" },
  { 7, "Reserved" },
  { 0, NULL }
};

static const value_string pv1_management_frame_type_vals[] = {
  { 0, "Action" },
  { 1, "Action No Ack" },
  { 2, "PV1 Probe Response" },
  { 3, "Resource Allocation" },
  { 4, "Reserved" },
  { 5, "Reserved" },
  { 6, "Reserved" },
  { 7, "Reserved" },
  { 0, NULL }
};

static const value_string pv1_bandwidth_indic_vals[] = {
  { 0, "1 MHz" },
  { 1, "2 MHz" },
  { 2, "4 MHz" },
  { 3, "8 MHz" },
  { 4, "16 MHz" },
  { 5, "Reserved" },
  { 6, "Reserved" },
  { 7, "Reserved" },
  { 0, NULL },
};

/*
 * Extract the three interesting flags from an SID, however, only set
 * the respective booleans if the flag is set in the SID.
 */
static void
extract_a3_a4_amsdu(uint16_t sid, bool *a3_present, bool *a4_present,
                    bool *a_msdu)
{
  if (sid & SID_A3_PRESENT)
    *a3_present = true;
  if (sid & SID_A4_PRESENT)
    *a4_present = true;
  if (sid & SID_A_MSDU)
    *a_msdu = true;
}

static int
wlan_aid_to_str(const address* addr, char* buf, int buf_len)
{
    int ret;

    ret = snprintf(buf, buf_len, "0x%04"PRIx16, *(uint16_t *)addr->data);

    return ret + 1;
}

static int
wlan_aid_str_len(const address* addr _U_)
{
    return sizeof("0x0000");
}

#if 0
/* The length is 2 bytes, but tvb_address_to_str() etc. don't have a way of
 * dealing with addresses that need to mask out bits in the tvb. */
static int
wlan_aid_len(void)
{
    return 2;
}
#endif

/*
 * If we know the AID, then translated it to an Ethernet addr, otherwise
 * just place the AID in the correct col
 */
static void
set_sid_addr_cols(packet_info *pinfo, uint16_t sid, bool dst)
{
  uint16_t* aid = wmem_new0(pinfo->pool, uint16_t);
  *aid = sid & SID_AID_MASK;
  if (dst) {
    set_address(&pinfo->dl_dst, wlan_aid_address_type, (int)sizeof(*aid), aid);
    copy_address_shallow(&pinfo->dst, &pinfo->dl_dst);
  } else {
    set_address(&pinfo->dl_src, wlan_aid_address_type, (int)sizeof(*aid), aid);
    copy_address_shallow(&pinfo->src, &pinfo->dl_src);
  }
}

static int * const sid_headers[] = {
  &hf_ieee80211_pv1_sid_association_id,
  &hf_ieee80211_pv1_sid_a3_present,
  &hf_ieee80211_pv1_sid_a4_present,
  &hf_ieee80211_pv1_sid_a_msdu,
  NULL
};

static void
dissect_pv1_sid(proto_tree *tree, packet_info *pinfo _U_, tvbuff_t *tvb,
                unsigned offset)
{
  proto_tree_add_bitmask(tree, tvb, offset, hf_ieee80211_pv1_sid,
                         ett_pv1_sid_field, sid_headers, ENC_LITTLE_ENDIAN);

}

static void
dissect_pv1_sequence_control(proto_tree *tree, packet_info *pinfo _U_,
                             tvbuff_t *tvb, unsigned offset)
{
  proto_tree *seq_ctrl_tree = NULL;

  seq_ctrl_tree = proto_tree_add_subtree(tree, tvb, offset, 2,
                                         ett_pv1_seq_control, NULL,
                                         "Sequence Control");
  proto_tree_add_item(seq_ctrl_tree, hf_ieee80211_frag_number, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  proto_tree_add_item(seq_ctrl_tree, hf_ieee80211_seq_number, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
}

static int
dissect_pv1_data(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_,
                 int offset, bool a_msdu _U_, struct ieee_802_11_phdr *phdr _U_,
                 unsigned len_no_fcs _U_)
{

  return offset;
}

static int
dissect_pv1_mgmt_action(tvbuff_t *tvb _U_, packet_info *pinfo _U_,
                        proto_tree *tree _U_, int offset _U_,
                        struct ieee_802_11_phdr *phdr _U_,
                        unsigned len _U_)
{
  proto_tree *mgmt_action_tree = NULL;

  mgmt_action_tree = proto_tree_add_subtree(tree, tvb, offset, 4,
                                            ett_pv1_mgmt_action, NULL,
                                            "Action");
  dissect_mgt_action(tvb, pinfo, mgmt_action_tree, offset, NULL);

  return offset;
}

static int
dissect_pv1_mgmt_action_no_ack(tvbuff_t *tvb _U_, packet_info *pinfo _U_,
                               proto_tree *tree _U_, int offset _U_,
                               struct ieee_802_11_phdr *phdr _U_,
                               unsigned len _U_)
{
  proto_tree *mgmt_action_tree = NULL;

  mgmt_action_tree = proto_tree_add_subtree(tree, tvb, offset, 4,
                                            ett_pv1_mgmt_action, NULL,
                                            "Action No Ack");
  dissect_mgt_action(tvb, pinfo, mgmt_action_tree, offset, NULL);

  return offset;
}

#define PV1_NEXT_TBTT_PRESENT 0x0100
#define PV1_FULL_SSID_PRESENT 0x0200
#define PV1_ANO_PRESENT       0x0400

static int
dissect_pv1_mgmt_probe_response(tvbuff_t *tvb _U_, packet_info *pinfo _U_,
                                proto_tree *tree _U_, int offset _U_,
                                struct ieee_802_11_phdr *phdr _U_,
                                unsigned len _U_, uint16_t frame_control _U_)
{

  return offset;
}

static int
dissect_pv1_mgmt_resource_alloc(tvbuff_t *tvb _U_, packet_info *pinfo _U_,
                                proto_tree *tree _U_, int offset _U_,
                                struct ieee_802_11_phdr *phdr _U_,
                                unsigned len _U_, uint16_t frame_control _U_)
{

  return offset;
}

static int
dissect_pv1_management(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_,
                 int offset, struct ieee_802_11_phdr *phdr _U_, uint8_t subtype,
                 unsigned len_no_fcs, uint16_t frame_control _U_)
{

  /*
   * XXX - We add COMPOSE_FRAME_TYPE(fcf) (which doesn't work for PV1) as
   * proto_data FRAME_TYPE_KEY for PV0. Do we need to put something here?
   */
  switch (subtype) {
    case PV1_MANAGEMENT_ACTION:
      offset = dissect_pv1_mgmt_action(tvb, pinfo, tree, offset, phdr, len_no_fcs);
      break;
    case PV1_MANAGEMENT_ACTION_NO_ACK:
      offset = dissect_pv1_mgmt_action_no_ack(tvb, pinfo, tree, offset, phdr, len_no_fcs);
      break;
    case PV1_MANAGEMENT_PROBE_RESPONSE:
      offset = dissect_pv1_mgmt_probe_response(tvb, pinfo, tree, offset, phdr, len_no_fcs, frame_control);
      break;
    case PV1_MANAGEMENT_RESOURCE_ALLOC:
      offset = dissect_pv1_mgmt_resource_alloc(tvb, pinfo, tree, offset, phdr, len_no_fcs, frame_control);
      break;
    default:
      proto_tree_add_item(tree, hf_ieee80211_pv1_mgmt_reserved, tvb, offset,
                          len_no_fcs, ENC_NA);
      offset = len_no_fcs;
  }

  return offset;
}

static int
dissect_pv1_control_stack(tvbuff_t *tvb, packet_info *pinfo _U_,
                          proto_tree *tree, int offset,
                          struct ieee_802_11_phdr *phdr _U_,
                          unsigned len _U_, uint16_t frame_control _U_)
{
  proto_tree *stack_tree = NULL;

  stack_tree = proto_tree_add_subtree(tree, tvb, offset, 4, ett_pv1_cntl_stack,
                                      NULL, "STACK");
  proto_tree_add_item(stack_tree, hf_ieee80211_pv1_cnt_stack_tetra_timest,
                      tvb, offset, 4, ENC_LITTLE_ENDIAN);
  offset += 4;

  return offset;
}

static int
dissect_pv1_control_bat(tvbuff_t *tvb, packet_info *pinfo _U_,
                        proto_tree *tree, int offset,
                        struct ieee_802_11_phdr *phdr _U_,
                        unsigned len _U_,
                        uint16_t frame_control _U_)
{
  proto_tree *bat_tree = NULL;

  bat_tree = proto_tree_add_subtree(tree, tvb, offset, 4, ett_pv1_cntl_stack,
                                      NULL, "BAT");

  proto_tree_add_item(bat_tree, hf_ieee80211_pv1_cnt_bat_beacon_seq, tvb,
                      offset, 1, ENC_NA);
  offset += 1;

  proto_tree_add_item(bat_tree, hf_ieee80211_pv1_cnt_bat_penta_timest, tvb,
                      offset, 5, ENC_LITTLE_ENDIAN);
  offset += 5;

  proto_tree_add_item(bat_tree, hf_ieee80211_pv1_cnt_bat_next_twt_info, tvb,
                      offset, 6, ENC_LITTLE_ENDIAN);
  offset += 6;

  proto_tree_add_item(bat_tree, hf_ieee80211_pv1_cnt_bat_stating_seq_cntl, tvb,
                      offset, 2, ENC_LITTLE_ENDIAN);
  offset += 6;

  proto_tree_add_item(bat_tree, hf_ieee80211_pv1_cnt_bat_bitmap, tvb, offset,
                      4, ENC_LITTLE_ENDIAN);
  offset += 4;

  return offset;
}

static int
dissect_pv1_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
                 int offset, struct ieee_802_11_phdr *phdr, uint8_t subtype,
                 unsigned len_no_fcs, uint16_t frame_control)
{
  switch (subtype) {
    case PV1_CONTROL_STACK:
      offset = dissect_pv1_control_stack(tvb, pinfo, tree, offset, phdr, len_no_fcs, frame_control);
      break;

    case PV1_CONTROL_BAT:
      offset = dissect_pv1_control_bat(tvb, pinfo, tree, offset, phdr, len_no_fcs, frame_control);
      break;

    default:
      proto_tree_add_item(tree, hf_ieee80211_pv1_cntl_reserved, tvb, offset,
                          len_no_fcs, ENC_NA);
      offset = len_no_fcs;
  }

  return offset;
}

static int
dissect_ieee80211_pv1(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,
                      struct ieee_802_11_phdr *phdr)
{
  uint16_t     fcf;
  uint8_t      type, subtype, from_ds;
  unsigned     offset = 0;
  const char *fts_str = NULL;
  proto_item  *ti;
  proto_tree  *hdr_tree;
  proto_item  *fc_item = NULL;
  proto_tree  *fc_tree = NULL;
  bool        a1_is_sid = false;
  bool        a2_is_sid = false;
  bool        a3_present = false;
  bool        a4_present = false;
  bool        a_msdu = false;
  unsigned    len = tvb_reported_length_remaining(tvb, offset);
  unsigned    len_no_fcs = len;
  proto_tree  *mgt_tree;

  fcf = tvb_get_letohs(tvb, offset);

  type = FCF_PV1_TYPE(fcf);
  subtype = FCF_PV1_SUBTYPE(fcf);

  fts_str = val_to_str(type, pv1_frame_type_vals, "Unrecognized frame type (%d)");
  col_set_str(pinfo->cinfo, COL_INFO, fts_str);

  /* Create the protocol tree */
  ti = proto_tree_add_protocol_format (tree, proto_wlan, tvb, 0, -1,
                                       "IEEE 802.11 %s", fts_str);
  hdr_tree = proto_item_add_subtree(ti, ett_80211);

  /* Add the FC and duration/id to the current tree */
  fc_item = proto_tree_add_item(hdr_tree, hf_ieee80211_fc_field, tvb, offset, 2, ENC_LITTLE_ENDIAN);

  fc_tree = proto_item_add_subtree(fc_item, ett_fc_tree);

  proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_proto_version, tvb, offset,
                      2, ENC_LITTLE_ENDIAN);
  proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_type, tvb, offset, 2,
                      ENC_LITTLE_ENDIAN);
  /*
   * PDID/Subtype depends on ... whether it is a QoS data frame or Control
   * or Management frames
   */
  switch (type) {
  case PV1_QOS_DATA_1MAC:
  case PV1_QOS_DATA_2MAC:
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_ptid, tvb, offset, 2,
                        ENC_LITTLE_ENDIAN);
    break;

  case PV1_MANAGEMENT:
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_mgmt_subtype, tvb, offset,
                        2, ENC_LITTLE_ENDIAN);
    break;

  case PV1_CONTROL:
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_cntl_subtype, tvb, offset,
                        2, ENC_LITTLE_ENDIAN);
    break;

  default: /* Assume all else just a 3-bit field */
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_unk_field, tvb, offset, 2,
                        ENC_LITTLE_ENDIAN);
    break;
  }

  from_ds = (fcf >> 8) & 0x01; /* It's also the slot assignment field */

  switch (type) {
  case PV1_CONTROL:
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_bw_indication, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_dynamic_indication, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_cntl_power_mgmt, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_cntl_more_data, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_cntl_flow_control, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_cntl_next_twt_info, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
    break;
  case PV1_MANAGEMENT:
    if (subtype == PV1_MANAGEMENT_PROBE_RESPONSE) {
      proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_mgmt_pr_next_tbt, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_mgmt_pr_full_ssid, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_mgmt_pr_ano, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_mgmt_pr_bss_bw, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_mgmt_pr_security, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_mgmt_pr_1mhz_pc, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
    } else if (subtype == PV1_MANAGEMENT_RESOURCE_ALLOC) {
      proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_mgmt_pr_slot_assign, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_mgmt_pr_more_frag, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_mgmt_pr_pwr_mgmt, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_mgmt_pr_grp_indic, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_mgmt_pr_protected, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_mgmt_pr_end_of_svc, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_mgmt_pr_relayed_frm, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
      proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_mgmt_pr_ack_policy, tvb,
                          offset, 2, ENC_LITTLE_ENDIAN);
    } else {
      // TODO: What about the rest
    }
    break;

  default:
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_from_ds, tvb, offset, 2,
                        ENC_LITTLE_ENDIAN);
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_more_fragments, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_power_mgmt, tvb, offset, 2,
                        ENC_LITTLE_ENDIAN);
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_more_data, tvb, offset, 2,
                        ENC_LITTLE_ENDIAN);
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_protected_frame, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_end_service_per, tvb,
                        offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_relayed_frame, tvb, offset,
                        2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(fc_tree, hf_ieee80211_fc_pv1_ack_policy, tvb, offset, 2,
                        ENC_LITTLE_ENDIAN);
  }

  offset += 2;

  /*
   * Now, handle the MAC addresses or SIDs, which is dependent on the
   * Type and From DS etc.
   */

  if (from_ds == 0x0) {
    a2_is_sid = true;
  } else {
    a1_is_sid = true;
  }

  /* Now override where needed */
  switch (type) {
  case PV1_MANAGEMENT:
    if (subtype == PV1_MANAGEMENT_PROBE_RESPONSE) {
      a1_is_sid = false;
      a2_is_sid = false;
    }
    break;
  case PV1_CONTROL:
    a1_is_sid = true;
    break;
  case PV1_QOS_DATA_2MAC:
    a1_is_sid = false;
    a2_is_sid = false;
    break;
  }

  /*
   * Now handle the address fields.
   * If one of them is a SID, then it tells us if A3 and/or A4 is there.
   *
   * Also, add the SID (with MAC address if we know it), or the MAC
   * addr depending on type.
   *
   * XXX - For PV1_CONTROL frames (IEEE 802.11-2020 9.8.4), the A3 Present,
   * A4 Present, and A-MSDU subfields of the SID are reserved. Should
   * they be dissected differently, and ignored / expert info if set?
   *
   * For PV1_MANAGMENT frames (9.8.5), A4 and A-MSDU cannot be present.
   * Ignore / expert info if set?
   */
  if (a1_is_sid) {
    uint16_t a1 = tvb_get_letohs(tvb, offset);
    proto_tree *dst_sid = NULL;

    extract_a3_a4_amsdu(a1, &a3_present, &a4_present, &a_msdu);
    set_sid_addr_cols(pinfo, a1, true); /* Set the R SID address from A1 */

    dst_sid = proto_tree_add_subtree(hdr_tree, tvb, offset, 2, ett_pv1_sid,
                                      NULL, "Receiver SID");
    dissect_pv1_sid(dst_sid, pinfo, tvb, offset);
    offset += 2;
  } else {
    set_dst_addr_cols(pinfo, tvb, offset, wlan_ra_ta_address_type);
    proto_tree_add_mac48_detail(&mac_ra, &mac_addr, ett_addr, tvb, hdr_tree, offset);
    offset += 6;
  }

  if (a2_is_sid) {
    uint16_t a2 = tvb_get_letohs(tvb, offset);
    proto_tree *src_sid = NULL;

    extract_a3_a4_amsdu(a2, &a3_present, &a4_present, &a_msdu);
    set_sid_addr_cols(pinfo, a2, false); /* Set the T SID address from A2 */

    src_sid = proto_tree_add_subtree(hdr_tree, tvb, offset, 2, ett_pv1_sid,
                                      NULL, "Transmitter SID");
    dissect_pv1_sid(src_sid, pinfo, tvb, offset);
    offset += 2;
  } else {
    set_src_addr_cols(pinfo, tvb, offset, wlan_ra_ta_address_type);
    proto_tree_add_mac48_detail(&mac_ta, NULL, ett_addr, tvb, hdr_tree, offset);
    offset += 6;
  }

  /* Now, add the sequence control field if present */
  switch (type) {
  case PV1_QOS_DATA_1MAC:
  case PV1_QOS_DATA_2MAC:
    dissect_pv1_sequence_control(hdr_tree, pinfo, tvb, offset);
    offset += 2;
    break;
  case PV1_MANAGEMENT:
    if (subtype != PV1_MANAGEMENT_PROBE_RESPONSE) {
      dissect_pv1_sequence_control(hdr_tree, pinfo, tvb, offset);
      offset += 2;
    }
    break;
  }
  /* Now, add A3 and A4 if present */
  if (a3_present) {
    set_dst_addr_cols(pinfo, tvb, offset, wlan_address_type);
    proto_tree_add_mac48_detail(&mac_da, &mac_addr, ett_addr, tvb, hdr_tree, offset);
    offset += 6;
  }

  if (a4_present) {
    set_src_addr_cols(pinfo, tvb, offset, wlan_address_type);
    proto_tree_add_mac48_detail(&mac_sa, &mac_addr, ett_addr, tvb, hdr_tree, offset);
    offset += 6;
  }

  /* TODO: Properly handle the FCS len */
  if (phdr->fcs_len == 4)
    len_no_fcs -= 4;

  /* Now, handle the body */
  switch (type) {
  case PV1_QOS_DATA_1MAC:
  case PV1_QOS_DATA_2MAC:
    offset = dissect_pv1_data(tvb, pinfo, tree, offset, a_msdu, phdr, len_no_fcs);
    break;
  case PV1_MANAGEMENT:
    ti = proto_tree_add_item(tree, hf_ieee80211_mgt, tvb, 0, -1, ENC_NA);
    mgt_tree = proto_item_add_subtree(ti, ett_80211_mgt);
    offset = dissect_pv1_management(tvb, pinfo, mgt_tree, offset, phdr, subtype, len_no_fcs, fcf);
    break;
  case PV1_CONTROL:
    offset = dissect_pv1_control(tvb, pinfo, fc_tree, offset, phdr, subtype, len_no_fcs, fcf);
    break;
  default:
    /* Invalid so far. Insert as data and add an Expert Info */
    break;
  }

  /* Now, handle the FCS, if present */
  if (phdr->fcs_len == 4) {
    proto_tree_add_checksum(hdr_tree, tvb, len - 4, hf_ieee80211_fcs, hf_ieee80211_fcs_status, &ei_ieee80211_fcs, pinfo, 0, ENC_LITTLE_ENDIAN, PROTO_CHECKSUM_NO_FLAGS);
  }

  return offset;
}

static int
dissect_ieee80211_pv0(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
                      uint32_t option_flags, wlan_hdr_t *whdr,
                      struct ieee_802_11_phdr *phdr)
{
  uint16_t         fcf, flags, frame_type_subtype, ctrl_fcf, ctrl_type_subtype;
  uint16_t         cw_fcf;
  uint16_t         seq_control;
  uint32_t         seq_number, frag_number;
  bool             more_frags;
  proto_item      *ti          = NULL;
  proto_item      *cw_item     = NULL;
  proto_tree      *flags_item;
  proto_item      *hidden_item;
  proto_tree      *cw_tree     = NULL;
  uint16_t         hdr_len, ohdr_len;
  uint16_t         htc_len     = 0;
  bool             has_fcs;
  int              len, reported_len, ivlen;
  int              sta_addr_offset = 0;
  bool             is_amsdu    = 0;
  bool             save_fragmented;
  uint32_t         addr_type;
  uint8_t          octet1, octet2;
  uint16_t         etype;
  char             out_buff[SHORT_STR];
  int              is_iv_bad;
  unsigned char    iv_buff[4];
  int              addr1_type = wlan_ra_ta_address_type;
  unsigned         offset = 0;
  const char      *fts_str;
  char             flag_str[]  = "opmPRMFTC";
  int              ii;
  uint16_t         qosoff      = 0;
  uint16_t         qos_control = 0;
  int              meshctl_len = 0;
  uint8_t          mesh_flags;
  uint16_t         meshoff     = 0;
  bool             retransmitted;
  bool             isDMG = (phdr->phy == PHDR_802_11_PHY_11AD);

  encap_t     encap_type;
  proto_tree *hdr_tree = NULL;
  tvbuff_t   *next_tvb = NULL;

#define PROTECTION_ALG_WEP  DOT11DECRYPT_KEY_TYPE_WEP
#define PROTECTION_ALG_TKIP  DOT11DECRYPT_KEY_TYPE_TKIP
#define PROTECTION_ALG_CCMP  DOT11DECRYPT_KEY_TYPE_CCMP
#define PROTECTION_ALG_CCMP_256  DOT11DECRYPT_KEY_TYPE_CCMP_256
#define PROTECTION_ALG_GCMP  DOT11DECRYPT_KEY_TYPE_GCMP
#define PROTECTION_ALG_GCMP_256  DOT11DECRYPT_KEY_TYPE_GCMP_256
#define PROTECTION_ALG_RSNA  PROTECTION_ALG_CCMP | PROTECTION_ALG_TKIP
#define IS_TKIP(tvb, hdr_len)  (tvb_get_uint8(tvb, hdr_len + 1) == \
  ((tvb_get_uint8(tvb, hdr_len) | 0x20) & 0x7f))
#define IS_CCMP(tvb, hdr_len)  (tvb_get_uint8(tvb, hdr_len + 2) == 0)
  uint8_t algorithm=UINT8_MAX;
  uint32_t sec_trailer=0;

  fcf = FETCH_FCF(0);

  frame_type_subtype = COMPOSE_FRAME_TYPE(fcf);
  whdr->type = frame_type_subtype;
  if (frame_type_subtype == CTRL_CONTROL_WRAPPER)
    ctrl_fcf = FETCH_FCF(10);
  else
    ctrl_fcf = 0;

  fts_str = val_to_str_ext_const(frame_type_subtype, &frame_type_subtype_vals_ext,
                                 "Unrecognized (Reserved frame)");
  col_set_str(pinfo->cinfo, COL_INFO, fts_str);


# define FROM_TO_DS 3
  flags = FCF_FLAGS(fcf);
  more_frags = HAVE_FRAGMENTS(flags);

  for (ii = 0; ii < 8; ii++) {
    if (! (flags & 0x80 >> ii)) {
      flag_str[ii] = '.';
    }
  }

  switch (FCF_FRAME_TYPE (fcf)) {

  case MGT_FRAME:
    hdr_len = MGT_FRAME_HDR_LEN;

    /*
     * IEEE 802.11-2016 section 9.2.4.1.10 "+HTC/Order subfield" says:
     *
     *  The +HTC/Order subfield is 1 bit in length. It is used for two
     *  purposes:
     *
     *    -- It is set to 1 in a non-QoS Data frame transmitted by a
     *       non-QoS STA to indicate that the frame contains an MSDU,
     *       or fragment thereof, that is being transferred using the
     *       StrictlyOrdered service class.
     *
     *    -- It is set to 1 in a QoS Data or Management frame transmitted
     *       with a value of HT_GF, HT_MF, or VHT for the FORMAT parameter
     *       of the TXVECTOR to indicate that the frame contains an
     *       HT Control field.
     *
     *  Otherwise, the +HTC/Order subfield is set to 0.
     *
     *  NOTE -- The +HTC/Order subfield is always set to 0 for frames
     *  transmitted by a DMG STA.
     *
     * and 802.11ax drafts appear to say that the +HTC/Order flag, for
     * QoS frames, also indicates that there's an HT Control field.
     */
    if (HAS_HT_CONTROL(FCF_FLAGS(fcf))) {
      /*
       * For the DMG PHY, do *not* treat the +HTC field as an indication
       * that there's an HT Control field, because, in the ns-3 capture
       * in issue 11277, it's set in packets with a channel frequency
       * in the 60 GHz band, meaning DMG (802.11ad), but it's not
       * supposed to be set, and those packets lack an HT Control
       * field, so they would be dissected incorrectly if we treated
       * them as if they had an HT Control field.
       */
      if (!isDMG) {
        /*
         * Non-DMG PHY; treat this field as hving an HT Control field.
         *
         * XXX - as I read the above, this shouldn't be set except for
         * HT, VHT, or HE PHYs; however, in the capture in issue 11351,
         * a frame with an HT Control field, with a radiotap header,
         * has no MCS, VHT, or HE field in that header, so Wireshark
         * has no clue that it's an HT, VHT, or HE field. assumed that
         * this meant that it wouldn't have an HT Control field even
         * if it's a QoS field with +HTC/Order set, and misdissected
         * it.  Omnipeek, which also appeared to have no clue that it
         * was an HT or VHT field - it called it an 802.11b frame - *did*
         * dissect the HT Control field.  Therefore, we must not require
         * an indication that a QoS frame is an HT, VHT, or HE frame
         * in order to dissect it a having an HT Control field.
         */
        hdr_len += 4;
        htc_len = 4;
      }
    }
    break;

  case CONTROL_FRAME:
    if (frame_type_subtype == CTRL_CONTROL_WRAPPER) {
      hdr_len = 6;
      cw_fcf = ctrl_fcf;
    } else {
      hdr_len = 0;
      cw_fcf = fcf;
    }
    switch (COMPOSE_FRAME_TYPE (cw_fcf)) {

    case CTRL_TRIGGER:
      /*
       * This is a variable length frame ... we set the real length below
       * and since the common info is variable, just set the hdr len to
       * the fixed portion, 16. There can also be one or more user-info
       * sections, followed by padding.
       */
      hdr_len = 16;
      break;

    case CTRL_TACK:
      /*
       * This also is a variable length frame. Set to 22, the common portion
       */
      hdr_len = 22;
      break;

    case CTRL_BEAMFORM_RPT_POLL:
      hdr_len += 17;
      break;

    case CTRL_VHT_NDP_ANNC:
      hdr_len += 17;
      /* TODO: for now we only consider a single STA, add support for more */
      hdr_len += 2;
      break;

    case CTRL_CTS:
    case CTRL_ACKNOWLEDGEMENT:
      hdr_len += 10;
      break;

    case CTRL_POLL:
      hdr_len += 18;
      break;

    case CTRL_SPR:
    case CTRL_GRANT:
    case CTRL_GRANT_ACK:
      hdr_len += 23;
      break;

    case CTRL_DMG_CTS:
      hdr_len += 16;
      break;

    case CTRL_DMG_DTS:
    case CTRL_SSW:
      hdr_len += 22;
      break;

    case CTRL_SSW_FEEDBACK:
    case CTRL_SSW_ACK:
      hdr_len += 24;
      break;

    case CTRL_RTS:
    case CTRL_PS_POLL:
    case CTRL_CFP_END:
    case CTRL_CFP_ENDACK:
    case CTRL_BLOCK_ACK_REQ:
    case CTRL_BLOCK_ACK:
      hdr_len += 16;
      break;

    default:
      hdr_len += 4;  /* XXX */
      break;
    }
    break;

  case DATA_FRAME:
    hdr_len = (FCF_ADDR_SELECTOR(fcf) == DATA_ADDR_T4) ? DATA_LONG_HDR_LEN : DATA_SHORT_HDR_LEN;

    if (option_flags & IEEE80211_COMMON_OPT_NORMAL_QOS) {
      /*
       * IEEE 802.11-2016 section 9.2.4.1.10 "+HTC/Order subfield" says:
       *
       *  The +HTC/Order subfield is 1 bit in length. It is used for two
       *  purposes:
       *
       *    -- It is set to 1 in a non-QoS Data frame transmitted by a
       *       non-QoS STA to indicate that the frame contains an MSDU,
       *       or fragment thereof, that is being transferred using the
       *       StrictlyOrdered service class.
       *
       *    -- It is set to 1 in a QoS Data or Management frame transmitted
       *       with a value of HT_GF, HT_MF, or VHT for the FORMAT parameter
       *       of the TXVECTOR to indicate that the frame contains an
       *       HT Control field.
       *
       *  Otherwise, the +HTC/Order subfield is set to 0.
       *
       *  NOTE -- The +HTC/Order subfield is always set to 0 for frames
       *  transmitted by a DMG STA.
       *
       * and 802.11ax drafts appear to say that the +HTC/Order flag, for
       * QoS frames, also indicates that there's an HT Control field.
       */
      if (DATA_FRAME_IS_QOS(frame_type_subtype)) {
        /* QoS frame */
        qosoff = hdr_len;
        qos_control = tvb_get_letohs(tvb, qosoff);
        hdr_len += 2; /* Include the QoS field in the header length */

        if (HAS_HT_CONTROL(FCF_FLAGS(fcf))) {
          /*
           * For the DMG PHY, do *not* treat the +HTC field as an indication
           * that there's an HT Control field, because, in the ns-3 capture
           * in issue 11277, it's set in packets with a channel frequency
           * in the 60 GHz band, meaning DMG (802.11ad), but it's not
           * supposed to be set, and those packets lack an HT Control
           * field, so they would be dissected incorrectly if we treated
           * them as if they had an HT Control field.
           */
          if (!isDMG) {
            /*
             * Non-DMG PHY; treat this field as hving an HT Control field.
             *
             * XXX - as I read the above, this shouldn't be set except for
             * HT, VHT, or HE PHYs; however, in the capture in issue 11351,
             * a frame with an HT Control field, with a radiotap header,
             * has no MCS, VHT, or HE field in that header, so Wireshark
             * has no clue that it's an HT, VHT, or HE field. assumed that
             * this meant that it wouldn't have an HT Control field even
             * if it's a QoS field with +HTC/Order set, and misdissected
             * it.  Omnipeek, which also appeared to have no clue that it
             * was an HT or VHT field - it called it an 802.11b frame - *did*
             * dissect the HT Control field.  Therefore, we must not require
             * an indication that a QoS frame is an HT, VHT, or HE frame
             * in order to dissect it a having an HT Control field.
             */
            hdr_len += 4;
            htc_len = 4;
          }
        }
      }
    }
    break;

  case EXTENSION_FRAME:
    hdr_len = 10;
    break;

  default:
    hdr_len = 4;  /* XXX */
    break;
  }

  /*
   * Some portions of this code calculate offsets relative to the end of the
   * header.  But when the header has been padded to align the data this must
   * be done relative to true header size, not the padded/aligned value.  To
   * simplify this work we stash the original header size in ohdr_len instead
   * of recalculating it every time we need it.
   */
  ohdr_len = hdr_len;
  if (phdr->datapad) {
    /*
     * Add in Atheros padding between the 802.11 header and body.
     *
     * In the Atheros mesh capture sample we have, the padding
     * is before the mesh header, possibly because it doesn't
     * recognize the mesh header.
     */
    hdr_len = WS_ROUNDUP_4(hdr_len);
  }

  if (FCF_FRAME_TYPE (fcf) == DATA_FRAME) {
    /*
     * Does it look as if we have a mesh header?
     *
     * For locally originated mesh frames, the QoS header may be added
     * by the hardware, and no present in wireshark captures.  This
     * poses a problem as the QoS header indicates the presence of the
     * mesh control header.
     *
     * In addition, we have examples of mesh captures where the QoS
     * field indicates that there is no mesh control header, yet there
     * is one.
     *
     * Instead of QoS, we use a few heuristics to determine the presence
     * of the mesh control header, which is tricky because it can have a
     * variable length. We fall back to using the QoS field if it exists
     * and the packet isn't long enough (due to truncation or something
     * malformed that should be flagged.)
     *
     * Assume minimal length, and then correct if wrong.
     */
    if (tvb_bytes_exist(tvb, hdr_len, 1)) {
      meshoff = hdr_len;
      mesh_flags = tvb_get_uint8(tvb, meshoff);
      meshctl_len = find_mesh_control_length(mesh_flags);
      /* ... and try to read two bytes of next header */
      if (tvb_bytes_exist(tvb, hdr_len, meshctl_len + 2)) {
        uint16_t next_header = tvb_get_letohs(tvb, meshoff + meshctl_len);
        if (!has_mesh_control_local(fcf, mesh_flags, next_header)) {
          meshctl_len = 0;
        }
      } else {
        if (DATA_FRAME_IS_QOS(frame_type_subtype)) {
          /* QoS frame */
          /*
           * Look at the Mesh Control subfield of the QoS field and at the
           * purported mesh flag fields.
           */
          if (!has_mesh_control(fcf, qos_control, mesh_flags)) {
            meshctl_len = 0;
          }
        } else {
          /* Not QoS frame, can't do the other heuristic, so assume no mesh */
          meshctl_len = 0;
        }
      }
    }
    hdr_len += meshctl_len;
  }

  /* Create the protocol tree */
  ti = proto_tree_add_protocol_format(tree, proto_wlan, tvb, 0, hdr_len,
                                      "IEEE 802.11 %s", fts_str);
  hdr_tree = proto_item_add_subtree(ti, ett_80211);

  /* Add the FC and duration/id to the current tree */
  dissect_frame_control(hdr_tree, tvb, option_flags, 0, pinfo, isDMG);
  dissect_durid(hdr_tree, tvb, frame_type_subtype, 2);

  switch (phdr->fcs_len)
    {
      case 0: /* Definitely has no FCS */
        has_fcs = false;
        break;

      case 4: /* Definitely has an FCS */
        has_fcs = true;
        break;

      case -2: /* Data frames have no FCS, other frames may have an FCS */
               /* XXX: -2 currently used only in wiretap/netmon.c       */
        if (FCF_FRAME_TYPE (fcf) == DATA_FRAME)
          has_fcs = false;
        else /* Management, Control, Extension */
          has_fcs = wlan_check_fcs;
        break;

      default: /* Don't know - use "wlan_check_fcs" */
        has_fcs = wlan_check_fcs;
        break;
    }

  /*
   * Decode the part of the frame header that isn't the same for all
   * frame types.
   */
  seq_control = 0;
  frag_number = 0;
  seq_number = 0;

  /* all frames have address 1 = RA */
  proto_tree_add_mac48_detail(&mac_ra, &mac_addr, ett_addr, tvb, hdr_tree, 4);

  switch (FCF_FRAME_TYPE (fcf))
  {

    case MGT_FRAME:
      /*
       * All management frame types have the same header.
       */
      set_dst_addr_cols(pinfo, tvb, 4, wlan_address_type);
      set_src_addr_cols(pinfo, tvb, 10, wlan_address_type);

      /* for tap */
      set_address_tvb(&whdr->bssid, wlan_bssid_address_type, 6, tvb, 16);
      copy_address_shallow(&whdr->src, &pinfo->dl_src);
      copy_address_shallow(&whdr->dst, &pinfo->dl_dst);

      seq_control = tvb_get_letohs(tvb, 22);
      frag_number = SEQCTL_FRAGMENT_NUMBER(seq_control);
      seq_number = SEQCTL_SEQUENCE_NUMBER(seq_control);

      col_append_fstr(pinfo->cinfo, COL_INFO,
            ", SN=%d", seq_number);

      col_append_fstr(pinfo->cinfo, COL_INFO,
            ", FN=%d", frag_number);

      if (tree)
      {
        proto_tree_add_mac48_detail(&mac_da, NULL, ett_addr, tvb, hdr_tree, 4);
        proto_tree_add_mac48_detail(&mac_ta, NULL, ett_addr, tvb, hdr_tree, 10);
        proto_tree_add_mac48_detail(&mac_sa, NULL, ett_addr, tvb, hdr_tree, 10);
        check_s1g_setting(pinfo, tvb, 10);
        proto_tree_add_mac48_detail(&mac_bssid, NULL, ett_addr, tvb, hdr_tree, 16);

        /* FIXME: With mgmt frames FROM_TO_DS is always 0, perhaps compare address to bssid instead? */
        if ((flags & FROM_TO_DS) == FLAG_FROM_DS) { /* Receiver address */
          sta_addr_offset = 4;
        } else if ((flags & FROM_TO_DS) == FLAG_TO_DS) { /* Transmitter address */
          sta_addr_offset = 10;
        }
        if (sta_addr_offset > 0) {
          proto_tree_add_mac48_detail(&mac_staa, NULL, ett_addr, tvb, hdr_tree, sta_addr_offset);
        }
        /* add items for wlan.addr filter */
        hidden_item = proto_tree_add_mac48_detail(&mac_addr_hidden, NULL, -1, tvb, hdr_tree, 10);
        proto_item_set_hidden(hidden_item);
        hidden_item = proto_tree_add_mac48_detail(&mac_addr_hidden, NULL, -1, tvb, hdr_tree, 16);
        proto_item_set_hidden(hidden_item);
        proto_tree_add_item(hdr_tree, hf_ieee80211_frag_number, tvb, 22, 2, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(hdr_tree, hf_ieee80211_seq_number, tvb, 22, 2, ENC_LITTLE_ENDIAN);
      }
      break;

    case CONTROL_FRAME:
    {
      /*
       * Control Wrapper frames insert themselves between address 1
       * and address 2 in a normal control frame.  Process address 1
       * first, then handle the rest of the frame in dissect_control.
       */
      if (frame_type_subtype == CTRL_CONTROL_WRAPPER) {
        offset = 10; /* FC + D/ID + Address 1 + CFC + HTC */
        ctrl_fcf = FETCH_FCF(10);
        ctrl_type_subtype = COMPOSE_FRAME_TYPE(ctrl_fcf);
      } else {
        offset = 10; /* FC + D/ID + Address 1 */
        ctrl_type_subtype = frame_type_subtype;
      }
      /* Added to disallow DMG STA to transfer packets of certain forbidden types. */
      switch (ctrl_type_subtype)
      {
        case CTRL_PS_POLL:
        case CTRL_CTS:
        case CTRL_CFP_ENDACK:
        if(isDMG == true) {
          expert_add_info_format(pinfo, hdr_tree, &ei_ieee80211_dmg_subtype,
              "DMG STA shouldn't transmit control frame of type contention-free period end+ack");
        }
        break;
        default:
          break;
      }

      if (ctrl_type_subtype == CTRL_PS_POLL) {
        addr1_type = wlan_bssid_address_type;
        proto_tree_add_mac48_detail(&mac_bssid, NULL, ett_addr, tvb, hdr_tree, 4);
      }

      /* Add address 1 */
      set_dst_addr_cols(pinfo, tvb, 4, addr1_type);

      /*
       * Start shoving in other fields if needed.
       */
      if (frame_type_subtype == CTRL_CONTROL_WRAPPER) {
        /* if (tree) */
        {
          cw_tree = proto_tree_add_subtree(hdr_tree, tvb, offset, 2,
                      ett_cntrl_wrapper_fc, NULL, "Contained Frame Control");
          dissect_frame_control(cw_tree, tvb, 0, offset, pinfo, isDMG);
          dissect_ht_control(pinfo, hdr_tree, tvb, offset + 2);
          offset += 6;
          hdr_tree = proto_tree_add_subtree(hdr_tree, tvb, offset, 2,
                      ett_cntrl_wrapper_fc, &cw_item, "Carried Frame");
          if (isDMG) {
            expert_add_info_format(pinfo, cw_item, &ei_ieee80211_dmg_subtype,
                                   "DMG STA shouldn't transmit Control Wrapper frame");
          }
        }
      }

      switch (ctrl_type_subtype)
      {
        case CTRL_PS_POLL:
        case CTRL_CFP_ENDACK:
        {
          set_src_addr_cols(pinfo, tvb, offset, wlan_ra_ta_address_type);
          proto_tree_add_mac48_detail(&mac_ta, &mac_addr, ett_addr, tvb, hdr_tree, offset);
          offset += 6;
          break;
        }

        case CTRL_CFP_END:
        {
          if (isDMG)
            set_src_addr_cols(pinfo, tvb, offset, wlan_ra_ta_address_type);
          else
            set_src_addr_cols(pinfo, tvb, offset, wlan_bssid_address_type);
          /* if (tree) */
          {
            if (isDMG) {
              proto_tree_add_mac48_detail(&mac_ta, &mac_addr, ett_addr, tvb, hdr_tree, offset);
            } else {
              proto_tree_add_mac48_detail(&mac_bssid, &mac_addr, ett_addr, tvb, hdr_tree, offset);
            }
            offset += 6;
          }
          break;
        }

        case CTRL_TRIGGER:
          set_src_addr_cols(pinfo, tvb, offset, wlan_ra_ta_address_type);
          /*
           * The len returned will be adjusted to include any padding required
           */
          hdr_len = dissect_ieee80211_he_eht_trigger(tvb, pinfo, hdr_tree, offset,
                                                     phdr->fcs_len);
          ohdr_len = hdr_len;
          break;

        case CTRL_TACK:
         set_src_addr_cols(pinfo, tvb, offset, wlan_ra_ta_address_type);
         hdr_len = dissect_ieee80211_s1g_tack(tvb, pinfo, hdr_tree, offset,
                                        flags);
         break;

        case CTRL_BEAMFORM_RPT_POLL:
        {
          set_src_addr_cols(pinfo, tvb, offset, wlan_ra_ta_address_type);
          proto_tree_add_mac48_detail(&mac_ta, &mac_addr, ett_addr, tvb, hdr_tree, offset);
          offset += 6;
          proto_tree_add_item(hdr_tree, hf_ieee80211_beamform_feedback_seg_retrans_bitmap, tvb, offset, 1, ENC_NA);
          break;
        }

        case CTRL_VHT_NDP_ANNC:
          set_src_addr_cols(pinfo, tvb, offset, wlan_ra_ta_address_type);

          dissect_ieee80211_ndp_annc(tvb, pinfo, hdr_tree, offset, has_fcs);
          break;

        case CTRL_GRANT_ACK:
        case CTRL_SSW:
        case CTRL_SSW_FEEDBACK:
        case CTRL_SSW_ACK:
        case CTRL_DMG_CTS:
        case CTRL_GRANT:
        case CTRL_SPR:
        case CTRL_POLL:
        case CTRL_RTS:
        {
          set_src_addr_cols(pinfo, tvb, offset, wlan_ra_ta_address_type);
          proto_tree_add_mac48_detail(&mac_ta, &mac_addr, ett_addr, tvb, hdr_tree, offset);
          offset += 6;
          break;
        }

        case CTRL_CONTROL_WRAPPER:
          /* XXX - We shouldn't see this.  Should we throw an error? */
          break;

        case CTRL_BLOCK_ACK_REQ:
          set_src_addr_cols(pinfo, tvb, offset, wlan_ra_ta_address_type);

          dissect_ieee80211_block_ack(tvb, pinfo, hdr_tree, offset, isDMG, true, has_fcs);
          break;

        case CTRL_BLOCK_ACK:
          set_src_addr_cols(pinfo, tvb, offset, wlan_ra_ta_address_type);

          dissect_ieee80211_block_ack(tvb, pinfo, hdr_tree, offset, isDMG, false, has_fcs);
          break;
      }
/*
 * 802.11ad : Used for extension types.
 */
      switch (ctrl_type_subtype) {
        case CTRL_POLL: {
                proto_tree_add_item(hdr_tree, hf_ieee80211_cf_response_offset,
                      tvb, offset, 2, ENC_LITTLE_ENDIAN);

                break;
        }
        case CTRL_GRANT:
        case CTRL_GRANT_ACK:
        case CTRL_SPR: {
          bool isGrant;
          if(ctrl_type_subtype != CTRL_GRANT_ACK) {
            offset += add_ff_dynamic_allocation(hdr_tree, tvb, pinfo, offset);
          } else { /* CTRL_GRANT_ACK have 5 octets that are reserved*/
            proto_tree_add_item(hdr_tree, hf_ieee80211_grant_ack_reserved, tvb, offset, 5, ENC_NA);
            offset += 5;
          }
          isGrant = ((ctrl_type_subtype==CTRL_GRANT)||(ctrl_type_subtype==CTRL_GRANT_ACK));
          add_ff_beamforming_ctrl(hdr_tree, tvb, pinfo, offset, isGrant);
          /* offset += 2; */
          break;
        }
        case CTRL_SSW: {
          uint32_t sector_sweep;

          sector_sweep = tvb_get_letoh24(tvb, offset);
          offset += add_ff_sector_sweep(hdr_tree, tvb, pinfo, offset);
          /* if Sector Sweep Direction = Responder, use SW Feedback field format when not transmitted as part of an ISS */
          if(sector_sweep & 0x00001) {
            add_ff_sector_sweep_feedback_to_iss(hdr_tree, tvb, pinfo, offset);
          } else {
            add_ff_sector_sweep_feedback_from_iss(hdr_tree, tvb, pinfo, offset);
          }
          /* offset += 3; */
          break;
        }
        case CTRL_SSW_ACK:
        case CTRL_SSW_FEEDBACK: {
          offset += add_ff_sector_sweep_feedback_to_iss(hdr_tree, tvb, pinfo, offset);
          offset += add_ff_BRP_request(hdr_tree, tvb, pinfo, offset);
          add_ff_beamformed_link(hdr_tree, tvb, pinfo, offset);
          /* offset += 1; */
          break;
        }
        case CTRL_DMG_DTS: {
          proto_tree_add_item(hdr_tree, hf_ieee80211_addr_nav_sa, tvb, offset, 6, ENC_NA);
          offset += 6;
          proto_tree_add_item(hdr_tree, hf_ieee80211_addr_nav_da, tvb, offset, 6, ENC_NA);
          /* offset += 6; */
          break;
        }
        default:
                break;
      }
      break;
    }

    case DATA_FRAME:
    {
      uint32_t src_offset, dst_offset, da_offset, sa_offset, ta_offset = 10, bssid_offset;
      addr_type = FCF_ADDR_SELECTOR(fcf);
      if ((option_flags & IEEE80211_COMMON_OPT_NORMAL_QOS) && DATA_FRAME_IS_QOS(frame_type_subtype)) {
        if (!phdr->no_a_msdus && !DATA_FRAME_IS_NULL(frame_type_subtype)) {
          is_amsdu = QOS_AMSDU_PRESENT(qos_control);
        }
      }

      /* In order to show src/dst address we must always do the following */
      switch (addr_type)
      {

        case DATA_ADDR_T1:
          da_offset = 4;
          sa_offset = 10;
          bssid_offset = 16;
          dst_offset = da_offset;
          src_offset = sa_offset;
          break;

        case DATA_ADDR_T2:
          da_offset = 4;
          sa_offset = !is_amsdu ? 16 : 0;
          bssid_offset = 10;
          dst_offset = da_offset;
          src_offset = sa_offset;
          break;

        case DATA_ADDR_T3:
          da_offset = !is_amsdu ? 16 : 0;
          sa_offset = 10;
          bssid_offset = 4;
          dst_offset = da_offset;
          src_offset = sa_offset;
          break;

        case DATA_ADDR_T4:
          if (!is_amsdu) {
            da_offset = 16;
            sa_offset = 24;
            bssid_offset = 0;
            dst_offset = da_offset;
            src_offset = sa_offset;
          } else {
            da_offset = 0;
            sa_offset = 0;
            // The second BSSID (Addr4) is handled below.
            bssid_offset = 16;
            dst_offset = 4;     // RA
            src_offset = 10;    // TA
          }
          break;

        default:
          /* All four cases are covered above. */
          DISSECTOR_ASSERT_NOT_REACHED();
      }

      if (src_offset) {
        set_address_tvb(&pinfo->dl_src, wlan_address_type, 6, tvb, src_offset);
        copy_address_shallow(&pinfo->src, &pinfo->dl_src);
      }
      if (dst_offset) {
        set_address_tvb(&pinfo->dl_dst, wlan_address_type, 6, tvb, dst_offset);
        copy_address_shallow(&pinfo->dst, &pinfo->dl_dst);
      }

      if (bssid_offset) {
        /* for tap */
        set_address_tvb(&whdr->bssid, wlan_bssid_address_type, 6, tvb, bssid_offset);
        /* for dot11decrypt */
        save_proto_data(tvb, pinfo, bssid_offset, 6, BSSID_KEY);
      }

      if (src_offset) {
        copy_address_shallow(&whdr->src, &pinfo->dl_src);
      }
      if (dst_offset) {
        copy_address_shallow(&whdr->dst, &pinfo->dl_dst);
      }

      if ((flags & FROM_TO_DS) == FLAG_FROM_DS) { /* Receiver address */
        sta_addr_offset = 4;
      } else if ((flags & FROM_TO_DS) == FLAG_TO_DS) { /* Transmitter address */
        sta_addr_offset = ta_offset;
      }

      /* for dot11decrypt */
      if (sta_addr_offset > 0) {
        save_proto_data(tvb, pinfo, sta_addr_offset, 6, STA_KEY);
      }

      seq_control = tvb_get_letohs(tvb, 22);
      frag_number = SEQCTL_FRAGMENT_NUMBER(seq_control);
      seq_number = SEQCTL_SEQUENCE_NUMBER(seq_control);

      col_append_fstr(pinfo->cinfo, COL_INFO,
            ", SN=%d, FN=%d", seq_number, frag_number);

      /* Now if we have a tree we start adding stuff */
      if (tree)
      {
        switch (addr_type)
        {
          case DATA_ADDR_T1:
          case DATA_ADDR_T2:
          case DATA_ADDR_T3:
          case DATA_ADDR_T4:
            proto_tree_add_mac48_detail(&mac_ta, &mac_addr, ett_addr, tvb, hdr_tree, ta_offset);

            if (da_offset) {
              bool add_mac = (da_offset >= 16 && da_offset != sa_offset);
              proto_tree_add_mac48_detail(&mac_da, add_mac ? &mac_addr : NULL, ett_addr, tvb, hdr_tree, da_offset);
            }

            if (sa_offset) {
              bool add_mac = (sa_offset >= 16);
              proto_tree_add_mac48_detail(&mac_sa, add_mac ? &mac_addr : NULL, ett_addr, tvb, hdr_tree, sa_offset);
            }

            if (bssid_offset) {
              bool add_mac = (bssid_offset >= 16 && bssid_offset != sa_offset && bssid_offset != da_offset);
              proto_tree_add_mac48_detail(&mac_bssid, add_mac ? &mac_addr : NULL, ett_addr, tvb, hdr_tree, bssid_offset);
            }

            if (addr_type == DATA_ADDR_T4 && is_amsdu) {
              proto_tree_add_mac48_detail(&mac_bssid, NULL, ett_addr, tvb, hdr_tree, 24);
            }

            if (sta_addr_offset > 0) {
              proto_tree_add_mac48_detail(&mac_staa, NULL, ett_addr, tvb, hdr_tree, sta_addr_offset);
            }
            proto_tree_add_item(hdr_tree, hf_ieee80211_frag_number, tvb, 22, 2, ENC_LITTLE_ENDIAN);
            proto_tree_add_item(hdr_tree, hf_ieee80211_seq_number, tvb, 22, 2, ENC_LITTLE_ENDIAN);

            break;
        }

      }
      break;
    }
    case EXTENSION_FRAME: {
      switch (frame_type_subtype) {
        case EXTENSION_DMG_BEACON: {
          set_dst_addr_cols(pinfo, tvb, 4, wlan_bssid_address_type);
          proto_tree_add_mac48_detail(&mac_bssid, &mac_addr, ett_addr, tvb, hdr_tree, 4);
          break;
        }
        case EXTENSION_S1G_BEACON: {
          uint8_t *src_addr[6];
          tvb_memcpy(tvb, src_addr, 4, 6);

          /* Insert this src_addr into the s1g sta hash */
          if (!wmem_map_lookup(sta_prop_hash, src_addr)) {
            wmem_map_insert(sta_prop_hash, wmem_memdup(wmem_file_scope(), src_addr, 6), GUINT_TO_POINTER(STA_IS_S1G));
          }

          check_s1g_setting(pinfo, tvb, 4);

          set_src_addr_cols(pinfo, tvb, 4, wlan_address_type);
          proto_tree_add_mac48_detail(&mac_sa, &mac_addr, ett_addr, tvb, hdr_tree, 4);
          break;
        }
      }
    }
  }

  len = tvb_captured_length_remaining(tvb, hdr_len);
  reported_len = tvb_reported_length_remaining(tvb, hdr_len);

  if (has_fcs)
    {
      /*
       * Well, this packet should, in theory, have an FCS.
       * Do we have the entire packet, and does it have enough data for
       * the FCS?
       */
      if (reported_len < 4)
      {
        /*
         * The packet is claimed not to even have enough data for a 4-byte
         * FCS.
         * Pretend it doesn't have an FCS.
         */
        ;
      }
      else if (len < reported_len)
      {
        /*
         * The packet is claimed to have enough data for a 4-byte FCS, but
         * we didn't capture all of the packet.
         * Slice off the 4-byte FCS from the reported length, and trim the
         * captured length so it's no more than the reported length; that
         * will slice off what of the FCS, if any, is in the captured
         * length.
         */
        reported_len -= 4;
        if (len > reported_len)
            len = reported_len;
      }
      else
      {
        /*
         * We have the entire packet, and it includes a 4-byte FCS.
         * Slice it off, and put it into the tree.
         */
        len          -= 4;
        reported_len -= 4;
        if (wlan_check_checksum)
        {
          uint32_t sent_fcs = tvb_get_letohl(tvb, hdr_len + len);
          uint32_t fcs;

          if (phdr->datapad)
            fcs = crc32_802_tvb_padded(tvb, ohdr_len, hdr_len, len);
          else
            fcs = crc32_ccitt_tvb(tvb, hdr_len + len);
          if (fcs != sent_fcs) {
            flag_str[8] = '.';
          }

          proto_tree_add_checksum(hdr_tree, tvb, hdr_len + len, hf_ieee80211_fcs, hf_ieee80211_fcs_status, &ei_ieee80211_fcs, pinfo, fcs, ENC_LITTLE_ENDIAN, PROTO_CHECKSUM_VERIFY);
        } else {
          proto_tree_add_checksum(hdr_tree, tvb, hdr_len + len, hf_ieee80211_fcs, hf_ieee80211_fcs_status, &ei_ieee80211_fcs, pinfo, 0, ENC_LITTLE_ENDIAN, PROTO_CHECKSUM_NO_FLAGS);
        }
      }
    }
  else
    {
      flag_str[8] = '\0';
    }

  proto_item_append_text(ti, ", Flags: %s", flag_str);
  col_append_fstr(pinfo->cinfo, COL_INFO, ", Flags=%s", flag_str);

  flags_item = proto_tree_add_string(hdr_tree, hf_ieee80211_fc_flags_str, tvb, 0, 0, flag_str);
  proto_item_set_generated(flags_item);

  /*
   * Only management and data frames have a body, so we don't have
   * anything more to do for other types of frames.
   */
  switch (FCF_FRAME_TYPE (fcf))
    {

    case MGT_FRAME:
      if (htc_len == 4) {
        dissect_ht_control(pinfo, hdr_tree, tvb, ohdr_len - 4);
      }
      break;

    case DATA_FRAME:
      if ((option_flags & IEEE80211_COMMON_OPT_NORMAL_QOS) && tree && DATA_FRAME_IS_QOS(frame_type_subtype))
      {
        proto_item *qos_fields, *qos_ti;
        proto_tree *qos_tree;

        uint16_t qos_eosp;
        uint16_t qos_field_content;

        qos_fields = proto_tree_add_item(hdr_tree, hf_ieee80211_qos, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
        qos_tree = proto_item_add_subtree(qos_fields, ett_qos_parameters);

        qos_eosp = QOS_EOSP(qos_control);
        qos_field_content = QOS_FIELD_CONTENT(qos_control);

        proto_tree_add_item(qos_tree, hf_ieee80211_qos_tid, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);

        qos_ti = proto_tree_add_item(qos_tree, hf_ieee80211_qos_priority, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
        proto_item_set_generated(qos_ti);

        if (FLAGS_DS_STATUS(flags) == (FLAG_FROM_DS|FLAG_TO_DS)) {
          /* mesh frame */
          proto_tree_add_item(qos_tree, hf_ieee80211_qos_eosp, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
        } else {
          /*
           * Table 9-3 from IEEE802.11-2016 tells us that FROM DS means from
           * an AP. And Table 9-6 tells us that we should treat bit 4 as
           * EOSP if from an AP otherwise as simply bit 4.
           */
          if (flags & FLAG_FROM_DS) {
            proto_tree_add_item(qos_tree, hf_ieee80211_qos_eosp, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
          } else {
            proto_tree_add_item(qos_tree, hf_ieee80211_qos_bit4, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
          }
        }

        proto_tree_add_item(qos_tree, hf_ieee80211_qos_ack_policy, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);

        if (!DATA_FRAME_IS_NULL(frame_type_subtype)) {
          proto_tree_add_item(qos_tree, hf_ieee80211_qos_amsdu_present, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
          if (!phdr->no_a_msdus)
            is_amsdu = QOS_AMSDU_PRESENT(qos_control);
        }

        if (meshctl_len) {
          proto_tree_add_item(qos_tree, hf_ieee80211_qos_mesh_ctl_present, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
          if (POWER_MGT_STATUS(flags)) {
            if (tvb_get_uint8(tvb, 4) & 0x1)
              proto_tree_add_item(qos_tree, hf_ieee80211_qos_mesh_ps_multicast, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
            else
              proto_tree_add_item(qos_tree, hf_ieee80211_qos_mesh_ps_unicast, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
          } else {
            proto_tree_add_item(qos_tree, hf_ieee80211_qos_mesh_ps_rsvd, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
          }
          proto_tree_add_item(qos_tree, hf_ieee80211_qos_mesh_rspi, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
        } else if (flags & FLAG_FROM_DS) {
          if (DATA_FRAME_IS_CF_POLL(frame_type_subtype)) {
            /* txop limit */
              qos_ti = proto_tree_add_item(qos_tree, hf_ieee80211_qos_txop_limit, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
            if (qos_field_content == 0) {
              proto_item_append_text(qos_ti, " (transmit one frame immediately)");
            }
          } else {
            /* qap ps buffer state */
            proto_item *qos_ps_buf_state_fields;
            proto_tree *qos_ps_buf_state_tree;

            qos_ps_buf_state_fields = proto_tree_add_item(qos_tree, hf_ieee80211_qos_ps_buf_state, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
            qos_ps_buf_state_tree = proto_item_add_subtree(qos_ps_buf_state_fields, ett_qos_ps_buf_state);

            proto_tree_add_item(qos_ps_buf_state_tree, hf_ieee80211_qos_buf_state_indicated, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);

            if (QOS_PS_BUF_STATE_INDICATED(qos_field_content)) {
              proto_tree_add_item(qos_ps_buf_state_tree, hf_ieee80211_qos_highest_pri_buf_ac, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
              qos_ti = proto_tree_add_item(qos_ps_buf_state_tree, hf_ieee80211_qos_qap_buf_load, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
              switch (QOS_PS_QAP_BUF_LOAD(qos_field_content)) {

              case 0:
                proto_item_append_text(qos_ti, " (no buffered traffic)");
                break;

              default:
                proto_item_append_text(qos_ti, " (%d octets)", QOS_PS_QAP_BUF_LOAD(qos_field_content)*4096);
                break;

              case 15:
                proto_item_append_text(qos_ti, " (greater than 57344 octets)");
                break;
              }

            }
          }
        } else {
          /*
           * Only QoS Data, Qos CF-ACK and NULL frames To-DS have a Queue Size
           * field.
           */
          uint16_t scaling_factor = QOS_SCALING_FACTOR(qos_field_content);
          uint16_t unscaled_value = QOS_UNSCALED_VALUE(qos_field_content);

          if ((DATA_FRAME_IS_NULL(frame_type_subtype) ||
               (frame_type_subtype & 0x7) == 0 ||
               DATA_FRAME_IS_CF_ACK(frame_type_subtype))) {
            if (qos_eosp) {
              /* queue size */
              qos_ti = proto_tree_add_item(qos_tree, hf_ieee80211_qos_queue_size, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
              switch (qos_field_content) {
              case 0:
                proto_item_append_text(qos_ti, " (no buffered traffic in the queue)");
                break;

              case 254:
                proto_item_append_text(qos_ti, " (more than 64768 octets)");
                break;

              case 255:
                proto_item_append_text(qos_ti, " (unspecified or unknown)");
                break;

              default:
                switch (scaling_factor) {
                case 0:
                  proto_item_append_text(qos_ti, " (%u bytes)", 16 * unscaled_value);
                  break;
                case 1:
                  proto_item_append_text(qos_ti, " (%u bytes)", (1024 + (256 * unscaled_value)));
                  break;
                case 2:
                  proto_item_append_text(qos_ti, " (%u bytes)", (17408 + (2048 * unscaled_value)));
                  break;
                case 3:
                  if (unscaled_value < 62)
                    proto_item_append_text(qos_ti, " (%u bytes)", (148480 + (32768 * unscaled_value)));
                  else if (unscaled_value == 62)
                    proto_item_append_text(qos_ti, " (> 2147328)");
                  else if (unscaled_value == 63)
                    proto_item_append_text(qos_ti, " (unspecified or unknown)");
                  break;
                default:
                  proto_item_append_text(qos_ti, " (unspecified or unknown)");
                  break;
                }
                break;
              }
            } else {
              /* txop duration requested */
              qos_ti = proto_tree_add_item(qos_tree, hf_ieee80211_qos_txop_dur_req,
                                   tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
              if (qos_field_content == 0) {
                proto_item_append_text(qos_ti, " (no TXOP requested)");
              }
            }
          }
        }

        /* Do we have +HTC? */
        if (htc_len == 4) {
          dissect_ht_control(pinfo, hdr_tree, tvb, ohdr_len - 4);
        }

      } /* end of qos control field */

      if (meshctl_len != 0) {
        proto_item *msh_fields;
        proto_tree *msh_tree;

        msh_fields = proto_tree_add_item(hdr_tree, hf_ieee80211_mesh_control_field, tvb, meshoff, meshctl_len, ENC_NA);
        msh_tree = proto_item_add_subtree(msh_fields, ett_msh_control);
        add_ff_mesh_control(msh_tree, tvb, pinfo, meshoff);
      }

      /*
       * No-data frames don't have a body.
       */
      if (DATA_FRAME_IS_NULL(frame_type_subtype))
        goto end_of_wlan;

      if (!wlan_subdissector) {
        unsigned fnum = 0;

        /* key: bssid:src
         * data: last seq_control seen and frame number
         */
        retransmitted = false;
        if (!pinfo->fd->visited) {
          retransmit_key key;
          retransmit_key *result;

          if (whdr->bssid.type == wlan_bssid_address_type) {
            memcpy(key.bssid, whdr->bssid.data, 6);
          } else {
            memset(key.bssid, 0, 6);
          }
          if (whdr->src.type != AT_NONE) {
            memcpy(key.src, whdr->src.data, 6);
          } else {
            memset(key.src, 0, 6);
          }
          key.seq_control = 0;
          result = (retransmit_key *)g_hash_table_lookup(fc_analyse_retransmit_table, &key);
          if (result && (result->seq_control == seq_control)) {
            /* keep a pointer to the first seen frame, could be done with proto data? */
            fnum = result->fnum;
            g_hash_table_insert(fc_first_frame_table, GINT_TO_POINTER(pinfo->num),
                                GINT_TO_POINTER(fnum));
            retransmitted = true;
          } else {
            /* first time or new seq*/
            if (!result) {
              result = wmem_new(wmem_file_scope(), retransmit_key);
              *result = key;
              g_hash_table_insert(fc_analyse_retransmit_table, result, result);
            }
            result->seq_control = seq_control;
            result->fnum =  pinfo->num;
          }
        }
        else if ((fnum = GPOINTER_TO_UINT(g_hash_table_lookup(fc_first_frame_table, GINT_TO_POINTER(pinfo->num))))) {
          retransmitted = true;
        }

        if (retransmitted) {
          col_append_str(pinfo->cinfo, COL_INFO, " [retransmitted]");
          if (tree) {
            proto_item *item;

            item=proto_tree_add_none_format(hdr_tree, hf_ieee80211_fc_analysis_retransmission, tvb, 0, 0,
                                            "Retransmitted frame");
            proto_item_set_generated(item);
            item=proto_tree_add_uint(hdr_tree, hf_ieee80211_fc_analysis_retransmission_frame, tvb, 0, 0, fnum);
            proto_item_set_generated(item);
          }
          next_tvb = tvb_new_subset_length_caplen(tvb, hdr_len, len, reported_len);
          call_data_dissector(next_tvb, pinfo, tree);
          goto end_of_wlan;
        }
      }
      break;

    case CONTROL_FRAME:
      goto end_of_wlan;

    case EXTENSION_FRAME:
      break;

    default:
      goto end_of_wlan;
    }

  if (IS_PROTECTED(FCF_FLAGS(fcf))
      && (frame_type_subtype != EXTENSION_S1G_BEACON)
      && !phdr->decrypted
      && (wlan_ignore_prot != WLAN_IGNORE_PROT_WO_IV)) {
    /*
     * It's a WEP or WPA encrypted frame, and it hasn't already been
     * decrypted; dissect the protections parameters and decrypt the data,
     * if we have a matching key. Otherwise display it as data.
     */
    bool        can_decrypt = false;
    proto_tree *wep_tree    = NULL;
    uint32_t    iv;
    uint8_t     wep_key, keybyte;
    DOT11DECRYPT_KEY_ITEM  used_key = { 0 };

    if (len == reported_len) {
      next_tvb = try_decrypt(tvb, pinfo, hdr_len, reported_len,
                             &algorithm, &sec_trailer, &used_key);
    }

    keybyte = tvb_get_uint8(tvb, hdr_len + 3);
    wep_key = KEY_OCTET_WEP_KEY(keybyte);
    if ((keybyte & KEY_EXTIV) && (len >= EXTIV_LEN)) {
      /* Extended IV; this frame is likely encrypted with TKIP or CCMP */
      if (tree) {
        if (algorithm==PROTECTION_ALG_TKIP)
          wep_tree = proto_tree_add_subtree(hdr_tree, tvb, hdr_len, 8,
              ett_wep_parameters, NULL, "TKIP parameters");
        else if (algorithm == PROTECTION_ALG_CCMP || algorithm == PROTECTION_ALG_CCMP_256)
          wep_tree = proto_tree_add_subtree(hdr_tree, tvb, hdr_len, 8,
            ett_wep_parameters, NULL, "CCMP parameters");
        else if (algorithm == PROTECTION_ALG_GCMP || algorithm == PROTECTION_ALG_GCMP_256)
          wep_tree = proto_tree_add_subtree(hdr_tree, tvb, hdr_len, 8,
            ett_wep_parameters, NULL, "GCMP parameters");
        else {
          if (IS_TKIP(tvb, hdr_len)) {
            algorithm=PROTECTION_ALG_TKIP;
            wep_tree = proto_tree_add_subtree(hdr_tree, tvb, hdr_len, 8,
                ett_wep_parameters, NULL, "TKIP parameters");
          } else if (IS_CCMP(tvb, hdr_len)) {
            algorithm=PROTECTION_ALG_CCMP;
            wep_tree = proto_tree_add_subtree(hdr_tree, tvb, hdr_len, 8,
                ett_wep_parameters, NULL, "CCMP parameters");
          } else
            wep_tree = proto_tree_add_subtree(hdr_tree, tvb, hdr_len, 8,
                ett_wep_parameters, NULL, "TKIP/CCMP parameters");
        }
        proto_item_set_len(ti, hdr_len + 8);

        if (algorithm==PROTECTION_ALG_TKIP) {
          snprintf(out_buff, SHORT_STR, "0x%08X%02X%02X",
              tvb_get_letohl(tvb, hdr_len + 4),
              tvb_get_uint8(tvb, hdr_len),
              tvb_get_uint8(tvb, hdr_len + 2));
          proto_tree_add_string(wep_tree, hf_ieee80211_tkip_extiv, tvb, hdr_len,
              EXTIV_LEN, out_buff);
        } else if (algorithm == PROTECTION_ALG_CCMP || algorithm == PROTECTION_ALG_CCMP_256 ||
                   algorithm == PROTECTION_ALG_GCMP || algorithm == PROTECTION_ALG_GCMP_256) {
          snprintf(out_buff, SHORT_STR, "0x%08X%02X%02X",
              tvb_get_letohl(tvb, hdr_len + 4),
              tvb_get_uint8(tvb, hdr_len + 1),
              tvb_get_uint8(tvb, hdr_len));
          proto_tree_add_string(wep_tree, hf_ieee80211_ccmp_extiv, tvb, hdr_len,
              EXTIV_LEN, out_buff);
        }

        proto_tree_add_uint(wep_tree, hf_ieee80211_wep_key, tvb, hdr_len + 3, 1, wep_key);
      }

      /* Subtract out the length of the IV. */
      len          -= EXTIV_LEN;
      reported_len -= EXTIV_LEN;
      ivlen         = EXTIV_LEN;
      /* It is unknown whether this is TKIP or CCMP, so let's not even try to
       * parse TKIP Michael MIC+ICV or CCMP MIC. */

      const uint8_t *key = NULL;
      int key_len;

      /* checking for the trailer                            */
      if (next_tvb!=NULL) {
        if (reported_len < (int) sec_trailer) {
          /* There is no space for a trailer, ignore it and don't decrypt  */
          ;
        } else if (len < reported_len) {
          /* There is space for a trailer, but we haven't capture all the  */
          /* packet. Slice off the trailer, but don't try to decrypt      */
          reported_len -= sec_trailer;
          if (len > reported_len)
            len = reported_len;
        } else {
          /* Ok, we have a trailer and the whole packet. Decrypt it!      */
          /* TODO: At the moment we won't add the trailer to the tree,    */
          /* so don't remove the trailer from the packet                  */
          len          -= sec_trailer;
          reported_len -= sec_trailer;
          can_decrypt   = true;

          /* Add Key information to packet */
          if (!tvb_get_bits8(tvb, 39, 1)) { /* RA is unicast, encrypted with pairwise key */
            key_len = Dot11DecryptGetTK(&used_key, &key);
            bytes_to_hexstr(out_buff, key, key_len);
            out_buff[2 * key_len] = '\0';
            ti = proto_tree_add_string(wep_tree, hf_ieee80211_fc_analysis_tk, tvb, 0, 0, out_buff);
            proto_item_set_generated(ti);

            /* Also add the PMK used to decrypt the packet. (PMK==PSK) */
            if (used_key.KeyData.Wpa.PskLen > 0) {

              bytes_to_hexstr(out_buff, used_key.KeyData.Wpa.Psk, used_key.KeyData.Wpa.PskLen);
              out_buff[2*used_key.KeyData.Wpa.PskLen] = '\0';
              ti = proto_tree_add_string(wep_tree, hf_ieee80211_fc_analysis_pmk, tvb, 0, 0, out_buff);
              proto_item_set_generated(ti);
            }

          } else { /* Encrypted with Group Key */
            key_len = Dot11DecryptGetGTK(&used_key, &key);
            bytes_to_hexstr(out_buff, key, key_len);
            out_buff[2 * key_len] = '\0';
            ti = proto_tree_add_string(wep_tree, hf_ieee80211_fc_analysis_gtk, tvb, 0, 0, out_buff);
            proto_item_set_generated(ti);
          }
        }
      }
    } else {
      /* No Ext. IV - WEP packet */
      /*
       * XXX - pass the IV and key to "try_decrypt_wep()", and have it pass
       * them to "wep_decrypt()", rather than having "wep_decrypt()" extract
       * them itself.
       *
       * Also, just pass the data *following* the WEP parameters as the
       * buffer to decrypt.
       */
      iv = tvb_get_ntoh24(tvb, hdr_len);
      if (tree) {
        wep_tree = proto_tree_add_subtree(hdr_tree, tvb, hdr_len, 4,
            ett_wep_parameters, NULL, "WEP parameters");

        proto_tree_add_uint(wep_tree, hf_ieee80211_wep_iv, tvb, hdr_len, 3, iv);
        tvb_memcpy(tvb, iv_buff, hdr_len, 3);
        is_iv_bad = weak_iv(iv_buff);
        if (is_iv_bad != -1) {
          proto_tree_add_boolean_format (wep_tree, hf_ieee80211_wep_iv_weak,
              tvb, 0, 0, true,
              "Weak IV for key byte %d",
              is_iv_bad);
        }
      }
      if (tree)
        proto_tree_add_uint(wep_tree, hf_ieee80211_wep_key, tvb, hdr_len + 3, 1, wep_key);

      /* Subtract out the length of the IV. */
      len          -= 4;
      reported_len -= 4;
      ivlen         = 4;

      /* Even if the decryption was not successful, set the algorithm */
      algorithm=PROTECTION_ALG_WEP;

      /*
       * Well, this packet should, in theory, have an ICV.
       * Do we have the entire packet, and does it have enough data for
       * the ICV?
       */
      if (reported_len < 4) {
        /*
         * The packet is claimed not to even have enough data for a
         * 4-byte ICV.
         * Pretend it doesn't have an ICV.
         */
        ;
      } else if (len < reported_len) {
        /*
         * The packet is claimed to have enough data for a 4-byte ICV,
         * but we didn't capture all of the packet.
         * Slice off the 4-byte ICV from the reported length, and trim
         * the captured length so it's no more than the reported length;
         * that will slice off what of the ICV, if any, is in the
         * captured length.
         */
        reported_len -= 4;
        if (len > reported_len)
          len         = reported_len;
      } else {
        /*
         * We have the entire packet, and it includes a 4-byte ICV.
         * Slice it off, and put it into the tree.
         *
         * We only support decrypting if we have the ICV.
         *
         * XXX - the ICV is encrypted; we're putting the encrypted
         * value, not the decrypted value, into the tree.
         */
        len          -= 4;
        reported_len -= 4;
        can_decrypt   = true;
      }
    }

    if (algorithm == PROTECTION_ALG_WEP) {
      (void) g_strlcpy(wlan_stats.protection, "WEP", MAX_PROTECT_LEN);
    } else if (algorithm == PROTECTION_ALG_TKIP) {
      (void) g_strlcpy(wlan_stats.protection, "TKIP", MAX_PROTECT_LEN);
    } else if (algorithm == PROTECTION_ALG_CCMP || algorithm == PROTECTION_ALG_CCMP_256) {
      (void) g_strlcpy(wlan_stats.protection, "CCMP", MAX_PROTECT_LEN);
    } else if (algorithm == PROTECTION_ALG_GCMP || algorithm == PROTECTION_ALG_GCMP_256) {
      (void) g_strlcpy(wlan_stats.protection, "GCMP", MAX_PROTECT_LEN);
    } else {
      (void) g_strlcpy(wlan_stats.protection, "Unknown", MAX_PROTECT_LEN);
    }

    /* protection header                                  */
    if (!can_decrypt || (next_tvb == NULL)) {
      /*
       * WEP decode impossible or failed, treat payload as raw data
       * and don't attempt fragment reassembly or further dissection.
       */
      next_tvb = tvb_new_subset_length_caplen(tvb, hdr_len + ivlen, len, reported_len);

      if (tree) {
        if (algorithm == PROTECTION_ALG_WEP) {
          if (can_decrypt)
            proto_tree_add_uint_format_value(wep_tree, hf_ieee80211_wep_icv, tvb,
                hdr_len + ivlen + len, 4,
                tvb_get_ntohl(tvb, hdr_len + ivlen + len),
                "0x%08x (not verified)",
                tvb_get_ntohl(tvb, hdr_len + ivlen + len));
        } else if (algorithm == PROTECTION_ALG_CCMP) {
        } else if (algorithm == PROTECTION_ALG_TKIP) {
        }
      }

      if ((!(option_flags & IEEE80211_COMMON_OPT_IS_CENTRINO)) && (wlan_ignore_prot == WLAN_IGNORE_PROT_NO)) {
        /* Some wireless drivers (such as Centrino) WEP payload already decrypted */
        call_data_dissector(next_tvb, pinfo, tree);
        goto end_of_wlan;
      }
    } else {
      if (algorithm == PROTECTION_ALG_WEP) {
        if (tree)
          proto_tree_add_uint_format_value(wep_tree, hf_ieee80211_wep_icv, tvb,
              hdr_len + ivlen + len, 4,
              tvb_get_ntohl(tvb, hdr_len + ivlen + len),
              "0x%08x (correct)",
              tvb_get_ntohl(tvb, hdr_len + ivlen + len));

        add_new_data_source(pinfo, next_tvb, "Decrypted WEP data");
      } else if (algorithm == PROTECTION_ALG_CCMP || algorithm == PROTECTION_ALG_CCMP_256) {
        add_new_data_source(pinfo, next_tvb, "Decrypted CCMP data");
      } else if (algorithm == PROTECTION_ALG_GCMP || algorithm == PROTECTION_ALG_GCMP_256) {
        add_new_data_source(pinfo, next_tvb, "Decrypted GCMP data");
      } else if (algorithm==PROTECTION_ALG_TKIP) {
        add_new_data_source(pinfo, next_tvb, "Decrypted TKIP data");
      }
#undef IS_TKIP
#undef IS_CCMP
#undef PROTECTION_ALG_CCMP
#undef PROTECTION_ALG_TKIP
#undef PROTECTION_ALG_WEP
    }

    /*
     * WEP decryption successful!
     *
     * Use the tvbuff we got back from the decryption; the data starts at
     * the beginning.  The lengths are already correct for the decoded WEP
     * payload.
     */
    hdr_len = 0;

  } else {
    /*
     * Not a WEP-encrypted frame; just use the data from the tvbuff
     * handed to us.
     *
     * The payload starts at "hdr_len" (i.e., just past the 802.11
     * MAC header), the length of data in the tvbuff following the
     * 802.11 header is "len", and the length of data in the packet
     * following the 802.11 header is "reported_len".
     */
    next_tvb = tvb;
  }

  /*
   * Do defragmentation if "wlan_defragment" is true, and we have more
   * fragments or this isn't the first fragment.
   *
   * We have to do some special handling to catch frames that
   * have the "More Fragments" indicator not set but that
   * don't show up as reassembled and don't have any other
   * fragments present.  Some networking interfaces appear
   * to do reassembly even when you're capturing raw packets
   * *and* show the reassembled packet without the "More
   * Fragments" indicator set *but* with a non-zero fragment
   * number.
   *
   * "fragment_add_seq_802_11()" handles that; we want to call it
   * even if we have a short frame, so that it does those checks - if
   * the frame is short, it doesn't do reassembly on it.
   *
   * (This could get some false positives if we really *did* only
   * capture the last fragment of a fragmented packet, but that's
   * life.)
   */
  save_fragmented = pinfo->fragmented;
  if (wlan_defragment && (more_frags || (frag_number != 0))) {
    fragment_head *fd_head;

    /*
     * If we've already seen this frame, look it up in the
     * table of reassembled packets, otherwise add it to
     * whatever reassembly is in progress, if any, and see
     * if it's done.
     */
    if (reported_len < 0)
      THROW(ReportedBoundsError);
    fd_head = fragment_add_seq_802_11(&wlan_reassembly_table,
        next_tvb, hdr_len, pinfo, seq_number, NULL,
        frag_number,
        reported_len,
        more_frags);
    next_tvb = process_reassembled_data(tvb, hdr_len, pinfo,
        "Reassembled 802.11", fd_head,
        &frag_items, NULL, hdr_tree);
  } else {
    /*
     * If this is the first fragment, dissect its contents, otherwise
     * just show it as a fragment.
     */
    if (frag_number != 0) {
      /* Not the first fragment - don't dissect it. */
      next_tvb = NULL;
    } else {
      /* First fragment, or not fragmented.  Dissect what we have here. */

      /* Get a tvbuff for the payload. */
      next_tvb = tvb_new_subset_length_caplen(next_tvb, hdr_len, len, reported_len);

      /*
       * If this is the first fragment, but not the only fragment,
       * tell the next protocol that.
       */
      if (more_frags)
        pinfo->fragmented = true;
      else
        pinfo->fragmented = false;
    }
  }

  if (next_tvb == NULL) {
    /* Just show this as an incomplete fragment. */
    col_set_str(pinfo->cinfo, COL_INFO, "Fragmented IEEE 802.11 frame");
    next_tvb = tvb_new_subset_length_caplen(tvb, hdr_len, len, reported_len);
    call_data_dissector(next_tvb, pinfo, tree);
    pinfo->fragmented = save_fragmented;
    goto end_of_wlan;
  }

  switch (FCF_FRAME_TYPE (fcf))
    {

    case MGT_FRAME:
      dissect_ieee80211_mgt(fcf, next_tvb, pinfo, tree);
      try_scan_ft_assoc_keys(pinfo, whdr);
      break;

    case DATA_FRAME:
      if (is_amsdu && (tvb_reported_length_remaining(next_tvb, 0) > 4)) {
        proto_item   *parent_item;
        proto_tree   *mpdu_tree;
        uint32_t      msdu_offset = 0;
        unsigned      i           = 1;

        parent_item = proto_tree_add_protocol_format(tree, proto_aggregate, next_tvb, 0,
                                    tvb_reported_length_remaining(next_tvb, 0), "IEEE 802.11 Aggregate MSDU");
        mpdu_tree = proto_item_add_subtree(parent_item, ett_msdu_aggregation_parent_tree);

        do {
          tvbuff_t           *msdu_tvb;
          uint16_t            msdu_length;
          proto_tree         *subframe_tree;
          bool                last_subframe = false;
          uint16_t            subframe_length;

          /*
           * IEEE Std 802.11-2012 says, in section 8.3.2.2 "A-MSDU format":
           *
           *  The A-MSDU subframe header contains three fields: DA, SA, and
           *  Length. The order of these fields and the bits within these
           *  fields are the same as the IEEE 802.3 frame format.
           *
           * which means that the length field is big-endian, not
           * little-endian.
           */
          msdu_length = tvb_get_ntohs(next_tvb, msdu_offset+12);

          if (tvb_reported_length_remaining(next_tvb, msdu_offset+14+msdu_length) <= 14)
            last_subframe = true;

          /* The last A-MSDU subframe has no padding. */
          if (last_subframe)
            subframe_length = 14+msdu_length;
          else
            subframe_length = WS_ROUNDUP_4(14+msdu_length);

          parent_item = proto_tree_add_item(mpdu_tree, hf_ieee80211_amsdu_subframe, next_tvb,
                            msdu_offset, subframe_length, ENC_NA);
          proto_item_append_text(parent_item, " #%u", i);
          subframe_tree = proto_item_add_subtree(parent_item, ett_msdu_aggregation_subframe_tree);
          i += 1;

          proto_tree_add_mac48_detail(&mac_da, NULL, ett_addr, tvb, subframe_tree, msdu_offset);
          proto_tree_add_mac48_detail(&mac_sa, NULL, ett_addr, tvb, subframe_tree, msdu_offset+6);
          proto_tree_add_item(subframe_tree, hf_ieee80211_amsdu_length, next_tvb, msdu_offset+12, 2, ENC_BIG_ENDIAN);

          msdu_offset += 14;
          msdu_tvb = tvb_new_subset_length(next_tvb, msdu_offset, msdu_length);
          call_dissector(llc_handle, msdu_tvb, pinfo, subframe_tree);
          if (!last_subframe) {
            uint8_t padding = (4-((msdu_offset+msdu_length)&3))&3;
            if (padding > 0)
              proto_tree_add_item(subframe_tree, hf_ieee80211_amsdu_padding, next_tvb, msdu_offset+msdu_length, padding, ENC_NA);
          }

          msdu_offset = WS_ROUNDUP_4(msdu_offset+msdu_length);
        } while (tvb_reported_length_remaining(next_tvb, msdu_offset) > 14);
      } else {
        /* I guess some bridges take Netware Ethernet_802_3 frames,
           which are 802.3 frames (with a length field rather than
           a type field, but with no 802.2 header in the payload),
           and just stick the payload into an 802.11 frame.  I've seen
           captures that show frames of that sort.

           We also handle some odd form of encapsulation in which a
           complete Ethernet frame is encapsulated within an 802.11
           data frame, with no 802.2 header.  This has been seen
           from some hardware.

           On top of that, at least at some point it appeared that
           the OLPC XO sent out frames with two bytes of 0 between
           the "end" of the 802.11 header and the beginning of
           the payload. Something similar has also been observed
           with Atheros chipsets. There the sequence control field
           seems repeated.

           And, on top of *that*, IEEE Std 802.11-2018 section
           5.1.4 "MSDU format" says:

             Logical Link Control (LLC) sublayer entities use the MAC
             sublayer service to exchange PDUs with peer LLC sublayer
             entities. These PDUs are termed MAC sublayer SDUs (MSDUs)
             when sent to the MAC sublayer. There are two LLC sublayer
             protocols used (see IEEE Std 802-2014); LLC Protocol
             Discrimination (LPD) (see ISO/IEC 8802-2:1998) and EtherType
             Protocol Discrimination (EPD) (see IEEE Std 802.3-2012).
             LPD is used for transmission of all IEEE 802.11 MSDUs with
             the exception of the 5.9 GHz bands where EPD is used
             (see E.2.3 and E.2.4).

           and IEEE Std 1609.3-2016, section 5.2 "Logical link control",
           subsection 5.2.1 "General", says:

             A Networking Services implementation shall use EPD in the
             LLC sublayer as described in IEEE Std 802, using an EtherType
             in the LLC sublayer header Type9 field (see Figure 5 and
             Figure 28). The LLC sublayer header consists solely of a
             2-octet field that contains an EtherType that identifies
             the higher layer protocol.

           and ISO 21215, second edition, 2018-06, "Intelligent transport
           systems -- Localized communications -- ITS-M5", section 6.3
           "Logical link control sub-layer" says:

             IEEE Std 802.11TM-2016 does not specify a logical link control
             sub-layer protocol. Related functionality is part of the
             communication adaptation sub-layer specified in 6.4.

             The Length/Type field specified in IEEE 802.3-2015 contains
             a 2-octet unsigned Integer number. Dependent on the value,
             the field provides either length information or EtherType
             information. If the value contained in this field is equal
             to or larger than 1 536 = 0x06.00, the field contains an
             EtherType address. Ethertype addresses are assigned by the
             IEEE Registration Authority, and are used to identify the
             protocol employed directly above the ITS-S access layer.
             This method of addressing is named "EtherType Protocol
             Discrimination" (EPD). An ITS-M5 CI shall support EPD
             specified in IEEE Std 802.

                 ...

             NOTE 2    EPD replaces LLC Protocol Discrimination (LPD).
             ETSI ITS-G5 is the only known ITS access technology still
             using LPD.

             Different to the information in IEEE Std 802.11-2016, 5.1.4,
             EPD is applicable in all frequency bands as long as
             dot11OCBActivated is set to true, i.e. activating the operation
             mode "outside the context of a BSS" (OCB).

           meaning that a packet might just begin with an Ethertype.

           So, if the packet doesn't start with 0xaa 0xaa:

             we first use the same scheme that linux-wlan-ng does to detect
             those encapsulated Ethernet frames, namely looking to see whether
             the frame either starts with 6 octets that match the destination
             address from the 802.11 header or has 6 octets that match the
             source address from the 802.11 header following the first 6 octets,
             and, if so, treat it as an encapsulated Ethernet frame;

             otherwise, we use the same scheme that we use in the Ethernet
             dissector to recognize Netware 802.3 frames, namely checking
             whether the packet starts with 0xff 0xff and, if so, treat it
             as an encapsulated IPX frame;

             otherwise, we check whether the packet starts with 0x00 0x00
             or with a copy of the sequence control field and, if so, treat
             those two octets as mysterious extra stuff preceding the
             payload (possibly OLPC stuff, possibly Ruckus Wireless stuff,
             possibly Atheros stuff), and treat what follows as a frame
             using LPD;

             otherwise, we check whether the first two octets, treated
             as an Ethertype, has a dissector and, if so, treat this as
             a frame using EPD;

             otherwise, we treat this as a frame using LPD. */
        heur_dtbl_entry_t  *hdtbl_entry;
        if (dissector_try_heuristic(heur_subdissector_list, next_tvb, pinfo, tree, &hdtbl_entry, NULL)) {
          pinfo->fragmented = save_fragmented;
          goto end_of_wlan; /* heuristics dissector handled it. */
        }
        encap_type = ENCAP_802_2;
        if (tvb_bytes_exist(next_tvb, 0, 2)) {
          octet1 = tvb_get_uint8(next_tvb, 0);
          octet2 = tvb_get_uint8(next_tvb, 1);
          if ((octet1 != 0xaa) || (octet2 != 0xaa)) {
            if ((tvb_memeql(next_tvb, 6, (const uint8_t *)pinfo->dl_src.data, 6) == 0) ||
                (tvb_memeql(next_tvb, 0, (const uint8_t *)pinfo->dl_dst.data, 6) == 0))
              encap_type = ENCAP_ETHERNET;
            else if ((octet1 == 0xff) && (octet2 == 0xff))
              encap_type = ENCAP_IPX;
            else if (((octet1 == 0x00) && (octet2 == 0x00)) &&
              tvb_bytes_exist(next_tvb, 0, 18) &&
              (tvb_memeql(next_tvb, 6, (const uint8_t*)pinfo->dl_dst.data, 6) == 0) &&
              (tvb_memeql(next_tvb, 12, (const uint8_t*)pinfo->dl_src.data, 6) == 0)) {
              proto_tree_add_item(tree, hf_ieee80211_mysterious_extra_stuff, next_tvb, 0, 6, ENC_NA);
              next_tvb = tvb_new_subset_remaining(next_tvb, 6);
              encap_type = ENCAP_ETHERNET;
            } else if (((octet1 == 0x00) && (octet2 == 0x00)) ||
                     (((octet2 << 8) | octet1) == seq_control)) {
              proto_tree_add_item(tree, hf_ieee80211_mysterious_extra_stuff, next_tvb, 0, 2, ENC_NA);
              next_tvb = tvb_new_subset_remaining(next_tvb, 2);
            } else if ((etype = ((octet1 << 8) | octet2)) > ETHERNET_II_MIN_LEN) {
              /*
               * This might be an Ethertype, so maybe this is 802.11
               * using EPD rather than LPD.  Is this a *known* Ethertype?
               */
              if (dissector_get_uint_handle(ethertype_subdissector_table,
                                            etype) != NULL) {
                /* Yes. */
                encap_type = ENCAP_EPD;
              }
            }
          }
        }

        switch (encap_type) {

        case ENCAP_802_2:
          /* 802.2 LPD */
          call_dissector(llc_handle, next_tvb, pinfo, tree);
          break;

        case ENCAP_ETHERNET:
          call_dissector(eth_withoutfcs_handle, next_tvb, pinfo, tree);
          break;

        case ENCAP_IPX:
          call_dissector(ipx_handle, next_tvb, pinfo, tree);
          break;

        case ENCAP_EPD:
          /* EPD */
          call_dissector(epd_llc_handle, next_tvb, pinfo, tree);
          break;
        }
      }
      break;

    case EXTENSION_FRAME:
    {
      dissect_ieee80211_extension(fcf, next_tvb, pinfo, tree, flags);
      break;
    }
  }
  pinfo->fragmented = save_fragmented;

end_of_wlan:
  whdr->stats = wlan_stats;
  tap_queue_packet(wlan_tap, pinfo, whdr);
  memset(&wlan_stats, 0, sizeof wlan_stats);

  return tvb_captured_length(tvb);
}

static int
dissect_ieee80211_unknown_pv(tvbuff_t *tvb, packet_info *pinfo _U_,
                             proto_tree *tree, uint8_t pv,
                             struct ieee_802_11_phdr *phdr)
{
  proto_item *ti;
  int         len;
  unsigned    offset = 0;
  proto_tree *hdr_tree;
  tvbuff_t   *next_tvb;

  col_add_fstr(pinfo->cinfo, COL_INFO, "Unknown protocol version: %u", pv);

  /* Create the protocol tree */
  len = tvb_reported_length_remaining(tvb, offset);
  ti = proto_tree_add_protocol_format(tree, proto_wlan, tvb, offset, len,
                                      "IEEE 802.11 Unknown Protocol Version:"
                                      "%d", pv);
  hdr_tree = proto_item_add_subtree(ti, ett_80211);
  proto_tree_add_item(hdr_tree, hf_ieee80211_fc_proto_version, tvb, offset, 1, ENC_NA);
  if (phdr->fcs_len == 4)
    len -= 4;
  len -= 2;  /* We have already dealt with two bytes */
  next_tvb = tvb_new_subset_length(tvb, 2, len);
  call_data_dissector(next_tvb, pinfo, hdr_tree);
  proto_tree_add_checksum(hdr_tree, tvb, len + 2, hf_ieee80211_fcs, hf_ieee80211_fcs_status, &ei_ieee80211_fcs, pinfo, 0, ENC_LITTLE_ENDIAN, PROTO_CHECKSUM_NO_FLAGS);

  return tvb_captured_length(tvb);
}

/* ************************************************************************* */
/*                          Dissect 802.11 frame                             */
/* ************************************************************************* */
/*
 * The 802.11n specification makes some fairly significant changes to the
 * layout of the MAC header.  The first two bits of the MAC header are the
 * protocol version.  You'd think that the 802.11 committee would have
 * bumped the version to indicate a different MAC layout, but NOOOO -- we
 * have to go digging for bits in various locations instead.
 */
static int
dissect_ieee80211_common(tvbuff_t *tvb, packet_info *pinfo,
                          proto_tree *tree, uint32_t option_flags,
                          struct ieee_802_11_phdr *phdr)
{
  uint8_t          pv = 0;
  bool             isDMG = (phdr->phy == PHDR_802_11_PHY_11AD);
  bool             isS1G = (phdr->phy == PHDR_802_11_PHY_11AH);
  uint16_t         fcf;
  static wlan_hdr_t whdrs[4];
  wlan_hdr_t *whdr;

  /* Update these so the info is available down the line */
  if (pinfo->pseudo_header) {
    pinfo->pseudo_header->ieee_802_11.has_frequency = phdr->has_frequency;
    pinfo->pseudo_header->ieee_802_11.frequency = phdr->frequency;
  }

  p_add_proto_data(wmem_file_scope(), pinfo, proto_wlan, IS_DMG_KEY, GINT_TO_POINTER(isDMG));

  memset(&whdrs[0], 0, sizeof(wlan_hdr_t) * 4);
  whdr= &whdrs[0];

  p_add_proto_data(wmem_file_scope(), pinfo, proto_wlan, IS_S1G_KEY, GINT_TO_POINTER(isS1G));

  /* Handling for one-one mapping between associations and conversations */
  if (!pinfo->fd->visited) {
    p_add_proto_data(wmem_file_scope(), pinfo, proto_wlan, ASSOC_COUNTER_KEY,
                     GUINT_TO_POINTER(association_counter));
  }

  col_set_str(pinfo->cinfo, COL_PROTOCOL, "802.11");
  col_clear(pinfo->cinfo, COL_INFO);

  fcf = FETCH_FCF(0);

  /*
   * Handle PV0 and PV1 in separate functions.
   */
  pv = FCF_PROT_VERSION(fcf);
  switch (pv) {
  case PV0:
    dissect_ieee80211_pv0(tvb, pinfo, tree, option_flags, whdr, phdr);
    break;
  case PV1:
    dissect_ieee80211_pv1(tvb, pinfo, tree, phdr);
    break;
  default: /* Unknown protocol version */
    dissect_ieee80211_unknown_pv(tvb, pinfo, tree, pv, phdr);
    break;
  }
  return tvb_captured_length(tvb);
}

/*
 * Dissect 802.11 with a variable-length link-layer header and with the FCS
 * presence or absence indicated by the pseudo-header, if there is one.
 */
static int
dissect_ieee80211(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
  struct ieee_802_11_phdr *phdr = (struct ieee_802_11_phdr *)data;
  struct ieee_802_11_phdr ourphdr;

  if (phdr == NULL) {
    /*
     * Fake a pseudo-header.
     * XXX - what are we supposed to do if the FCS length is unknown?
     */
    memset(&ourphdr, 0, sizeof(ourphdr));
    ourphdr.fcs_len = -1;
    ourphdr.decrypted = false;
    ourphdr.datapad = false;
    ourphdr.phy = PHDR_802_11_PHY_UNKNOWN;
    phdr = &ourphdr;
  }
  return dissect_ieee80211_common(tvb, pinfo, tree, IEEE80211_COMMON_OPT_NORMAL_QOS, phdr);
}

/*
 * Dissect 802.11 with a variable-length link-layer header and with an
 * FCS, but no pseudo-header.
 */
static int
dissect_ieee80211_withfcs(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
  struct ieee_802_11_phdr phdr;

  /* Construct a pseudo-header to hand to the common code. */
  memset(&phdr, 0, sizeof(phdr));
  phdr.fcs_len = 4;
  phdr.decrypted = false;
  phdr.datapad = false;
  phdr.phy = PHDR_802_11_PHY_UNKNOWN;
  dissect_ieee80211_common(tvb, pinfo, tree, IEEE80211_COMMON_OPT_NORMAL_QOS, &phdr);
  return tvb_captured_length(tvb);
}

/*
 * Dissect 802.11 with a variable-length link-layer header and without an
 * FCS, but no pseudo-header.
 */
static int
dissect_ieee80211_withoutfcs(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
  struct ieee_802_11_phdr phdr;

  /* Construct a pseudo-header to hand to the common code. */
  memset(&phdr, 0, sizeof(phdr));
  phdr.decrypted = false;
  phdr.datapad = false;
  phdr.phy = PHDR_802_11_PHY_UNKNOWN;
  dissect_ieee80211_common(tvb, pinfo, tree, IEEE80211_COMMON_OPT_NORMAL_QOS, &phdr);
  return tvb_captured_length(tvb);
}

/*
 * Dissect 802.11 from an Intel 2200BG adapter in a Centrino laptop
 * running Windows XP.
 *
 * From
 *
 *   https://www.wireshark.org/lists/ethereal-dev/200407/msg00184.html
 *
 * and
 *
 *   https://www.wireshark.org/lists/ethereal-dev/200407/msg00393.html:
 *
 *  I tried capturing from a Centrino laptop with the Intel 2200BG 802.11g
 *  chipset. I saw a lot of "Ethernet II" frames with 0x2452 as ethertype.
 *
 *    ...
 *
 *  This behaviour has been observed on Windows XP. In my opinion it is
 *  a "proprietary" behaviour of either the Centrino driver or the Centrino
 *  hardware. Currently I have no Linux distro installed on the machine to
 *  verify whether it is also the case.
 *
 *  These packets are seen only in a promiscuous capture:
 *    - Packets normally received by the Centrino computer have the normal
 *      structure (no 802.11/LLC header but directly IP header).
 *    - Packets that are supposed to be received by another computer have
 *      the 802.11/LLC headers. ... Also I noticed that when WEP is enabled,
 *      the 802.11 header has the flag "WEP" set to true, but the packet
 *      is already decrypted. I added a test in the code to accommodate this.
 *      For TKIP it seems to stay encrypted.
 */
static int
dissect_ieee80211_centrino(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
  struct ieee_802_11_phdr phdr;

  /* Construct a pseudo-header to hand to the common code. */
  memset(&phdr, 0, sizeof(phdr));
  phdr.decrypted = false;
  phdr.datapad = false;
  phdr.phy = PHDR_802_11_PHY_UNKNOWN;
  dissect_ieee80211_common(tvb, pinfo, tree, IEEE80211_COMMON_OPT_IS_CENTRINO|IEEE80211_COMMON_OPT_NORMAL_QOS, &phdr);
  return tvb_captured_length(tvb);
}

/*
 * Dissect 802.11 with a variable-length link-layer header and a byte-swapped
 * control field and with no FCS (some hardware sends out LWAPP-encapsulated
 * 802.11 packets with the control field byte swapped).
 */
static int
dissect_ieee80211_bsfc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
  struct ieee_802_11_phdr phdr;

  /* Construct a pseudo-header to hand to the common code. */
  memset(&phdr, 0, sizeof(phdr));
  phdr.decrypted = false;
  phdr.datapad = false;
  phdr.phy = PHDR_802_11_PHY_UNKNOWN;
  dissect_ieee80211_common(tvb, pinfo, tree, IEEE80211_COMMON_OPT_BROKEN_FC|IEEE80211_COMMON_OPT_NORMAL_QOS, &phdr);
  return tvb_captured_length(tvb);
}

/*
 * Dissect 802.11 with a variable-length link-layer header without qos elements
 * in data+qos frames and with no FCS (sent as WIDS frames by Cisco standalone
 * APs).
 */
static int
dissect_ieee80211_noqos(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
  struct ieee_802_11_phdr phdr;

  /* Construct a pseudo-header to hand to the common code. */
  memset(&phdr, 0, sizeof(phdr));
  phdr.decrypted = false;
  phdr.datapad = false;
  phdr.phy = PHDR_802_11_PHY_UNKNOWN;
  dissect_ieee80211_common(tvb, pinfo, tree, 0, &phdr);
  return tvb_captured_length(tvb);
}


/* ------------- */
static unsigned
retransmit_hash(const void *k)
{
  const retransmit_key *key = (const retransmit_key *)k;
  unsigned hash_val;
  int   i;

  hash_val = 0;
  for (i = 0; i < 6; i++)
    hash_val += key->bssid[i];

  for (i = 0; i < 6; i++)
    hash_val += key->src[i];

  return hash_val;
}

static int
retransmit_equal(const void *k1, const void *k2)
{
  const retransmit_key *key1 = (const retransmit_key *)k1;
  const retransmit_key *key2 = (const retransmit_key *)k2;

  return ((!memcmp(key1->bssid, key2->bssid, 6) && !memcmp(key1->src, key2->src, 6)) ? true:false);
}

static unsigned
frame_hash(const void *k)
{
  uint32_t frame = GPOINTER_TO_UINT(k);

  return frame;
}

static int
frame_equal(const void *k1, const void *k2)
{
  uint32_t frame1 = GPOINTER_TO_UINT(k1);
  uint32_t frame2 = GPOINTER_TO_UINT(k2);

  return frame1==frame2;
}

/*
 * EAPOL key description dissectors.
 */
#define KEY_INFO_KEYDES_VERSION_MASK        0x0007
#define KEY_INFO_KEY_TYPE_MASK              0x0008
#define KEY_INFO_KEY_INDEX_MASK             0x0030
#define KEY_INFO_INSTALL_MASK               0x0040
#define KEY_INFO_KEY_ACK_MASK               0x0080
#define KEY_INFO_KEY_MIC_MASK               0x0100
#define KEY_INFO_SECURE_MASK                0x0200
#define KEY_INFO_ERROR_MASK                 0x0400
#define KEY_INFO_REQUEST_MASK               0x0800
#define KEY_INFO_ENCRYPTED_KEY_DATA_MASK    0x1000
#define KEY_INFO_SMK_MESSAGE_MASK           0x2000

#define KEYDES_VER_TYPE1        0x01
#define KEYDES_VER_TYPE2        0x02
#define KEYDES_VER_TYPE3        0x03

static const value_string keydes_version_vals[] = {
  { KEYDES_VER_TYPE1,     "RC4 Cipher, HMAC-MD5 MIC" },
  { KEYDES_VER_TYPE2,     "AES Cipher, HMAC-SHA1 MIC" },
  { KEYDES_VER_TYPE3,     "AES Cipher, AES-128-CMAC MIC" },
  { 0, NULL }
};

static int proto_wlan_rsna_eapol;

static int hf_wlan_rsna_eapol_wpa_keydes_msgnr;
static int hf_wlan_rsna_eapol_wpa_keydes_keyinfo;
static int hf_wlan_rsna_eapol_wpa_keydes_keyinfo_keydes_version;
static int hf_wlan_rsna_eapol_wpa_keydes_keyinfo_key_type;
static int hf_wlan_rsna_eapol_wpa_keydes_keyinfo_key_index;
static int hf_wlan_rsna_eapol_wpa_keydes_keyinfo_install;
static int hf_wlan_rsna_eapol_wpa_keydes_keyinfo_key_ack;
static int hf_wlan_rsna_eapol_wpa_keydes_keyinfo_key_mic;
static int hf_wlan_rsna_eapol_wpa_keydes_keyinfo_secure;
static int hf_wlan_rsna_eapol_wpa_keydes_keyinfo_error;
static int hf_wlan_rsna_eapol_wpa_keydes_keyinfo_request;
static int hf_wlan_rsna_eapol_wpa_keydes_keyinfo_encrypted_key_data;
static int hf_wlan_rsna_eapol_wpa_keydes_keyinfo_smk_message;
static int hf_wlan_rsna_eapol_keydes_key_len;
static int hf_wlan_rsna_eapol_keydes_replay_counter;
static int hf_wlan_rsna_eapol_keydes_key_iv;
static int hf_wlan_rsna_eapol_wpa_keydes_nonce;
static int hf_wlan_rsna_eapol_wpa_keydes_rsc;
static int hf_wlan_rsna_eapol_wpa_keydes_id;
static int hf_wlan_rsna_eapol_wpa_keydes_mic;
static int hf_wlan_rsna_eapol_wpa_keydes_data_len;
static int hf_wlan_rsna_eapol_wpa_keydes_data;
static int hf_wlan_rsna_eapol_wpa_keydes_padding;
static int hf_wlan_rsna_eapol_wpa_extraneous;

static int ett_keyinfo;
static int ett_wlan_rsna_eapol_keydes_data;

static const true_false_string keyinfo_key_type_tfs = { "Pairwise Key", "Group Key" };

static int
keydata_padding_len(tvbuff_t *tvb)
{
  int keydata_len = tvb_reported_length(tvb);
  int len_no_padding = keydata_len;
  const uint8_t *keydata = tvb_get_ptr(tvb, 0, keydata_len);
  while (len_no_padding > 0 && (keydata[len_no_padding - 1] == 0x00)) {
    len_no_padding--;
  }
  if (len_no_padding > 0 && keydata[len_no_padding - 1] == 0xdd) {
    len_no_padding--;
    return keydata_len - len_no_padding;
  }
  return 0;
}

static void
get_eapol_parsed(packet_info *pinfo, PDOT11DECRYPT_EAPOL_PARSED eapol_parsed)
{
  if (!eapol_parsed) {
    return;
  }

  proto_eapol_key_frame_t *eapol_key =
    (proto_eapol_key_frame_t *)p_get_proto_data(pinfo->pool, pinfo, proto_eapol,
                                                EAPOL_KEY_FRAME_KEY);
  if (!eapol_key) {
    return;
  }
  eapol_parsed->len = eapol_key->len;
  eapol_parsed->key_type = eapol_key->type;
  eapol_parsed->key_version = (uint8_t)
    GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wlan, KEY_VERSION_KEY));
  eapol_parsed->key_len = (uint16_t)
    GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wlan, KEY_LEN_KEY));
  eapol_parsed->key_iv = (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, KEY_IV_KEY);
  eapol_parsed->key_data = (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, KEY_DATA_KEY);
  eapol_parsed->key_data_len = (uint16_t)
    GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wlan, KEY_DATA_LEN_KEY));
  eapol_parsed->nonce = (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, NONCE_KEY);
  eapol_parsed->group_cipher = (uint8_t)
    GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wlan, GROUP_CIPHER_KEY));
  eapol_parsed->cipher = (uint8_t)
    GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wlan, CIPHER_KEY));
  eapol_parsed->akm = (uint8_t)
    GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wlan, AKM_KEY));
  eapol_parsed->mic = (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, MIC_KEY);
  eapol_parsed->mic_len =
    GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wlan, MIC_LEN_KEY));
  eapol_parsed->gtk = (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, GTK_KEY);
  eapol_parsed->gtk_len = (uint16_t)
    GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wlan, GTK_LEN_KEY));

  /* For fast bss transition akms */
  eapol_parsed->mdid = (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, MDID_KEY);
  eapol_parsed->fte.r0kh_id =
    (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, FTE_R0KH_ID_KEY);
  eapol_parsed->fte.r0kh_id_len = (uint8_t)
    GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wlan, FTE_R0KH_ID_LEN_KEY));
  eapol_parsed->fte.r1kh_id =
    (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, FTE_R1KH_ID_KEY);
  eapol_parsed->fte.r1kh_id_len = (uint8_t)
    GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wlan, FTE_R1KH_ID_LEN_KEY));
}

static void
get_assoc_parsed(packet_info *pinfo, PDOT11DECRYPT_ASSOC_PARSED assoc_parsed)
{
  if (!assoc_parsed) {
    return;
  }

  assoc_parsed->group_cipher = (uint8_t)
    GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wlan, GROUP_CIPHER_KEY));
  assoc_parsed->cipher = (uint8_t)
    GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wlan, CIPHER_KEY));
  assoc_parsed->akm = (uint8_t)
    GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wlan, AKM_KEY));
  assoc_parsed->fte.mic = (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, FTE_MIC_KEY);
  assoc_parsed->fte.mic_len =
    GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wlan, FTE_MIC_LEN_KEY));
  assoc_parsed->mdid = (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, MDID_KEY);
  assoc_parsed->fte.anonce =
    (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, FTE_ANONCE_KEY);
  assoc_parsed->fte.snonce =
    (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, FTE_SNONCE_KEY);
  assoc_parsed->fte.r0kh_id =
    (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, FTE_R0KH_ID_KEY);
  assoc_parsed->fte.r0kh_id_len = (uint8_t)
    GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wlan, FTE_R0KH_ID_LEN_KEY));
  assoc_parsed->fte.r1kh_id =
    (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, FTE_R1KH_ID_KEY);
  assoc_parsed->fte.r1kh_id_len = (uint8_t)
    GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wlan, FTE_R1KH_ID_LEN_KEY));
  assoc_parsed->rsne_tag =
    (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, RSNE_TAG_KEY);
  assoc_parsed->mde_tag =
    (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, MDE_TAG_KEY);
  assoc_parsed->fte_tag =
    (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, FTE_TAG_KEY);
  assoc_parsed->rde_tag =
    (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, RDE_TAG_KEY);
  assoc_parsed->gtk = (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, GTK_KEY);
  assoc_parsed->gtk_len = (uint16_t)
    GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wlan, GTK_LEN_KEY));
  assoc_parsed->gtk_subelem_key_len = (uint16_t)
    GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wlan, GTK_SUBELEM_KEY_LEN_KEY));
}

static void
try_decrypt_keydata(packet_info *pinfo)
{
  uint32_t dec_caplen;
  unsigned char dec_data[DOT11DECRYPT_EAPOL_MAX_LEN];
  DOT11DECRYPT_EAPOL_PARSED eapol_parsed;
  DOT11DECRYPT_KEY_ITEM used_key;

  if (!enable_decryption) {
    return;
  }

  uint8_t *bssid = (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, BSSID_KEY);
  uint8_t *sta = (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, STA_KEY);
  if (!bssid || !sta) {
    return;
  }

  memset(&eapol_parsed, 0, sizeof(eapol_parsed));
  get_eapol_parsed(pinfo, &eapol_parsed);

  int ret = Dot11DecryptDecryptKeyData(&dot11decrypt_ctx,
                                        &eapol_parsed,
                                        bssid, sta,
                                        dec_data, &dec_caplen,
                                        &used_key);
  if (ret == DOT11DECRYPT_RET_SUCCESS && dec_caplen > 0) {
    proto_keydata_t *eapol = wmem_new(wmem_file_scope(), proto_keydata_t);
    eapol->used_key = used_key;
    eapol->keydata_len = dec_caplen;
    eapol->keydata = (uint8_t *)wmem_memdup(wmem_file_scope(), dec_data, dec_caplen);

    /* Save decrypted eapol keydata for rsna dissector */
    p_add_proto_data(wmem_file_scope(), pinfo, proto_wlan, DECRYPTED_EAPOL_KEY, eapol);
  }
}

static void
try_scan_eapol_keys(packet_info *pinfo, DOT11DECRYPT_HS_MSG_TYPE msg_type)
{
  DOT11DECRYPT_EAPOL_PARSED eapol_parsed;

  if (!enable_decryption) {
    return;
  }

  proto_eapol_key_frame_t *eapol_key =
    (proto_eapol_key_frame_t *)p_get_proto_data(pinfo->pool, pinfo, proto_eapol,
                                                EAPOL_KEY_FRAME_KEY);
  uint8_t *bssid = (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, BSSID_KEY);
  uint8_t *sta = (uint8_t *)p_get_proto_data(pinfo->pool, pinfo, proto_wlan, STA_KEY);

  if (!eapol_key || !bssid || !sta) {
    return;
  }

  memset(&eapol_parsed, 0, sizeof(eapol_parsed));
  get_eapol_parsed(pinfo, &eapol_parsed);
  eapol_parsed.msg_type = msg_type;

  Dot11DecryptScanEapolForKeys(&dot11decrypt_ctx,
                               &eapol_parsed,
                               eapol_key->data, eapol_key->len,
                               bssid, sta);
}

static void
try_scan_ft_assoc_keys(packet_info *pinfo, const wlan_hdr_t *whdr)
{
  DOT11DECRYPT_ASSOC_PARSED assoc_parsed;
  uint8_t decrypted_buf[DOT11DECRYPT_WPA_PTK_MAX_LEN];
  size_t decrypted_len = 0;
  DOT11DECRYPT_KEY_ITEM used_key;
  int ret;

  if (!enable_decryption || pinfo->fd->visited || !whdr) {
    return;
  }
  if (whdr->type != MGT_ASSOC_REQ && whdr->type != MGT_ASSOC_RESP &&
      whdr->type != MGT_REASSOC_REQ && whdr->type != MGT_REASSOC_RESP) {
    return;
  }

  memset(&assoc_parsed, 0, sizeof(assoc_parsed));
  get_assoc_parsed(pinfo, &assoc_parsed);
  /* Implicit conversion from MGT_ASSOC_xxx to DOT11DECRYPT_SUBTYPE_xxx */
  assoc_parsed.frame_subtype = (uint8_t)whdr->type;
  memcpy(assoc_parsed.bssid, whdr->bssid.data, 6);
  memcpy(assoc_parsed.sa, whdr->src.data, 6);
  memcpy(assoc_parsed.da, whdr->dst.data, 6);

  ret = Dot11DecryptScanFtAssocForKeys(&dot11decrypt_ctx, &assoc_parsed,
                                       decrypted_buf, &decrypted_len,
                                       &used_key);
  if (ret == DOT11DECRYPT_RET_SUCCESS_HANDSHAKE && decrypted_len > 0) {
    proto_keydata_t *proto = wmem_new(wmem_file_scope(), proto_keydata_t);
    proto->used_key = used_key;
    proto->keydata_len = (unsigned)decrypted_len;
    proto->keydata = (uint8_t *)wmem_memdup(wmem_file_scope(), decrypted_buf, decrypted_len);

    /* Save decrypted GTK keydata for tag dissector */
    p_add_proto_data(wmem_file_scope(), pinfo, proto_wlan, DECRYPTED_GTK_KEY, proto);
  }
}

/*
 * In some cases we do not know the key mic len from other sources, however
 * we can figure it out from the first frame in the four-way handshake.
 *
 * It defaults to 16 bytes, but if there are more than 16 bytes of zeros before
 * the eapol data len, then we can adjust upwards. We used steps of 8 bytes
 * because the MIC len is usually a multiple of 8 in length.
 *
 * If we find it, set it in the conversation data for the wlan conversation
 * found via the pinfo.
 */
static void
discover_key_mic_len1(tvbuff_t *tvb, packet_info *pinfo, unsigned offset)
{
  conversation_t *conversation = find_or_create_wlan_conversation(pinfo);
  ieee80211_conversation_data_t *conversation_data = get_or_create_conversation_data(conversation);
  uint16_t mic_len = 16;

  /*
   * The first sixteen bytes at offset should 0. If not, get out of here
   */
  if (tvb_get_letoh64(tvb, offset) != 0 ||
      tvb_get_letoh64(tvb, offset + 8) != 0) {
    return;
  }

  offset += 16;
  /*
   * Do we have another 8 bytes of zeros? But do not fall off the end!
   */
  while ((tvb_captured_length(tvb) > (offset + 8)) &&
         tvb_get_letoh64(tvb, offset) == 0) {
    /*
     * equal to the rest of the data.
     */
    mic_len += 8;
    offset += 8;

  }

  /*
   * Do the next two bytes give us the length of the remainder?
   */
  if (tvb_get_uint16(tvb, offset, ENC_BIG_ENDIAN) + 2 ==
      tvb_reported_length_remaining(tvb, offset)) {
    conversation_data->discovered_key_mic_len = mic_len;
  }
}

/*
 * Sometimes we cannot discover it from the first frame of the four-way
 * handshake, however, we can still determine it from the second frame.
 */
static void
discover_key_mic_len2(tvbuff_t *tvb, packet_info *pinfo, unsigned offset)
{
  conversation_t *conversation = find_or_create_wlan_conversation(pinfo);
  ieee80211_conversation_data_t *conversation_data = get_or_create_conversation_data(conversation);
  uint16_t mic_len = 16;

  /*
   * The KeyMIC should have a 2-byte length field following it, and that
   * should cover the rest of the captured data ...
   */
  offset += 16;

  while ((tvb_captured_length(tvb) > (offset + 2)) &&
          tvb_get_uint16(tvb, offset, ENC_BIG_ENDIAN) !=
            tvb_reported_length_remaining(tvb, offset + 2)) {

    /*
     * Add 8 more bytes.
     */
    mic_len +=8;
    offset+= 8;
  }

  /*
   * Check that we are correct ... ie, the two bytes where we are is the length
   * of the remaining data, because we might have walked off the end of the
   * tvb.
   *
   * We check against the reported length remaining because the capture might
   * have been truncated beyond the key data length field.
   */
  if (tvb_captured_length_remaining(tvb, offset) >= 2 &&
      tvb_get_uint16(tvb, offset, ENC_BIG_ENDIAN) + 2 ==
        tvb_reported_length_remaining(tvb, offset)) {
    conversation_data->discovered_key_mic_len = mic_len;
  }
}

static int
dissect_wlan_rsna_eapol_wpa_or_rsn_key(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
{
  unsigned    offset = 0;
  uint16_t    keyinfo;
  uint16_t    eapol_data_len;
  proto_tree *keydes_tree;
  proto_tree *ti = NULL;
  static int * const wlan_rsna_eapol_wpa_keydes_keyinfo[] = {
    &hf_wlan_rsna_eapol_wpa_keydes_keyinfo_keydes_version,
    &hf_wlan_rsna_eapol_wpa_keydes_keyinfo_key_type,
    &hf_wlan_rsna_eapol_wpa_keydes_keyinfo_key_index,
    &hf_wlan_rsna_eapol_wpa_keydes_keyinfo_install,
    &hf_wlan_rsna_eapol_wpa_keydes_keyinfo_key_ack,
    &hf_wlan_rsna_eapol_wpa_keydes_keyinfo_key_mic,
    &hf_wlan_rsna_eapol_wpa_keydes_keyinfo_secure,
    &hf_wlan_rsna_eapol_wpa_keydes_keyinfo_error,
    &hf_wlan_rsna_eapol_wpa_keydes_keyinfo_request,
    &hf_wlan_rsna_eapol_wpa_keydes_keyinfo_encrypted_key_data,
    &hf_wlan_rsna_eapol_wpa_keydes_keyinfo_smk_message,
    NULL
  };
  uint16_t eapol_data_offset = 76;  /* 92 - 16 */
  bool has_nonce = determine_nonce_is_set(tvb);
  bool defaulted_mic_len = false;
  uint16_t eapol_key_mic_len = determine_mic_len(pinfo, false, &defaulted_mic_len);
  save_proto_data_value(pinfo, eapol_key_mic_len, MIC_LEN_KEY);
  eapol_data_offset += eapol_key_mic_len;
  DOT11DECRYPT_HS_MSG_TYPE msg_type = DOT11DECRYPT_HS_MSG_TYPE_INVALID;

  /*
   * RSNA key descriptors.
   */
  eapol_data_len = tvb_get_ntohs(tvb, offset+eapol_data_offset);
  keyinfo = tvb_get_ntohs(tvb, offset);
  if (keyinfo & KEY_INFO_REQUEST_MASK) {
    col_set_str(pinfo->cinfo, COL_INFO, "Key (Request)");
    if (keyinfo & KEY_INFO_ERROR_MASK)
      col_set_str(pinfo->cinfo, COL_INFO, "Key (Request, Error)");
  } else if (keyinfo & KEY_INFO_KEY_TYPE_MASK) {
    uint16_t masked;
    /* Windows is setting the Secure Bit on message 2 when rekeying, so we'll ignore it */
    /* When an AEAD cipher is used no MIC is included, so we cannot rely on the MIC flag */
    masked = keyinfo &
      (KEY_INFO_INSTALL_MASK | KEY_INFO_KEY_ACK_MASK);

    switch (masked) {
    case KEY_INFO_KEY_ACK_MASK:
    {
      ti = proto_tree_add_uint(tree, hf_wlan_rsna_eapol_wpa_keydes_msgnr, tvb, offset, 0, 1);

      col_set_str(pinfo->cinfo, COL_INFO, "Key (Message 1 of 4)");
      /*
       * If we defaulted it, then try to determine the mic len and update
       * structures.
       */
      if (defaulted_mic_len) {
        discover_key_mic_len1(tvb, pinfo, 76);
        /* Must reset the MIC len */
        eapol_key_mic_len = determine_mic_len(pinfo, false, &defaulted_mic_len);
        save_proto_data_value(pinfo, eapol_key_mic_len, MIC_LEN_KEY);
        eapol_data_offset = 76 + eapol_key_mic_len;
        eapol_data_len = tvb_get_ntohs(tvb, offset + eapol_data_offset);
      }
      msg_type = DOT11DECRYPT_HS_MSG_TYPE_4WHS_1;
      break;
    }

    case (KEY_INFO_INSTALL_MASK | KEY_INFO_KEY_ACK_MASK):
    {
      ti = proto_tree_add_uint(tree, hf_wlan_rsna_eapol_wpa_keydes_msgnr, tvb, offset, 0, 3);

      col_set_str(pinfo->cinfo, COL_INFO, "Key (Message 3 of 4)");
      /* Get correct MIC LEN if there is no M1 and M2 */
      if (defaulted_mic_len) {
        discover_key_mic_len2(tvb, pinfo, 76);
        eapol_key_mic_len = determine_mic_len(pinfo, false, &defaulted_mic_len);
        save_proto_data_value(pinfo, eapol_key_mic_len, MIC_LEN_KEY);
        eapol_data_offset = 76 + eapol_key_mic_len;
        eapol_data_len = tvb_get_ntohs(tvb, offset + eapol_data_offset);
      }
      msg_type = DOT11DECRYPT_HS_MSG_TYPE_4WHS_3;
      break;
    }

    default:
      /* We check the key length to differentiate between message 2 and 4 and just hope that
      there are no strange implementations with key data and non-zero key length in message 4.
      According to the IEEE specification, sections 11.6.6.3 and 11.6.6.5 we should
      use the Secure Bit and/or the Nonce, but there are implementations ignoring the spec.
      The Secure Bit is incorrectly set on rekeys for Windows clients for Message 2 and the Nonce is non-zero
      in Message 4 in Bug 11994 (Apple?) */
      /* In Wi-SUN protocol, message 2 does not contains any data. However, all the implementations
       * respect 802.11X, so Secure Bit is set only on message 2 and Nonce is set only on message 4
       * (see section 6.5.2.3 of Wi-SUN specification) */
      /* When using AES-SIV without plaintext (i.e. only for integrity), the ciphertext has length 16 */
      /* With MLO message 4 will have 12 bytes of data */
      if (((eapol_key_mic_len == 0) && (eapol_data_len > 16)) ||
          ((eapol_key_mic_len > 0) && (eapol_data_len == 0) && !(keyinfo & KEY_INFO_SECURE_MASK) && has_nonce) ||
          ((eapol_key_mic_len > 0) && (eapol_data_len != 0) && (eapol_data_len != 12))) {
        ti = proto_tree_add_uint(tree, hf_wlan_rsna_eapol_wpa_keydes_msgnr, tvb, offset, 0, 2);

        col_set_str(pinfo->cinfo, COL_INFO, "Key (Message 2 of 4)");
        if (defaulted_mic_len) {
          discover_key_mic_len2(tvb, pinfo, 76);
          eapol_key_mic_len = determine_mic_len(pinfo, false, &defaulted_mic_len);
          save_proto_data_value(pinfo, eapol_key_mic_len, MIC_LEN_KEY);
          eapol_data_offset = 76 + eapol_key_mic_len;
          eapol_data_len = tvb_get_ntohs(tvb, offset + eapol_data_offset);
        }
        msg_type = DOT11DECRYPT_HS_MSG_TYPE_4WHS_2;
      } else {
        ti = proto_tree_add_uint(tree, hf_wlan_rsna_eapol_wpa_keydes_msgnr, tvb, offset, 0, 4);

        col_set_str(pinfo->cinfo, COL_INFO, "Key (Message 4 of 4)");
        msg_type = DOT11DECRYPT_HS_MSG_TYPE_4WHS_4;
      }
      break;
    }
  } else {
    if (keyinfo & KEY_INFO_KEY_ACK_MASK) {
      ti = proto_tree_add_uint(tree, hf_wlan_rsna_eapol_wpa_keydes_msgnr, tvb, offset, 0, 1);

      col_set_str(pinfo->cinfo, COL_INFO, "Key (Group Message 1 of 2)");
      msg_type = DOT11DECRYPT_HS_MSG_TYPE_GHS_1;
    } else {
      ti = proto_tree_add_uint(tree, hf_wlan_rsna_eapol_wpa_keydes_msgnr, tvb, offset, 0, 2);

      col_set_str(pinfo->cinfo, COL_INFO, "Key (Group Message 2 of 2)");
      msg_type = DOT11DECRYPT_HS_MSG_TYPE_GHS_2;
    }
  }
  proto_item_set_generated(ti);

  uint16_t keydes_version = tvb_get_ntohs(tvb, offset) & KEY_INFO_KEYDES_VERSION_MASK;
  save_proto_data_value(pinfo, keydes_version, KEY_VERSION_KEY);
  proto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_wlan_rsna_eapol_wpa_keydes_keyinfo,
                                    ett_keyinfo, wlan_rsna_eapol_wpa_keydes_keyinfo,
                                    ENC_BIG_ENDIAN, BMT_NO_APPEND);
  offset += 2;

  uint16_t key_len = tvb_get_ntohs(tvb, offset);
  proto_tree_add_item(tree, hf_wlan_rsna_eapol_keydes_key_len, tvb, offset,
                      2, ENC_BIG_ENDIAN);
  save_proto_data_value(pinfo, tvb_get_ntohs(tvb, offset), KEY_LEN_KEY);
  offset += 2;
  proto_tree_add_item(tree, hf_wlan_rsna_eapol_keydes_replay_counter, tvb,
                      offset, 8, ENC_BIG_ENDIAN);
  offset += 8;
  proto_tree_add_item(tree, hf_wlan_rsna_eapol_wpa_keydes_nonce, tvb, offset,
                      32, ENC_NA);
  save_proto_data(tvb, pinfo, offset, 32, NONCE_KEY);

  offset += 32;
  proto_tree_add_item(tree, hf_wlan_rsna_eapol_keydes_key_iv, tvb,
                      offset, 16, ENC_NA);
  save_proto_data(tvb, pinfo, offset, 16, KEY_IV_KEY);
  offset += 16;
  proto_tree_add_item(tree, hf_wlan_rsna_eapol_wpa_keydes_rsc, tvb, offset,
                      8, ENC_NA);
  offset += 8;
  proto_tree_add_item(tree, hf_wlan_rsna_eapol_wpa_keydes_id, tvb, offset, 8,
                      ENC_NA);
  offset += 8;

  proto_tree_add_item(tree, hf_wlan_rsna_eapol_wpa_keydes_mic, tvb, offset,
                      eapol_key_mic_len, ENC_NA);
  save_proto_data(tvb, pinfo, offset, eapol_key_mic_len, MIC_KEY);
  offset += eapol_key_mic_len;

  proto_tree_add_item(tree, hf_wlan_rsna_eapol_wpa_keydes_data_len, tvb,
                      offset, 2, ENC_BIG_ENDIAN);
  save_proto_data_value(pinfo, tvb_get_ntohs(tvb, offset), KEY_DATA_LEN_KEY);
  offset += 2;

  if (eapol_data_len != 0) {
    save_proto_data(tvb, pinfo, offset, eapol_data_len, KEY_DATA_KEY);
    ti = proto_tree_add_item(tree, hf_wlan_rsna_eapol_wpa_keydes_data,
                             tvb, offset, eapol_data_len, ENC_NA);
    if ((keyinfo & KEY_INFO_ENCRYPTED_KEY_DATA_MASK) ||
        (!(keyinfo & KEY_INFO_KEY_TYPE_MASK) && key_len)) {
      /* RSN: EAPOL-Key Key Data is encrypted.
       * WPA: Group Keys use encrypted Key Data.
       * IEEE 802.11i-2004 8.5.2.
       * Having an encrypted data field without the Encrypted Key Data set
       * is not standard, but there are WPA implementation which assume
       * encryption when Key Type = 0. In Wi-SUN, the EAPOL-Key frame has
       * Key Type = 0 and Encrypted Key Data = 0, but the Key Data is not
       * encrypted. To differentiate this case from non standard WPA, we
       * check the Key Length, which is 0 for Wi-SUN.
       * Let decryption engine try to decrypt this and if successful it's
       * stored in EAPOL_KEY proto data.
       */
      if (!pinfo->fd->visited) {
        try_decrypt_keydata(pinfo);
      }

      proto_keydata_t *eapol;
      eapol = (proto_keydata_t*)
        p_get_proto_data(wmem_file_scope(), pinfo, proto_wlan, DECRYPTED_EAPOL_KEY);

      if (eapol) {
        int keydata_len = eapol->keydata_len;
        tvbuff_t *next_tvb = tvb_new_child_real_data(tvb, eapol->keydata,
                                                     keydata_len, keydata_len);
        keydes_tree = proto_item_add_subtree(ti, ett_wlan_rsna_eapol_keydes_data);

        if (keydes_version == KEYDES_VER_TYPE1) {
          add_new_data_source(pinfo, next_tvb, "Decrypted RC4 keydata");
          save_proto_data(next_tvb, pinfo, 0, keydata_len, GTK_KEY);
          save_proto_data_value(pinfo, keydata_len, GTK_LEN_KEY);
        } else {
          add_new_data_source(pinfo, next_tvb, "Decrypted AES keydata");
          int padding_len = keydata_padding_len(next_tvb);
          ieee_80211_add_tagged_parameters(next_tvb, 0, pinfo, keydes_tree,
                                          keydata_len - padding_len,
                                          -1, NULL);
          if (padding_len) {
            proto_tree_add_item(keydes_tree, hf_wlan_rsna_eapol_wpa_keydes_padding,
                                next_tvb, keydata_len - padding_len,
                                padding_len, ENC_NA);
          }
        }
        /* Also add the PTK used to decrypt and validate the keydata. */
        add_ptk_analysis(tvb, keydes_tree, &eapol->used_key);
      }
    } else {
      keydes_tree = proto_item_add_subtree(ti, ett_wlan_rsna_eapol_keydes_data);
      ieee_80211_add_tagged_parameters(tvb, offset, pinfo, keydes_tree,
                                       tvb_reported_length_remaining(tvb, offset),
                                       -1, NULL);
    }

    offset += eapol_data_len;
  }
  if (!pinfo->fd->visited && msg_type != DOT11DECRYPT_HS_MSG_TYPE_INVALID) {
    /* Key data at this pointer was either not encrypted or dot11decrypt
     * engine has tried to decrypt keydata. Try to extract the keys now that
     * all fields from the EAPOL frame have been parsed.
     */
    try_scan_eapol_keys(pinfo, msg_type);
  }

  /*
   * Do we have extraneous data at the end?
   */
  if (offset < (tvb_captured_length(tvb) - 1)) {
    proto_item *extra;
    extra = proto_tree_add_item(tree, hf_wlan_rsna_eapol_wpa_extraneous, tvb,
                                offset,
                                tvb_captured_length_remaining(tvb, offset),
                                ENC_NA);
    expert_add_info_format(pinfo, extra, &ei_ieee80211_inv_val,
                           "Extraneous and invalid data in EAPOL frame");
  }
  return tvb_captured_length(tvb);
}

static void try_scan_tdls_keys(tvbuff_t *tvb, packet_info *pinfo _U_, int offset)
{
  if (!enable_decryption) {
    return;
  }
  int len = tvb_captured_length(tvb) - offset;
  const uint8_t *action = tvb_get_ptr(tvb, offset, len);
  if (action) {
    Dot11DecryptScanTdlsForKeys(&dot11decrypt_ctx, action, len);
  }
}

/* It returns the algorithm used for decryption and trailer length. */
static tvbuff_t *
try_decrypt(tvbuff_t *tvb, packet_info *pinfo, unsigned offset, unsigned len,
            uint8_t *algorithm, uint32_t *sec_trailer,
            PDOT11DECRYPT_KEY_ITEM used_key)
{
  const uint8_t     *enc_data;
  tvbuff_t          *decr_tvb = NULL;
  uint32_t           dec_caplen;
  unsigned char      dec_data[DOT11DECRYPT_MAX_CAPLEN];

  if (!enable_decryption)
    return NULL;

  /* get the entire packet                                  */
  enc_data = tvb_get_ptr(tvb, 0, len+offset);

  /* decrypt packet with Dot11Decrypt */
  int ret = Dot11DecryptDecryptPacket(&dot11decrypt_ctx, enc_data, offset, offset+len,
                                       dec_data, &dec_caplen, used_key);
  if (ret == DOT11DECRYPT_RET_SUCCESS) {
    uint8_t *tmp;
    *algorithm=used_key->KeyType;
    switch (*algorithm) {
      case DOT11DECRYPT_KEY_TYPE_WEP:
        *sec_trailer=DOT11DECRYPT_WEP_TRAILER;
        break;
      case DOT11DECRYPT_KEY_TYPE_CCMP:
        *sec_trailer=DOT11DECRYPT_CCMP_TRAILER;
        break;
      case DOT11DECRYPT_KEY_TYPE_CCMP_256:
        *sec_trailer = DOT11DECRYPT_CCMP_256_TRAILER;
        break;
      case DOT11DECRYPT_KEY_TYPE_GCMP:
      case DOT11DECRYPT_KEY_TYPE_GCMP_256:
        *sec_trailer = DOT11DECRYPT_GCMP_TRAILER;
        break;
      case DOT11DECRYPT_KEY_TYPE_TKIP:
        *sec_trailer=DOT11DECRYPT_TKIP_TRAILER;
        break;
      default:
        return NULL;
    }
    if (dec_caplen > offset) {
        /* allocate buffer for decrypted payload */
        tmp = (uint8_t *)wmem_memdup(pinfo->pool, dec_data+offset, dec_caplen-offset);
        len = dec_caplen-offset;

        /* decrypt successful, let's set up a new data tvb. */
        decr_tvb = tvb_new_child_real_data(tvb, tmp, len, len);
    }
  }
  return decr_tvb;
}

/* Collect our WEP and WPA keys */
static void
set_dot11decrypt_keys(void)
{
  unsigned                  i;
  DOT11DECRYPT_KEYS_COLLECTION  *keys = g_new(DOT11DECRYPT_KEYS_COLLECTION, 1);

  keys->nKeys = 0;

  for (i = 0; (uat_wep_key_records != NULL) && (i < num_wepkeys_uat) && (i < MAX_ENCRYPTION_KEYS); i++)
  {
    decryption_key_t *dk;
    dk = parse_key_string(uat_wep_key_records[i].string, uat_wep_key_records[i].key, NULL);

    if (dk != NULL)
    {
      /* parse_key_string() does vaildation, so if it doesn't
       * return NULL, we can just copy the results.
       */
      DOT11DECRYPT_KEY_ITEM key = { 0 };
      if (dk->type == DOT11DECRYPT_KEY_TYPE_WEP)
      {
        key.KeyType = DOT11DECRYPT_KEY_TYPE_WEP;

        /*
         * WEP key is correct (well, at least no longer than
         * DOT11DECRYPT_WEP_KEY_MAXLEN)
         */
        memcpy(key.KeyData.Wep.WepKey, dk->key->data, dk->key->len);
        key.KeyData.Wep.WepKeyLen = dk->key->len;
        keys->Keys[keys->nKeys] = key;
        keys->nKeys += 1;
      }
      else if (dk->type == DOT11DECRYPT_KEY_TYPE_WPA_PWD)
      {
        key.KeyType = DOT11DECRYPT_KEY_TYPE_WPA_PWD;

        /*
         * dk->key has a valid length, because otherwise
         * parse_key_string() would have returned NULL.
         */
        memcpy(key.UserPwd.Passphrase, dk->key->data, dk->key->len);
        key.UserPwd.PassphraseLen = dk->key->len;

        key.UserPwd.SsidLen = 0;
        if ((dk->ssid != NULL) && (dk->ssid->len <= DOT11DECRYPT_WPA_SSID_MAX_LEN))
        {
          memcpy(key.UserPwd.Ssid, dk->ssid->data, dk->ssid->len);
          key.UserPwd.SsidLen = dk->ssid->len;
        }

        keys->Keys[keys->nKeys] = key;
        keys->nKeys += 1;
      }
      else if (dk->type == DOT11DECRYPT_KEY_TYPE_WPA_PSK)
      {
        key.KeyType = DOT11DECRYPT_KEY_TYPE_WPA_PSK;

        memcpy(key.KeyData.Wpa.Psk, dk->key->data, dk->key->len);
        key.KeyData.Wpa.PskLen = dk->key->len;
        keys->Keys[keys->nKeys] = key;
        keys->nKeys += 1;
      }
      else if (dk->type == DOT11DECRYPT_KEY_TYPE_TK)
      {
        key.KeyType = DOT11DECRYPT_KEY_TYPE_TK;

        memcpy(key.Tk.Tk, dk->key->data, dk->key->len);
        key.Tk.Len = dk->key->len;
        keys->Keys[keys->nKeys] = key;
        keys->nKeys += 1;
      }
      else if (dk->type == DOT11DECRYPT_KEY_TYPE_MSK)
      {
        key.KeyType = DOT11DECRYPT_KEY_TYPE_MSK;

        memcpy(key.Msk.Msk, dk->key->data, dk->key->len);
        key.Msk.Len = dk->key->len;
        keys->Keys[keys->nKeys] = key;
        keys->nKeys += 1;
      }
      free_key_string(dk);
    }
  }

  /* Now set the keys */
  Dot11DecryptSetKeys(&dot11decrypt_ctx, keys->Keys, keys->nKeys);
  g_free(keys);
}

static void
init_wepkeys(void)
{

  /*
   * XXX - Dot11Decrypt - That God sends it to us beautiful (che dio ce la mandi bona)
   * The next lines will add a key to the Dot11Decrypt context. The keystring will be added
   * to the old WEP array too, but we don't care, because the packets will come here
   * already decrypted... One of these days we will fix this too
   */
  set_dot11decrypt_keys();
}

/*
 * This code had been taken from AirSnort crack.c function classify()
 * Permission granted by snax <at> shmoo dot com
 * weak_iv - determine which key byte an iv is useful in resolving
 * parm     - p, pointer to the first byte of an IV
 * return   -  n - this IV is weak for byte n of a WEP key
 *            -1 - this IV is not weak for any key bytes
 *
 * This function tests for IVs that are known to satisfy the criteria
 * for a weak IV as specified in FMS section 7.1
 *
 */
static int
weak_iv(unsigned char *iv)
{
  unsigned char sum, k;

  if ((iv[1] == 255) && (iv[0] > 2) && (iv[0] < 16)) {
    return iv[0] -3;
  }

  sum = iv[0] + iv[1];
  if (sum == 1) {
    if (iv[2] <= 0x0a) {
      return iv[2] +2;
    }
    else if (iv[2] == 0xff) {
      return 0;
    }
  }
  k = 0xfe - iv[2];
  if ((sum == k)  && ((iv[2] >= 0xf2) && (iv[2] <= 0xfe) && (iv[2] != 0xfd))) {
    return k;
  }
  return -1;
}

static void
wlan_retransmit_init(void)
{
  if (fc_analyse_retransmit_table) {
    g_hash_table_destroy(fc_analyse_retransmit_table);
    fc_analyse_retransmit_table = NULL;
  }

  if (fc_first_frame_table) {
    g_hash_table_destroy(fc_first_frame_table);
    fc_first_frame_table = NULL;
  }

  if (wlan_subdissector)
    return;

  fc_analyse_retransmit_table= g_hash_table_new(retransmit_hash, retransmit_equal);
  fc_first_frame_table = g_hash_table_new(frame_hash, frame_equal);

}

static int
dissect_data_encap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
  int         offset = 0;
  uint8_t     type;
  int         tagged_parameter_tree_len;
  proto_tree *tagged_tree;

  type = tvb_get_uint8(tvb, offset);
  proto_tree_add_item(tree, hf_ieee80211_data_encap_payload_type, tvb, offset,
                      1, ENC_LITTLE_ENDIAN);
  offset += 1;
  switch (type) {
  case 1:
    col_set_str(pinfo->cinfo, COL_PROTOCOL, "RRB");
    /* TODO: IEEE 802.11r */
    break;
  case 2:
    col_set_str(pinfo->cinfo, COL_PROTOCOL, "TDLS");
    col_clear(pinfo->cinfo, COL_INFO);
    offset += add_ff_action(tree, tvb, pinfo, offset, NULL);
    tagged_parameter_tree_len = tvb_reported_length_remaining(tvb, offset);
    if (tagged_parameter_tree_len > 0) {
      tagged_tree = get_tagged_parameter_tree(tree, tvb, offset,
                                              tagged_parameter_tree_len);
      ieee_80211_add_tagged_parameters(tvb, offset, pinfo, tagged_tree,
                                       tagged_parameter_tree_len, -1, NULL);
    }
    break;
  }
  return tvb_captured_length(tvb);
}

void
proto_register_ieee80211(void)
{

  static hf_register_info hf[] = {
    {&hf_ieee80211_fc_field,
     {"Frame Control Field", "wlan.fc",
      FT_UINT16, BASE_HEX, NULL, 0,
      "MAC Frame control", HFILL }},

    {&hf_ieee80211_fc_proto_version,
     {"Version", "wlan.fc.version",
      FT_UINT8, BASE_DEC, NULL, 0x03,
      "MAC Protocol version", HFILL }},  /* 0 */

    {&hf_ieee80211_fc_frame_type,
     {"Type", "wlan.fc.type",
      FT_UINT8, BASE_DEC, VALS(frame_type), 0x0C,
      "Frame type", HFILL }},

    {&hf_ieee80211_fc_frame_subtype,
     {"Subtype", "wlan.fc.subtype",
      FT_UINT8, BASE_DEC, NULL, 0xF0,
      "Frame subtype", HFILL }},  /* 2 */

    {&hf_ieee80211_fc_frame_type_subtype,
     {"Type/Subtype", "wlan.fc.type_subtype",
      FT_UINT16, BASE_HEX|BASE_EXT_STRING, &frame_type_subtype_vals_ext, 0x0,
      "Type and subtype combined (as bytes (for Control Frame Extension subtypes) or nibbles)", HFILL }},

    {&hf_ieee80211_fc_frame_extension,
     {"Control Frame Extension", "wlan.fc.extension",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_fc_flags,
     {"Flags", "wlan.flags",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_fc_flags_str,
     {"WLAN Flags", "wlan.flags.str",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_fc_data_ds,
     {"DS status", "wlan.fc.ds",
      FT_UINT8, BASE_HEX, VALS(tofrom_ds), (FLAG_FROM_DS|FLAG_TO_DS),
      "Data-frame DS-traversal status", HFILL }},  /* 3 */

    {&hf_ieee80211_fc_to_ds,
     {"To DS", "wlan.fc.tods",
      FT_BOOLEAN, 8, TFS(&tods_flag), FLAG_TO_DS,
      "To DS flag", HFILL }},    /* 4 */

    {&hf_ieee80211_fc_from_ds,
     {"From DS", "wlan.fc.fromds",
      FT_BOOLEAN, 8, TFS(&fromds_flag), FLAG_FROM_DS,
      "From DS flag", HFILL }},    /* 5 */

    {&hf_ieee80211_fc_more_frag,
     {"More Fragments", "wlan.fc.frag",
      FT_BOOLEAN, 8, TFS(&more_fragments), FLAG_MORE_FRAGMENTS,
      "More Fragments flag", HFILL }},  /* 6 */

    {&hf_ieee80211_fc_retry,
     {"Retry", "wlan.fc.retry",
      FT_BOOLEAN, 8, TFS(&retry_flags), FLAG_RETRY,
      "Retransmission flag", HFILL }},

    {&hf_ieee80211_fc_analysis_retransmission,
     {"Retransmission", "wlan.analysis.retransmission",
      FT_NONE, BASE_NONE, NULL, 0x0,
      "This frame is a suspected wireless retransmission", HFILL }},

    {&hf_ieee80211_fc_analysis_retransmission_frame,
     {"Retransmission of frame", "wlan.analysis.retransmission_frame",
      FT_FRAMENUM, BASE_NONE, NULL, 0x0,
      "This is a retransmission of frame #", HFILL }},

    {&hf_ieee80211_fc_pwr_mgt,
     {"PWR MGT", "wlan.fc.pwrmgt",
      FT_BOOLEAN, 8, TFS(&pm_flags), FLAG_POWER_MGT,
      "Power management status", HFILL }},

    {&hf_ieee80211_fc_more_data,
     {"More Data", "wlan.fc.moredata",
      FT_BOOLEAN, 8, TFS(&md_flags), FLAG_MORE_DATA,
      "More data flag", HFILL }},

    {&hf_ieee80211_fc_protected,
     {"Protected flag", "wlan.fc.protected",
      FT_BOOLEAN, 8, TFS(&protected_flags), FLAG_PROTECTED,
      NULL, HFILL }},

    {&hf_ieee80211_fc_order,
     {"+HTC/Order flag", "wlan.fc.order",
      FT_BOOLEAN, 8, TFS(&order_flags), FLAG_ORDER,
      "HT Control present/strictly ordered flag", HFILL }},

    {&hf_ieee80211_fc_pv1_proto_version,
     {"Version", "wlan.fc.version",
      FT_UINT16, BASE_HEX, NULL, 0x0003, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_type,
     {"Type", "wlan.fc.type",
      FT_UINT16, BASE_HEX, VALS(pv1_frame_type_vals), 0x001C, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_ptid,
     {"PTID", "wlan.fc.ptid",
      FT_UINT16, BASE_HEX, NULL, 0x00E0, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_mgmt_subtype,
     {"Subtype", "wlan.fc.subtype",
      FT_UINT16, BASE_HEX, VALS(pv1_management_frame_type_vals),
      0x00E0, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_cntl_subtype,
     {"Subtype", "wlan.fc.subtype",
      FT_UINT16, BASE_HEX, VALS(pv1_control_frame_type_vals),
      0x00E0, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_unk_field,
     {"Unknown Subtype", "wlan.fc.unknown_subtype",
      FT_UINT16, BASE_HEX, NULL, 0x00E0, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_bw_indication,
     {"Bandwidth Indication", "wlan.fc.control.bandwidth_indication",
      FT_UINT16, BASE_DEC, VALS(pv1_bandwidth_indic_vals),
      0x0700, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_dynamic_indication,
     {"Dynamic Indication", "wlan.fc.control.dynamic_indication",
      FT_BOOLEAN, 16, NULL, 0x0800, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_cntl_power_mgmt,
     {"Power Management", "wlan.fc.control.power_management",
      FT_BOOLEAN, 16, NULL, 0x1000, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_cntl_more_data,
     {"More Data", "wlan.fc.control.more_data",
      FT_BOOLEAN, 16, NULL, 0x2000, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_cntl_flow_control,
     {"Flow Control", "wlan.fc.control.flow_control",
      FT_BOOLEAN, 16, NULL, 0x4000, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_cntl_next_twt_info,
     {"Next TWT Info Present", "wlan.fc.control.next_twt_info_present",
      FT_BOOLEAN, 16, NULL, 0x8000, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_mgmt_pr_next_tbt,
     {"Next TBTT Present", "wlan.fc.mgmt.next_tbtt_present",
      FT_BOOLEAN, 16, NULL, 0x0100, NULL, HFILL }},
    {&hf_ieee80211_fc_pv1_mgmt_pr_full_ssid,
     {"Full SSID Present", "wlan.fc.mgmt.full_ssid_present",
      FT_BOOLEAN, 16, NULL, 0x0200, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_mgmt_pr_ano,
     {"AMO Present", "wlan.fc.mgmt.amo_present",
      FT_BOOLEAN, 16, NULL, 0x0400, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_mgmt_pr_bss_bw,
     {"BSS BW", "wlan.fc.mgmt.bss_bw",
      FT_UINT16, BASE_DEC, NULL, 0x3800, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_mgmt_pr_security,
     {"Security", "wlan.fc.mgmt.security",
      FT_BOOLEAN, 16, NULL, 0x4000, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_mgmt_pr_1mhz_pc,
     {"1MHz Primary Channel Location",
      "wlan.fc.mgmt.1mhz_primary_channel_location",
      FT_BOOLEAN, 16, NULL, 0x8000, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_mgmt_pr_slot_assign,
     {"Slot Assignment Mode", "wlan.fc.mgmt.slot_assignment_mode",
      FT_BOOLEAN, 16, NULL, 0x0100, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_mgmt_pr_more_frag,
     {"More Fragments", "wlan.fc.mgmt.more_fragments",
      FT_BOOLEAN, 16, NULL, 0x0200, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_mgmt_pr_pwr_mgmt,
     {"Power Management", "wlan.fc.mgmt.power_management",
      FT_BOOLEAN, 16, NULL, 0x0400, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_mgmt_pr_grp_indic,
     {"Group Indication", "wlan.fc.mgmt.group_indication",
      FT_BOOLEAN, 16, NULL, 0x0800, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_mgmt_pr_protected,
     {"Protected Frame", "wlan.fc.mgmt.protected_frame",
      FT_BOOLEAN, 16, NULL, 0x1000, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_mgmt_pr_end_of_svc,
     {"End of Service Period", "wlan.fc.mgmt.end_of_service_period",
      FT_BOOLEAN, 16, NULL, 0x2000, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_mgmt_pr_relayed_frm,
     {"Relayed Frame", "wlan.fc.mgmt.relayed_frame",
      FT_BOOLEAN, 16, NULL, 0x4000, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_mgmt_pr_ack_policy,
     {"Ack Policy", "wlan.fc.mgmt.ack_policy",
      FT_BOOLEAN, 16, NULL, 0x8000, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_from_ds,
     {"From DS", "wlan.fc.from_ds",
      FT_BOOLEAN, 16, NULL, 0x0100, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_more_fragments,
     {"More Fragments", "wlan.fc.more_fragments",
      FT_BOOLEAN, 16, NULL, 0x0200, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_power_mgmt,
     {"Power Management", "wlan.fc.power_management",
      FT_BOOLEAN, 16, NULL, 0x0400, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_more_data,
     {"More Data", "wlan.fc.more_data",
      FT_BOOLEAN, 16, NULL, 0x0800, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_protected_frame,
     {"Protected Frame", "wlan.fc.protected_frame",
      FT_BOOLEAN, 16, NULL, 0x1000, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_end_service_per,
     {"End of Service Period", "wlan.fc.end_of_service_period",
      FT_BOOLEAN, 16, NULL, 0x2000, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_relayed_frame,
     {"Relayed Frame", "wlan.fc.relayed_frame",
      FT_BOOLEAN, 16, NULL, 0x4000, NULL, HFILL }},

    {&hf_ieee80211_fc_pv1_ack_policy,
     {"Ack Policy", "wlan.fc.ack_policy",
      FT_BOOLEAN, 16, NULL, 0x8000, NULL, HFILL }},

    {&hf_ieee80211_pv1_sid,
     {"SID", "wlan.fc.sid",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_pv1_sid_association_id,
     {"Association ID", "wlan.fc.sid.association_id",
      FT_UINT16, BASE_HEX, NULL, SID_AID_MASK, NULL, HFILL }},

    {&hf_ieee80211_pv1_sid_a3_present,
     {"A3 Present", "wlan.fc.sid.a3_present",
      FT_BOOLEAN, 16, NULL, SID_A3_PRESENT, NULL, HFILL }},

    {&hf_ieee80211_pv1_sid_a4_present,
     {"A4 Present", "wlan.fc.sid.a4_present",
      FT_BOOLEAN, 16, NULL, SID_A4_PRESENT, NULL, HFILL }},

    {&hf_ieee80211_pv1_sid_a_msdu,
     {"A MSDU", "wlan.fc.sid.a_msdu",
      FT_BOOLEAN, 16, NULL, SID_A_MSDU, NULL, HFILL }},

    {&hf_ieee80211_pv1_cnt_stack_tetra_timest,
     {"Tetrapartial Timestamp", "wlan.pv1.control.stack.tetraparial_timestamp",
      FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_pv1_cnt_bat_beacon_seq,
     {"Beacon Sequence", "wlan.pv1.control.bat.beacon_sequence",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_pv1_cnt_bat_penta_timest,
     {"Pentapartial Timestamp", "wlan.pv1.control.bat.pentapartial_timestamp",
      FT_UINT40, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_pv1_cnt_bat_next_twt_info,
     {"Next TWT Info", "wlan.pv1.control.bat.next_twt_info",
      FT_UINT48, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_pv1_cnt_bat_stating_seq_cntl,
     {"Starting Sequence Control", "wlan.pv1.control.bat.starting_sequence_control",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_pv1_cnt_bat_bitmap,
     {"BAT Bitmap", "wlan.pv1.control.bat.bat_bitmap",
      FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_pv1_mgmt_reserved,
     {"PV1 Reserved Management frame", "wlan.pv1.management.reserved",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_pv1_cntl_reserved,
     {"PV1 Reserved Control frame", "wlan.pv1.control.reserved",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_fc_s1g_next_tbtt_present,
     {"Next TBTT Present", "wlan.fc.s1g.next_tbtt_present",
      FT_BOOLEAN, 8, TFS(&tfs_present_not_present), 0x01, NULL, HFILL }},

    {&hf_ieee80211_fc_s1g_compressed_ssid_present,
     {"Compressed SSID Present", "wlan.fc.s1g.compressed_ssid_present",
      FT_BOOLEAN, 8, TFS(&tfs_present_not_present), 0x02, NULL, HFILL }},

    {&hf_ieee80211_fc_s1g_ano_present,
     {"ANO Present", "wlan.fc.s1g.ano_present",
      FT_BOOLEAN, 8, TFS(&tfs_present_not_present), 0x04, NULL, HFILL }},

    {&hf_ieee80211_fc_s1g_bss_bw,
     {"BSS BW", "wlan.fc.s1g.bss_bw",
      FT_UINT8, BASE_DEC, NULL, 0x38, NULL, HFILL }},

    {&hf_ieee80211_fc_s1g_security,
     {"Security", "wlan.fc.s1g.security",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x40, NULL, HFILL }},

    {&hf_ieee80211_fc_s1g_ap_pm,
     {"AP PM", "wlan.fc.s1g.ap_pm",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x80, NULL, HFILL }},

    {&hf_ieee80211_assoc_id,
     {"Association ID", "wlan.aid",
      FT_UINT16, BASE_DEC, NULL, 0x3FFF,
      NULL, HFILL }},

    {&hf_ieee80211_did_duration,
     {"Duration", "wlan.duration",
      FT_UINT16, BASE_DEC, NULL, 0x7FFF,
      NULL, HFILL }},

    {&hf_ieee80211_addr_da,
     {"Destination address", "wlan.da",
      FT_ETHER, BASE_NONE, NULL, 0,
      "Destination Hardware Address", HFILL }},

    {&hf_ieee80211_addr_da_resolved,
      {"Destination address (resolved)", "wlan.da_resolved", FT_STRING,
        BASE_NONE, NULL, 0x0,
        "Destination Hardware Address (resolved)", HFILL }},

    {&hf_ieee80211_addr_da_oui,
     {"Destination OUI", "wlan.da.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      "Destination Organizationally Unique Identifier", HFILL }},

    {&hf_ieee80211_addr_da_oui_resolved,
     {"Destination OUI (resolved)", "wlan.da.oui_resolved",
      FT_STRING, BASE_NONE, NULL, 0,
      "Destination Organizationally Unique Identifier (resolved)", HFILL }},

    { &hf_ieee80211_addr_da_lg,
      { "LG bit", "wlan.da.lg",
        FT_BOOLEAN, 24, TFS(&lg_tfs), 0x020000,
        "Specifies if this is a locally administered or globally unique (IEEE assigned) address", HFILL }},

    { &hf_ieee80211_addr_da_ig,
      { "IG bit", "wlan.da.ig",
        FT_BOOLEAN, 24, TFS(&ig_tfs), 0x010000,
        "Specifies if this is an individual (unicast) or group (broadcast/multicast) address", HFILL }},

    {&hf_ieee80211_addr_sa,
     {"Source address", "wlan.sa",
      FT_ETHER, BASE_NONE, NULL, 0,
      "Source Hardware Address", HFILL }},

    {&hf_ieee80211_addr_sa_resolved,
      {"Source address (resolved)", "wlan.sa_resolved", FT_STRING,
       BASE_NONE, NULL, 0x0,
       "Source Hardware Address (resolved)", HFILL }},

    {&hf_ieee80211_addr_sa_oui,
     {"Source OUI", "wlan.sa.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      "Source Organizationally Unique Identifier", HFILL }},

    {&hf_ieee80211_addr_sa_oui_resolved,
     {"Source OUI (resolved)", "wlan.sa.oui_resolved",
      FT_STRING, BASE_NONE, NULL, 0,
      "Source Organizationally Unique Identifier (resolved)", HFILL }},

    { &hf_ieee80211_addr_sa_lg,
      { "LG bit", "wlan.sa.lg",
        FT_BOOLEAN, 24, TFS(&lg_tfs), 0x020000,
        "Specifies if this is a locally administered or globally unique (IEEE assigned) address", HFILL }},

    { &hf_ieee80211_addr_sa_ig,
      { "IG bit", "wlan.sa.ig",
        FT_BOOLEAN, 24, TFS(&ig_tfs), 0x010000,
        "Specifies if this is an individual (unicast) or group (broadcast/multicast) address", HFILL }},

    {&hf_ieee80211_addr,
      {"Hardware address", "wlan.addr",
       FT_ETHER, BASE_NONE, NULL, 0,
       "SA, DA, BSSID, RA or TA Hardware Address", HFILL }},

    {&hf_ieee80211_addr_resolved,
      { "Hardware address (resolved)", "wlan.addr_resolved", FT_STRING,
        BASE_NONE, NULL, 0x0,
        "SA, DA, BSSID, RA or TA Hardware Address (resolved)", HFILL }},

    {&hf_ieee80211_addr_oui,
     {"Hardware OUI", "wlan.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      "Hardware Organizationally Unique Identifier", HFILL }},

    {&hf_ieee80211_addr_oui_resolved,
     {"Hardware OUI (resolved)", "wlan.oui_resolved",
      FT_STRING, BASE_NONE, NULL, 0,
      "Hardware Organizationally Unique Identifier (resolved)", HFILL }},

    { &hf_ieee80211_addr_lg,
      { "LG bit", "wlan.addr.lg",
        FT_BOOLEAN, 24, TFS(&lg_tfs), 0x020000,
        "Specifies if this is a locally administered or globally unique (IEEE assigned) address", HFILL }},

    { &hf_ieee80211_addr_ig,
      { "IG bit", "wlan.addr.ig",
        FT_BOOLEAN, 24, TFS(&ig_tfs), 0x010000,
        "Specifies if this is an individual (unicast) or group (broadcast/multicast) address", HFILL }},

    {&hf_ieee80211_addr_ra,
     {"Receiver address", "wlan.ra",
      FT_ETHER, BASE_NONE, NULL, 0,
      "Receiving Station Hardware Address", HFILL }},

    {&hf_ieee80211_addr_ra_resolved,
      {"Receiver address (resolved)", "wlan.ra_resolved", FT_STRING, BASE_NONE,
        NULL, 0x0, "Receiving Station Hardware Address (resolved)", HFILL }},

    {&hf_ieee80211_addr_ra_oui,
     {"Receiver OUI", "wlan.ra.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      "Receiver Organizationally Unique Identifier", HFILL }},

    {&hf_ieee80211_addr_ra_oui_resolved,
     {"Receiver OUI (resolved)", "wlan.ra.oui_resolved",
      FT_STRING, BASE_NONE, NULL, 0,
      "Receiver Organizationally Unique Identifier (resolved)", HFILL }},

    { &hf_ieee80211_addr_ra_lg,
      { "LG bit", "wlan.ra.lg",
        FT_BOOLEAN, 24, TFS(&lg_tfs), 0x020000,
        "Specifies if this is a locally administered or globally unique (IEEE assigned) address", HFILL }},

    { &hf_ieee80211_addr_ra_ig,
      { "IG bit", "wlan.ra.ig",
        FT_BOOLEAN, 24, TFS(&ig_tfs), 0x010000,
        "Specifies if this is an individual (unicast) or group (broadcast/multicast) address", HFILL }},

    {&hf_ieee80211_addr_ta,
     {"Transmitter address", "wlan.ta",
      FT_ETHER, BASE_NONE, NULL, 0,
      "Transmitting Station Hardware Address", HFILL }},

    {&hf_ieee80211_addr_ta_resolved,
      {"Transmitter address (resolved)", "wlan.ta_resolved", FT_STRING,
        BASE_NONE, NULL, 0x0,
        "Transmitting Station Hardware Address (resolved)", HFILL }},

    {&hf_ieee80211_addr_ta_oui,
     {"Transmitter OUI", "wlan.ta.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      "Transmitter Organizationally Unique Identifier", HFILL }},

    {&hf_ieee80211_addr_ta_oui_resolved,
     {"Transmitter OUI (resolved)", "wlan.ta.oui_resolved",
      FT_STRING, BASE_NONE, NULL, 0,
      "Transmitter Organizationally Unique Identifier (resolved)", HFILL }},

    { &hf_ieee80211_addr_ta_lg,
      { "LG bit", "wlan.ta.lg",
        FT_BOOLEAN, 24, TFS(&lg_tfs), 0x020000,
        "Specifies if this is a locally administered or globally unique (IEEE assigned) address", HFILL }},

    { &hf_ieee80211_addr_ta_ig,
      { "IG bit", "wlan.ta.ig",
        FT_BOOLEAN, 24, TFS(&ig_tfs), 0x010000,
        "Specifies if this is an individual (unicast) or group (broadcast/multicast) address", HFILL }},

    {&hf_ieee80211_addr_bssid,
     {"BSS Id", "wlan.bssid",
      FT_ETHER, BASE_NONE, NULL, 0,
      "Basic Service Set ID", HFILL }},

    {&hf_ieee80211_addr_bssid_resolved,
      {"BSS Id (resolved)", "wlan.bssid_resolved", FT_STRING, BASE_NONE, NULL,
        0x0, "Basic Service Set ID (resolved)", HFILL }},

    {&hf_ieee80211_addr_bssid_oui,
     {"BSS Id OUI", "wlan.bssid.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      "BSS Id Organizationally Unique Identifier", HFILL }},

    {&hf_ieee80211_addr_bssid_oui_resolved,
     {"BSS Id OUI (resolved)", "wlan.bssid.oui_resolved",
      FT_STRING, BASE_NONE, NULL, 0,
      "BSS Id Organizationally Unique Identifier (resolved)", HFILL }},

    { &hf_ieee80211_addr_bssid_lg,
      { "LG bit", "wlan.bssid.lg",
        FT_BOOLEAN, 24, TFS(&lg_tfs), 0x020000,
        "Specifies if this is a locally administered or globally unique (IEEE assigned) address", HFILL }},

    { &hf_ieee80211_addr_bssid_ig,
      { "IG bit", "wlan.bssid.ig",
        FT_BOOLEAN, 24, TFS(&ig_tfs), 0x010000,
        "Specifies if this is an individual (unicast) or group (broadcast/multicast) address", HFILL }},

    {&hf_ieee80211_addr_staa,
     {"STA address", "wlan.staa",
      FT_ETHER, BASE_NONE, NULL, 0,
      "Station Hardware Address", HFILL }},

    {&hf_ieee80211_addr_staa_resolved,
      {"STA address (resolved)", "wlan.staa_resolved", FT_STRING, BASE_NONE, NULL,
        0x0, "Station Hardware Address (resolved)", HFILL }},

    {&hf_ieee80211_addr_staa_oui,
     {"STA OUI", "wlan.staa.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      "STA Organizationally Unique Identifier", HFILL }},

    {&hf_ieee80211_addr_staa_oui_resolved,
     {"STA OUI (resolved)", "wlan.staa.oui_resolved",
      FT_STRING, BASE_NONE, NULL, 0,
      "STA Organizationally Unique Identifier (resolved)", HFILL }},

    { &hf_ieee80211_addr_staa_lg,
      { "LG bit", "wlan.staa.lg",
        FT_BOOLEAN, 24, TFS(&lg_tfs), 0x020000,
        "Specifies if this is a locally administered or globally unique (IEEE assigned) address", HFILL }},

    { &hf_ieee80211_addr_staa_ig,
      { "IG bit", "wlan.staa.ig",
        FT_BOOLEAN, 24, TFS(&ig_tfs), 0x010000,
        "Specifies if this is an individual (unicast) or group (broadcast/multicast) address", HFILL }},

    {&hf_ieee80211_frag_number,
     {"Fragment number", "wlan.frag",
      FT_UINT16, BASE_DEC, NULL, 0x000F,
      NULL, HFILL }},

    {&hf_ieee80211_seq_number,
     {"Sequence number", "wlan.seq",
      FT_UINT16, BASE_DEC, NULL, 0xFFF0,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_control_field,
     {"Mesh Control Field", "wlan.mesh.control_field",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_qos,
     {"Qos Control", "wlan.qos",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_qos_tid,
     {"TID", "wlan.qos.tid",
      FT_UINT16, BASE_DEC, NULL, 0x000F,
      NULL, HFILL }},

    {&hf_ieee80211_qos_priority,
     {"Priority", "wlan.qos.priority",
      FT_UINT16, BASE_DEC, VALS(ieee80211_qos_tags_acs), 0x0007,
      "802.1D Tag", HFILL }},

    {&hf_ieee80211_qos_eosp,
     {"EOSP", "wlan.qos.eosp",
      FT_BOOLEAN, 16, TFS(&eosp_flag), QOS_FLAG_EOSP,
      "EOSP Field", HFILL }},

    {&hf_ieee80211_qos_bit4,
     {"QoS bit 4", "wlan.qos.bit4",
      FT_BOOLEAN, 16, TFS(&bit4_flag), QOS_FLAG_EOSP,
      NULL, HFILL }},

    {&hf_ieee80211_qos_ack_policy,
     {"Ack Policy", "wlan.qos.ack",
      FT_UINT16, BASE_HEX,  VALS(ack_policy), 0x0060,
      NULL, HFILL }},

    {&hf_ieee80211_qos_amsdu_present,
     {"Payload Type", "wlan.qos.amsdupresent",
      FT_BOOLEAN, 16, TFS(&ieee80211_qos_amsdu_present_flag), 0x0080,
      NULL, HFILL }},

    {&hf_ieee80211_qos_txop_limit,
     {"TXOP Limit", "wlan.qos.txop_limit",
      FT_UINT16, BASE_DEC, NULL, 0xFF00,
      NULL, HFILL }},

    {&hf_ieee80211_qos_ps_buf_state,
     {"QAP PS Buffer State", "wlan.qos.ps_buf_state",
      FT_UINT16, BASE_HEX, NULL, 0xFF00,
      NULL, HFILL }},

    {&hf_ieee80211_qos_buf_state_indicated,
     {"Buffer State Indicated", "wlan.qos.buf_state_indicated",
      FT_BOOLEAN, 16, TFS(&tfs_yes_no), 0x0200,
      NULL, HFILL }},

    {&hf_ieee80211_qos_highest_pri_buf_ac,
     {"Highest-Priority Buffered AC", "wlan.qos.highest_pri_buf_ac",
       FT_UINT16, BASE_DEC, VALS(wme_acs), 0x0C00,
      NULL, HFILL }},

    {&hf_ieee80211_qos_qap_buf_load,
     {"QAP Buffered Load", "wlan.qos.qap_buf_load",
      FT_UINT16, BASE_DEC, NULL, 0xF000,
      NULL, HFILL }},

    {&hf_ieee80211_qos_txop_dur_req,
     {"TXOP Duration Requested", "wlan.qos.txop_dur_req",
      FT_UINT16, BASE_DEC, NULL, 0xFF00,
      NULL, HFILL }},

    {&hf_ieee80211_qos_queue_size,
     {"Queue Size", "wlan.qos.queue_size",
      FT_UINT16, BASE_DEC, NULL, 0xFF00,
      NULL, HFILL }},

    {&hf_ieee80211_qos_mesh_ctl_present,
     {"Mesh Control Present", "wlan.qos.mesh_ctl_present",
      FT_UINT16, BASE_DEC, NULL, 0x0100,
      NULL, HFILL }},

    {&hf_ieee80211_qos_mesh_ps_rsvd,
     {"Mesh Power Save Level (reserved)", "wlan.qos.mesh_ps.reserved",
      FT_UINT16, BASE_DEC, NULL, 0x0200,
      NULL, HFILL }},

    {&hf_ieee80211_qos_mesh_ps_unicast,
     {"Mesh Power Save Level (for the receiving peer)", "wlan.qos.mesh_ps.unicast",
      FT_BOOLEAN, 16, TFS(&ieee80211_qos_mesh_ps), 0x0200,
      NULL, HFILL }},

    {&hf_ieee80211_qos_mesh_ps_multicast,
     {"Mesh Power Save Level (for all receiving peers)", "wlan.qos.mesh_ps.multicast",
      FT_BOOLEAN, 16, TFS(&mesh_config_cap_power_save_level_flags), 0x0200,
      NULL, HFILL }},

    {&hf_ieee80211_qos_mesh_rspi,
     {"Receiver Service Period Initiated (RSPI)", "wlan.qos.mesh_rspi",
      FT_UINT16, BASE_DEC, NULL, 0x0400,
      NULL, HFILL }},

    {&hf_ieee80211_fcs,
     {"Frame check sequence", "wlan.fcs",
      FT_UINT32, BASE_HEX, NULL, 0,
      "Frame Check Sequence (FCS)", HFILL }},

    {&hf_ieee80211_fcs_status,
     {"FCS Status", "wlan.fcs.status",
      FT_UINT8, BASE_NONE, VALS(proto_checksum_vals), 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_fragment_overlap,
      {"Fragment overlap", "wlan.fragment.overlap",
       FT_BOOLEAN, BASE_NONE, NULL, 0x0,
       "Fragment overlaps with other fragments", HFILL }},

    {&hf_ieee80211_fragment_overlap_conflict,
      {"Conflicting data in fragment overlap", "wlan.fragment.overlap.conflict",
       FT_BOOLEAN, BASE_NONE, NULL, 0x0,
       "Overlapping fragments contained conflicting data", HFILL }},

    {&hf_ieee80211_fragment_multiple_tails,
      {"Multiple tail fragments found", "wlan.fragment.multipletails",
       FT_BOOLEAN, BASE_NONE, NULL, 0x0,
       "Several tails were found when defragmenting the packet", HFILL }},

    {&hf_ieee80211_fragment_too_long_fragment,
      {"Fragment too long", "wlan.fragment.toolongfragment",
       FT_BOOLEAN, BASE_NONE, NULL, 0x0,
       "Fragment contained data past end of packet", HFILL }},

    {&hf_ieee80211_fragment_error,
      {"Defragmentation error", "wlan.fragment.error",
       FT_FRAMENUM, BASE_NONE, NULL, 0x0,
       "Defragmentation error due to illegal fragments", HFILL }},

    {&hf_ieee80211_fragment_count,
      {"Fragment count", "wlan.fragment.count",
       FT_UINT32, BASE_DEC, NULL, 0x0,
       NULL, HFILL }},

    {&hf_ieee80211_fragment,
      {"802.11 Fragment", "wlan.fragment",
       FT_FRAMENUM, BASE_NONE, NULL, 0x0,
       NULL, HFILL }},

    {&hf_ieee80211_fragments,
      {"802.11 Fragments", "wlan.fragments",
       FT_NONE, BASE_NONE, NULL, 0x0,
       NULL, HFILL }},

    {&hf_ieee80211_reassembled_in,
      {"Reassembled 802.11 in frame", "wlan.reassembled_in",
       FT_FRAMENUM, BASE_NONE, NULL, 0x0,
       "This 802.11 packet is reassembled in this frame", HFILL }},

    {&hf_ieee80211_reassembled_length,
      {"Reassembled 802.11 length", "wlan.reassembled.length",
       FT_UINT32, BASE_DEC, NULL, 0x0,
       "The total length of the reassembled payload", HFILL }},

    {&hf_ieee80211_wep_iv,
     {"Initialization Vector", "wlan.wep.iv",
      FT_UINT24, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wep_iv_weak,
     {"Weak IV", "wlan.wep.weakiv",
      FT_BOOLEAN, BASE_NONE, NULL, 0x0,
       NULL, HFILL}},

    {&hf_ieee80211_tkip_extiv,
     {"TKIP Ext. Initialization Vector", "wlan.tkip.extiv",
      FT_STRING, BASE_NONE, NULL, 0,
      "TKIP Extended Initialization Vector", HFILL }},

    {&hf_ieee80211_ccmp_extiv,
     {"CCMP Ext. Initialization Vector", "wlan.ccmp.extiv",
      FT_STRING, BASE_NONE, NULL, 0,
      "CCMP Extended Initialization Vector", HFILL }},

    {&hf_ieee80211_wep_key,
     {"Key Index", "wlan.wep.key",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wep_icv,
     {"WEP ICV", "wlan.wep.icv",
      FT_UINT32, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_fc_analysis_pmk,
     {"PMK", "wlan.analysis.pmk",
      FT_STRING, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_fc_analysis_kck,
     {"KCK", "wlan.analysis.kck",
      FT_STRING, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_fc_analysis_kek,
     {"KEK", "wlan.analysis.kek",
      FT_STRING, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_fc_analysis_tk,
     {"TK", "wlan.analysis.tk",
      FT_STRING, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_fc_analysis_gtk,
     {"GTK", "wlan.analysis.gtk",
      FT_STRING, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_mgt,
     {"IEEE 802.11 Wireless Management", "wlan.mgt",
      FT_PROTOCOL, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_block_ack_control,
     {"Block Ack Control", "wlan.ba.control",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_block_ack_control_ack_policy,
     {"BA Ack Policy", "wlan.ba.control.ackpolicy",
      FT_BOOLEAN, 16, TFS(&ieee80211_block_ack_control_ack_policy_flag), 0x0001,
      "Block Ack Request (BAR) Ack Policy", HFILL }},

    {&hf_ieee80211_block_ack_control_type,
     {"BA Type", "wlan.ba.control.ba_type",
      FT_UINT16, BASE_HEX, VALS(block_ack_type_vals), 0x001e, NULL, HFILL }},

    {&hf_ieee80211_block_ack_control_reserved,
     {"Reserved", "wlan.ba.control.reserved",
      FT_UINT16, BASE_HEX, NULL, 0x0fe0,
      NULL, HFILL }},

    {&hf_ieee80211_block_ack_control_tid_info,
     {"TID for which a Basic BlockAck frame is requested", "wlan.ba.basic.tidinfo",
      FT_UINT16, BASE_HEX, NULL, 0xf000,
      "Traffic Identifier (TID) for which a Basic BlockAck frame is requested", HFILL }},

    {&hf_ieee80211_block_ack_multi_sta_aid11,
     {"AID11", "wlan.ba.multi_sta.aid11",
      FT_UINT16, BASE_HEX, NULL, 0x07ff, NULL, HFILL }},

    {&hf_ieee80211_block_ack_multi_sta_ack_type,
     {"Ack Type", "wlan.ba.multi_sta.ack_type",
      FT_UINT16, BASE_HEX, NULL, 0x0800, NULL, HFILL }},

    {&hf_ieee80211_block_ack_multi_sta_tid,
     {"TID", "wlan.ba.multi_sta.tid",
      FT_UINT16, BASE_HEX, NULL, 0xf000, NULL, HFILL }},

    {&hf_ieee80211_block_ack_multi_sta_aid_tid,
     {"AID TID Info", "wlan.ba.multi_sta.aid_tid_info",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_block_ack_multi_sta_reserved,
     {"Reserved", "wlan.ba.multi_sta.reserved",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_block_ack_multi_sta_ra,
     {"RA", "wlan.ba.multi_sta.ra",
      FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_block_ack_multi_tid_reserved,
     {"Reserved", "wlan.bar.mtid.tidinfo.reserved",
      FT_UINT16, BASE_HEX, NULL, 0x0fff,
      NULL, HFILL }},

    {&hf_ieee80211_block_ack_multi_tid_value,
     {"Multi-TID Value", "wlan.bar.mtid.tidinfo.value",
      FT_UINT16, BASE_HEX, NULL, 0xf000,
      NULL, HFILL }},

    {&hf_ieee80211_block_ack_bitmap,
     {"Block Ack Bitmap", "wlan.ba.bm",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    /* Used for Extended compressed BlockAck */
    {&hf_ieee80211_block_ack_RBUFCAP,
     {"Block Ack RBUFCAP", "wlan.ba.RBUFCAP",
      FT_BOOLEAN, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_block_ack_bitmap_missing_frame,
     {"Missing frame", "wlan.ba.bm.missing_frame",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_block_ack_gcr_addr,
     {"GCR Group Address", "wlan.ba.gcr_group_addr",
      FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_beamform_feedback_seg_retrans_bitmap,
     {"Feedback segment Retransmission Bitmap", "wlan.beamform.feedback_seg_retrans_bitmap",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ndp_annc_token,
     {"Sounding Dialog Token", "wlan.ndp.token",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ndp_annc_variant,
     {"NDP Announcement Variant", "wlan.ndp.token.variant",
      FT_UINT8, BASE_HEX, VALS(ndp_annc_variant_vals), 0x03,
      NULL, HFILL }},

    {&hf_ieee80211_ndp_annc_token_number,
     {"Sounding Dialog Token", "wlan.ndp.token.number",
      FT_UINT8, BASE_HEX, NULL, 0xFC,
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_aid12,
     {"AID12", "wlan.vht_ndp.sta_info.aid12",
      FT_UINT16, BASE_HEX, NULL, 0x0FFF,
      "12 least significant bits of the AID of the target STA", HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_feedback_type,
     {"Feedback Type", "wlan.vht_ndp.sta_info.feedback_type",
      FT_BOOLEAN, 16, TFS(&vht_ndp_annc_sta_info_feedback_type), 0x1000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_nc_index,
     {"Nc Index", "wlan.vht_ndp.sta_info.nc_index",
      FT_UINT16, BASE_DEC, VALS(num_plus_one_3bit_flag), 0xE000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_reserved,
     {"Reserved", "wlan.vht_ndp.sta_info.reserved",
      FT_UINT32, BASE_HEX, NULL, 0xE000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008,
     {"STA Info, AID11 < 2008", "wlan.vht_ndp.sta_info.ranging_2008",
      FT_UINT32, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_aid11,
     {"AID11", "wlan.vht_ndp.sta_info.ranging_2008.aid11",
      FT_UINT32, BASE_DEC, NULL, GENMASK(10, 0),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_ltf_offset,
     {"LTF Offset", "wlan.vht_ndp.sta_info.ranging_2008.ltf_offset",
      FT_UINT32, BASE_DEC, NULL, GENMASK(16, 11),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_r2i_n_sts,
     {"R2I N STS", "wlan.vht_ndp.sta_info.ranging_2008.r2i_n_sts",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(sts_custom), GENMASK(19, 17),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_r2i_rep,
     {"R2I Rep", "wlan.vht_ndp.sta_info.ranging_2008.r2i_rep",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(rep_custom), GENMASK(22, 20),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_i2r_n_sts,
     {"I2R N STS", "wlan.vht_ndp.sta_info.ranging_2008.i2r_n_sts",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(sts_custom), GENMASK(25, 23),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_reserved1,
     {"Reserved", "wlan.vht_ndp.sta_info.ranging_2008.reserved1",
      FT_UINT32, BASE_DEC, NULL, GENMASK(26, 26),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_disambiguation,
     {"Disambiguation", "wlan.vht_ndp.sta_info.ranging_2008.disambiguation",
      FT_UINT32, BASE_DEC, NULL, GENMASK(27, 27),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_i2r_rep,
     {"I2R Rep", "wlan.vht_ndp.sta_info.ranging_2008.i2r_rep",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(rep_custom), GENMASK(30, 28),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2008_reserved2,
     {"Reserved", "wlan.vht_ndp.sta_info.ranging_2008.reserved2",
      FT_UINT32, BASE_DEC, NULL, GENMASK(31, 31),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2043,
     {"STA Info, AID11 == 2043", "wlan.sta_info_ranging_2043",
      FT_UINT32, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2043_aid11,
     {"AID11", "wlan.sta_info_ranging_2043.aid11",
      FT_UINT32, BASE_DEC, NULL, GENMASK(10, 1),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2043_sac,
     {"SAC", "wlan.sta_info_ranging_2043.sac",
      FT_UINT32, BASE_DEC, NULL, GENMASK(26, 11),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2043_disambiguation,
     {"Disambiguation", "wlan.sta_info_ranging_2043.disambiguation",
      FT_UINT32, BASE_DEC, NULL, GENMASK(27, 27),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2043_reserved,
     {"Reserved", "wlan.sta_info_ranging_2043.reserved",
      FT_UINT32, BASE_HEX, NULL, GENMASK(31, 28),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2044,
     {"STA Info, AID11 == 2044", "wlan.sta_info_ranging_2044",
      FT_UINT32, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2044_aid11,
     {"AID11", "wlan.sta_info_ranging_2044.aid11",
      FT_UINT32, BASE_DEC, NULL, GENMASK(10, 1),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2044_partial_tsf,
     {"Partial TSF", "wlan.sta_info_ranging_2044.partial_tsf",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(partial_tsf_custom), GENMASK(26, 11),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2044_disambiguation,
     {"Disambiguation", "wlan.sta_info_ranging_2044.disambiguation",
      FT_UINT32, BASE_DEC, NULL, GENMASK(27, 27),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2044_reserved,
     {"Reserved", "wlan.sta_info_ranging_2044.reserved",
      FT_UINT32, BASE_DEC, NULL, GENMASK(28, 28),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2044_token,
     {"Token", "wlan.sta_info_ranging_2044.token",
      FT_UINT32, BASE_DEC, NULL, GENMASK(31, 29),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2045,
     {"STA Info Ranging, AID11 == 2045", "wlan.sta_info_ranging_2045",
      FT_UINT32, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2045_aid11,
     {"AID11", "wlan.sta_info_ranging_2045.aid11",
      FT_UINT32, BASE_DEC, NULL, GENMASK(10, 1),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2045_i2r_ndp_tx_power,
     {"I2R NDP Tx Power", "wlan.sta_info_ranging_2045.i2r_ndp_tx_power",
      FT_UINT32, BASE_DEC, NULL, GENMASK(18, 11),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2045_r2i_ndp_target_rssi,
     {"R2I NDP Target RSSI", "wlan.sta_info_ranging_2045.r2i_ndp_target_rssi",
      FT_UINT32, BASE_DEC, NULL, GENMASK(26, 19),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2045_disambiguation,
     {"Disambiguation", "wlan.sta_info_ranging_2045.disambiguation",
      FT_UINT32, BASE_DEC, NULL, GENMASK(27, 27),
      NULL, HFILL }},

    {&hf_ieee80211_vht_ndp_annc_sta_info_ranging_2045_reserved,
     {"Reserved", "wlan.sta_info_ranging_2045.reserved",
      FT_UINT32, BASE_HEX, NULL, GENMASK(31, 28),
      NULL, HFILL }},

    {&hf_ieee80211_ndp_eht_annc_sta_info,
     {"STA Info", "wlan.ndp_eht.sta_info",
      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_ndp_eht_annc_aid11,
     {"AID11", "wlan.ndp_eht.sta_info.aid11",
      FT_UINT32, BASE_HEX, NULL, 0x000007ff, NULL, HFILL }},

    {&hf_ieee80211_ndp_eht_annc_resolution,
     {"Resolution", "wlan.ndp_eht.sta_info.resolution",
      FT_UINT32, BASE_HEX, NULL, 0x00000800, NULL, HFILL }},

    {&hf_ieee80211_ndp_eht_annc_feedback_map,
     {"Feedback Bitmap", "wlan.ndp_eht.sta_info.feedback_bitmap",
      FT_UINT32, BASE_HEX, NULL, 0x000ff000, NULL, HFILL }},

    {&hf_ieee80211_ndp_eht_annc_reserved1,
     {"Reserved", "wlan.ndp_eht.sta_info.reserved1",
      FT_UINT32, BASE_HEX, NULL, 0x00100000, NULL, HFILL }},

    {&hf_ieee80211_ndp_eht_annc_nc_index,
     {"Nc Index", "wlan.ndp_eht.sta_info.nc_index",
      FT_UINT32, BASE_HEX, NULL, 0x01e00000, NULL, HFILL }},

    {&hf_ieee80211_ndp_eht_annc_feedback_type,
     {"Feedback Type And Ng", "wlan.ndp_eht.sta_info.feedback_type_and_ng",
      FT_UINT32, BASE_HEX, NULL, 0x06000000, NULL, HFILL }},

    {&hf_ieee80211_ndp_eht_annc_disambiguation,
     {"Disambiguation", "wlan.ndp_eht.sta_info.disambiguation",
      FT_UINT32, BASE_HEX, NULL, 0x08000000, NULL, HFILL }},

    {&hf_ieee80211_ndp_eht_annc_codebook_size,
     {"Codebook Size", "wlan.ndp_eht.sta_info.codebook_size",
      FT_UINT32, BASE_HEX, NULL, 0x10000000, NULL, HFILL }},

    {&hf_ieee80211_ndp_eht_annc_reserved2,
     {"Reserved", "wlan.ndp_eht.sta_info.reserved2",
      FT_UINT32, BASE_HEX, NULL, 0xe0000000, NULL, HFILL }},

    {&hf_ieee80211_data_encap_payload_type,
     {"Payload Type", "wlan.data_encap.payload_type",
      FT_UINT8, BASE_DEC, VALS(ieee80211_data_encap_payload_types), 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_tdls_action_code,
     {"Action code", "wlan.fixed.action_code",
      FT_UINT8, BASE_DEC|BASE_EXT_STRING, &tdls_action_codes_ext, 0,
      "Management action code", HFILL }},

    {&hf_ieee80211_ff_target_channel,
     {"Target Channel", "wlan.fixed.target_channel",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_operating_class,
     {"Operating Class", "wlan.fixed.operating_class",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_wnm_action_code,
     {"Action code", "wlan.fixed.action_code",
      FT_UINT8, BASE_DEC|BASE_EXT_STRING, &wnm_action_codes_ext, 0,
      "Management action code", HFILL }},

    {&hf_ieee80211_ff_unprotected_wnm_action_code,
     {"Action code", "wlan.fixed.action_code",
      FT_UINT8, BASE_DEC|BASE_EXT_STRING, &unprotected_wnm_action_codes_ext, 0,
      "Management action code", HFILL }},

    {&hf_ieee80211_ff_key_data,
     {"Key Data", "wlan.fixed.key_data",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_ff_key_data_length,
     {"Key Data Length", "wlan.fixed.key_data_length",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_ff_wnm_notification_type,
     {"WNM-Notification type", "wlan.fixed.wnm_notification_type",
      FT_UINT8, BASE_DEC|BASE_EXT_STRING, &wnm_notification_types_ext, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_wnm_notification_response_status,
     {"Response Status", "wlan.fixed.wnm_notification_response_status",
      FT_UINT8, BASE_DEC|BASE_RANGE_STRING, RVALS(wnm_notification_response_code), 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_rm_action_code,
     {"Action code", "wlan.fixed.action_code",
      FT_UINT8, BASE_DEC|BASE_EXT_STRING, &rm_action_codes_ext, 0,
      "Radio Measurement Action", HFILL }},

    {&hf_ieee80211_ff_rm_dialog_token,
     {"Dialog token", "wlan.rm.dialog_token",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Non-zero Dialog Token identifies request/report transaction", HFILL }},

    {&hf_ieee80211_ff_rm_repetitions,
     {"Repetitions", "wlan.rm.repetitions",
      FT_UINT16, BASE_DEC, NULL, 0,
      "Number of Repetitions, 65535 indicates repeat until cancellation", HFILL }},

    {&hf_ieee80211_ff_rm_tx_power,
     {"Transmit Power Used", "wlan.rm.tx_power",
      FT_INT8, BASE_DEC|BASE_UNIT_STRING, UNS(&units_dbm), 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_rm_max_tx_power,
     {"Max Transmit Power", "wlan.rm.max_tx_power",
      FT_INT8, BASE_DEC|BASE_UNIT_STRING, UNS(&units_dbm), 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_tpc,
     {"TPC Report", "wlan.rm.tpc",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_tpc_element_id,
     {"TPC Element ID", "wlan.rm.tpc.element_id",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_tpc_length,
     {"TPC Length", "wlan.rm.tpc.length",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Length of TPC Report element (always 2)", HFILL }},

    {&hf_ieee80211_ff_tpc_tx_power,
     {"TPC Transmit Power", "wlan.rm.tpc.tx_power",
      FT_INT8, BASE_DEC|BASE_UNIT_STRING, UNS(&units_dbm), 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_tpc_link_margin,
     {"TPC Link Margin", "wlan.rm.tpc.link_margin",
      FT_INT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_rm_rx_antenna_id,
     {"Receive Antenna ID", "wlan.rm.rx_antenna_id",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_rm_tx_antenna_id,
     {"Transmit Antenna ID", "wlan.rm.tx_antenna_id",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_rm_rcpi,
     {"Received Channel Power", "wlan.rm.rcpi",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_rm_rsni,
     {"Received Signal to noise indication", "wlan.rm.rsni",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_request_mode_pref_cand,
     {"Preferred Candidate List Included", "wlan.fixed.request_mode.pref_cand",
      FT_UINT8, BASE_DEC, NULL, 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_ff_request_mode_abridged,
     {"Abridged", "wlan.fixed.request_mode.abridged",
      FT_UINT8, BASE_DEC, NULL, 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_ff_request_mode_disassoc_imminent,
     {"Disassociation Imminent", "wlan.fixed.request_mode.disassoc_imminent",
      FT_UINT8, BASE_DEC, NULL, 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_ff_request_mode_bss_term_included,
     {"BSS Termination Included", "wlan.fixed.request_mode.bss_term_included",
      FT_UINT8, BASE_DEC, NULL, 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_ff_request_mode_ess_disassoc_imminent,
     {"ESS Disassociation Imminent", "wlan.fixed.request_mode.ess_disassoc_imminent",
      FT_UINT8, BASE_DEC, NULL, 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_ff_request_mode_link_removal_imminent,
     {"Link Removal Imminent", "wlan.fixed.request_mode.link_removal_imminent",
      FT_UINT8, BASE_DEC, NULL, 0x20,
      NULL, HFILL }},

    {&hf_ieee80211_ff_request_mode_reserved,
     {"Reserved", "wlan.fixed.request_mode.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xc0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_disassoc_timer,
     {"Disassociation Timer", "wlan.fixed.disassoc_timer",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bss_termination_delay,
     {"BSS Termination Delay", "wlan.fixed.bss_termination_delay",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bss_transition_status_code,
     {"BSS Transition Status Code", "wlan.fixed.bss_transition_status_code",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_validity_interval,
     {"Validity Interval", "wlan.fixed.validity_interval",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_url_len,
     {"Session Information URL Length",
      "wlan.fixed.session_information.url_length",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_url,
     {"Session Information URL", "wlan.fixed.session_information.url",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_target_bss,
     {"BSS Transition Target BSS", "wlan.fixed.bss_transition_target_bss",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bss_transition_query_reason,
     {"BSS Transition Query Reason", "wlan.fixed.bss_transition_query_reason",
      FT_UINT8, BASE_DEC, VALS(ieee80211_transition_reasons), 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bss_transition_candidate_list_entries,
     {"BSS Transition Candidate List Entries", "wlan.fixed.bss_transition_candidate_list_entries",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

/* 802.11ai */

    {&hf_ieee80211_ff_fils_discovery_frame_control,
     {"Frame Control", "wlan.fils_discovery.frame_control",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_frame_control_ssid_length,
     {"SSID Length", "wlan.fils_discovery.frame_control.ssid_length",
      FT_UINT16, BASE_HEX, NULL, PA_FILS_FC_SSID_LENGTH,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_frame_control_capability,
     {"Capability", "wlan.fils_discovery.frame_control.capability",
      FT_BOOLEAN, 16, TFS(&tfs_present_not_present), PA_FILS_FC_CAPABILITY,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_frame_control_short_ssid,
     {"Short SSID", "wlan.fils_discovery.frame_control.short_ssid",
      FT_BOOLEAN, 16, TFS(&tfs_present_not_present), PA_FILS_FC_SHORT_SSID,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_frame_control_ap_csn,
     {"AP-CSN", "wlan.fils_discovery.frame_control.ap_csn",
      FT_BOOLEAN, 16, TFS(&tfs_present_not_present), PA_FILS_FC_AP_CSN,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_frame_control_ano,
     {"ANO", "wlan.fils_discovery.frame_control.ano",
      FT_BOOLEAN, 16, TFS(&tfs_present_not_present), PA_FILS_FC_ANO,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_frame_control_channel_center_frequency,
     {"Channel Center Frequency Segment 1", "wlan.fils_discovery.frame_control.channel_center_frequency",
      FT_BOOLEAN, 16, TFS(&tfs_present_not_present), PA_FILS_FC_CCFS1,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_frame_control_primary_channel,
     {"Primary Channel", "wlan.fils_discovery.frame_control.primary_channel",
      FT_BOOLEAN, 16, TFS(&tfs_present_not_present), PA_FILS_FC_PC,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_frame_control_rsn_info,
     {"RSN Info", "wlan.fils_discovery.frame_control.rsn_info",
      FT_BOOLEAN, 16, TFS(&tfs_present_not_present), PA_FILS_FC_RSN_INFO,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_frame_control_length,
     {"Length", "wlan.fils_discovery.frame_control.length",
      FT_BOOLEAN, 16, TFS(&tfs_present_not_present), PA_FILS_FC_LENGTH,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_frame_control_md,
     {"MD", "wlan.fils_discovery.frame_control.md",
      FT_BOOLEAN, 16, TFS(&tfs_present_not_present), PA_FILS_FC_MD,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_frame_control_reserved,
     {"Reserved", "wlan.fils_discovery.frame_control.reserved",
      FT_BOOLEAN, 16, TFS(&tfs_present_not_present), PA_FILS_FC_RESERVED,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_ssid,
     {"SSID", "wlan.fils_discovery.ssid_length",
      FT_STRING, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_capability,
     {"Capability", "wlan.fils_discovery.capability",
      FT_UINT16, BASE_HEX, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_capability_ess,
     {"ESS", "wlan.fils_discovery.capability.ess",
      FT_UINT16, BASE_HEX, NULL, 0x0001,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_capability_privacy,
     {"Privacy", "wlan.fils_discovery.capability.privacy",
      FT_UINT16, BASE_HEX, NULL, 0x0002,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_capability_bss_operating_channel_width,
     {"BSS Operating Channel width", "wlan.fils_discovery.capability.bss_operating_channel_width",
      FT_UINT16, BASE_HEX, VALS(fils_discovery_capability_bss_operating_channel_width), 0x001C,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_capability_max_number_of_spatial_streams,
     {"Maximum Number of Spatial Streams", "wlan.fils_discovery.maximum_number_of_spatial_streams",
      FT_UINT16, BASE_HEX, VALS(fils_discovery_capability_max_number_of_spatial_streams), 0x00E0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_capability_reserved,
     {"Reserved", "wlan.fils_discovery.capability.reserved",
      FT_UINT16, BASE_HEX, NULL, 0x0100,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_capability_multiple_bssid,
     {"Multiple BSSID", "wlan.fils_discovery.capability.multiple_bssid",
      FT_UINT16, BASE_HEX, NULL, 0x0200,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_capability_phy_index,
     {"PHY Index", "wlan.fils_discovery.capability.phy_index",
      FT_UINT16, BASE_HEX, VALS(fils_discovery_capability_phy_index), 0x1C00,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_capability_fils_minimum_rate_dsss,
     {"FILS Minimum Rate", "wlan.fils_discovery.capability.minimum_rate",
      FT_UINT16, BASE_HEX, VALS(fils_discovery_capability_fils_minimum_rate_dsss), 0xE000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_capability_fils_minimum_rate_ofdm,
     {"FILS Minimum Rate", "wlan.fils_discovery.capability.minimum_rate",
      FT_UINT16, BASE_HEX, VALS(fils_discovery_capability_fils_minimum_rate_ofdm), 0xE000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_capability_fils_minimum_rate_ht_vht_tvht,
     {"FILS Minimum Rate", "wlan.fils_discovery.capability.minimum_rate",
      FT_UINT16, BASE_HEX, VALS(fils_discovery_capability_fils_minimum_rate_ht_vht_tvht), 0xE000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_capability_fils_minimum_rate_he,
     {"FILS Minimum Rate", "wlan.fils_discovery.capability.minimum_rate",
      FT_UINT16, BASE_HEX, VALS(fils_discovery_capability_fils_minimum_rate_he), 0xE000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_capability_fils_minimum_rate,
     {"FILS Minimum Rate", "wlan.fils_discovery.capability.minimum_rate",
      FT_UINT16, BASE_HEX, NULL, 0xE000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_short_ssid,
     {"Short SSID", "wlan.fils_discovery.short_ssid",
      FT_UINT32, BASE_HEX, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_ap_csn,
     {"AP Configuration Sequence Number", "wlan.fils_discovery.ap_csn",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_ano,
     {"Access Network Options", "wlan.fils_discovery.ano",
      FT_UINT8, BASE_HEX, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_ccfs1,
     {"Channel Center Frequency Segment 1", "wlan.fils_discovery.channel_center_frequency",
      FT_UINT8, BASE_HEX, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_operating_class,
     {"Operating Class", "wlan.fils_discovery.operating_class",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_primary_channel,
     {"Primary Channel", "wlan.fils_discovery.primary_channel",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_rsn_info,
     {"RSN Info", "wlan.fils_discovery.rsn_info",
      FT_BYTES, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_length,
     {"Length", "wlan.fils_discovery.length",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_fils_discovery_md,
     {"MD", "wlan.fils_discovery.md",
      FT_UINT24, BASE_HEX, NULL, 0x0,
      NULL, HFILL }},

/* 802.11ad */
    {&hf_ieee80211_cf_response_offset,
     {"Response Offset", "wlan.res_offset",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_grant_ack_reserved,
     {"Reserved", "wlan.grant_ack.reserved",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_dynamic_allocation,
     {"Dynamic Allocation", "wlan.dynamic_allocation",
      FT_UINT40, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_TID,
     {"TID", "wlan.dynamic_allocation.tid",
      FT_UINT40, BASE_DEC, NULL, 0x000000000F,
      NULL, HFILL }},

    {&hf_ieee80211_ff_alloc_type,
     {"Allocation Type", "wlan.dynamic_allocation.alloc_type",
      FT_UINT40, BASE_DEC, NULL, 0x0000000070,
      NULL, HFILL }},

    {&hf_ieee80211_ff_src_aid,
     {"Source AID", "wlan.dynamic_allocation.src_aid",
      FT_UINT40, BASE_DEC, NULL, 0x0000007F80,
      NULL, HFILL }},

    {&hf_ieee80211_ff_dest_aid,
     {"Destination AID", "wlan.dynamic_allocation.dest_aid",
      FT_UINT40, BASE_DEC, NULL, 0x00007f8000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_alloc_duration,
     {"Allocation Duration", "wlan.dynamic_allocation.alloc_duration",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(allocation_duration_base_custom), 0x7FFF800000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_b39,
     {"Reserved (b39)", "wlan.dynamic_allocation.b39",
      FT_UINT40, BASE_HEX, NULL, 0x8000000000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ssw,
     {"Sector Sweep", "wlan.ssw",
      FT_UINT24, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ssw_direction,
     {"Sector Sweep Direction", "wlan.ssw.direction",
      FT_BOOLEAN, 24, TFS(&ieee80211_cf_ssw_direction), 0x000001,
      NULL, HFILL}},

    {&hf_ieee80211_ff_ssw_cdown,
     {"Sector Sweep CDOWN", "wlan.ssw.cdown",
      FT_UINT24, BASE_DEC, NULL, 0x0003fe,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ssw_sector_id,
     {"Sector Sweep Sector ID", "wlan.ssw.sector_id",
      FT_UINT24, BASE_DEC, NULL, 0x00fc00,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ssw_dmg_ant_id,
     {"Sector Sweep DMG Antenna ID", "wlan.ssw.dmg_ant_id",
      FT_UINT24, BASE_DEC, NULL, 0x030000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ssw_rxss_len,
     {"Sector Sweep RXSS Length", "wlan.ssw.rxss_len",
      FT_UINT24, BASE_DEC, NULL, 0xfc0000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bf,
     {"Beam Forming", "wlan.bf",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bf_train,
     {"Beam Forming Training", "wlan.bf.train",
      FT_BOOLEAN, 16, NULL, 0x0001,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bf_is_init,
     {"Beam Forming Is InitiatorTXSS", "wlan.bf.isInit",
      FT_BOOLEAN, 16, NULL, 0x0002,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bf_is_resp,
     {"Beam Forming Is ResponderTXSS", "wlan.bf.isResp",
      FT_BOOLEAN, 16, NULL, 0x0004,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bf_rxss_len,
     {"Beam Forming RXSS Length", "wlan.bf.rxss_len",
      FT_UINT16, BASE_DEC, NULL, 0x01f8,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bf_rxss_rate,
     {"Beam Forming RXSS Rate", "wlan.bf.rxss_rate",
      FT_BOOLEAN, 16, NULL, 0x0200,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bf_b10b15,
     {"Reserved (B10-B15)", "wlan.bf.reserved",
      FT_UINT16, BASE_HEX, NULL, 0xFC00,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bf_num_sectors,
     {"Beam Forming Total Number of Sectors", "wlan.bf.num_sectors",
      FT_UINT16, BASE_DEC, NULL, 0x03f8,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bf_num_rx_dmg_ants,
     {"Beam Forming Number of DMG Antennas", "wlan.bf.num_dmg_ants",
      FT_UINT16, BASE_DEC, NULL, 0x0c00,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bf_b12b15,
     {"Reserved (B12-B15)", "wlan.bf.reserved",
      FT_UINT16, BASE_HEX, NULL, 0xF000,
      NULL, HFILL }},

    {&hf_ieee80211_addr_nav_da,
     {"Destination address of STA that caused NAV update", "wlan.nav_da",
      FT_ETHER, BASE_NONE, NULL, 0,
      "DMG Destination Hardware Address", HFILL }},

    {&hf_ieee80211_addr_nav_sa,
     {"Source address of STA that caused NAV update", "wlan.nav_sa",
      FT_ETHER, BASE_NONE, NULL, 0,
      "DMG Source Hardware Address", HFILL }},

    {&hf_ieee80211_ff_sswf,
     {"Sector Sweep Feedback", "wlan.sswf",
      FT_UINT24, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_sswf_total_sectors,
     {"Sector Sweep Feedback total number of sectors", "wlan.sswf.num_sectors",
      FT_UINT24, BASE_DEC, NULL, 0x0001ff,
      NULL, HFILL }},

    {&hf_ieee80211_ff_sswf_num_rx_dmg_ants,
     {"Sector Sweep Feedback Number of receive DMG Antennas", "wlan.sswf.num_dmg_ants",
      FT_UINT24, BASE_DEC, NULL, 0x000600,
      NULL, HFILL }},

    {&hf_ieee80211_ff_sswf_poll_required,
     {"Sector Sweep Feedback Poll required", "wlan.sswf.poll",
      FT_BOOLEAN, 24, NULL, 0x010000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_sswf_reserved1,
     {"Sector Sweep Feedback Reserved", "wlan.sswf.reserved",
      FT_UINT24, BASE_HEX, NULL, 0x00F800,
      NULL, HFILL }},

    {&hf_ieee80211_ff_sswf_reserved2,
     {"Sector Sweep Feedback Reserved", "wlan.sswf.reserved",
      FT_UINT24, BASE_HEX, NULL, 0xFE0000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_sswf_sector_select,
     {"Sector Sweep Feedback Sector Select", "wlan.sswf.sector_select",
      FT_UINT24, BASE_DEC, NULL, 0x00003F,
      NULL, HFILL }},

    {&hf_ieee80211_ff_sswf_dmg_antenna_select,
     {"Sector Sweep Feedback DMG Antenna Select", "wlan.sswf.dmg_antenna_select",
      FT_UINT24, BASE_DEC, NULL, 0x0000C0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_sswf_snr_report,
     {"Sector Sweep Feedback SNR Report", "wlan.sswf.snr_report",
      FT_UINT24, BASE_DEC, NULL, 0x00FF00,
      NULL, HFILL }},


    {&hf_ieee80211_ff_brp,
     {"BRP Request", "wlan.brp",
      FT_UINT32, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_brp_L_RX,
     {"BRP Request L-RX", "wlan.brp.l_rx",
      FT_UINT32, BASE_DEC, NULL, 0x0000001f,
      NULL, HFILL }},

    {&hf_ieee80211_ff_brp_TX_TRN_REQ,
     {"BRP Request TX-TRN-REQ", "wlan.brp.tx_trn_req",
      FT_BOOLEAN, 32, NULL, 0x00000020,
      NULL, HFILL }},

    {&hf_ieee80211_ff_brp_MID_REQ,
     {"BRP Request MID-REQ", "wlan.brp.mid_req",
      FT_BOOLEAN, 32, NULL, 0x00000040,
      NULL, HFILL }},

    {&hf_ieee80211_ff_brp_BC_REQ,
     {"BRP Request BC-REQ", "wlan.brp.bc_req",
      FT_BOOLEAN, 32, NULL, 0x00000080,
      NULL, HFILL }},

    {&hf_ieee80211_ff_brp_MID_GRANT,
     {"BRP Request MID-GRANT", "wlan.brp.mid_grant",
      FT_BOOLEAN, 32, NULL, 0x00000100,
      NULL, HFILL }},

    {&hf_ieee80211_ff_brp_BC_GRANT,
     {"BRP Request BC-GRANT", "wlan.brp.bc_grant",
      FT_BOOLEAN, 32, NULL, 0x00000200,
      NULL, HFILL }},

    {&hf_ieee80211_ff_brp_chan_FBCK_CAP,
     {"BRP Request Chan FBCK-CAP", "wlan.brp.chan_fbck_cap",
      FT_BOOLEAN, 32, NULL, 0x00000400,
      NULL, HFILL }},

    {&hf_ieee80211_ff_brp_tx_sector,
     {"BRP Request TX Sector ID", "wlan.brp.tx_sector_id",
      FT_UINT32, BASE_DEC, NULL, 0x0001f800,
      NULL, HFILL }},

    {&hf_ieee80211_ff_brp_other_aid,
     {"BRP Request Other AID", "wlan.brp.other_aid",
      FT_UINT32, BASE_DEC, NULL, 0x01fe0000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_brp_tx_antenna,
     {"BRP Request TX Antenna ID", "wlan.brp.tx_antenna_id",
      FT_UINT32, BASE_DEC, NULL, 0x06000000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_brp_reserved,
     {"BRP Request Reserved", "wlan.brp.reserved",
      FT_UINT32, BASE_HEX, NULL, 0xF8000000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_blm,
     {"Beamformed Link Maintenance", "wlan.blm",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_blm_unit_index,
     {"BeamLink Maintenance Uint Index", "wlan.blm.uint_index",
      FT_BOOLEAN, 8, NULL, 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_ff_blm_maint_value,
     {"BeamLink Maintenance Value", "wlan.blm.value",
      FT_UINT8, BASE_DEC, NULL, 0x7e,
      NULL, HFILL }},

    {&hf_ieee80211_ff_blm_is_master,
     {"BeamLink Is Master", "wlan.blm.is_master",
      FT_BOOLEAN, 8, NULL, 0x80,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bic,
     {"Beacon Interval Control", "wlan.bic",
      FT_UINT48, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bic_cc_present,
     {"Clustering Control Present", "wlan.bic.cc",
      FT_BOOLEAN, 48, NULL, 0x000000000001,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bic_discovery_mode,
     {"Discovery Mode", "wlan.bic.discovery_mode",
      FT_BOOLEAN, 48, NULL, 0x000000000002,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bic_next_beacon,
     {"Next Beacon", "wlan.bic.next_beacon",
      FT_UINT48, BASE_DEC, NULL, 0x00000000003c,

      NULL, HFILL }},

    {&hf_ieee80211_ff_bic_ati_present,
     {"ATI Present", "wlan.bic.ati",
      FT_BOOLEAN, 48, NULL, 0x000000000040,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bic_abft_len,
     {"A-BFT length", "wlan.bic.abft_len",
      FT_UINT48, BASE_DEC, NULL, 0x000000000380,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bic_fss,
     {"FSS", "wlan.bic.fss",
      FT_UINT48, BASE_DEC, NULL, 0x000000003c00,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bic_is_resp,
     {"Is TXSS Responder", "wlan.bic.is_responder",
      FT_BOOLEAN, 48, NULL, 0x000000004000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bic_next_abft,
     {"Next A-BFT", "wlan.bic.next_abft",
      FT_UINT48, BASE_DEC, NULL, 0x000000078000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bic_frag_txss,
     {"Fragmented TXSS", "wlan.bic.frag_txss",
      FT_BOOLEAN, 48, NULL, 0x000000080000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bic_txss_span,
     {"TXSS span", "wlan.bic.txss_span",
      FT_UINT48, BASE_DEC, NULL, 0x000007f00000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bic_NBI_abft,
     {"Number of Beacon Intervals that are needed to allocate A-BFT", "wlan.bic.NBI_abft",
      FT_UINT48, BASE_DEC, NULL, 0x000078000000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bic_abft_count,
     {"A-BFT Count", "wlan.bic.abft_count",
      FT_UINT48, BASE_DEC, NULL, 0x001f80000000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bic_nabft,
     {"Number of A-BFT's received from each Antenna", "wlan.bic.nabft",
      FT_UINT48, BASE_DEC, NULL, 0x07e000000000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bic_pcp,
     {"PCP Association Ready", "wlan.bic.pcp",
      FT_BOOLEAN, 48, NULL, 0x080000000000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_bic_reserved,
     {"Reserved", "wlan.bic.reserved",
      FT_UINT48, BASE_HEX, NULL, 0xF00000000000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_dmg_params,
     {"DMG Parameters", "wlan.dmg_params",
      FT_UINT8, BASE_HEX , NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_dmg_params_bss,
     {"BSS Type", "wlan.dmg_params.bss",
      FT_UINT8, BASE_DEC, VALS(bss_type), 0x03,
      NULL, HFILL }},

    {&hf_ieee80211_ff_dmg_params_cbap_only,
     {"CBAP Only", "wlan.dmg_params.cbap_only",
      FT_BOOLEAN, 8, NULL, 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_ff_dmg_params_cbap_src,
     {"CBAP Source", "wlan.dmg_params.cbap_src",
      FT_BOOLEAN, 8, NULL, 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_ff_dmg_params_privacy,
     {"DMG Privacy", "wlan.dmg_params.privacy",
      FT_BOOLEAN, 8, NULL, 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_ff_dmg_params_policy,
     {"ECAPC Policy Enforced", "wlan.dmg_params.policy",
      FT_BOOLEAN, 8, NULL, 0x20,
      NULL, HFILL }},

    {&hf_ieee80211_ff_dmg_params_spec_mgmt,
     {"Spectrum Management", "wlan.dmg_params.spec_mgmt",
      FT_BOOLEAN, 8, TFS(&tfs_implemented_not_implemented), 0x40,
      NULL, HFILL }},

    {&hf_ieee80211_ff_dmg_params_radio_measure,
     {"Radio Measurement", "wlan.dmg_params.radio_measure",
      FT_BOOLEAN, 8, TFS(&tfs_implemented_not_implemented), 0x80,
      NULL, HFILL }},

    {&hf_ieee80211_ff_cc,
     {"Clustering Control", "wlan.cc",
      FT_UINT64, BASE_HEX , NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_cc_abft_resp_addr,
     {"A-BFT Responder Address", "wlan.cc.abft_resp_addr",
      FT_ETHER, BASE_NONE , NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_cc_sp_duration,
     {"Beacon SP Duration", "wlan.cc.sp_duration",
      FT_UINT8, BASE_DEC , NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_cc_cluster_id,
     {"Cluster ID", "wlan.cc.cluster_id",
      FT_UINT64, BASE_DEC , NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_cc_role,
     {"Cluster Member Role", "wlan.cc.rold",
      FT_UINT8, BASE_DEC , NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_cc_max_mem,
     {"Cluster MaxMem", "wlan.cc.max_mem",
      FT_UINT8, BASE_DEC , NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_relay_support,
     {"Relay Supportability", "wlan.relay_capabilities.relay_support",
      FT_BOOLEAN, 8, NULL, 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_relay_use,
     {"Relay Usability", "wlan.relay_capabilities.relay_use",
      FT_BOOLEAN, 8, NULL, 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_relay_permission,
     {"Relay Permission", "wlan.relay_capabilities.relay_permission",
      FT_BOOLEAN, 8, NULL, 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_AC_power,
     {"A/C Power", "wlan.relay_capabilities.AC_power",
      FT_BOOLEAN, 8, NULL, 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_tag_relay_prefer,
     {"Relay Preference", "wlan.relay_capabilities.relay_prefer",
      FT_BOOLEAN, 8, NULL, 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_tag_duplex,
     {"Duplex", "wlan.relay_capabilities.duplex",
      FT_UINT8, BASE_DEC, NULL, 0x60,
      NULL, HFILL }},

    {&hf_ieee80211_tag_cooperation,
     {"Cooperation", "wlan.relay_capabilities.cooperation",
      FT_BOOLEAN, 8, NULL, 0x80,
      NULL, HFILL }},

#if 0
    {&hf_ieee80211_ff_rcsi,
     {"Relay Capable STA Info", "wlan.rcsi",
      FT_UINT24, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_rcsi_aid,
     {"AID", "wlan.rcsi.aid",
      FT_UINT8, BASE_DEC, NULL, 0xff,
      NULL, HFILL }},
#endif

    {&hf_ieee80211_ff_band_id,
     {"Band ID", "wlan.band_id",
      FT_UINT8, BASE_DEC, VALS(band_id), 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_move,
     {"Move", "wlan.dmg_bss_param_change.move",
      FT_BOOLEAN, 8, NULL, 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_size,
     {"Size", "wlan.dmg_bss_param_change.size",
      FT_BOOLEAN, 8, NULL, 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_tbtt_offset,
     {"TBTT Offset", "wlan.dmg_bss_param_change.tbtt_offset",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(allocation_duration_base_custom), 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bi_duration,
     {"BI Duration", "wlan.dmg_bss_param_change.bi_duration",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_dmg_capa_sta_addr,
     {"STA Address", "wlan.dmg_capa.sta_addr",
      FT_ETHER, BASE_NONE, NULL, 0,
      "STA_Address", HFILL }},

    {&hf_ieee80211_tag_dmg_capa_aid,
     {"AID", "wlan.dmg_capa.aid",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},
/* 8.4.2.127.2 DMG STA Capability Information field */
    {&hf_ieee80211_tag_reverse_direction, /* DMG STA capa, bits [0] */
     {"Reverse Direction", "wlan.dmg_capa.reverse_direction",
      FT_BOOLEAN, 24, NULL, GENMASK(0, 0),
      NULL, HFILL }},

    {&hf_ieee80211_tag_hlts, /* DMG STA capa, bits [1] */
     {"Higher Layer Timer Synchronization", "wlan.dmg_capa.htls",
      FT_BOOLEAN, 24, NULL, GENMASK(1, 1),
      NULL, HFILL }},

    {&hf_ieee80211_tag_tpc, /* DMG STA capa, bits [2] */
     {"TPC", "wlan.dmg_capa.tpc",
      FT_BOOLEAN, 24, NULL, GENMASK(2, 2),
      NULL, HFILL }},

    {&hf_ieee80211_tag_spsh, /* DMG STA capa, bits [3] */
     {"SPSH and Interference Mitigation", "wlan.dmg_capa.spsh",
      FT_BOOLEAN, 24, NULL, GENMASK(3, 3),
      NULL, HFILL }},

    {&hf_ieee80211_tag_rx_antenna, /* DMG STA capa, bits [4..5] */
     {"Number of RX DMG Antennas", "wlan.dmg_capa.num_rx",
      FT_UINT24, BASE_CUSTOM, CF_FUNC(extra_one_base_custom), GENMASK(5, 4),
      NULL, HFILL }},

    {&hf_ieee80211_tag_fast_link, /* DMG STA capa, bits [6] */
     {"Fast Link Adaptation", "wlan.dmg_capa.fast_link",
      FT_BOOLEAN, 24, NULL, GENMASK(6, 6),
      NULL, HFILL }},

    {&hf_ieee80211_tag_num_sectors, /* DMG STA capa, bits [7..13] */
     {"Total Number of Sectors", "wlan.dmg_capa.num_sectors",
      FT_UINT24, BASE_CUSTOM, CF_FUNC(extra_one_base_custom), GENMASK(13, 7),
      NULL, HFILL }},

    {&hf_ieee80211_tag_rxss_length, /* DMG STA capa, bits [14..19] */
     {"RXSS Length", "wlan.dmg_capa.rxss_len",
      FT_UINT24, BASE_CUSTOM, CF_FUNC(extra_one_mul_two_base_custom), GENMASK(19, 14),
      NULL, HFILL }},

    {&hf_ieee80211_tag_reciprocity, /* DMG STA capa, bits [20] */
     {"DMG Antenna Reciprocity", "wlan.dmg_capa.reciprocity",
      FT_BOOLEAN, 24, NULL, GENMASK(20, 20),
      NULL, HFILL }},
/* DMG STA capa, A-MPDU params, bits [21..26] */
    {&hf_ieee80211_tag_max_ampdu_exp, /* DMG STA capa, bits [21..23] */
     {"Maximum A-MPDU Length Exponent", "wlan.dmg_capa.max_ampdu_exp",
      FT_UINT24, BASE_DEC, NULL, GENMASK(23, 21),
      NULL, HFILL }},

    {&hf_ieee80211_tag_min_mpdu_spacing, /* DMG STA capa, bits [24..26] */
     {"Minimum MPDU Start Spacing", "wlan.dmg_capa.min_mpdu_spacing",
      FT_UINT24, BASE_DEC, NULL, GENMASK(26-24, 24-24),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ba_flow_control , /* DMG STA capa, bits [27] */
     {"BA with Flow Control", "wlan.dmg_capa.bs_flow_ctrl",
      FT_BOOLEAN, 24, NULL, GENMASK(27-24, 27-24),
      NULL, HFILL }},
/* DMG STA capa, supported MCS set, bits [28..51] */
    {&hf_ieee80211_tag_max_sc_rx_mcs, /* DMG STA capa, bits [28..32] */
     {"Maximum SC Rx MCS", "wlan.dmg_capa.max_sc_rx_mcs",
      FT_UINT24, BASE_DEC, NULL, GENMASK(32-24, 28-24),
      NULL, HFILL }},

    {&hf_ieee80211_tag_max_ofdm_rx_mcs, /* DMG STA capa, bits [33..37] */
     {"Maximum OFDM Rx MCS", "wlan.dmg_capa.max_ofdm_rx_mcs",
      FT_UINT24, BASE_DEC, NULL, GENMASK(37-24, 33-24),
      NULL, HFILL }},

    {&hf_ieee80211_tag_max_sc_tx_mcs, /* DMG STA capa, bits [38..42] */
     {"Maximum SC Tx MCS", "wlan.dmg_capa.max_sc_tx_mcs",
      FT_UINT24, BASE_DEC, NULL, GENMASK(42-24, 38-24),
      NULL, HFILL }},

    {&hf_ieee80211_tag_max_ofdm_tx_mcs, /* DMG STA capa, bits [43..47] */
     {"Maximum OFDM Tx MCS", "wlan.dmg_capa.max_ofdm_tx_mcs",
      FT_UINT24, BASE_DEC, NULL, GENMASK(47-24, 43-24),
      NULL, HFILL }},

    {&hf_ieee80211_tag_low_power_supported, /* DMG STA capa, bits [48] */
     {"Low Power SC PHY Supported", "wlan.dmg_capa.low_power_supported",
      FT_BOOLEAN, 16, NULL, GENMASK(48-48, 48-48),
      NULL, HFILL }},

    {&hf_ieee80211_tag_code_rate, /* DMG STA capa, bits [49] */
     {"Code Rate 13/16", "wlan.dmg_capa.code_rate",
      FT_BOOLEAN, 16, NULL, GENMASK(49-48, 49-48),
      NULL, HFILL }},

    {&hf_ieee80211_tag_dtp, /* DMG STA capa, bits [52] */
     {"DTP Supported", "wlan.dmg_capa.dtp",
      FT_BOOLEAN, 16, NULL, GENMASK(52-48, 52-48),
      NULL, HFILL }},

    {&hf_ieee80211_tag_appdu_supp, /* DMG STA capa, bits [53] */
     {"A-PPDU Supported", "wlan.dmg_capa.appdu_supp",
      FT_BOOLEAN, 16, NULL, GENMASK(53-48, 53-48),
      NULL, HFILL }},

    {&hf_ieee80211_tag_heartbeat, /* DMG STA capa, bits [54] */
     {"HeartBeat", "wlan.dmg_capa.heartbeat",
      FT_BOOLEAN, 16, NULL, GENMASK(54-48, 54-48),
      NULL, HFILL }},

    {&hf_ieee80211_tag_other_aid, /* DMG STA capa, bits [55] */
     {"Supports Other_AID", "wlan.dmg_capa.other_aid",
      FT_BOOLEAN, 16, NULL, GENMASK(55-48, 55-48),
      NULL, HFILL }},

    {&hf_ieee80211_tag_pattern_recip, /* DMG STA capa, bits [56] */
     {"Antenna Pattern Reciprocity", "wlan.dmg_capa.pattern_recip",
      FT_BOOLEAN, 16, NULL, GENMASK(56-48, 56-48),
      NULL, HFILL }},

    {&hf_ieee80211_tag_heartbeat_elapsed, /* DMG STA capa, bits [57..59] */
     {"Heartbeat Elapsed Indication", "wlan.dmg_capa.heartbeat_elapsed",
      FT_UINT16, BASE_DEC, NULL, GENMASK(59-48, 57-48),
      NULL, HFILL }},

    {&hf_ieee80211_tag_grant_ack_supp, /* DMG STA capa, bits [60] */
     {"Grant ACK Supported", "wlan.dmg_capa.grant_ack_supp",
      FT_BOOLEAN, 16, NULL, GENMASK(60-48, 60-48),
      NULL, HFILL }},

    {&hf_ieee80211_tag_RXSSTxRate_supp, /* DMG STA capa, bits [61] */
     {"RXSSTxRate Supported", "wlan.dmg_capa.RXSSTxRate",
      FT_BOOLEAN, 16, NULL, GENMASK(61-48, 61-48),
      NULL, HFILL }},
/* 8.4.2.127.3 DMG PCP/AP Capability Information field */
    {&hf_ieee80211_tag_pcp_tddti, /* DMG PCP/AP capa, bits [0] */
     {"TDDTI", "wlan.dmg_capa.pcp_tdtti",
      FT_BOOLEAN, 16, NULL, GENMASK(0, 0),
      NULL, HFILL }},

    {&hf_ieee80211_tag_pcp_PSA, /* DMG PCP/AP capa, bits [1] */
     {"Pseudo-static Allocations", "wlan.dmg_capa.pcp_psa",
      FT_BOOLEAN, 16, NULL, GENMASK(1, 1),
      NULL, HFILL }},

    {&hf_ieee80211_tag_pcp_handover, /* DMG PCP/AP capa, bits [2] */
     {"PDP Handover", "wlan.dmg_capa.pcp_handover",
      FT_BOOLEAN, 16, NULL, GENMASK(2, 2),
      NULL, HFILL }},

    {&hf_ieee80211_tag_pcp_max_assoc, /* DMG PCP/AP capa, bits [3..10] */
     {"Max Associated STA Number", "wlan.dmg_capa.pcp_max_assoc",
      FT_UINT16, BASE_DEC, NULL, GENMASK(10, 3),
      NULL, HFILL }},

    {&hf_ieee80211_tag_pcp_power_src, /* DMG PCP/AP capa, bits [11] */
     {"Power Source", "wlan.dmg_capa.pcp_power_src",
      FT_BOOLEAN, 16, NULL, GENMASK(11, 11),
      NULL, HFILL }},

    {&hf_ieee80211_tag_pcp_decenter, /* DMG PCP/AP capa, bits [12] */
     {"Decentralized PCP/AP Clustering", "wlan.dmg_capa.pcp_decenter",
      FT_BOOLEAN, 16, NULL, GENMASK(12, 12),
      NULL, HFILL }},

    {&hf_ieee80211_tag_pcp_forwarding, /* DMG PCP/AP capa, bits [13] */
     {"PCP Forwarding", "wlan.dmg_capa.pcp_forwarding",
      FT_BOOLEAN, 16, NULL, GENMASK(13, 13),
      NULL, HFILL }},

    {&hf_ieee80211_tag_pcp_center, /* DMG PCP/AP capa, bits [14] */
     {"Centralized PCP/AP Clustering", "wlan.dmg_capa.pcp_center",
      FT_BOOLEAN, 16, NULL, GENMASK(14, 14),
      NULL, HFILL }},

    {&hf_ieee80211_tag_sta_beam_track, /* DMG STA beam track capa*/
     {"STA Beam Tracking Time Limit", "wlan.dmg_capa.beam_track",
      FT_UINT16, BASE_DEC | BASE_UNIT_STRING, UNS(&units_microseconds), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ext_sc_mcs_max_tx, /* DMG STA Ext SC MCS Capa: Max TX*/
     {"Extended SC Max Tx MCS Name", "wlan.dmg_capa.ext_sc_mcs_capa_max_tx",
      FT_UINT8, BASE_DEC, VALS(extended_sc_mcs), GENMASK(2, 0),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ext_sc_mcs_tx_code_7_8, /* DMG STA Ext SC MCS Capa: Tx code rate 7/8*/
     {"Extended SC Tx MCS code rate 7/8", "wlan.dmg_capa.ext_sc_mcs_tx_code_7_8",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), GENMASK(3, 3),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ext_sc_mcs_max_rx, /* DMG STA Ext SC MCS Capa: Max RX*/
     {"Extended SC Max Rx MCS Name", "wlan.dmg_capa.ext_sc_mcs_capa_max_rx",
      FT_UINT8, BASE_DEC, VALS(extended_sc_mcs), GENMASK(6, 4),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ext_sc_mcs_rx_code_7_8, /* DMG STA Ext SC MCS Capa: Rx code rate 7/8*/
     {"Extended SC Rx MCS code rate 7/8", "wlan.dmg_capa.ext_sc_mcs_rx_code_7_8",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), GENMASK(7, 7),
      NULL, HFILL }},

    {&hf_ieee80211_tag_max_basic_sf_amsdu, /* DMG Max Number of Basic Subframes in an A-MSDU*/
     {"Max Number of Basic Subframes in an A-MSDU", "wlan.dmg_capa.max_basic_sf_amsdu",
      FT_UINT8, BASE_RANGE_STRING | BASE_DEC, RVALS(max_basic_sf_amsdu), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_max_short_sf_amsdu, /* DMG Max Number of short Subframes in an A-MSDU*/
     {"Max Number of short Subframes in an A-MSDU", "wlan.dmg_capa.max_short_sf_amsdu",
      FT_UINT8, BASE_RANGE_STRING | BASE_DEC, RVALS(max_short_sf_amsdu), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_PSRSI,
     {"PS Request Suspension Interval", "wlan.dmg_oper.psrsi",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_min_BHI_duration,
     {"Min BHI Duration", "wlan.dmg_oper.min_BHI_duration",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_brdct_sta_info_dur,
     {"Broadcast STA Info Duration", "wlan.dmg_oper.brdcst_sta_info_dur",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_assoc_resp_confirm_time,
     {"Associated Response Confirm Time", "wlan.dmg_oper.assoc_resp_confirm_time",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_min_pp_duration,
     {"Min PP Duration", "wlan.dmg_oper.min_pp_duration",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_SP_idle_timeout,
     {"SP Idle Timeout", "wlan.dmg_oper.SP_idle_timeout",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_max_lost_beacons,
     {"Max Lost Beacons", "wlan.dmg_oper.max_lost_beacons",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_type,
     {"Type", "wlan.sctor_id.type",
      FT_UINT32, BASE_HEX, NULL, 0x0000000f,
      NULL, HFILL }},

    {&hf_ieee80211_tag_tap1,
     {"Tap 1", "wlan.sctor_id.tap1",
      FT_UINT32, BASE_HEX, NULL, 0x000003f0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_state1,
     {"State 1", "wlan.sctor_id.state1",
      FT_UINT32, BASE_HEX, NULL, 0x0000fc00,
      NULL, HFILL }},

    {&hf_ieee80211_tag_tap2,
     {"Tap 2", "wlan.sctor_id.tap2",
      FT_UINT32, BASE_HEX, NULL, 0x00ff0000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_state2,
     {"State 2", "wlan.sctor_id.state2",
      FT_UINT32, BASE_HEX, NULL, 0xff000000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_allocation_id,
     {"Allocation ID", "wlan.ext_sched.alloc_id",
      FT_UINT16, BASE_DEC, NULL, 0x000f,
      NULL, HFILL }},

    {&hf_ieee80211_tag_allocation_type,
     {"Allocation Type", "wlan.ext_sched.alloc_type",
      FT_UINT16, BASE_DEC, VALS(allocation_type), 0x0070,
      NULL, HFILL }},

    {&hf_ieee80211_tag_pseudo_static,
     {"Pseudo-static", "wlan.ext_sched.p_static",
      FT_BOOLEAN, 16, NULL, 0x0080,
      NULL, HFILL }},

    {&hf_ieee80211_tag_truncatable,
     {"Truncatable", "wlan.ext_sched.truncatable",
      FT_BOOLEAN, 16, NULL, 0x0100,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extendable,
     {"Extendable", "wlan.ext_sched.extendable",
      FT_BOOLEAN, 16, NULL, 0x0200,
      NULL, HFILL }},

    {&hf_ieee80211_tag_pcp_active,
     {"PCP Active", "wlan.ext_sched.pcp_active",
      FT_BOOLEAN, 16, NULL, 0x0400,
      NULL, HFILL }},

    {&hf_ieee80211_tag_lp_sc_used,
     {"LP SC Used", "wlan.ext_sched.lp_sc_used",
      FT_BOOLEAN, 16, NULL, 0x0800,
      NULL, HFILL }},

    {&hf_ieee80211_tag_src_aid,
     {"Source AID", "wlan.ext_sched.src_id",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_dest_aid,
     {"Destination AID", "wlan.ext_sched.dest_id",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_alloc_start,
     {"Allocation Start", "wlan.ext_sched.alloc_start",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_alloc_block_duration,
     {"Allocation Block Duration", "wlan.ext_sched.block_duration",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_num_blocks,
     {"Number of Blocks", "wlan.ext_sched.num_blocks",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_alloc_block_period,
     {"Allocation Block Period", "wlan.ext_sched.alloc_block_period",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_aid,
     {"AID", "wlan.sta_avail.aid",
      FT_UINT16, BASE_DEC, NULL, 0x00ff,
      NULL, HFILL }},

    {&hf_ieee80211_tag_cbap,
     {"CBAP", "wlan.sta_avail.cbap",
      FT_BOOLEAN, 16, NULL, 0x0100,
      NULL, HFILL }},

    {&hf_ieee80211_tag_pp_avail,
     {"PP Available", "wlan.sta_avail.pp_avail",
      FT_BOOLEAN, 16, NULL, 0x0200,
      NULL, HFILL }},

    {&hf_ieee80211_tag_next_ati_start_time,
     {"Start Time", "wlan.next_ati.start_time",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_next_ati_duration,
     {"ATI Duration", "wlan.next_ati.duration",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_old_bssid,
     {"Old BSSID", "wlan.pcp_handover.old_bssid",
      FT_ETHER, BASE_NONE, NULL, 0,
      "OLD_BSSID", HFILL }},

    {&hf_ieee80211_tag_new_pcp_addr,
     {"New PCP Address", "wlan.pcp_handover.new_pcp_addr",
      FT_ETHER, BASE_NONE, NULL, 0,
      "New_PCP_Address", HFILL }},

    {&hf_ieee80211_tag_bssid,
     {"BSSID", "wlan.quiet_res.bssid",
      FT_ETHER, BASE_NONE, NULL, 0,
      "BSS-ID", HFILL }},

    {&hf_ieee80211_tag_duplex_relay,
     {"Duplex", "wlan.relay_capabilities.duplex",
      FT_UINT8, BASE_DEC, NULL, 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_cooperation_relay,
     {"Cooperation", "wlan.relay_capabilities.cooperation",
      FT_BOOLEAN, 8, NULL, 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_tx_mode,
     {"TX-Mode", "wlan.relay_trans_param.tx_mode",
      FT_BOOLEAN, 8, NULL, 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_link_change_interval,
     {"Link Change Interval", "wlan.relay_trans_param.link_change_interval",
      FT_UINT8, BASE_CUSTOM, CF_FUNC(allocation_duration_base_custom), 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_data_sensing_time,
     {"Data Sensing Time", "wlan.relay_trans_param.data_sensing_time",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_first_period,
     {"First Period", "wlan.relay_trans_param.first_period",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_second_period,
     {"Second Period", "wlan.relay_trans_param.second_period",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_initiator,
     {"Initiator", "wlan.beam_refine.initiator",
      FT_BOOLEAN, 40, NULL, 0x0000000001,
      NULL, HFILL }},

    {&hf_ieee80211_tag_tx_train_res,
     {"TX-train-response", "wlan.beam_refine.tx_train_res",
      FT_BOOLEAN, 40, NULL, 0x0000000002,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rx_train_res,
     {"RX-train-response", "wlan.beam_refine.rx_train_res",
      FT_BOOLEAN, 40, NULL, 0x0000000004,
      NULL, HFILL }},

    {&hf_ieee80211_tag_tx_trn_ok,
     {"TX-TRN-OK", "wlan.beam_refine.tx_trn_ok",
      FT_BOOLEAN, 40, NULL, 0x0000000008,
      NULL, HFILL }},

    {&hf_ieee80211_tag_txss_fbck_req,
     {"TXSS-FBCK-REQ", "wlan.beam_refine.txss_fbck_req",
      FT_BOOLEAN, 40, NULL, 0x0000000010,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bs_fbck,
     {"BS-FBCK", "wlan.beam_refine.bs_fbck",
      FT_UINT40, BASE_DEC, NULL, 0x00000007e0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bs_fbck_antenna_id,
     {"BS-FBCK Antenna ID", "wlan.beam_refine.bs_fbck_antenna_id",
      FT_UINT40, BASE_DEC, NULL, 0x0000001800,
      NULL, HFILL }},

    {&hf_ieee80211_tag_snr_requested,
     {"SNR Requested", "wlan.beam_refine.snr_req",
      FT_BOOLEAN, 40, NULL, 0x0000002000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_channel_measurement_requested,
     {"Channel Measurement Requested", "wlan.beam_refine.ch_measure_req",
      FT_BOOLEAN, 40, NULL, 0x0000004000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_number_of_taps_requested,
     {"Number of Taps Requested", "wlan.beam_refine.taps_req",
      FT_UINT40, BASE_DEC | BASE_VAL64_STRING, VALS64(number_of_taps_values), 0x0000018000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_sector_id_order_req,
     {"Sector ID Order Requested", "wlan.beam_refine.sector_id_req",
      FT_BOOLEAN, 40, NULL, 0x0000020000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_snr_present,
     {"SNR Present", "wlan.beam_refine.snr_present",
      FT_BOOLEAN, 40, NULL, 0x0000040000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_channel_measurement_present,
     {"Channel Measurement Present", "wlan.beam_refine.ch_measure_present",
      FT_BOOLEAN, 40, NULL, 0x0000080000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_tap_delay_present,
     {"Tap Delay Present", "wlan.beam_refine.tap_delay_present",
      FT_BOOLEAN, 40, NULL, 0x0000100000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_number_of_taps_present,
     {"Number of Taps Present", "wlan.beam_refine.taps_present",
      FT_UINT40, BASE_DEC | BASE_VAL64_STRING, VALS64(number_of_taps_values), 0x0000600000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_number_of_measurement,
     {"Number of Measurements", "wlan.beam_refine.num_measurement",
      FT_UINT40, BASE_DEC, NULL, 0x003f800000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_sector_id_order_present,
     {"Sector ID Order Present", "wlan.beam_refine.sector_id_present",
      FT_BOOLEAN, 40, NULL, 0x0040000000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_number_of_beams,
     {"Number of Beams", "wlan.beam_refine.num_beams",
      FT_UINT40, BASE_DEC, NULL, 0x0f80000000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_mid_extension,
     {"MID Extension", "wlan.beam_refine.mid_ext",
      FT_BOOLEAN, 40, NULL, 0x1000000000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_capability_request,
     {"Capability Request", "wlan.beam_refine.cap_req",
      FT_BOOLEAN, 40, NULL, 0x2000000000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_beam_refine_reserved,
     {"Reserved", "wlan.beam_refine.reserved",
      FT_UINT40, BASE_HEX, NULL, 0xc000000000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_nextpcp_list,
      {"AID of NextPCP", "wlan.next_pcp.list",
       FT_UINT8, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_nextpcp_token,
      {"NextPCP List Token", "wlan.next_pcp.token",
       FT_UINT8, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_reamaining_BI,
      {"Remaining BI's", "wlan.pcp_handover.remaining_BIs",
       FT_UINT8, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_request_token,
      {"Request Token", "wlan.request_token",
       FT_UINT16, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_bi_start_time,
      {"BI Start Time", "wlan.bi_start_time",
       FT_UINT32, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_sleep_cycle,
      {"Sleep Cycle", "wlan.sleep_cycle",
       FT_UINT16, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_num_awake_bis,
      {"Number of Awake/Doze BIs", "wlan.num_awake_bis",
       FT_UINT16, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_dmg_action_code,
     {"DMG Action", "wlan.fixed.dmg_act",
      FT_UINT8, BASE_HEX, VALS(ff_dmg_action_flags), 0,
      "Action Code", HFILL }},

    {&hf_ieee80211_ff_unprotected_dmg_action_code,
     {"Unprotected DMG Action", "wlan.fixed.unprotected_dmg_act",
      FT_UINT8, BASE_HEX, VALS(ff_unprotected_dmg_action_flags), 0,
      "Action Code", HFILL }},

    {&hf_ieee80211_ff_dmg_pwr_mgmt,
      {"DMG Power Management", "wlan.dmg.pwr_mgmt",
       FT_BOOLEAN, 8, NULL, 0x01,
       NULL, HFILL }},

    {&hf_ieee80211_ff_subject_address,
      {"Subject Address", "wlan.dmg.subject_addr",
       FT_ETHER, BASE_NONE, NULL, 0,
       "MAC address of requested STA", HFILL }},

    {&hf_ieee80211_ff_handover_reason,
      {"Handover Reason", "wlan.dmg.handover_reason",
       FT_UINT8, BASE_DEC, NULL, 0x03,
       NULL, HFILL }},

    {&hf_ieee80211_ff_handover_remaining_bi,
      {"Handover Remaining BI", "wlan.dmg.handover_remaining_bi",
       FT_UINT8, BASE_DEC, NULL, 0x01,
       NULL, HFILL }},

    {&hf_ieee80211_ff_handover_result,
      {"Handover Result", "wlan.dmg.handover_result",
       FT_UINT8, BASE_DEC, NULL, 0x01,
       NULL, HFILL }},

    {&hf_ieee80211_ff_handover_reject_reason,
      {"Handover Reject Reason", "wlan.dmg.handover_reject_reason",
       FT_UINT8, BASE_DEC, NULL, 0x03,
       NULL, HFILL }},

    {&hf_ieee80211_ff_destination_reds_aid,
      {"Destination REDS AID", "wlan.dmg.destination_reds_aid",
       FT_UINT16, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_destination_aid,
      {"Destination AID", "wlan.dmg.destination_aid",
       FT_UINT16, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_relay_aid,
      {"Relay AID", "wlan.dmg.relay_aid",
       FT_UINT16, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_source_aid,
      {"Source AID", "wlan.dmg.source_aid",
       FT_UINT16, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_timing_offset,
      {"Timing Offset", "wlan.dmg.timing_offset",
       FT_UINT16, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_sampling_frequency_offset,
      {"Sampling Frequency Offset", "wlan.dmg.sampling_frequency_offset",
       FT_UINT16, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_relay_operation_type,
      {"Relay Operation Type", "wlan.dmg.relay_operation_type",
       FT_UINT8, BASE_DEC, NULL, 0x03,
       NULL, HFILL }},

    {&hf_ieee80211_ff_peer_sta_aid,
      {"Peer STA AID", "wlan.dmg.peer_sta_aid",
       FT_UINT8, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_snr,
      {"SNR", "wlan.dmg.snr",
       FT_UINT8, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_internal_angle,
      {"Internal Angle", "wlan.dmg.internal_angle",
       FT_UINT8, BASE_DEC, NULL, 0xfe,
       NULL, HFILL }},

    {&hf_ieee80211_ff_recommend,
      {"Recommend", "wlan.dmg.recommend",
       FT_UINT8, BASE_DEC, NULL, 0x01,
       NULL, HFILL }},

    {&hf_ieee80211_ff_fst_action_code,
      {"FST Action Code", "wlan.fst.action_code",
       FT_UINT8, BASE_HEX, VALS(ff_fst_action_flags), 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_robust_av_streaming_action_code,
     {"Robust AV Streaming Action Code", "wlan.robust_av_streaming.action_code",
      FT_UINT8, BASE_HEX, VALS(ff_robust_av_streaming_action_flags), 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_llt,
      {"Link Loss Timeout", "wlan.fst.llt",
       FT_UINT32, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_fsts_id,
      {"FSTS ID", "wlan.session_trans.fsts_id",
       FT_UINT32, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_mmpdu_len,
      {"MMPDU Length", "wlan.fst.mmpdu_length",
       FT_UINT16, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_mmpdu_ctrl,
      {"MMPDU Control", "wlan.fst.mmpdu_ctrl",
       FT_UINT16, BASE_HEX, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_oct_mmpdu,
      {"OCT MMPDU", "wlan.fst.oct_mmpdu",
       FT_BYTES, BASE_NONE, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_scs_scsid,
     {"SCSID", "wlan.scs.scs_status_list.scsid",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_ff_scs_status,
     {"Status", "wlan.scs.scs_status_list.status",
      FT_UINT16, BASE_DEC|BASE_EXT_STRING, &ieee80211_status_code_ext, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_scs_response_count,
     {"Count", "wlan.scs.scs_response.count",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_ff_vht_mimo_cntrl,
     {"VHT MIMO Control", "wlan.vht.mimo_control.control",
      FT_UINT24, BASE_HEX, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_vht_mimo_cntrl_nc_index,
     {"Nc Index", "wlan.vht.mimo_control.ncindex",
      FT_UINT24, BASE_HEX, VALS(ff_vht_mimo_cntrl_nc_index_vals), 0x000007,
      "Number of Columns Less One", HFILL }},

    {&hf_ieee80211_ff_vht_mimo_cntrl_nr_index,
     {"Nr Index", "wlan.vht.mimo_control.nrindex",
      FT_UINT24, BASE_HEX, VALS(ff_vht_mimo_cntrl_nr_index_vals), 0x000038,
      "Number of Rows Less One", HFILL }},

    {&hf_ieee80211_ff_vht_mimo_cntrl_channel_width,
     {"Channel Width", "wlan.vht.mimo_control.chanwidth",
      FT_UINT24, BASE_HEX, VALS(ff_vht_mimo_cntrl_channel_width_vals), 0x0000C0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_vht_mimo_cntrl_grouping,
     {"Grouping (Ng)", "wlan.vht.mimo_control.grouping",
      FT_UINT24, BASE_HEX, VALS(ff_vht_mimo_cntrl_grouping_vals), 0x000300,
      NULL, HFILL }},

    {&hf_ieee80211_ff_vht_mimo_cntrl_codebook_info,
     {"Codebook Information", "wlan.vht.mimo_control.codebookinfo",
      FT_UINT24, BASE_HEX, NULL, 0x000400,
      NULL, HFILL }},

    {&hf_ieee80211_ff_vht_mimo_cntrl_feedback_type,
     {"Feedback Type", "wlan.vht.mimo_control.feedbacktype",
      FT_UINT24, BASE_HEX, VALS(ff_vht_mimo_cntrl_feedback_vals), 0x000800,
      NULL, HFILL }},

    {&hf_ieee80211_ff_vht_mimo_cntrl_remaining_feedback_seg,
     {"Remaining Feedback Segments", "wlan.vht.mimo_control.remainingfeedbackseg",
      FT_UINT24, BASE_HEX, NULL, 0x007000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_vht_mimo_cntrl_first_feedback_seg,
     {"First Feedback Segments", "wlan.vht.mimo_control.firstfeedbackseg",
      FT_UINT24, BASE_HEX, NULL, 0x008000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_vht_mimo_cntrl_reserved,
     {"Reserved", "wlan.vht.mimo_control.reserved",
      FT_UINT24, BASE_HEX, NULL, 0x030000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_vht_mimo_cntrl_sounding_dialog_token_number,
     {"Sounding Dialog Token Number", "wlan.vht.mimo_control.sounding_dialog_token_nbr",
      FT_UINT24, BASE_HEX, NULL, 0xFC0000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_vht_action,
      {"VHT Action", "wlan.vht.action",
       FT_UINT8, BASE_DEC, VALS(vht_action_vals), 0,
       NULL, HFILL }},

    {&hf_ieee80211_vht_compressed_beamforming_report,
      {"VHT Compressed Beamforming Report", "wlan.vht.compressed_beamforming_report",
       FT_BYTES, BASE_NONE, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_vht_mu_exclusive_beamforming_report,
      {"VHT MU Exclusive Beamforming Report","wlan.vht.exclusive_beamforming_report",
       FT_BYTES, BASE_NONE, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_vht_compressed_beamforming_report_snr,
      {"Signal to Noise Ratio (SNR)", "wlan.vht.compressed_beamforming_report.snr",
       FT_INT8, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_vht_compressed_beamform_scidx,
     {"SCIDX", "wlan.vht.compressed_beamforming_report.scidx",
      FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_vht_mu_exclusive_beamforming_delta_snr,
      {"Delta SNR for space-time stream Nc for subcarrier k", "wlan.vht.exclusive_beamforming_report.delta_snr",
       FT_NONE, BASE_NONE, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_vht_group_id_management,
      {"Group ID Management", "wlan.vht.group_id_management",
       FT_BYTES, BASE_NONE, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_vht_membership_status_array,
      {"Membership Status Array", "wlan.vht.membership_status_array",
       FT_BYTES, BASE_NONE, NULL, 0,
       NULL, HFILL }},

      {&hf_ieee80211_vht_user_position_array,
        {"User Position Array", "wlan.vht.user_position_array",
         FT_BYTES, BASE_NONE, NULL, 0,
         NULL, HFILL }},

      {&hf_ieee80211_vht_membership_status_field,
        {"Membership Status Field", "wlan.vht.membership_status_array.field",
         FT_UINT8, BASE_DEC, NULL, 0,
         NULL, HFILL }},

      {&hf_ieee80211_vht_user_position_field,
        {"User Position Field", "wlan.vht.user_position_array.field",
         FT_UINT8, BASE_DEC, NULL, 0,
         NULL, HFILL }},

    {&hf_ieee80211_vht_operation_mode_notification,
      {"Operation Mode Notification", "wlan.vht.operation_mode_notification",
       FT_BYTES, BASE_NONE, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_he_action,
      {"HE Action", "wlan.he.action",
       FT_UINT8, BASE_RANGE_STRING | BASE_DEC, RVALS(he_action_rvals), 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_protected_he_action,
      {"Protected HE Action", "wlan.he.protected_action",
       FT_UINT8, BASE_RANGE_STRING | BASE_DEC, RVALS(protected_he_action_rvals), 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_protected_eht_action,
      {"Protected EHT Action", "wlan.eht.protected_action",
       FT_UINT8, BASE_RANGE_STRING | BASE_DEC, RVALS(protected_eht_action_rvals), 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_protected_ftm_action,
      {"Protected FTM Action", "wlan.ftm.protected_action",
       FT_UINT8, BASE_DEC, VALS(protected_ftm_action_vals), 0,
       NULL, HFILL }},

    {&hf_ieee80211_ff_eht_action,
     {"EHT Action", "wlan.eht.action",
      FT_UINT8, BASE_RANGE_STRING | BASE_DEC, RVALS(eht_action_rvals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_he_mimo_control_nc_index,
     {"Nc Index", "wlan.he.mimo.nc_index",
      FT_UINT40, BASE_DEC|BASE_VAL64_STRING, VALS64(he_mimo_cntrl_nc_index_vals),
      0x0000000007, NULL, HFILL }},

    {&hf_ieee80211_he_mimo_control_nr_index,
     {"Nr Index", "wlan.he.mimo.nr_index",
      FT_UINT40, BASE_DEC|BASE_VAL64_STRING, VALS64(he_mimo_cntrl_nr_index_vals),
      0x0000000038, NULL, HFILL }},

    {&hf_ieee80211_he_mimo_control_bw,
     {"BW", "wlan.he.mimo.bw",
      FT_UINT40, BASE_DEC, NULL, 0x00000000C0, NULL, HFILL }},

    {&hf_ieee80211_he_mimo_control_grouping,
     {"Grouping", "wlan.he.mimo.grouping",
      FT_UINT40, BASE_DEC|BASE_VAL64_STRING, VALS64(he_mimo_cntrl_grouping_flags),
      0x0000000100, NULL, HFILL }},

    {&hf_ieee80211_he_mimo_control_codebook_info,
     {"Codebook Information", "wlan.he.mimo.codebook_info",
      FT_UINT40, BASE_DEC, NULL, 0x0000000200, NULL, HFILL }},

    {&hf_ieee80211_he_mimo_control_feedback_type,
     {"Feedback Type", "wlan.he.mimo.feedback_type",
      FT_UINT40, BASE_DEC|BASE_VAL64_STRING, VALS64(he_mimo_cntrl_feedback_vals),
      0x0000000C00, NULL, HFILL }},

    {&hf_ieee80211_he_mimo_control_remaining_feedback_segs,
     {"Remaining Feedback Segments", "wlan.he.mimo.remaining_feedback_segs",
      FT_UINT40, BASE_DEC, NULL, 0x0000007000, NULL, HFILL }},

    {&hf_ieee80211_he_mimo_control_first_feedback_seg,
     {"First Feedback Segment", "wlan.he.mimo.first_feedback_seg",
      FT_UINT40, BASE_DEC, NULL, 0x0000008000, NULL, HFILL }},

    {&hf_ieee80211_he_mimo_control_ru_start_index,
     {"RU Start Index", "wlan.he.mimo.ru_start_index",
      FT_UINT40, BASE_HEX, NULL, 0x00007F0000, NULL, HFILL }},

    {&hf_ieee80211_he_mimo_control_ru_end_index,
     {"RU End Index", "wlan.he.mimo.ru_end_index",
      FT_UINT40, BASE_HEX, NULL, 0x003F800000, NULL, HFILL }},

    {&hf_ieee80211_he_mimo_control_sounding_dialog_token_num,
     {"Sounding Dialog Token Number", "wlan.he.mimo.sounding_dialog_token_num",
      FT_UINT40, BASE_DEC, NULL, 0x0FC0000000, NULL, HFILL }},

    {&hf_ieee80211_he_mimo_control_reserved,
     {"Reserved", "wlan.he.mimo.reserved",
      FT_UINT40, BASE_HEX, NULL, 0xF000000000, NULL, HFILL }},

    {&hf_ieee80211_he_mimo_control_field,
     {"HE MIMO Control", "wlan.he.action.he_mimo_control",
      FT_UINT40, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_compressed_beamforming_report_snr,
     {"AvgSNR", "wlan.he.mimo.beamforming_report.avgsnr",
      FT_INT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_compressed_beamform_scidx,
     {"SCIDX", "wlan.he.action.he_mimo_control.scidx",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_beamforming_report_len,
     {"Report Len", "wlan.he.action.he_mimo_control.report_len",
      FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_tspec_allocation_id,
      {"Allocation ID", "wlan.dmg_tspec.allocation_id",
       FT_UINT24, BASE_DEC, NULL, 0x00000f,
       NULL, HFILL }},

    {&hf_ieee80211_tag_tspec_allocation_type,
      {"Allocation Type", "wlan.dmg_tspec.allocation_type",
       FT_UINT24, BASE_DEC, NULL, 0x000070,
       NULL, HFILL }},

    {&hf_ieee80211_tag_tspec_allocation_format,
      {"Allocation Format", "wlan.dmg_tspec.allocation_format",
       FT_BOOLEAN, 24, NULL, 0x000080,
       NULL, HFILL }},

    {&hf_ieee80211_tag_tspec_pseudo_static,
      {"Pseudo Static", "wlan.dmg_tspec.pseudo_static",
       FT_BOOLEAN, 24, NULL, 0x000100,
       NULL, HFILL }},

    {&hf_ieee80211_tag_tspec_truncatable,
      {"Truncatable", "wlan.dmg_tspec.truncatable",
       FT_BOOLEAN, 24, NULL, 0x000200,
       NULL, HFILL }},

    {&hf_ieee80211_tag_tspec_extendable,
      {"Extendable", "wlan.dmg_tspec.extendable",
       FT_BOOLEAN, 24, NULL, 0x000400,
       NULL, HFILL }},

    {&hf_ieee80211_tag_tspec_lp_sc_used,
      {"LP SC Usec", "wlan.dmg_tspec.lp_sc_used",
       FT_BOOLEAN, 24, NULL, 0x000800,
       NULL, HFILL }},

    {&hf_ieee80211_tag_tspec_up,
      {"UP", "wlan.dmg_tspec.up",
       FT_UINT24, BASE_HEX, NULL, 0x007000,
       NULL, HFILL }},

    {&hf_ieee80211_tag_tspec_dest_aid,
      {"Destination AID", "wlan.dmg_tspec.dest_aid",
       FT_UINT24, BASE_HEX, NULL, 0x7f8000,
       NULL, HFILL }},

    {&hf_ieee80211_tag_tspec_allocation_period,
      {"Allocation Period", "wlan.dmg_tspec.allocation_period",
       FT_UINT16, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_tspec_min_allocation,
      {"Minimal Allocation", "wlan.dmg_tspec.min_allocation",
       FT_UINT16, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_tspec_max_allocation,
      {"Maximal Allocation", "wlan.dmg_tspec.max_allocation",
       FT_UINT16, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_tspec_min_duration,
      {"Minimal Duration", "wlan.dmg_tspec.min_duration",
       FT_UINT16, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_tspec_num_of_constraints,
      {"Number Of Constraints", "wlan.dmg_tspec.num_of_constraints",
       FT_UINT8, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_tspec_tsconst_start_time,
      {"TS Constraint Start Time", "wlan.dmg_tspec.tsconst.start_time",
       FT_UINT32, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_tspec_tsconst_duration,
      {"TS Constraint Duration", "wlan.dmg_tspec.tsconst.duration",
       FT_UINT16, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_tspec_tsconst_period,
      {"TS Constraint Period", "wlan.dmg_tspec.tsconst.period",
       FT_UINT16, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_tspec_tsconst_interferer_mac,
      {"TS Constraint Interferer MAC Address", "wlan.dmg_tspec.tsconst.interferer_mac",
       FT_ETHER, BASE_NONE, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_channel_measurement_feedback_relative_I,
      {"Channel Measurement Feedback Relative I", "wlan.ch_meas_fb.relative_I",
       FT_UINT8, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_channel_measurement_feedback_relative_Q,
      {"Channel Measurement Feedback Relative Q", "wlan.ch_meas_fb.relative_Q",
       FT_UINT8, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_channel_measurement_feedback_tap_delay,
      {"Channel Measurement Feedback Tap Delay", "wlan.ch_meas_fb.tap_delay",
       FT_UINT8, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_channel_measurement_feedback_sector_id,
      {"Channel Measurement Feedback Sector ID", "wlan.ch_meas_fb.sector_id",
       FT_UINT8, BASE_DEC, NULL, 0xfc,
       NULL, HFILL }},

    {&hf_ieee80211_tag_channel_measurement_feedback_antenna_id,
      {"Channel Measurement Feedback Antenna ID", "wlan.ch_meas_fb.antenna_id",
       FT_UINT8, BASE_DEC, NULL, 0x03,
       NULL, HFILL }},

    {&hf_ieee80211_tag_awake_window,
      {"Awake Window", "wlan.awake_window",
       FT_UINT16, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_addba_ext_no_frag,
      {"ADDBA No Fragmentation", "wlan.addba.no_frag",
       FT_BOOLEAN, 8, NULL, 0x01,
       NULL, HFILL }},

    {&hf_ieee80211_tag_addba_ext_he_fragmentation_operation,
      {"ADDBA HE Fragmentation Operation", "wlan.addba.he_frag_oper",
       FT_UINT8, BASE_HEX, NULL, 0x06,
       NULL, HFILL }},

    {&hf_ieee80211_tag_addba_ext_reserved,
      {"Reserved", "wlan.addba.reserved",
       FT_UINT8, BASE_HEX, NULL, 0xF8,
       NULL, HFILL }},

    {&hf_ieee80211_tag_addba_ext_buffer_size,
     {"Extended Buffer Size", "wlan.addba.extended_buffer_size",
      FT_UINT8, BASE_DEC, NULL, 0xE0, NULL, HFILL }},

    {&hf_ieee80211_tag_multi_band_ctrl_sta_role,
      {"STA Rold", "wlan.multi_band.ctrl_sta_role",
       FT_UINT8, BASE_DEC, NULL, 0xe0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_multi_band_ctrl_addr_present,
      {"STA MAC Address Present", "wlan.multi_band.ctrl_addr_present",
       FT_BOOLEAN, 8, NULL, 0x10,
       NULL, HFILL }},

    {&hf_ieee80211_tag_multi_band_ctrl_cipher_present,
      {"PCS Present", "wlan.multi_band.ctrl_cipher_present",
       FT_BOOLEAN, 8, NULL, 0x08,
       NULL, HFILL }},

    {&hf_ieee80211_tag_multi_band_oper_class,
      {"Operating Class", "wlan.multi_band.oper_class",
       FT_UINT8, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_multi_band_channel_number,
      {"Channel Number", "wlan.multi_band.channel_number",
       FT_UINT8, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_multi_band_tsf_offset,
      {"TSF Offset", "wlan.multi_band.tsf_offset",
       FT_UINT64, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_multi_band_conn_ap,
      {"Connection Capability AP", "wlan.multi_band.conn_ap",
       FT_BOOLEAN, 8, NULL, 0x80,
       NULL, HFILL }},

    {&hf_ieee80211_tag_multi_band_conn_pcp,
      {"Connection Capability PCP", "wlan.multi_band.conn_pcp",
       FT_BOOLEAN, 8, NULL, 0x40,
       NULL, HFILL }},

    {&hf_ieee80211_tag_multi_band_conn_dls,
      {"Connection Capability DLS", "wlan.multi_band.conn_dls",
       FT_BOOLEAN, 8, NULL, 0x20,
       NULL, HFILL }},

    {&hf_ieee80211_tag_multi_band_conn_tdls,
      {"Connection Capability TDLS", "wlan.multi_band.conn_tdls",
       FT_BOOLEAN, 8, NULL, 0x10,
       NULL, HFILL }},

    {&hf_ieee80211_tag_multi_band_conn_ibss,
      {"Connection Capability IBSS", "wlan.multi_band.conn_ibss",
       FT_BOOLEAN, 8, NULL, 0x08,
       NULL, HFILL }},

    {&hf_ieee80211_tag_multi_band_fst_timeout,
      {"FST Session Timeout", "wlan.multi_band.fst_timeout",
       FT_UINT8, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_multi_band_sta_mac,
      {"Transmitting STA MAC Address", "wlan.multi_band.sta_mac",
       FT_ETHER, BASE_NONE, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_activity,
      {"Activity", "wlan.activity",
       FT_UINT8, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_dmg_link_adapt_mcs,
      {"MCS", "wlan.dmg_link_adapt.mcs",
       FT_UINT8, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_dmg_link_adapt_link_margin,
      {"Link Margin", "wlan.dmg_link_adapt.link_margin",
       FT_UINT8, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_ref_timestamp,
      {"Reference Timestamp", "wlan.ref_timestamp",
       FT_UINT32, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_switching_stream_non_qos,
      {"Non-Qos Data Frames", "wlan.switching_stream.non_qos",
       FT_BOOLEAN, BASE_NONE, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_switching_stream_param_num,
      {"Number Of Switching Stream Elements", "wlan.switching_stream.param_num",
       FT_UINT8, BASE_DEC, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_tag_switching_stream_old_tid,
      {"Old Band TID", "wlan.switching_stream.old_tid",
       FT_UINT16, BASE_DEC, NULL, 0xf000,
       NULL, HFILL }},

    {&hf_ieee80211_tag_switching_stream_old_direction,
      {"Old Band Direction", "wlan.switching_stream.old_direction",
       FT_BOOLEAN, 16, NULL, 0x0800,
       NULL, HFILL }},

    {&hf_ieee80211_tag_switching_stream_new_tid,
      {"New Band TID", "wlan.switching_stream.new_tid",
       FT_UINT16, BASE_DEC, NULL, 0x0780,
       NULL, HFILL }},

    {&hf_ieee80211_tag_switching_stream_new_direction,
      {"New Band Direction", "wlan.switching_stream.new_direction",
       FT_BOOLEAN, 16, NULL, 0x0040,
       NULL, HFILL }},

    {&hf_ieee80211_tag_switching_stream_new_valid_id,
      {"Stream ID in New Band Valid", "wlan.switching_stream.new_valid_id",
       FT_BOOLEAN, 16, NULL, 0x0020,
       NULL, HFILL }},

    {&hf_ieee80211_tag_switching_stream_llt_type,
      {"LLT Type", "wlan.switching_stream.llt_type",
       FT_BOOLEAN, 16, NULL, 0x0010,
       NULL, HFILL }},

    {&hf_ieee80211_ff_timestamp,
     {"Timestamp", "wlan.fixed.timestamp",
      FT_UINT64, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_auth_alg,
     {"Authentication Algorithm", "wlan.fixed.auth.alg",
      FT_UINT16, BASE_DEC, VALS(auth_alg), 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_beacon_interval,
     {"Beacon Interval", "wlan.fixed.beacon",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(beacon_interval_base_custom), 0,
      NULL, HFILL }},

    {&hf_ieee80211_fixed_parameters,
     {"Fixed parameters", "wlan.fixed.all",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tagged_parameters,
     {"Tagged parameters", "wlan.tagged.all",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ssid,
     {"SSID", "wlan.ssid",
      FT_BYTES, BASE_SHOW_UTF_8_PRINTABLE, NULL, 0,
      "Indicates the identity of an ESS or IBSS", HFILL }},

    {&hf_ieee80211_tag_supp_rates,
     {"Supported Rates", "wlan.supported_rates",
      FT_UINT8, BASE_HEX|BASE_EXT_STRING, &ieee80211_supported_rates_vals_ext, 0x0,
      "In Mbit/sec, (B) for Basic Rates", HFILL }},

    {&hf_ieee80211_tag_fh_dwell_time,
     {"Dwell Time", "wlan.fh.dwell_time",
      FT_UINT16, BASE_HEX, NULL, 0x0,
      "In Time Unit (TU)", HFILL }},

    {&hf_ieee80211_tag_fh_hop_set,
     {"Hop Set", "wlan.fh.hop_set",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_fh_hop_pattern,
     {"Hop Pattern", "wlan.fh.hop_pattern",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_fh_hop_index,
     {"Hop Index", "wlan.fh.hop_index",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_block_ack_params,
     {"Block Ack Parameters", "wlan.fixed.baparams",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_block_ack_params_amsdu_permitted,
     {"A-MSDUs", "wlan.fixed.baparams.amsdu",
      FT_BOOLEAN, 16, TFS(&ff_block_ack_params_amsdu_permitted_flag), 0x0001,
      "A-MSDU Permitted in QoS Data MPDUs", HFILL }},

    {&hf_ieee80211_ff_block_ack_params_policy,
     {"Block Ack Policy", "wlan.fixed.baparams.policy",
      FT_BOOLEAN, 16, TFS(&ff_block_ack_params_policy_flag), 0x0002,
      NULL, HFILL }},

    {&hf_ieee80211_ff_block_ack_params_tid,
     {"Traffic Identifier", "wlan.fixed.baparams.tid",
      FT_UINT16, BASE_HEX, NULL, 0x003C,
      NULL, HFILL }},

    {&hf_ieee80211_ff_block_ack_params_buffer_size,
     {"Number of Buffers (1 Buffer = 2304 Bytes)", "wlan.fixed.baparams.buffersize",
      FT_UINT16, BASE_DEC, NULL, 0xFFC0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_block_ack_timeout,
     {"Block Ack Timeout", "wlan.fixed.batimeout",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_block_ack_ssc,
     {"Block Ack Starting Sequence Control (SSC)", "wlan.fixed.ssc",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_block_ack_ssc_fragment,
     {"Fragment", "wlan.fixed.ssc.fragment",
      FT_UINT16, BASE_DEC, NULL, 0x000f,
      NULL, HFILL }},

    {&hf_ieee80211_ff_block_ack_ssc_sequence,
     {"Starting Sequence Number", "wlan.fixed.ssc.sequence",
      FT_UINT16, BASE_DEC, NULL, 0xfff0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_delba_param,
     {"Delete Block Ack (DELBA) Parameter Set", "wlan.fixed.delba.param",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_delba_param_reserved,
     {"Reserved", "wlan.fixed.delba.param.reserved",
      FT_UINT16, BASE_HEX, NULL, 0x07ff,
      NULL, HFILL }},

    {&hf_ieee80211_ff_delba_param_init,
     {"Initiator", "wlan.fixed.delba.param.initiator",
      FT_BOOLEAN, 16, NULL, 0x0800,
      NULL, HFILL }},

    {&hf_ieee80211_ff_delba_param_tid,
     {"TID", "wlan.fixed.delba.param.tid",
      FT_UINT16, BASE_HEX, NULL, 0xf000,
      "Traffic Identifier (TID)", HFILL }},

    {&hf_ieee80211_ff_max_reg_pwr,
     {"Maximum Regulation Power", "wlan.fixed.maxregpwr",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_measurement_pilot_int,
     {"Measurement Pilot Interval", "wlan.fixed.msmtpilotint",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Measurement Pilot Interval Fixed Field (in TUs)", HFILL }},

    {&hf_ieee80211_ff_country_str,
     {"Country String", "wlan.fixed.country",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_max_tx_pwr,
     {"Maximum Transmit Power", "wlan.fixed.maxtxpwr",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_tx_pwr_used,
     {"Transmit Power Used", "wlan.fixed.txpwr",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_transceiver_noise_floor,
     {"Transceiver Noise Floor", "wlan.fixed.tnoisefloor",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_channel_width,
     {"Supported Channel Width", "wlan.fixed.chanwidth",
      FT_UINT8, BASE_HEX, VALS(ff_channel_width_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_qos_info_ap,
     {"QoS Information (AP)", "wlan.fixed.qosinfo.ap",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_qos_info_ap_edca_param_set_counter,
     {"EDCA Parameter Set Update Count", "wlan.fixed.qosinfo.ap.edcaupdate",
      FT_UINT8, BASE_HEX, NULL, 0x0F,
      "Enhanced Distributed Channel Access (EDCA) Parameter Set Update Count", HFILL }},

    {&hf_ieee80211_ff_qos_info_ap_q_ack,
     {"Q-Ack", "wlan.fixed.qosinfo.ap.qack",
      FT_BOOLEAN, 8, TFS(&ff_qos_info_ap_q_ack_flag), 0x10,
      "QoS Ack", HFILL }},

    {&hf_ieee80211_ff_qos_info_ap_queue_req,
     {"Queue Request", "wlan.fixed.qosinfo.ap.queue_req",
      FT_BOOLEAN, 8, TFS(&ff_qos_info_ap_queue_req_flag), 0x20,
      NULL, HFILL }},

    {&hf_ieee80211_ff_qos_info_ap_txop_request,
     {"TXOP Request", "wlan.fixed.qosinfo.ap.txopreq",
      FT_BOOLEAN, 8, TFS(&ff_qos_info_ap_txop_request_flag), 0x40,
      "Transmit Opportunity (TXOP) Request", HFILL }},

    {&hf_ieee80211_ff_qos_info_ap_more_data_ack,
     {"More Data Ack", "wlan.fixed.qosinfo.ap.more_data_ack",
      FT_BOOLEAN, 8, NULL, 0x80,
      NULL, HFILL }},

    {&hf_ieee80211_ff_qos_info_sta,
     {"QoS Information (STA)", "wlan.fixed.qosinfo.sta",
      FT_UINT8, BASE_HEX, NULL, 0,
      "TCLAS Processing", HFILL }},

    {&hf_ieee80211_ff_qos_info_sta_ac_vo,
     {"AC_VO U-APSD Flag", "wlan.fixed.qosinfo.sta.ac_vo",
      FT_BOOLEAN, 8, TFS(&ff_qos_info_sta_ac_flag), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_ff_qos_info_sta_ac_vi,
     {"AC_VI U-APSD Flag", "wlan.fixed.qosinfo.sta.ac_vi",
      FT_BOOLEAN, 8, TFS(&ff_qos_info_sta_ac_flag), 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_ff_qos_info_sta_ac_bk,
     {"AC_BK U-APSD Flag", "wlan.fixed.qosinfo.sta.ac_bk",
      FT_BOOLEAN, 8, TFS(&ff_qos_info_sta_ac_flag), 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_ff_qos_info_sta_ac_be,
     {"AC_BE U-APSD Flag", "wlan.fixed.qosinfo.sta.ac_be",
      FT_BOOLEAN, 8, TFS(&ff_qos_info_sta_ac_flag), 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_ff_qos_info_sta_q_ack,
     {"Q-Ack", "wlan.fixed.qosinfo.sta.qack",
      FT_BOOLEAN, 8, TFS(&ff_qos_info_sta_q_ack_flag), 0x10,
      "QoS Ack", HFILL }},

    {&hf_ieee80211_ff_qos_info_sta_max_sp_length,
     {"Max SP Length", "wlan.fixed.qosinfo.sta.max_sp_length",
      FT_UINT8, BASE_HEX, VALS(ff_qos_info_sta_max_sp_len_flags) , 0x60,
      NULL, HFILL }},

    {&hf_ieee80211_ff_qos_info_sta_more_data_ack,
     {"More Data Ack", "wlan.fixed.qosinfo.sta.more_data_ack",
      FT_BOOLEAN, 8, TFS(&ff_qos_info_sta_more_data_ack_flag), 0x80,
      NULL, HFILL }},

    {&hf_ieee80211_ff_sm_pwr_save,
     {"Spatial Multiplexing (SM) Power Control", "wlan.fixed.sm.powercontrol",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_sm_pwr_save_enabled,
     {"SM Power Save", "wlan.fixed.sm.powercontrol.enabled",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x01,
      "Spatial Multiplexing (SM) Power Save", HFILL }},

    {&hf_ieee80211_ff_sm_pwr_save_sm_mode,
     {"SM Mode", "wlan.fixed.sm.powercontrol.mode",
      FT_BOOLEAN, 8, TFS(&ff_sm_pwr_save_sm_mode_flag), 0x02,
      "Spatial Multiplexing (SM) Mode", HFILL }},

    {&hf_ieee80211_ff_sm_pwr_save_reserved,
     {"Reserved", "wlan.fixed.sm.powercontrol.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xFC,
      NULL, HFILL }},

    {&hf_ieee80211_ff_pco_phase_cntrl,
     {"Phased Coexistence Operation (PCO) Phase Control", "wlan.fixed.pco.phasecntrl",
      FT_BOOLEAN, BASE_NONE, TFS(&ff_pco_phase_cntrl_flag), 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_psmp_param_set,
     {"Power Save Multi-Poll (PSMP) Parameter Set", "wlan.fixed.psmp.paramset",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_psmp_param_set_n_sta,
     {"Number of STA Info Fields Present", "wlan.fixed.psmp.paramset.nsta",
      FT_UINT16, BASE_HEX, NULL, 0x000F,
      NULL, HFILL }},

    {&hf_ieee80211_ff_psmp_param_set_more_psmp,
     {"More PSMP", "wlan.fixed.psmp.paramset.more",
      FT_BOOLEAN, 16, TFS(&ff_psmp_param_set_more_psmp_flag), 0x0010,
      "More Power Save Multi-Poll (PSMP)", HFILL }},

    {&hf_ieee80211_ff_psmp_param_set_psmp_sequence_duration,
     {"PSMP Sequence Duration [us]", "wlan.fixed.psmp.paramset.seqduration",
      FT_UINT16, BASE_DEC, NULL, 0xFFE0,
      "Power Save Multi-Poll (PSMP) Sequence Duration", HFILL }},

    {&hf_ieee80211_ff_mimo_cntrl,
     {"MIMO Control", "wlan.fixed.mimo.control",
      FT_BYTES, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_mimo_cntrl_nc_index,
     {"Nc Index", "wlan.fixed.mimo.control.ncindex",
      FT_UINT16, BASE_HEX, VALS(ff_mimo_cntrl_nc_index_flags), 0x0003,
      "Number of Columns Less One", HFILL }},

    {&hf_ieee80211_ff_mimo_cntrl_nr_index,
     {"Nr Index", "wlan.fixed.mimo.control.nrindex",
      FT_UINT16, BASE_HEX, VALS(ff_mimo_cntrl_nr_index_flags), 0x000C,
      "Number of Rows Less One", HFILL }},

    {&hf_ieee80211_ff_mimo_cntrl_channel_width,
     {"Channel Width", "wlan.fixed.mimo.control.chanwidth",
      FT_BOOLEAN, 16, TFS(&ff_mimo_cntrl_channel_width_flag), 0x0010,
      NULL, HFILL }},

    {&hf_ieee80211_ff_mimo_cntrl_grouping,
     {"Grouping (Ng)", "wlan.fixed.mimo.control.grouping",
      FT_UINT16, BASE_HEX, VALS(ff_mimo_cntrl_grouping_flags), 0x0060,
      NULL, HFILL }},

    {&hf_ieee80211_ff_mimo_cntrl_coefficient_size,
     {"Coefficient Size (Nb)", "wlan.fixed.mimo.control.cosize",
      FT_UINT16, BASE_HEX, VALS(ff_mimo_cntrl_coefficient_size_flags), 0x0180,
      NULL, HFILL }},

    {&hf_ieee80211_ff_mimo_cntrl_codebook_info,
     {"Codebook Information", "wlan.fixed.mimo.control.codebookinfo",
      FT_UINT16, BASE_HEX, VALS(ff_mimo_cntrl_codebook_info_flags), 0x0600,
      NULL, HFILL }},

    {&hf_ieee80211_ff_mimo_cntrl_remaining_matrix_segment,
     {"Remaining Matrix Segment", "wlan.fixed.mimo.control.matrixseg",
      FT_UINT16, BASE_HEX, NULL, 0x3800,
      NULL, HFILL }},

    {&hf_ieee80211_ff_mimo_cntrl_reserved,
     {"Reserved", "wlan.fixed.mimo.control.reserved",
      FT_UINT16, BASE_HEX, NULL, 0xC000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_mimo_cntrl_sounding_timestamp,
     {"Sounding Timestamp", "wlan.fixed.mimo.control.soundingtime",
      FT_UINT32, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_param_delim1,
     {"FTM Params (Subset 1 of 3)", "wlan.fixed.ftm.param.delim1",
      FT_UINT16, BASE_HEX, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_param_status_indication,
     {"Status Indication", "wlan.fixed.ftm.param.status_indication",
      FT_UINT16, BASE_HEX, NULL, 0x0003,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_param_value,
     {"Value", "wlan.fixed.ftm.param.value",
      FT_UINT16, BASE_HEX, NULL, 0x007C,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_param_reserved1,
     {"Reserved1", "wlan.fixed.ftm.param.reserved1",
      FT_UINT16, BASE_HEX, NULL, 0x0080,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_param_burst_exponent,
     {"Number of Burst Exponent", "wlan.fixed.ftm.param.burst_exponent",
      FT_UINT16, BASE_HEX, NULL, 0x0F00,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_param_burst_duration,
     {"Burst Duration", "wlan.fixed.ftm.param.burst_duration",
      FT_UINT16, BASE_HEX, NULL, 0xF000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_param_delim2,
     {"FTM Params (Subset 2 of 3)", "wlan.fixed.ftm.param.delim2",
      FT_UINT32, BASE_HEX, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_param_min_delta_ftm,
     {"Min Delta FTM", "wlan.fixed.ftm.param.min_delta_ftm",
      FT_UINT32, BASE_HEX, NULL, 0x000000FF,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_param_partial_tsf_timer,
     {"Partial TSF timer", "wlan.fixed.ftm.param.partial_tsf_timer",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(partial_tsf_custom), 0x00FFFF00,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_param_partial_tsf_no_pref,
     {"Partial TSF no pref", "wlan.fixed.ftm.param.partial_tsf_no_pref",
      FT_UINT32, BASE_HEX, NULL, 0x01000000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_param_asap_capable,
     {"ASAP Capable", "wlan.fixed.ftm.param.asap_capable",
      FT_UINT32, BASE_HEX, NULL, 0x02000000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_param_asap,
     {"ASAP", "wlan.fixed.ftm.param.asap",
      FT_UINT32, BASE_HEX, NULL, 0x04000000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_param_ftm_per_burst,
     {"FTM per burst", "wlan.fixed.ftm.param.ftm_per_burst",
      FT_UINT32, BASE_HEX, NULL, 0xF8000000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_param_delim3,
     {"FTM Params (Subset 3 of 3)", "wlan.fixed.ftm.param.delim3",
      FT_UINT24, BASE_HEX, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_param_reserved2,
     {"Reserved2", "wlan.fixed.ftm.param.reserved2",
      FT_UINT24, BASE_HEX, NULL, 0x000003,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_param_format_and_bw,
     {"Format and Bandwidth", "wlan.fixed.ftm.param.format_and_bw",
      FT_UINT24, BASE_HEX, NULL, 0x0000FC,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_param_burst_period,
     {"Burst Period", "wlan.fixed.ftm.param.burst_period",
      FT_UINT24, BASE_HEX, NULL, 0xFFFF00,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_tod_err1,
     {"FTM TOD Error", "wlan.fixed.ftm.tod_error",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Management action FTM LMR TOD Error", HFILL }},

    /* az: Ranging Parameters element */

    {&hf_ieee80211_tag_ranging_parameters,
     {"Ranging Parameters", "wlan.ranging",
      FT_UINT56, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_subelt_tag,
     {"Subelement Tag", "wlan.tag.ranging.subelt_tag",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_subelt_len,
     {"Subelement Len", "wlan.tag.ranging.subelt_len",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_status_indication,
     {"Status Indication", "wlan.ranging.status",
      FT_UINT56, BASE_DEC | BASE_VAL64_STRING, VALS64(ieee80211_ranging_status_vals), GENMASK(1, 0),
      "Status Indication", HFILL }},

    {&hf_ieee80211_tag_ranging_value,
     {"Value", "wlan.ranging.value",
      FT_UINT56, BASE_DEC, NULL, GENMASK(6, 2),
      "When Status Indication is 3, the Value field contains a duration in units of seconds", HFILL }},

    {&hf_ieee80211_tag_ranging_i2r_lmr_feedback,
     {"I2R LMR Feedback", "wlan.ranging.i2r_lmr_feedback",
      FT_UINT56, BASE_DEC, NULL, GENMASK(7, 7),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_secure_ltf_required,
     {"Secure LTF Required", "wlan.ranging.secure_ltf_required",
      FT_UINT56, BASE_DEC, NULL, GENMASK(8, 8),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_secure_ltf_support,
     {"Secure LTF Support", "wlan.ranging.secure_ltf_support",
      FT_UINT56, BASE_DEC, NULL, GENMASK(9, 9),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_ranging_priority,
     {"Ranging Priority", "wlan.ranging.priority",
      FT_UINT56, BASE_DEC, NULL, GENMASK(11, 10),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_r2i_toa_type,
     {"R2I TOA Type", "wlan.ranging.r2i_toa_type",
      FT_UINT56, BASE_DEC, NULL, GENMASK(12, 12),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_i2r_toa_type,
     {"I2R TOA Type", "wlan.ranging.i2r_toa_type",
      FT_UINT56, BASE_DEC, NULL, GENMASK(13, 13),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_r2i_aoa_requested,
     {"R2I AOA Requested", "wlan.ranging.r2i_aoa_requested",
      FT_UINT56, BASE_DEC, NULL, GENMASK(14, 14),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_i2r_aoa_requested,
     {"I2R AOA Requested", "wlan.ranging.i2r_aoa_requested",
      FT_UINT56, BASE_DEC, NULL, GENMASK(15, 15),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_format_and_bandwidth,
     {"Format and Bandwidth", "wlan.ranging.format_and_bandwidth",
      FT_UINT56, BASE_DEC | BASE_VAL64_STRING, VALS64(ieee80211_ranging_fmt_bw_vals), GENMASK(21, 16),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_immediate_r2i_feedback,
     {"Immediate R2I Feedback", "wlan.ranging.immediate_r2i_feedback",
      FT_UINT56, BASE_DEC, NULL, GENMASK(22, 22),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_immediate_i2r_feedback,
     {"Immediate I2R Feedback", "wlan.ranging.immediate_i2r_feedback",
      FT_UINT56, BASE_DEC, NULL, GENMASK(23, 23),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_max_i2r_repetition,
     {"Max I2R Repetition", "wlan.ranging.max_i2r_repetition",
      FT_UINT56, BASE_CUSTOM, CF_FUNC(rep_custom), GENMASK(26, 24),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_max_r2i_repetition,
     {"Max R2I Repetition", "wlan.ranging.max_r2i_repetition",
      FT_UINT56, BASE_CUSTOM, CF_FUNC(rep_custom), GENMASK(29, 27),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_reserved1,
     {"Reserved", "wlan.ranging.reserved1",
      FT_UINT56, BASE_DEC, NULL, GENMASK(30, 30),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_reserved2,
     {"Reserved", "wlan.ranging.reserved2",
      FT_UINT56, BASE_DEC, NULL, GENMASK(31, 31),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_max_r2i_sts_le_80_mhz,
     {"Max R2I STS <= 80 MHz", "wlan.ranging.max_r2i_sts_le_80_mhz",
      FT_UINT56, BASE_CUSTOM, CF_FUNC(sts_custom), GENMASK64(34, 32),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_max_r2i_sts_gt_80_mhz,
     {"Max R2I STS > 80 MHz", "wlan.ranging.max_r2i_sts_gt_80_mhz",
      FT_UINT56, BASE_CUSTOM, CF_FUNC(sts_custom), GENMASK64(37, 35),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_max_r2i_ltf_total,
     {"Max R2I LTF Total", "wlan.ranging.max_r2i_ltf_total",
      FT_UINT56, BASE_DEC | BASE_VAL64_STRING, VALS64(ieee80211_ranging_ltf_total_vals), GENMASK64(39, 38),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_max_i2r_ltf_total,
     {"Max I2R LTF Total", "wlan.ranging.max_i2r_ltf_total",
      FT_UINT56, BASE_DEC | BASE_VAL64_STRING, VALS64(ieee80211_ranging_ltf_total_vals), GENMASK64(41, 40),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_max_i2r_sts_le_80_mhz,
     {"Max I2R STS <= 80 MHz", "wlan.ranging.max_i2r_sts_le_80_mhz",
      FT_UINT56, BASE_CUSTOM, CF_FUNC(sts_custom), GENMASK64(44, 42),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_max_i2r_sts_gt_80_mhz,
     {"Max I2R STS > 80 MHz", "wlan.ranging.max_i2r_sts_gt_80_mhz",
      FT_UINT56, BASE_CUSTOM, CF_FUNC(sts_custom), GENMASK64(47, 45),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_bss_color_info,
     {"BSS Color Information",
      "wlan.tag.ftm.param.ranging.bss_color_information",
      FT_UINT56, BASE_HEX, NULL, GENMASK64(55, 48), NULL, HFILL }},

    /* az: non-TB-specific subelement */

    {&hf_ieee80211_tag_ranging_ntb,
     {"Non-TB specific subelement", "wlan.ranging.ntb",
      FT_UINT48, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_ntb_reserved1,
     {"Reserved", "wlan.ranging.ntb.reserved1",
      FT_UINT48, BASE_DEC, NULL, GENMASK(0, 0),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_ntb_min_time_msmts,
     {"Min Time Between Measurements", "wlan.ranging.ntb.min_time",
      FT_UINT48, BASE_DEC | BASE_UNIT_STRING, UNS(&units_100_us), GENMASK(23, 1),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_ntb_max_time_msmts,
     {"Max Time Between Measurements", "wlan.ranging.ntb.max_time",
      FT_UINT48, BASE_DEC | BASE_UNIT_STRING, UNS(&units_10_ms), GENMASK64(43, 24),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_ntb_r2i_tx_power,
     {"R2I Tx Power", "wlan.ranging.ntb.r2i_tx_power",
      FT_UINT48, BASE_DEC, NULL, GENMASK64(44, 44),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_ntb_i2r_tx_power,
     {"I2R Tx Power", "wlan.ranging.ntb.i2r_tx_power",
      FT_UINT48, BASE_DEC, NULL, GENMASK64(45, 45),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_ntb_reserved2,
     {"Reserved", "wlan.ranging.ntb.reserved2",
      FT_UINT48, BASE_HEX, NULL, GENMASK64(47, 46),
      NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_aid_rsid,
     {"AID/RSID", "wlan.ranging.tb.aid_rsid",
      FT_UINT32, BASE_HEX, NULL, 0x0000ffff, NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_device_class,
     {"Device Class", "wlan.tb.device_class",
      FT_UINT32, BASE_DEC, NULL, 0x00010000, NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_full_bw_ul_mu_mimo,
     {"Full Bandwidth UL MU-MIMO", "wlan.tb.full_bw_ul_mu_mimo",
      FT_UINT32, BASE_DEC, NULL, 0x00020000, NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_trigger_frame_paddur,
     {"Trigger Frame Padding Duration",
      "wlan.ranging.tb.trigger_frame_padding_duration",
      FT_BOOLEAN, 32, NULL, 0x000C0000, NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_max_sess_exp,
     {"Max Session Exp", "wlan.ranging.tb.max_session.exp",
      FT_UINT32, BASE_DEC, NULL, 0x00f00000, NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_passive_tb_ranging,
     {"Passive TB Ranging", "wlan.ftm.tb_specific.passive_tb_ranging",
      FT_BOOLEAN, 32, NULL, 0x01000000, NULL, HFILL }},

    {&hf_ieee80211_tag_ranging_tb_specific_reserved,
     {"Reserved", "wlan.ftm.tb_specific.reserved",
      FT_UINT32, BASE_HEX, NULL, 0xFE000000, NULL, HFILL }},

    {&hf_ieee80211_tag_dirn_meas_results_aoa_results,
     {"AOA Results", "wlan.etag.direction_measurement_results.aoa_results",
      FT_UINT48, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_tag_ftm_aoa_results_aoa_azimuth,
     {"AOA Azimuth", "wlan.etag.direction_measurement_results.aoa_azimuth",
      FT_UINT48, BASE_CUSTOM, CF_FUNC(aoa_azimuth_custom),
      0x0000000007ff, NULL, HFILL }},

    {&hf_ieee80211_tag_ftm_aoa_results_aoa_elevation,
     {"AOA Elevation", "wlan.etag.direction_measurement_results.aoa_elevation",
      FT_UINT48, BASE_CUSTOM, CF_FUNC(aoa_elevation_custom),
      0x0000001ff800, NULL, HFILL }},

    {&hf_ieee80211_tag_ftm_aoa_results_aoa_azimuth_accuracy,
     {"AOA Azimuth Accuracy",
      "wlan.etag.direction_measurement_results.aoa_azimuth_accuracy",
      FT_UINT48, BASE_CUSTOM, CF_FUNC(aoa_accuracy_custom),
      0x00000fe00000, NULL, HFILL }},

    {&hf_ieee80211_tag_ftm_aoa_results_aoa_elevation_accuracy,
     {"AOA Elevation Accuracy",
      "wlan.etag.direction_measurement_results.aoa_elevation_accuracy",
      FT_UINT48, BASE_CUSTOM, CF_FUNC(aoa_accuracy_custom),
      0x0007f0000000, NULL, HFILL }},

    {&hf_ieee80211_tag_ftm_aoa_results_best_awv_id,
     {"Best AWV ID", "wlan.etag.direction_measurement_results.best_awv_id",
      FT_UINT48, BASE_DEC, NULL, 0x3ff800000000, NULL, HFILL }},

    {&hf_ieee80211_tag_ftm_aoa_results_aoa_reference,
     {"AOA Reference", "wlan.etag.direction_measurement_results.aoa_reference",
      FT_BOOLEAN, 48, TFS(&aoa_reference_tfs), 0x400000000000, NULL, HFILL }},

    {&hf_ieee80211_tag_ftm_aoa_results_reserved,
     {"Reserved", "wlan.etag.direction_measurement_results.reserved",
      FT_UINT48, BASE_DEC, NULL, 0x800000000000, NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_max_tod_error_exponent,
     {"Max TOD Error Exponent", "wlan.fixed.ftm.max_tod_error_exponent",
      FT_UINT8, BASE_DEC, NULL, GENMASK(4, 0), NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_tod_err_reserved,
     {"Reserved", "wlan.fixed.ftm.tod_reserved",
      FT_UINT8, BASE_HEX, NULL, GENMASK(6, 5), NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_tod_not_continuous,
     {"TOD Not Continuous", "wlan.fixed.ftm.tod_not_continuous",
      FT_BOOLEAN, 8, NULL, GENMASK(7, 7), NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_toa_err1,
     {"FTM TOA Error", "wlan.fixed.ftm_toa_err",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Management action FTM LMR TOA Error", HFILL }},

    {&hf_ieee80211_ff_ftm_max_toa_error_exponent,
     {"Max TOA Error Exponent", "wlan.fixed.ftm_max_toa_error_exponent",
      FT_UINT8, BASE_DEC, NULL, GENMASK(4, 0), NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_toa_err_reserved,
     {"Reserved", "wlan.fixed.ftm_toa_reserved",
      FT_UINT8, BASE_HEX, NULL, GENMASK(5, 5), NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_invalid_measurement,
     {"Invalid Measurement", "wlan.fixed.ftm_invalid_measurement",
      FT_BOOLEAN, 8, NULL, GENMASK(6, 6), NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_toa_type,
     {"TOA Type", "wlan.fixed.ftm_toa_type",
      FT_UINT8, BASE_DEC, NULL, GENMASK(7, 7), NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_cfo,
     {"CFO", "wlan.fixed.ftm.param.cfo",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_r2i_ndp_tx_power,
     {"R2I NDP Tx Power", "wlan.fixed.ftm.param.r2i_ndp_tx_power",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ftm_i2r_ndp_target_rssi,
     {"I2R NDP Target RSSI", "wlan.fixed.ftm.param.i2r_ndp_target_rssi",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_secure_ltf_params_counter,
     {"Secure LTF Counter", "wlan.etag.secure_ltf_params.secure_ltf_counter",
      FT_UINT48, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_tag_secure_ltf_generation_sac,
     {"LTF Generation SAC", "wlan.etag.secure_ltf_params.ltf_generation_sac",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_tag_secure_ltf_management_sac,
     {"Ranging Management SAC",
      "wlan.etag.secure_ltf_params.ranging_management_sac",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_tag_secure_ltf_result_ltf_ofs,
     {"Measurement Result LTF Offset",
      "wlan.etag.secure_ltf_params.measurement_result_ltf_offset",
     FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_ftm_ista_availability_count,
     {"ISTA Availability Count", "wlan.ranging.ista.availability_count",
      FT_UINT16, BASE_DEC, NULL, 0x01FF, NULL, HFILL }},

    {&hf_ieee80211_ftm_ista_availability_reserved,
     {"Reserved", "wlan.ranging.ista.availability_reserved",
      FT_UINT16, BASE_HEX, NULL, 0xFE00, NULL, HFILL }},

    {&hf_ieee80211_ftm_ista_avail_bits,
     {"ISTA Availability", "wlan.ranging.ista.availability_bits",
      FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_ftm_ista_avail_pad,
     {"Padding", "wlan.ranging.ista.availability_pad",
      FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_ftm_rsta_header,
     {"Header", "wlan.ftm.rsta.header",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_ftm_rsta_count,
     {"RSTA Count", "wlan.ranging.rsta.count",
      FT_UINT8, BASE_HEX, NULL, 0x7F, NULL, HFILL }},

    {&hf_ieee80211_ftm_rsta_avail_window_bcast_fmt,
     {"Availability Window Broadcast Format",
      "wlan.ftm.rsta.availability_window_broadcast_format",
      FT_UINT8, BASE_HEX, NULL, 0x80, NULL, HFILL }},

    {&hf_ieee80211_ftm_rsta_partial_tsf_timer1,
     {"Partial TSF Timer", "wlan.ranging.rsta.partial_tsf_timer",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(partial_tsf_custom), 0x0000ffff, NULL, HFILL }},

    {&hf_ieee80211_ftm_rsta_duration1,
     {"Duration", "wlan.ranging.rsta.duration",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(hundred_us_base_custom), 0x7f0000, NULL, HFILL }},

    {&hf_ieee80211_ftm_rsta_passive_tb_ranging_reserved1,
     {"Reserved", "wlan.ranging.rsta.reserved1",
      FT_BOOLEAN, 32, NULL, 0x00800000, NULL, HFILL }},

    {&hf_ieee80211_ftm_rsta_periodicity1,
     {"Periodicity", "wlan.ranging.rsta.periodicity1",
      FT_UINT32, BASE_DEC, NULL, 0xff000000, NULL, HFILL }},

    {&hf_ieee80211_ftm_rsta_partial_tsf_timer,
     {"Partial TSF Timer", "wlan.ranging.rsta.partial_tsf_timer_long",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(partial_tsf_custom), 0xffff, NULL, HFILL }},

    {&hf_ieee80211_ftm_rsta_duration,
     {"Duration", "wlan.ranging.rsta.duration_long",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(hundred_us_base_custom), 0x7f0000, NULL, HFILL }},

    {&hf_ieee80211_ftm_rsta_passive_tb_ranging_reserved,
     {"Reserved", "wlan.ranging.rsta.reserved",
      FT_BOOLEAN, 40, NULL, 0x0000800000, NULL, HFILL }},

    {&hf_ieee80211_ftm_rsta_periodicity,
     {"Periodicity", "wlan.ranging.rsta.periodicity",
      FT_UINT40, BASE_DEC, NULL, 0x00ff000000, NULL, HFILL }},

    {&hf_ieee80211_ftm_rsta_format_and_bandwidth,
      {"Format and Bandwidth", "wlan.ftm.rsta.format_and_bandwidth",
       FT_UINT40, BASE_HEX, NULL, 0x3F00000000, NULL, HFILL }},

    {&hf_ieee80211_ftm_rsta_reserved,
     {"Reserved", "wlan.ftm.rsta.reserved",
      FT_UINT40, BASE_HEX, NULL, 0xC000000000, NULL, HFILL }},

    {&hf_ieee80211_ftm_rsta_avail_subfield_short,
     {"RSTA Availability Information", "wlan.ranging.rsta.availability_window",
      FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_ftm_rsta_avail_subfield_long,
     {"RSTA Availability Information",
      "wlan.ranging.rsta.availability_window_long",
      FT_UINT40, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_ff_psmp_sta_info,
     {"Power Save Multi-Poll (PSMP) Station Information", "wlan.fixed.psmp.stainfo",
      FT_UINT64, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_psmp_sta_info_type,
     {"Sta Info Type", "wlan.fixed.psmp.stainfo.type",
      FT_UINT32, BASE_HEX, VALS(ff_psmp_sta_info_flags), PSMP_STA_INFO_FLAG_TYPE,
      NULL, HFILL }},

    {&hf_ieee80211_ff_psmp_sta_info_dtt_start_offset,
     {"DTT Start Offset", "wlan.fixed.psmp.stainfo.dttstart",
      FT_UINT32, BASE_HEX, NULL, PSMP_STA_INFO_FLAG_DTT_START,
      NULL, HFILL }},

    {&hf_ieee80211_ff_psmp_sta_info_dtt_duration,
     {"DTT Duration", "wlan.fixed.psmp.stainfo.dttduration",
      FT_UINT32, BASE_HEX, NULL, PSMP_STA_INFO_FLAG_DTT_DURATION,
      NULL, HFILL }},

    {&hf_ieee80211_ff_psmp_sta_info_sta_id,
     {"Target Station ID", "wlan.fixed.psmp.stainfo.staid",
      FT_UINT32, BASE_HEX, NULL, PSMP_STA_INFO_FLAG_STA_ID,
      NULL, HFILL }},

    {&hf_ieee80211_ff_psmp_sta_info_utt_start_offset,
     {"UTT Start Offset", "wlan.fixed.psmp.stainfo.uttstart",
      FT_UINT32, BASE_HEX, NULL, PSMP_STA_INFO_FLAG_UTT_START,
      NULL, HFILL }},

    {&hf_ieee80211_ff_psmp_sta_info_utt_duration,
     {"UTT Duration", "wlan.fixed.psmp.stainfo.uttduration",
      FT_UINT32, BASE_HEX, NULL, PSMP_STA_INFO_FLAG_UTT_DURATION,
      NULL, HFILL }},

    {&hf_ieee80211_ff_psmp_sta_info_reserved_small,
     {"Reserved", "wlan.fixed.psmp.stainfo.reserved",
      FT_UINT32, BASE_HEX, NULL, PSMP_STA_INFO_FLAG_IA_RESERVED,
      NULL, HFILL }},

    {&hf_ieee80211_ff_psmp_sta_info_reserved_large,
     {"Reserved", "wlan.fixed.psmp.stainfo.reserved64",
      FT_UINT64, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_psmp_sta_info_psmp_multicast_id,
     {"Power Save Multi-Poll (PSMP) Multicast ID", "wlan.fixed.psmp.stainfo.multicastid",
      FT_UINT64, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ant_selection,
     {"Antenna Selection", "wlan.fixed.antsel",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ant_selection_0,
     {"Antenna 0", "wlan.fixed.antsel.ant0",
      FT_UINT8, BASE_HEX, NULL, 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ant_selection_1,
     {"Antenna 1", "wlan.fixed.antsel.ant1",
      FT_UINT8, BASE_HEX, NULL, 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ant_selection_2,
     {"Antenna 2", "wlan.fixed.antsel.ant2",
      FT_UINT8, BASE_HEX, NULL, 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ant_selection_3,
     {"Antenna 3", "wlan.fixed.antsel.ant3",
      FT_UINT8, BASE_HEX, NULL, 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ant_selection_4,
     {"Antenna 4", "wlan.fixed.antsel.ant4",
      FT_UINT8, BASE_HEX, NULL, 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ant_selection_5,
     {"Antenna 5", "wlan.fixed.antsel.ant5",
      FT_UINT8, BASE_HEX, NULL, 0x20,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ant_selection_6,
     {"Antenna 6", "wlan.fixed.antsel.ant6",
      FT_UINT8, BASE_HEX, NULL, 0x40,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ant_selection_7,
     {"Antenna 7", "wlan.fixed.antsel.ant7",
      FT_UINT8, BASE_HEX, NULL, 0x80,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ext_channel_switch_announcement,
     {"Extended Channel Switch Announcement", "wlan.fixed.extchansw",
      FT_UINT32, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ext_channel_switch_announcement_switch_mode,
     {"Channel Switch Mode", "wlan.fixed.extchansw.switchmode",
      FT_UINT32, BASE_HEX, VALS(ieee80211_tag_ext_channel_switch_announcement_switch_mode_flags), 0x000000FF,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ext_channel_switch_announcement_new_ope_class,
     {"New Operating Class", "wlan.fixed.extchansw.new.opeclass",
      FT_UINT32, BASE_HEX, NULL, 0x0000FF00,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ext_channel_switch_announcement_new_chan_number,
     {"New Channel Number", "wlan.fixed.extchansw.new.channumber",
      FT_UINT32, BASE_HEX, NULL, 0x00FF0000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ext_channel_switch_announcement_switch_count,
     {"Channel Switch Count", "wlan.extchansw.switchcount",
      FT_UINT32, BASE_HEX, NULL, 0xFF000000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ht_info,
     {"HT Information", "wlan.fixed.mimo",
      FT_UINT8, BASE_HEX, NULL, 0,
      "HT Information Fixed Field", HFILL }},

    {&hf_ieee80211_ff_ht_info_information_request,
     {"Information Request", "wlan.fixed.mimo.control.inforequest",
      FT_BOOLEAN, 8, TFS(&ff_ht_info_information_request_flag), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ht_info_40_mhz_intolerant,
     {"40 MHz Intolerant", "wlan.fixed.mimo.control.intolerant",
      FT_BOOLEAN, 8, TFS(&ff_ht_info_40_mhz_intolerant_flag), 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ht_info_sta_chan_width,
     {"Station Channel Width", "wlan.fixed.mimo.control.chanwidth",
      FT_BOOLEAN, 8, TFS(&ff_ht_info_sta_chan_width_flag), 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ht_info_reserved,
     {"Reserved", "wlan.fixed.reserved",
      FT_UINT8, BASE_HEX, 0, 0xF8,
      "Reserved Field", HFILL }},

    {&hf_ieee80211_ff_ht_action,
     {"HT Action", "wlan.fixed.htact",
      FT_UINT8, BASE_HEX, VALS(ff_ht_action_flags), 0,
      "HT Action Code", HFILL }},

    {&hf_ieee80211_ff_mimo_csi_snr,
     {"Signal to Noise Ratio (SNR)", "wlan.mimo.csimatrices.snr",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_mimo_csi_matrices,
     {"CSI Matrices", "wlan.mimo.csimatrices",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_mimo_csi_bf_matrices,
     {"Beamforming Feedback Matrices", "wlan.mimo.csimatrices.bf",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_mimo_csi_cbf_matrices,
     {"Compressed Beamforming Feedback Matrices", "wlan.mimo.csimatrices.cbf",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_public_action,
     {"Public Action", "wlan.fixed.publicact",
      FT_UINT8, BASE_HEX|BASE_EXT_STRING, &ff_pa_action_codes_ext, 0,
      "Public Action Code", HFILL }},

    {&hf_ieee80211_ff_protected_public_action,
     {"Protected Public Action", "wlan.fixed.protectedpublicact",
      FT_UINT8, BASE_HEX|BASE_EXT_STRING, &ff_ppa_action_codes_ext, 0,
      "Protected Public Action Code", HFILL }},

    {&hf_ieee80211_ff_capture,
     {"Capabilities Information", "wlan.fixed.capabilities",
      FT_UINT16, BASE_HEX, NULL, 0,
      "Capability information", HFILL }},

    {&hf_ieee80211_ff_cf_ess,
     {"ESS capabilities", "wlan.fixed.capabilities.ess",
      FT_BOOLEAN, 16, TFS(&cf_ess_flags), 0x0001,
      NULL, HFILL }},

    {&hf_ieee80211_ff_cf_ibss,
     {"IBSS status", "wlan.fixed.capabilities.ibss",
      FT_BOOLEAN, 16, TFS(&cf_ibss_flags), 0x0002,
      "IBSS participation", HFILL }},

    {&hf_ieee80211_ff_cf_reserved1,
     {"Reserved", "wlan.fixed.capabilities.reserved1",
      FT_UINT16, BASE_DEC, NULL, 0x0004, NULL, HFILL }},

    {&hf_ieee80211_ff_cf_reserved2,
     {"Reserved", "wlan.fixed.capabilities.reserved2",
      FT_UINT16, BASE_DEC, NULL, 0x0008, NULL, HFILL }},

    {&hf_ieee80211_ff_cf_privacy,
     {"Privacy", "wlan.fixed.capabilities.privacy",
      FT_BOOLEAN, 16, TFS(&cf_privacy_flags), 0x0010,
      "Data privacy", HFILL }},

    {&hf_ieee80211_ff_cf_preamble,
     {"Short Preamble", "wlan.fixed.capabilities.short_preamble",
      FT_BOOLEAN, 16, TFS(&tfs_allowed_not_allowed), 0x0020,
      NULL, HFILL }},

    {&hf_ieee80211_ff_cf_critical_update_flag,
     {"Critical Update Flag", "wlan.fixed.capabilities.critical_update_flag",
      FT_BOOLEAN, 16, NULL, 0x0040, NULL, HFILL }},

    {&hf_ieee80211_ff_cf_nontran_bss_critical_update_flag,
     {"Nontransmitted BSSIDs Critical Update Flag", "wlan.fixed.capabilities.nontran_bss_critical_update_flag",
      FT_BOOLEAN, 16, NULL, 0x0080, NULL, HFILL }},

    {&hf_ieee80211_ff_cf_spec_man,
     {"Spectrum Management", "wlan.fixed.capabilities.spec_man",
      FT_BOOLEAN, 16, TFS(&tfs_implemented_not_implemented), 0x0100,
      NULL, HFILL }},

    {&hf_ieee80211_ff_cf_qos,
     {"QoS", "wlan.fixed.capabilities.qos",
      FT_BOOLEAN, 16, TFS(&tfs_implemented_not_implemented), 0x0200,
      NULL, HFILL }},

    {&hf_ieee80211_ff_cf_short_slot_time,
     {"Short Slot Time", "wlan.fixed.capabilities.short_slot_time",
      FT_BOOLEAN, 16, TFS(&tfs_inuse_not_inuse), 0x0400,
      NULL, HFILL }},

    {&hf_ieee80211_ff_cf_apsd,
     {"Automatic Power Save Delivery", "wlan.fixed.capabilities.apsd",
      FT_BOOLEAN, 16, TFS(&tfs_implemented_not_implemented), 0x0800,
      NULL, HFILL }},

    {&hf_ieee80211_ff_cf_radio_measurement,
     {"Radio Measurement", "wlan.fixed.capabilities.radio_measurement",
      FT_BOOLEAN, 16, TFS(&tfs_implemented_not_implemented), 0x1000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_cf_epd,
     {"EPD", "wlan.fixed.capabilities.epd",
      FT_BOOLEAN, 16, TFS(&tfs_implemented_not_implemented), 0x2000,
      NULL, HFILL }},

    {&hf_ieee80211_ff_cf_reserved5,
     {"Reserved", "wlan.fixed.capabilities.reserved5",
      FT_UINT16, BASE_DEC, NULL, 0x4000, NULL, HFILL }},

    {&hf_ieee80211_ff_cf_reserved6,
     {"Reserved", "wlan.fixed.capabilities.reserved6",
      FT_UINT16, BASE_DEC, NULL, 0x8000, NULL, HFILL }},

    {&hf_ieee80211_ff_auth_seq,
     {"Authentication SEQ", "wlan.fixed.auth_seq",
      FT_UINT16, BASE_HEX, NULL, 0,
      "Authentication Sequence Number", HFILL }},

    {&hf_ieee80211_ff_assoc_id,
     {"Association ID", "wlan.fixed.aid",
      FT_UINT16, BASE_HEX, NULL, 0x3FFF,
      NULL, HFILL }},

    {&hf_ieee80211_ff_listen_ival,
     {"Listen Interval", "wlan.fixed.listen_ival",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_current_ap,
     {"Current AP", "wlan.fixed.current_ap",
      FT_ETHER, BASE_NONE, NULL, 0,
      "MAC address of current AP", HFILL }},

    {&hf_ieee80211_ff_reason,
     {"Reason code", "wlan.fixed.reason_code",
      FT_UINT16, BASE_HEX|BASE_EXT_STRING, &ieee80211_reason_code_ext, 0,
      "Reason for unsolicited notification", HFILL }},

    {&hf_ieee80211_ff_status_code,
     {"Status code", "wlan.fixed.status_code",
      FT_UINT16, BASE_HEX|BASE_EXT_STRING, &ieee80211_status_code_ext, 0,
      "Status of requested event", HFILL }},

    {&hf_ieee80211_ff_category_code,
     {"Category code", "wlan.fixed.category_code",
      FT_UINT16, BASE_DEC|BASE_EXT_STRING, &category_codes_ext, 0,
      "Management action category", HFILL }},

    {&hf_ieee80211_ff_action_code,
     {"Action code", "wlan.fixed.action_code",
      FT_UINT16, BASE_DEC, VALS(action_codes), 0,
      "Management action code", HFILL }},

    {&hf_ieee80211_ff_dialog_token,
     {"Dialog token", "wlan.fixed.dialog_token",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Management action dialog token", HFILL }},

    {&hf_ieee80211_ff_trigger,
     {"Trigger", "wlan.fixed.trigger",
      FT_UINT8, BASE_DEC, VALS(ftm_trigger_vals), 0,
      "FTM action trigger", HFILL }},

    {&hf_ieee80211_ff_ftm_tod,
     {"FTM TOD", "wlan.fixed.ftm_tod",
      FT_UINT48, BASE_DEC, NULL, 0,
      "Management action FTM TOD", HFILL }},

    {&hf_ieee80211_ff_ftm_toa,
     {"FTM TOA", "wlan.fixed.ftm_toa",
      FT_UINT48, BASE_DEC, NULL, 0,
      "Management action FTM TOA", HFILL }},

    {&hf_ieee80211_ff_ftm_tod_err,
     {"FTM TOD Error", "wlan.fixed.ftm_tod_err",
      FT_UINT16, BASE_DEC, NULL, 0,
      "Management action FTM TOD Error", HFILL }},

    {&hf_ieee80211_ff_ftm_toa_err,
     {"FTM TOA Error", "wlan.fixed.ftm_toa_err",
      FT_UINT16, BASE_DEC, NULL, 0,
      "Management action FTM TOA Error", HFILL }},

    {&hf_ieee80211_ff_followup_dialog_token,
     {"Followup Dialog token", "wlan.fixed.followup_dialog_token",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Management action followup dialog token", HFILL }},

    {&hf_ieee80211_ff_marvell_action_type,
     {"Marvell Action type", "wlan.fixed.mrvl_action_type",
      FT_UINT8, BASE_DEC, VALS(vendor_action_types_mrvl), 0,
      "Vendor Specific Action Type (Marvell)", HFILL }},

    {&hf_ieee80211_ff_marvell_mesh_mgt_action_code,
     {"Mesh action(Marvell)", "wlan.fixed.mrvl_mesh_action",
      FT_UINT8, BASE_HEX, VALS(mesh_mgt_action_codes_mrvl), 0,
      "Mesh action code(Marvell)", HFILL }},

    {&hf_ieee80211_ff_marvell_mesh_mgt_length,
     {"Message Length", "wlan.fixed.length",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_marvell_mesh_mgt_mode,
     {"Message Mode", "wlan.fixed.mode",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_marvell_mesh_mgt_ttl,
     {"Message TTL", "wlan.fixed.ttl",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_marvell_mesh_mgt_dstcount,
     {"Destination Count", "wlan.fixed.dstcount",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_marvell_mesh_mgt_hopcount,
     {"Hop Count", "wlan.fixed.hopcount",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_marvell_mesh_mgt_rreqid,
     {"RREQ ID", "wlan.fixed.rreqid",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_marvell_mesh_mgt_sa,
     {"Source Address", "wlan.fixed.sa",
      FT_ETHER, BASE_NONE, NULL, 0,
      "Source MAC address", HFILL }},

    {&hf_ieee80211_ff_marvell_mesh_mgt_ssn,
     {"SSN", "wlan.fixed.ssn",
      FT_UINT32, BASE_DEC, NULL, 0,
      "Source Sequence Number", HFILL }},

    {&hf_ieee80211_ff_marvell_mesh_mgt_metric,
     {"Metric", "wlan.fixed.metric",
      FT_UINT32, BASE_DEC, NULL, 0,
      "Route Metric", HFILL }},

    {&hf_ieee80211_ff_marvell_mesh_mgt_flags,
     {"RREQ Flags", "wlan.fixed.flags",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_marvell_mesh_mgt_da,
     {"Destination Address", "wlan.fixed.da",
      FT_ETHER, BASE_NONE, NULL, 0,
      "Destination MAC address", HFILL }},

    {&hf_ieee80211_ff_marvell_mesh_mgt_dsn,
     {"DSN", "wlan.fixed.dsn",
      FT_UINT32, BASE_DEC, NULL, 0,
      "Destination Sequence Number", HFILL }},

    {&hf_ieee80211_ff_marvell_mesh_mgt_lifetime,
     {"Lifetime", "wlan.fixed.lifetime",
      FT_UINT32, BASE_DEC, NULL, 0,
      "Route Lifetime", HFILL }},

    {&hf_ieee80211_ff_wme_action_code,
     {"Action code", "wlan.fixed.action_code",
      FT_UINT16, BASE_HEX, VALS(wme_action_codes), 0,
      "Management notification action code", HFILL }},

    {&hf_ieee80211_ff_wme_status_code,
     {"Status code", "wlan.fixed.status_code",
      FT_UINT16, BASE_HEX, VALS(wme_status_codes), 0,
      "Management notification setup response status code", HFILL }},

    {&hf_ieee80211_ff_mesh_action,
     {"Mesh Action code", "wlan.fixed.mesh_action",
      FT_UINT8, BASE_HEX|BASE_EXT_STRING, &mesh_action_ext, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_multihop_action,
     {"Multihop Action code", "wlan.fixed.multihop_action",
      FT_UINT8, BASE_HEX, VALS(multihop_action), 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_mesh_flags,
     {"Mesh Flags", "wlan.fixed.mesh_flags",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_mesh_ttl,
     {"Mesh TTL", "wlan.fixed.mesh_ttl",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_mesh_sequence,
     {"Sequence Number", "wlan.fixed.mesh_sequence",
      FT_UINT32, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_mesh_addr4,
     {"Mesh Extended Address 4", "wlan.fixed.mesh_addr4",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_mesh_addr5,
     {"Mesh Extended Address 5", "wlan.fixed.mesh_addr5",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_mesh_addr6,
     {"Mesh Extended Address 6", "wlan.fixed.mesh_addr6",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_selfprot_action,
     {"Self-protected Action code", "wlan.fixed.selfprot_action",
      FT_UINT8, BASE_HEX, VALS(selfprot_action), 0,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_peering_proto,
     {"Mesh Peering Protocol ID", "wlan.peering.proto",
      FT_UINT16, BASE_HEX, VALS(mesh_peering_proto_ids), 0,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_peering_local_link_id,
     {"Local Link ID", "wlan.peering.local_id",
      FT_UINT16, BASE_HEX, NULL, 0,
      "Mesh Peering Management Local Link ID", HFILL }},

    {&hf_ieee80211_mesh_peering_peer_link_id,
     {"Peer Link ID", "wlan.peering.peer_id",
      FT_UINT16, BASE_HEX, NULL, 0,
      "Mesh Peering Management Peer Link ID", HFILL }},

    {&hf_ieee80211_ff_hwmp_flags,
     {"HWMP Flags", "wlan.hwmp.flags",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_hwmp_hopcount,
     {"HWMP Hop Count", "wlan.hwmp.hopcount",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_hwmp_ttl,
     {"HWMP TTL", "wlan.hwmp.ttl",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_hwmp_pdid,
     {"HWMP Path Discovery ID", "wlan.hwmp.pdid",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_hwmp_orig_sta,
     {"Originator STA Address", "wlan.hwmp.orig_sta",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_hwmp_orig_sn,
     {"HWMP Originator Sequence Number", "wlan.hwmp.orig_sn",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL}},

    {&hf_ieee80211_ff_hwmp_orig_ext,
     {"Originator External Address", "wlan.hwmp.orig_ext",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_hwmp_lifetime,
     {"HWMP Lifetime", "wlan.hwmp.lifetime",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_hwmp_metric,
     {"HWMP Metric", "wlan.hwmp.metric",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_hwmp_targ_count,
     {"HWMP Target Count", "wlan.hwmp.targ_count",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_hwmp_targ_flags,
     {"HWMP Per-Target Flags", "wlan.hwmp.targ_flags",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_hwmp_targ_to_flags,
     {"TO Flag", "wlan.hwmp.to_flag",
      FT_BOOLEAN, 8, TFS(&hwmp_targ_to_flags), 0x01,
      "Target Only Flag", HFILL }},

    {&hf_ieee80211_ff_hwmp_targ_usn_flags,
     {"USN Flag", "wlan.hwmp.usn_flag",
      FT_BOOLEAN, 8, TFS(&hwmp_targ_usn_flags), 0x04,
      "Unknown Target HWMP Sequence Number Flag", HFILL }},

    {&hf_ieee80211_ff_hwmp_targ_sta,
     {"Target STA Address", "wlan.hwmp.targ_sta",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_hwmp_targ_ext,
     {"Target External Address", "wlan.hwmp.targ_ext",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_hwmp_targ_sn,
     {"Target HWMP Sequence Number", "wlan.hwmp.targ_sn",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_config_path_sel_protocol,
     {"Path Selection Protocol", "wlan.mesh.config.ps_protocol",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Mesh Configuration Path Selection Protocol", HFILL }},

    {&hf_ieee80211_mesh_config_path_sel_metric,
     {"Path Selection Metric", "wlan.mesh.config.ps_metric",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Mesh Configuration Path Selection Metric", HFILL }},

    {&hf_ieee80211_mesh_config_congestion_control,
     {"Congestion Control", "wlan.mesh.config.cong_ctl",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Mesh Configuration Congestion Control", HFILL }},

    {&hf_ieee80211_mesh_config_sync_method,
     {"Synchronization Method", "wlan.mesh.config.sync_method",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Mesh Configuration Synchronization Method", HFILL }},

    {&hf_ieee80211_mesh_config_auth_protocol,
     {"Authentication Protocol", "wlan.mesh.config.auth_protocol",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Mesh Configuration Authentication Protocol", HFILL }},

    {&hf_ieee80211_mesh_config_formation_info,
     {"Formation Info", "wlan.mesh.config.formation_info",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Mesh Configuration Formation Info", HFILL }},

    {&hf_ieee80211_mesh_form_info_conn_to_mesh_gate,
     {"Connected to Mesh Gate", "wlan.mesh.formation_info.connect_to_mesh_gate",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_form_info_num_of_peerings,
     {"Number of Peerings", "wlan.mesh.config.formation_info.num_peers",
      FT_UINT8, BASE_DEC, NULL, 0x7E,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_form_info_conn_to_as,
     {"Connected to AS", "wlan.mesh.formation_info.connect_to_as",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x80,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_config_capability,
     {"Capability", "wlan.mesh.config.cap",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Mesh Configuration Capability", HFILL }},

    {&hf_ieee80211_mesh_config_cap_accepting,
     {"Accepting Additional Mesh Peerings", "wlan.mesh.config.cap.accept",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_config_cap_mcca_support,
     {"MCCA Support", "wlan.mesh.config.cap.mcca_support",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_config_cap_mcca_enabled,
     {"MCCA Enabled", "wlan.mesh.config.cap.mcca_enabled",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_config_cap_forwarding,
     {"Mesh Forwarding", "wlan.mesh.config.cap.forwarding",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_config_cap_mbca_enabled,
     {"MBCA Enabled", "wlan.mesh.config.cap.mbca_enabled",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_config_cap_tbtt_adjusting,
     {"TBTT Adjustment", "wlan.mesh.config.cap.tbtt_adjusting",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x20,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_config_cap_power_save_level,
     {"Power Save", "wlan.mesh.config.cap.power_save_level",
      FT_BOOLEAN, 8, TFS(&mesh_config_cap_power_save_level_flags), 0x40,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_config_cap_reserved,
     {"Reserved", "wlan.mesh.config.cap.reserved",
      FT_UINT8, BASE_HEX, NULL, 0x80,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_id,
     {"Mesh ID", "wlan.mesh.id",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_bcn_timing_rctrl,
     {"Report Control", "wlan.bcntime.rctrl",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_bcn_timing_rctrl_more,
     {"More Beacon Timing Elements", "wlan.bcntime.rctrl.more",
      FT_BOOLEAN, 8, TFS(&tfs_more_nomore), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_bcn_timing_rctrl_element_num,
     {"Beacon Timing Element Number", "wlan.bcntime.rctrl.elem_num",
      FT_UINT8, BASE_HEX, NULL, 0x0E,
      NULL, HFILL }},

    {&hf_ieee80211_bcn_timing_rctrl_status_num,
     {"Status Number", "wlan.bcntime.rctrl.status_num",
      FT_UINT8, BASE_HEX, NULL, 0xF0,
      NULL, HFILL }},

    {&hf_ieee80211_bcn_timing_info,
     {"Beacon Timing Info", "wlan.bcntime.info",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_bcn_timing_info_nsta_id,
     {"Neighbor STA ID", "wlan.bcntime.info.nstaid",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_bcn_timing_info_nsta_tbtt,
     {"Neighbor STA TBTT", "wlan.bcntime.info.nstatbtt",
      FT_UINT24, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_bcn_timing_info_nsta_bi,
     {"Neighbor STA Beacon Interval", "wlan.bcntime.info.nstabi",
       FT_UINT16, BASE_CUSTOM, CF_FUNC(beacon_interval_base_custom), 0,
      NULL, HFILL }},

    {&hf_ieee80211_gann_flags,
     {"GANN Flags", "wlan.gann.flags",
       FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_gann_flags_reserved,
     {"Reserved", "wlan.gann.flags.reserved",
       FT_UINT8, BASE_HEX, NULL, 0xff,
      NULL, HFILL }},

    {&hf_ieee80211_gann_hop_count,
     {"GANN Hop count", "wlan.gann.hop_count",
       FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_gann_elem_ttl,
     {"GANN Element TTL", "wlan.gann.elem_ttl",
       FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_gann_mesh_gate_addr,
     {"GANN Mesh Gate Address", "wlan.gann.gate_addr",
       FT_BYTES, SEP_COLON, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_gann_seq_num,
     {"GANN Sequence Number", "wlan.gann.seq_num",
       FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_gann_interval,
     {"GANN Interval", "wlan.gann.interval",
       FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_mic,
     {"Mesh Peering Management MIC", "wlan.mesh.mic",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_mesh_ampe_encrypted_data,
     {"Authenticated Mesh Peering Exchange Encrypted Data", "wlan.mesh.ampe.encrypted_data",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rann_flags,
     {"RANN Flags", "wlan.rann.flags",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Root Announcement Flags", HFILL }},

    {&hf_ieee80211_rann_root_sta,
     {"Root STA Address", "wlan.rann.root_sta", FT_ETHER, BASE_NONE, NULL, 0,
      "Root Mesh STA Address", HFILL }},

    {&hf_ieee80211_rann_sn,
     {"Root STA Sequence Number", "wlan.rann.rann_sn",
      FT_UINT32, BASE_DEC, NULL, 0,
      "Root Mesh STA Sequence Number", HFILL }},

    {&hf_ieee80211_rann_interval,
     {"RANN Interval", "wlan.rann.interval",
      FT_UINT32, BASE_DEC, NULL, 0,
      "Root Announcement Interval", HFILL }},

    {&hf_ieee80211_pxu_pxu_id,
     {"PXU ID", "wlan.pxu.pxu_id",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_pxu_pxu_origin_mac,
     {"PXU Originator MAC Address", "wlan.pxu.origin_mac",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_pxu_no_proxy_info,
     {"Number of Proxy Information", "wlan.pxu.no_proxy_info",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_pxu_proxy_info,
     {"Proxy Information", "wlan.pxu.proxy_info",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_pxu_proxy_info_flags,
     {"Flags", "wlan.pxu.pxu_info.flags",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_pxu_proxy_info_flags_delete,
     {"Delete", "wlan.pxu.pxu_info.flags.delete",
      FT_BOOLEAN, 8, NULL, 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_pxu_proxy_info_flags_orig_is_proxy,
     {"Originator is Proxy", "wlan.pxu.pxu_info.flags.orig_is_proxy",
      FT_BOOLEAN, 8, NULL, 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_pxu_proxy_info_flags_lifetime,
     {"Lifetime", "wlan.pxu.pxu_info.flags.lifetime",
      FT_BOOLEAN, 8, NULL, 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_pxu_proxy_info_flags_reserved,
     {"Reserved", "wlan.pxu.pxu_info.flags.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xF8,
      NULL, HFILL }},

    {&hf_ieee80211_pxu_proxy_info_ext_mac,
     {"External MAC Address", "wlan.pxu.pxu_info.ext_mac",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_pxu_proxy_info_seq_num,
     {"Proxy Information Sequence Number", "wlan.pxu.pxu_info.seq_num",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_pxu_proxy_info_proxy_mac,
     {"Proxy MAC Address", "wlan.pxu.pxu_info.proxy_mac",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_pxu_proxy_info_lifetime,
     {"Proxy Information Lifetime", "wlan.pxu.pxu_info.lifetime",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_pxuc_pxu_id,
     {"PXU ID", "wlan.pxuc.pxu_id",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_pxuc_pxu_recip_mac,
     {"PXU Recipient MAC Address", "wlan.pxuc.recip_mac",
      FT_BYTES, SEP_COLON, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_qos_action_code,
     {"Action code", "wlan.fixed.action_code",
      FT_UINT16, BASE_HEX, VALS(qos_action_codes), 0,
      "QoS management action code", HFILL }},

    {&hf_ieee80211_ff_ba_action,
     {"Action code", "wlan.fixed.action_code",
      FT_UINT8, BASE_HEX, VALS(ba_action_codes), 0,
      "Block Ack action code", HFILL }},

    {&hf_ieee80211_ff_check_beacon,
     {"Check Beacon", "wlan.fixed.check_beacon",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Unprotected WNM Check Beacon", HFILL }},

    {&hf_ieee80211_ff_tod,
     {"TOD", "wlan.fixed.tod",
      FT_UINT32, BASE_DEC, NULL, 0,
      "Previous TS of transmit antenna port", HFILL }},

    {&hf_ieee80211_ff_toa,
     {"TOA", "wlan.fixed.toa",
      FT_UINT32, BASE_DEC, NULL, 0,
      "Previous TS of receive antenna port", HFILL }},

    {&hf_ieee80211_ff_max_tod_err,
     {"MAX TOD ERROR", "wlan.fixed.max_tod_err",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Maximal Error at Previous TS of transmit antenna port", HFILL }},

    {&hf_ieee80211_ff_max_toa_err,
     {"MAX TOA ERROR", "wlan.fixed.max_toa_err",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Maximal Error at Previous TS of receive antenna port", HFILL }},

    {&hf_ieee80211_ff_dls_action_code,
     {"Action code", "wlan.fixed.action_code",
      FT_UINT16, BASE_HEX, VALS(dls_action_codes), 0,
      "DLS management action code", HFILL }},

    {&hf_ieee80211_ff_dst_mac_addr,
     {"Destination address", "wlan.fixed.dst_mac_addr",
      FT_ETHER, BASE_NONE, NULL, 0,
      "Destination MAC address", HFILL }},

    {&hf_ieee80211_ff_src_mac_addr,
     {"Source address", "wlan.fixed.src_mac_addr",
      FT_ETHER, BASE_NONE, NULL, 0,
      "Source MAC address", HFILL }},

    {&hf_ieee80211_ff_req_ap_addr,
     {"RequesterAP address", "wlan.fixed.req_ap_addr",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_res_ap_addr,
     {"ResponderAP address", "wlan.fixed.res_ap_addr",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_ft_action_code,
     {"Action code", "wlan.fixed.action_code",
      FT_UINT8, BASE_DEC, VALS(ft_action_codes), 0,
      "Management action code", HFILL }},

    {&hf_ieee80211_ff_sta_address,
     {"STA Address", "wlan.fixed.sta_address",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_target_ap_address,
     {"Target AP Address", "wlan.fixed.target_ap_address",
      FT_ETHER, BASE_NONE, NULL, 0,
      "Target AP MAC address", HFILL }},

    {&hf_ieee80211_ff_gas_comeback_delay,
     {"GAS Comeback Delay", "wlan.fixed.gas_comeback_delay",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_gas_fragment_id,
     {"GAS Query Response Fragment ID", "wlan.fixed.gas_fragment_id",
      FT_UINT8, BASE_DEC, NULL, 0x7f,
      NULL, HFILL }},

    {&hf_ieee80211_ff_more_gas_fragments,
     {"More GAS Fragments", "wlan.fixed.more_gas_fragments",
      FT_UINT8, BASE_DEC, NULL, 0x80,
      NULL, HFILL }},

    {&hf_ieee80211_ff_query_request_length,
     {"Query Request Length", "wlan.fixed.query_request_length",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_query_request,
     {"Query Request", "wlan.fixed.query_request",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_query_response_length,
     {"Query Response Length", "wlan.fixed.query_response_length",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_query_response,
     {"Query Response", "wlan.fixed.query_response",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_gas_resp_fragments,
     {"GAS Query Response fragments", "wlan.fixed.fragments",
      FT_NONE, BASE_NONE, NULL, 0x00,
      NULL, HFILL } },

    {&hf_ieee80211_gas_resp_fragment,
     {"GAS Query Response fragment", "wlan.fixed.fragment",
      FT_FRAMENUM, BASE_NONE, NULL, 0x00,
      NULL, HFILL } },

    {&hf_ieee80211_gas_resp_fragment_overlap,
     {"GAS Query Response fragment overlap", "wlan.fixed.fragment.overlap",
      FT_BOOLEAN, BASE_NONE, NULL, 0x00,
      NULL, HFILL } },

    {&hf_ieee80211_gas_resp_fragment_overlap_conflict,
     {"GAS Query Response fragment overlapping with conflicting data", "wlan.fixed.fragment.overlap.conflicts",
      FT_BOOLEAN, BASE_NONE, NULL, 0x00,
      NULL, HFILL } },

    {&hf_ieee80211_gas_resp_fragment_multiple_tails,
     {"GAS Query Response has multiple tail fragments",  "wlan.fixed.fragment.multiple_tails",
      FT_BOOLEAN, BASE_NONE, NULL, 0x00,
      NULL, HFILL } },

    {&hf_ieee80211_gas_resp_fragment_too_long_fragment,
     {"GAS Query Response fragment too long", "wlan.fixed.fragment.too_long_fragment",
      FT_BOOLEAN, BASE_NONE, NULL, 0x00,
      NULL, HFILL } },

    {&hf_ieee80211_gas_resp_fragment_error,
     {"GAS Query Response reassembly error", "wlan.fixed.fragment.error",
      FT_FRAMENUM, BASE_NONE, NULL, 0x00,
      NULL, HFILL } },

    {&hf_ieee80211_gas_resp_fragment_count,
     {"GAS Query Response fragment count", "wlan.fixed.fragment.count",
      FT_UINT32, BASE_DEC, NULL, 0x00,
      NULL, HFILL } },

    {&hf_ieee80211_gas_resp_reassembled_in,
     {"Reassembled in", "wlan.fixed.reassembled.in",
      FT_FRAMENUM, BASE_NONE, NULL, 0x00,
      NULL, HFILL } },

    {&hf_ieee80211_gas_resp_reassembled_length,
     {"Reassembled length", "wlan.fixed.reassembled.length",
      FT_UINT32, BASE_DEC, NULL, 0x00,
      NULL, HFILL } },

    {&hf_ieee80211_ff_anqp_info_id,
     {"Info ID", "wlan.fixed.anqp.info_id",
      FT_UINT16, BASE_DEC|BASE_EXT_STRING, &anqp_info_id_vals_ext, 0,
      "Access Network Query Protocol Info ID", HFILL }},

    {&hf_ieee80211_ff_anqp_info_length,
     {"Length", "wlan.fixed.anqp.info_length",
      FT_UINT16, BASE_DEC, NULL, 0,
      "Access Network Query Protocol Length", HFILL }},

    {&hf_ieee80211_ff_anqp_info,
     {"Information", "wlan.fixed.anqp.info",
      FT_BYTES, BASE_NONE, NULL, 0,
      "Access Network Query Protocol Information", HFILL }},

    {&hf_ieee80211_ff_anqp_query_id,
     {"ANQP Query ID", "wlan.fixed.anqp.query_id",
      FT_UINT16, BASE_DEC|BASE_EXT_STRING, &anqp_info_id_vals_ext, 0,
      "Access Network Query Protocol Query ID", HFILL }},

    {&hf_ieee80211_ff_anqp_capability,
     {"ANQP Capability", "wlan.fixed.anqp.capability",
      FT_UINT16, BASE_DEC|BASE_EXT_STRING, &anqp_info_id_vals_ext, 0,
      "Access Network Query Protocol Capability", HFILL }},

    {&hf_ieee80211_ff_anqp_capability_vlen,
     {"Vendor-specific Capability Length", "wlan.fixed.anqp.capability_vlen",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_capability_vendor,
     {"Vendor-specific Capability", "wlan.fixed.anqp.capability_vendor",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_venue_info_group,
     {"Venue Group", "wlan.fixed.venue_info.group",
      FT_UINT8, BASE_DEC|BASE_EXT_STRING, &venue_group_vals_ext, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_venue_info_type,
     {"Venue Type", "wlan.fixed.venue_info.type",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_venue_length,
     {"Venue Name Duple Length", "wlan.fixed.anqp.venue.length",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_venue_language,
     {"Language Code", "wlan.fixed.anqp.venue.language",
      FT_STRING, BASE_NONE, NULL, 0,
      "Venue Name Language Code", HFILL }},

    {&hf_ieee80211_ff_anqp_venue_name,
     {"Venue Name", "wlan.fixed.anqp.venue.name",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nw_auth_type_indicator,
     {"Network Authentication Type Indicator", "wlan.fixed.anqp.nw_auth_type.indicator",
      FT_UINT8, BASE_DEC, VALS(nw_auth_type_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nw_auth_type_url_len,
     {"Re-direct URL Length", "wlan.fixed.anqp.nw_auth_type.url_len",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nw_auth_type_url,
     {"Re-direct URL", "wlan.fixed.anqp.nw_auth_type.url",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nw_auth_type_ts_indicator,
     {"Network Authentication Type w/ Timestamp Indicator",
      "wlan.fixed.anqp.nw_auth_type_ts.indicator",
      FT_UINT8, BASE_DEC, VALS(nw_auth_type_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nw_auth_type_ts_url_len,
     {"Re-direct URL Length", "wlan.fixed.anqp.nw_auth_type_ts.url_len",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nw_auth_type_ts_url,
     {"Re-direct URL", "wlan.fixed.anqp.nw_auth_type_ts.url",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nw_auth_type_ts_year,
     {"Timestamp (Year)", "wlan.fixed.anqp.nw_auth_type_ts.year",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nw_auth_type_ts_mon,
     {"Timestamp (Month)", "wlan.fixed.anqp.nw_auth_type_ts.mon",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nw_auth_type_ts_day,
     {"Timestamp (Day)", "wlan.fixed.anqp.nw_auth_type_ts.day",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nw_auth_type_ts_hr,
     {"Timestamp (Hours)", "wlan.fixed.anqp.nw_auth_type_ts.hr",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nw_auth_type_ts_min,
     {"Timestamp (Minutes)", "wlan.fixed.anqp.nw_auth_type_ts.min",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nw_auth_type_ts_sec,
     {"Timestamp (Seconds)", "wlan.fixed.anqp.nw_auth_type_ts.sec",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nw_auth_type_ts_msec,
     {"Timestamp (Milliseconds)", "wlan.fixed.anqp.nw_auth_type_ts.msec",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nw_auth_type_ts_rsvd,
     {"Timestamp (Reserved)", "wlan.fixed.anqp.nw_auth_type_ts.rsvd",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_roaming_consortium_oi_len,
     {"OI Length", "wlan.fixed.anqp.roaming_consortium.oi_len",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Roaming Consortium OI Length", HFILL }},

    {&hf_ieee80211_ff_anqp_roaming_consortium_oi,
     {"OI", "wlan.fixed.anqp.roaming_consortium.oi",
      FT_BYTES, BASE_NONE, NULL, 0,
      "Roaming Consortium OI", HFILL }},

    {&hf_ieee80211_ff_anqp_ip_addr_avail_ipv6,
     {"IPv6 Address", "wlan.fixed.anqp.ip_addr_availability.ipv6",
      FT_UINT8, BASE_DEC, VALS(ip_addr_avail_ipv6_vals), 0x03,
      "IP Address Type Availability information for IPv6", HFILL }},

    {&hf_ieee80211_ff_anqp_ip_addr_avail_ipv4,
     {"IPv4 Address", "wlan.fixed.anqp.ip_addr_availability.ipv4",
      FT_UINT8, BASE_DEC, VALS(ip_addr_avail_ipv4_vals), 0xfc,
      "IP Address Type Availability information for IPv4", HFILL }},

    {&hf_ieee80211_ff_anqp_nai_realm_count,
     {"NAI Realm Count", "wlan.fixed.anqp.nai_realm_list.count",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nai_field_len,
     {"NAI Realm Data Field Length", "wlan.fixed.anqp.nai_realm_list.field_len",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nai_realm_encoding,
     {"NAI Realm Encoding", "wlan.fixed.anqp_nai_realm_list.encoding",
      FT_UINT8, BASE_DEC, VALS(nai_realm_encoding_vals), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nai_realm_length,
     {"NAI Realm Length", "wlan.fixed.anqp_nai_realm_list.realm_length",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nai_realm,
     {"NAI Realm", "wlan.fixed.anqp_nai_realm_list.realm",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nai_realm_eap_count,
     {"EAP Method Count", "wlan.fixed.anqp_nai_realm_list.eap_method_count",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nai_realm_eap_len,
     {"EAP Method subfield Length", "wlan.fixed.anqp_nai_realm_list.eap_method_len",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nai_realm_eap_method,
     {"EAP Method", "wlan.fixed.anqp_nai_realm_list.eap_method",
      FT_UINT8, BASE_DEC|BASE_EXT_STRING, &eap_type_vals_ext, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nai_realm_auth_param_count,
     {"Authentication Parameter Count", "wlan.fixed.anqp_nai_realm_list.auth_param_count",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nai_realm_auth_param_id,
     {"Authentication Parameter ID", "wlan.fixed.anqp_nai_realm_list.auth_param_id",
      FT_UINT8, BASE_DEC, VALS(nai_realm_auth_param_id_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nai_realm_auth_param_len,
     {"Authentication Parameter Length", "wlan.fixed.anqp_nai_realm_list.auth_param_len",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_nai_realm_auth_param_value,
     {"Authentication Parameter Value", "wlan.fixed.anqp_nai_realm_list.auth_param_value",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_3gpp_gc_gud,
     {"GUD", "wlan.fixed.anqp.3gpp_cellular_info.gud",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Generic container User Data", HFILL }},

    {&hf_ieee80211_3gpp_gc_udhl,
     {"UDHL", "wlan.fixed.anqp.3gpp_cellular_info.udhl",
      FT_UINT8, BASE_DEC, NULL, 0,
      "User Data Header Length", HFILL }},

    {&hf_ieee80211_3gpp_gc_iei,
     {"IEI", "wlan.fixed.anqp.3gpp_cellular_info.iei",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Information Element Identity", HFILL }},

    {&hf_ieee80211_3gpp_gc_plmn_len,
     {"PLMN Length", "wlan.fixed.anqp.3gpp_cellular_info.plmn_len",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Length of PLMN List value contents", HFILL }},

    {&hf_ieee80211_3gpp_gc_num_plmns,
     {"Number of PLMNs", "wlan.fixed.anqp.3gpp_cellular_info.num_plmns",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_3gpp_gc_plmn,
     {"PLMN", "wlan.fixed.anqp.3gpp_cellular_info.plmn_info",
      FT_UINT24, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_domain_name_len,
     {"Domain Name Length", "wlan.fixed.anqp.domain_name_list.len",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_anqp_domain_name,
     {"Domain Name", "wlan.fixed.anqp.domain_name_list.name",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_dls_timeout,
     {"DLS timeout", "wlan.fixed.dls_timeout",
      FT_UINT16, BASE_HEX, NULL, 0,
      "DLS timeout value", HFILL }},

    {&hf_ieee80211_ff_sa_query_action_code,
     {"Action code", "wlan.fixed.action_code",
      FT_UINT8, BASE_DEC, VALS(sa_query_action_codes), 0,
      "Management action code", HFILL }},

    {&hf_ieee80211_ff_transaction_id,
     {"Transaction Id", "wlan.fixed.transaction_id",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_send_confirm,
     {"Send-Confirm", "wlan.fixed.send_confirm",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_scalar,
     {"Scalar", "wlan.fixed.scalar",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_finite_field_element,
     {"Finite Field Element", "wlan.fixed.finite_field_element",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_confirm,
     {"Confirm", "wlan.fixed.confirm",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_finite_cyclic_group,
     {"Group Id", "wlan.fixed.finite_cyclic_group",
      FT_UINT16, BASE_DEC, VALS(ff_finite_cyclic_group_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_sae_message_type,
     {"SAE Message Type", "wlan.fixed.sae_message_type",
      FT_UINT16, BASE_DEC, VALS(ff_sae_message_type_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_ff_sae_anti_clogging_token,
     {"Anti-Clogging Token", "wlan.fixed.anti_clogging_token",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_anqp_wfa_subtype,
     {"WFA Subtype", "wlan.anqp.wfa.subtype",
      FT_UINT8, BASE_DEC, VALS(wfa_anqp_subtype_vals), 0, NULL, HFILL }},

    {&hf_ieee80211_dpp_subtype,
     {"DPP Subtype", "wlan.wfa.dpp.subtype",
      FT_UINT8, BASE_DEC, VALS(dpp_subtype_vals), 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_indication_dgaf_disabled,
     {"DGAF Disabled", "wlan.hs20.indication.dgaf_disabled",
      FT_UINT8, BASE_DEC, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_hs20_indication_pps_mo_id_present,
     {"PPS MO ID Present", "wlan.hs20.indication.pps_mo_id_present",
      FT_BOOLEAN, 8, TFS(&tfs_present_not_present), 0x02, NULL, HFILL }},

    {&hf_ieee80211_hs20_indication_anqp_domain_id_present,
     {"ANQP Domain ID Present", "wlan.hs20.indication.anqp_domain_id_present",
      FT_BOOLEAN, 8, TFS(&tfs_present_not_present), 0x04, NULL, HFILL }},

    {&hf_ieee80211_hs20_reserved,
      { "Reserved", "wlan.hs20.indication.reserved",
       FT_BOOLEAN, 8, TFS(&tfs_set_notset), 0x08, NULL, HFILL }},

    {&hf_ieee80211_hs20_indication_version_number,
     {"Version Number", "wlan.hs20.indication.version_number",
      FT_UINT8, BASE_DEC, VALS(hs20_indication_version_number_vals), 0xF0, NULL, HFILL }},

    {&hf_ieee80211_hs20_indication_pps_mo_id,
     {"PPS MO ID", "wlan.hs20.indication.pps_mo_id",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_indication_anqp_domain_id,
     {"ANQP Domain ID", "wlan.hs20.indication.domain_id",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_subtype,
     {"Subtype", "wlan.hs20.anqp.subtype",
      FT_UINT8, BASE_DEC, VALS(hs20_anqp_subtype_vals), 0,
      "Hotspot 2.0 ANQP Subtype", HFILL }},

    {&hf_ieee80211_hs20_anqp_reserved,
     {"Reserved", "wlan.hs20.anqp.reserved",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_payload,
     {"Payload", "wlan.hs20.anqp.payload",
      FT_BYTES, BASE_NONE, NULL, 0,
      "Hotspot 2.0 ANQP Payload", HFILL }},

    {&hf_ieee80211_hs20_anqp_hs_query_list,
     {"Queried Subtype", "wlan.hs20.anqp.hs_query_list",
      FT_UINT8, BASE_DEC, VALS(hs20_anqp_subtype_vals), 0,
      "Queried HS 2.0 Element Subtype", HFILL }},

    {&hf_ieee80211_hs20_anqp_hs_capability_list,
     {"Capability", "wlan.hs20.anqp.hs_capability_list",
      FT_UINT8, BASE_DEC, VALS(hs20_anqp_subtype_vals), 0,
      "Hotspot 2.0 ANQP Subtype Capability", HFILL }},

    {&hf_ieee80211_hs20_anqp_ofn_length,
     {"Length", "wlan.hs20.anqp.ofn.length",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Operator Friendly Name Length", HFILL }},

    {&hf_ieee80211_hs20_anqp_ofn_language,
     {"Language Code", "wlan.hs20.anqp.ofn.language",
      FT_STRING, BASE_NONE, NULL, 0,
      "Operator Friendly Name Language Code", HFILL }},

    {&hf_ieee80211_hs20_anqp_ofn_name,
     {"Operator Friendly Name", "wlan.hs20.anqp.ofn.name",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_wan_metrics_link_status,
     {"Link Status", "wlan.hs20.anqp.wan_metrics.link_status",
      FT_UINT8, BASE_DEC, VALS(hs20_wm_link_status_vals), 0x03, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_wan_metrics_symmetric_link,
     {"Symmetric Link", "wlan.hs20.anqp.wan_metrics.symmetric_link",
      FT_UINT8, BASE_DEC, NULL, 0x04, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_wan_metrics_at_capacity,
     {"At Capacity", "wlan.hs20.anqp.wan_metrics.at_capacity",
      FT_UINT8, BASE_DEC, NULL, 0x08, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_wan_metrics_reserved,
     {"Reserved", "wlan.hs20.anqp.wan_metrics.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xf0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_wan_metrics_downlink_speed,
     {"Downlink Speed", "wlan.hs20.anqp.wan_metrics.downlink_speed",
      FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_wan_metrics_uplink_speed,
     {"Uplink Speed", "wlan.hs20.anqp.wan_metrics.uplink_speed",
      FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_wan_metrics_downlink_load,
     {"Downlink Load", "wlan.hs20.anqp.wan_metrics.downlink_load",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_wan_metrics_uplink_load,
     {"Uplink Load", "wlan.hs20.anqp.wan_metrics.uplink_load",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_wan_metrics_lmd,
     {"LMD", "wlan.hs20.anqp.wan_metrics.lmd",
      FT_UINT16, BASE_DEC, NULL, 0, "Load Measurement Duration", HFILL }},

    {&hf_ieee80211_hs20_anqp_cc_proto_ip_proto,
     {"IP Protocol", "wlan.hs20.anqp.cc.ip_proto",
      FT_UINT8, BASE_DEC, VALS(hs20_cc_proto_vals), 0,
      "ProtoPort Tuple - IP Protocol", HFILL }},

    {&hf_ieee80211_hs20_anqp_cc_proto_port_num,
     {"Port Number", "wlan.hs20.anqp.cc.port_num",
      FT_UINT16, BASE_DEC, VALS(hs20_cc_port_vals), 0,
      "ProtoPort Tuple - Port Number", HFILL }},

    {&hf_ieee80211_hs20_anqp_cc_proto_status,
     {"Status", "wlan.hs20.anqp.cc.status",
      FT_UINT8, BASE_DEC, VALS(hs20_cc_status_vals), 0,
      "ProtoPort Tuple - Status", HFILL }},

    {&hf_ieee80211_hs20_anqp_nai_hrq_count,
     {"NAI Home Realm Count", "wlan.hs20.anqp.nai_hrq.count",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_nai_hrq_encoding_type,
     {"NAI Home Realm Encoding Type",
      "wlan.hs20.anqp.nai_hrq.encoding_type",
      FT_UINT8, BASE_DEC, VALS(nai_realm_encoding_vals),
      0x01, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_nai_hrq_length,
     {"NAI Home Realm Name Length", "wlan.hs20.anqp.nai_hrq.length",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_nai_hrq_realm_name,
     {"NAI Home Realm Name", "wlan.hs20.anqp.nai_hrq.name",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_oper_class_indic,
     {"Operating Class", "wlan.hs20.anqp.oper_class_indic.oper_class",
      FT_UINT8, BASE_DEC | BASE_RANGE_STRING, RVALS(oper_class_rvals),
      0, NULL, HFILL }},

    {&hf_ieee80211_hs20_osu_friendly_names_len,
     {"OSU Friendly Name Length", "wlan.hs20.osu_friendly_names_len",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_osu_friendly_name_length,
     {"Length", "wlan.hs20.osu_friendly_name.len",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_osu_friendly_name_language,
     {"Language Code", "wlan.hs20.osu_friendly_name.language",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_osu_friendly_name_name,
     {"OSU Friendly Name", "wlan.hs20.osu_friendly_name.name",
     FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_osu_server_uri_len,
     {"OSU Server URI Length", "wlan.hs20.osu_server_uri_len",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_osu_server_uri,
     {"OSU Server URI", "wlan.hs20.osu_server_uri",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_osu_method_list_len,
     {"OSU Method List Length", "wlan.hs20.osu_method_list_len",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_osu_method_val,
     {"OSU Method", "wlan.hs20.osu_method_list.method",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_icons_avail_len,
     {"Icons Available Length", "wlan.hs20.osu_icons_avail_len",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_osu_providers_list_ssid_len,
     {"SSID Length", "wlan.hs20.anqp_osu_prov_list.ssid_len",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_osu_providers_ssid,
     {"SSID", "wlan.hs20.anqp_osu_prov_list.ssid",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_osu_providers_count,
     {"Number of OSU Providers", "wlan.hs20.anqp_osu_prov_list.number",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_osu_prov_length,
     {"OSU Provider Length", "wlan.hs20.anqp_osu_prov.len",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_icon_request_filename,
     {"Icon Filename", "wlan.hs20.anqp_icon_request.icon_filename",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_osu_icon_avail_width,
     {"Icon Width", "wlan.hs20.osu_icons_avail.icon_width",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_osu_icon_avail_height,
     {"Icon Height", "wlan.hs20.osu_icons_avail.icon_height",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_osu_icon_avail_lang_code,
     {"Language Code", "wlan.hs20.osu_icons_avail.lang_code",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_osu_icon_avail_icon_type_len,
     {"Icon Type Length", "wlan.hs20.osu_icons_avail.icon_type_len",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_osu_icon_avail_icon_type,
     {"Icon Type", "wlan.hs20.osu_icons_avail.icon_type",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_osu_icon_avail_filename_len,
     {"Icon Filename Length", "wlan.hs20.osu_icons_avail.icon_filename_len",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_osu_icon_avail_filename,
     {"Icon Filename", "wlan.hs20.osu_icons_avail.icon_filename",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_osu_nai_len,
     {"OSU_NAI Length", "wlan.hs20.osu_nai.len",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_osu_nai,
     {"OSU_NAI", "wlan.hs20.osu_nai",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_osu_service_desc_len,
     {"OSU Service Description Length", "wlan.hs20.osu_service_desc_len",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_osu_service_desc_duple_len,
     {"Length", "wlan.hs20.osu_service_desc.duple.len",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_osu_service_desc_lang,
     {"Language Code", "wlan.hs20.osu_service_desc.duple.lang",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_osu_service_desc,
     {"OSU Service Description", "wlan.hs20.osu_service_desc.duple.desc",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_icon_binary_file_status,
     {"Download Status Code", "wlan.hs20.anqp_icon_request.download_status",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_icon_type_length,
     {"Icon Type Length", "wlan.hs20.anqp_icon_request.icon_type_len",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_icon_type,
     {"Icon Type", "wlan.hs20.anqp_icon_request.icon_type",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_icon_binary_data_len,
     {"Icon Binary Data Length", "wlan.anqp_icon_request.icon_binary_data_len",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_icon_binary_data,
     {"Icon Binary Data", "wlan.h220.anqp_icon_request.icon_binary_data",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_subscription_remediation_url_len,
     {"Server URL Length", "wlan.hs20.subs_remediation.server_url_len",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_subscription_remediation_server_url,
     {"Server URL", "wlan.hs20.subs_remediation.server_url",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_subscription_remediation_server_method,
     {"Server Method", "wlan.hs20.subs_remediation.server_method",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_deauth_reason_code,
     {"De-Auth Reason Code", "wlan.hs20.deauth.reason_code",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_reauth_delay,
     {"Re-Auth Delay", "wlan.hs20.deauth.reauth_delay",
      FT_UINT16, BASE_DEC|BASE_UNIT_STRING, UNS(&units_seconds), 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_deauth_reason_url_len,
     {"Reason URL Length", "wlan.hs20.deauth.reason_url_len",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_deauth_imminent_reason_url,
     {"Reason URL", "wlan.hs20.deauth.reason_url",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_venue_url_length,
     {"Length", "wlan.hs20.venue_url.len",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_venue_number,
     {"Venue number", "wlan.hs20.venue_url.venue_num",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_venue_url,
     {"Venue URL", "wlan.hs20.venue_url.url",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_advice_of_charge_length,
     {"Length", "wlan.hs20.advice_of_charge.len",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_advice_of_charge_type,
     {"Advice of Charge Type", "wlan.hs20.advice_of_charge.type",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_aoc_nai_realm_encoding,
     {"NAI Realm Encoding", "wlan.hs20.advice_of_charge.nai_realm_enc",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_aoc_nai_realm_len,
     {"NAI Realm Length", "wlan.hs20.advice_of_charge.nai_realm_len",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_aoc_nai_realm,
     {"NAI Realm", "wlan.hs20.advice_of_charge.nai_realm",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_aoc_plan_len,
     {"Plan length", "wlan.hs20.advice_of_charge.plan_info_tuples.plan_len",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_aoc_plan_lang,
     {"Plan language", "wlan.hs20.advice_of_charge.plan_info_tuples.plan_lang",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_aoc_plan_curcy,
     {"Plan currency", "wlan.hs20.advice_of_charge.plan_info_tuples.plan_curcy",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_hs20_anqp_aoc_plan_information,
     {"Plan information", "wlan.hs20.advice_of_charge.plan_info_tuples.info",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag,
     {"Tag", "wlan.tag",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_number,
     {"Tag Number", "wlan.tag.number",
      FT_UINT8, BASE_DEC|BASE_EXT_STRING, &tag_num_vals_ext, 0,
      "Element ID", HFILL }},

    {&hf_ieee80211_tag_length,
     {"Tag length", "wlan.tag.length",
      FT_UINT32, BASE_DEC, NULL, 0,
      "Length of tag", HFILL }},

    {&hf_ieee80211_tag_data,
     {"Tag Data", "wlan.tag.data",
      FT_BYTES, BASE_NONE, NULL, 0,
      "Data Interpretation of tag", HFILL }},

    {&hf_ieee80211_tag_oui,
     {"OUI", "wlan.tag.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      "OUI of vendor specific IE", HFILL }},

    {&hf_ieee80211_tag_oui_wfa_subtype,
     {"WFA Subtype", "wlan.tag.oui.wfa_subtype",
      FT_UINT8, BASE_DEC, VALS(wfa_subtype_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ds_param_channel,
     {"Current Channel", "wlan.ds.current_channel",
      FT_UINT8, BASE_DEC, NULL, 0,
      "DS Parameter Set - Current Channel", HFILL }},

    {&hf_ieee80211_tag_cfp_count,
     {"CFP Count", "wlan.cfp.count",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Indicates how many delivery traffic indication messages (DTIMs)", HFILL }},

    {&hf_ieee80211_tag_cfp_period,
     {"CFP Period", "wlan.cfp.period",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Indicates the number of DTIM intervals between the start of CFPs", HFILL }},

    {&hf_ieee80211_tag_cfp_max_duration,
     {"CFP Max Duration", "wlan.cfp.max_duration",
      FT_UINT16, BASE_DEC, NULL, 0,
      "Indicates the maximum duration (in TU) of the CFP that may be generated by this PCF", HFILL }},

    {&hf_ieee80211_tag_cfp_dur_remaining,
     {"CFP Dur Remaining", "wlan.cfp.dur_remaining",
      FT_UINT16, BASE_DEC, NULL, 0,
      "Indicates the maximum time (in TU) remaining in the present CFP", HFILL }},

    {&hf_ieee80211_tag_vendor_oui_type,
     {"Vendor Specific OUI Type", "wlan.tag.vendor.oui.type",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_vendor_data,
     {"Vendor Specific Data", "wlan.tag.vendor.data",
      FT_BYTES, BASE_NONE, NULL, 0,
      "Unknown/undecoded Vendor Specific Data", HFILL }},

    {&hf_ieee80211_symbp_extreme_assoc_clients,
     {"Associated clients", "wlan.tag.symbol_proprietary.extreme.assoc_clients",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_symbp_extreme_load_kbps,
     {"Load", "wlan.tag.symbol_proprietary.extreme.load_kbps",
      FT_UINT16, BASE_DEC|BASE_UNIT_STRING, UNS(&units_kbps), 0,
      NULL, HFILL }},

    {&hf_ieee80211_symbp_extreme_load_pps,
     {"Load", "wlan.tag.symbol_proprietary.extreme.load_pps",
      FT_UINT16, BASE_DEC|BASE_UNIT_STRING, UNS(&units_pkts_per_sec), 0,
      NULL, HFILL }},

    {&hf_ieee80211_symbp_extreme_client_tx_power,
     {"Desired client Tx power", "wlan.tag.symbol_proprietary.extreme.client_txpower",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_symbp_extreme_timestamp,
     {"Timestamp", "wlan.tag.symbol_proprietary.extreme.timestamp",
      FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_symbol_proprietary_oui,
     {"Symbol Proprietary OUI", "wlan.tag.symbol_proprietary.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_symbol_proprietary_data,
     {"Symbol Proprietary Data", "wlan.tag.symbol_proprietary.data",
      FT_BYTES, BASE_NONE, NULL, 0,
      "Unknown/undecoded Symbol Proprietary Data", HFILL }},

    {&hf_ieee80211_tim_dtim_count,
     {"DTIM count", "wlan.tim.dtim_count",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Indicates how many Beacon frames (including the current frame) appear before the next DTIM", HFILL }},

    {&hf_ieee80211_tim_dtim_period,
     {"DTIM period", "wlan.tim.dtim_period",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Indicates the number of beacon intervals between successive DTIMs", HFILL }},

    {&hf_ieee80211_tim_bmapctl,
     {"Bitmap control", "wlan.tim.bmapctl",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tim_bmapctl_mcast,
     {"Multicast", "wlan.tim.bmapctl.multicast",
      FT_BOOLEAN, 8, NULL, 0x1,
      "Contains the Traffic Indicator bit associated with Association ID 0", HFILL }},

    {&hf_ieee80211_tim_bmapctl_offset,
     {"Bitmap Offset", "wlan.tim.bmapctl.offset",
      FT_UINT8, BASE_HEX, NULL, 0xFE,
      NULL, HFILL }},

    {&hf_ieee80211_tim_partial_virtual_bitmap,
     {"Partial Virtual Bitmap", "wlan.tim.partial_virtual_bitmap",
      FT_BYTES, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tim_aid,
     {"Association ID", "wlan.tim.aid",
      FT_UINT16, BASE_HEX, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ibss_atim_window,
     {"Atim Windows", "wlan.ibss.atim_windows",
      FT_UINT16, BASE_HEX, NULL, 0x0,
      "Contains the ATIM Window length in TU", HFILL }},

    {&hf_ieee80211_tag_country_info_code,
     {"Code", "wlan.country_info.code",
      FT_STRING, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_country_info_env,
     {"Environment", "wlan.country_info.environment",
      FT_UINT8, BASE_DEC|BASE_SPECIAL_VALS, VALS(environment_vals), 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_country_info_pad,
     {"Padding", "wlan.country_info.padding",
      FT_BYTES, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_country_info_fnm,
     {"Country Info", "wlan.country_info.fnm",
      FT_NONE, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_country_info_fnm_fcn,
     {"First Channel Number", "wlan.country_info.fnm.fcn",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_country_info_fnm_nc,
     {"Number of Channels", "wlan.country_info.fnm.nc",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_country_info_fnm_mtpl,
     {"Maximum Transmit Power Level", "wlan.country_info.fnm.mtpl",
      FT_INT8, BASE_DEC|BASE_UNIT_STRING, UNS(&units_dbm), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_country_info_rrc,
     {"Country Info", "wlan.country_info.rrc",
      FT_NONE, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_country_info_rrc_oei,
     {"Operating Extension Identifier", "wlan.country_info.rrc.oei",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_country_info_rrc_oc,
     {"Operating Class", "wlan.country_info.rrc.oc",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_country_info_rrc_cc,
     {"Coverage Class", "wlan.country_info.rrc.cc",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_fh_hopping_parameter_prime_radix,
     {"Prime Radix", "wlan.fh_hopping.parameter.prime_radix",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_fh_hopping_parameter_nb_channels,
     {"Number of Channels", "wlan.fh_hopping.parameter.nb_channels",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_fh_hopping_table_flag,
     {"Flag", "wlan.fh_hopping.table.flag",
      FT_UINT8, BASE_HEX, NULL, 0x0,
      "Indicates that a Random Table is present when the value is 1", HFILL }},

    {&hf_ieee80211_tag_fh_hopping_table_number_of_sets,
     {"Number of Sets", "wlan.fh_hopping.table.number_of_sets",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      "Indicates the total number of sets within the hopping patterns", HFILL }},

    {&hf_ieee80211_tag_fh_hopping_table_modulus,
     {"Modulus", "wlan.fh_hopping.table.modulus",
      FT_UINT8, BASE_HEX, NULL, 0x0,
      "Indicate the values to be used in the equations to create a hopping sequence from the Random Table information", HFILL }},

    {&hf_ieee80211_tag_fh_hopping_table_offset,
     {"Offset", "wlan.fh_hopping.table.offset",
      FT_UINT8, BASE_HEX, NULL, 0x0,
      "Indicate the values to be used in the equations to create a hopping sequence from the Random Table information", HFILL }},

    {&hf_ieee80211_tag_fh_hopping_random_table,
     {"Random Table", "wlan.fh_hopping.table.random_table",
      FT_UINT16, BASE_HEX, NULL, 0x0,
      "It is a vector of single octet values that indicate the random sequence to be followed during a hopping sequence", HFILL }},

    {&hf_ieee80211_tag_request,
     {"Requested Element ID", "wlan.tag.request",
      FT_UINT8, BASE_DEC|BASE_EXT_STRING, &tag_num_vals_ext, 0,
      "The list of elements that are to be included in the responding STA Probe Response frame", HFILL }},

    {&hf_ieee80211_tag_extended_request_id,
     {"Requested Element ID", "wlan.tag.extended_request.id",
      FT_UINT8, BASE_DEC|BASE_EXT_STRING, &tag_num_vals_ext, 0,
      "The Element ID used to indicate an extended element", HFILL }},

    {&hf_ieee80211_tag_extended_request_extension,
     {"Requested Element ID Extensions", "wlan.tag.extended_request.ext",
      FT_UINT8, BASE_DEC|BASE_EXT_STRING, &tag_num_vals_eid_ext_ext, 0,
      "The list of elements extensions that are to be included in the responding STA Probe Response frame", HFILL }},

    {&hf_ieee80211_tclas_up,
     {"User Priority", "wlan.tclas.user_priority",
      FT_UINT8, BASE_DEC|BASE_RANGE_STRING, RVALS(user_prio_rvals), 0,
      "Contains the value of the UP of the associated MSDUs", HFILL }},

    {&hf_ieee80211_tclas_class_type,
     {"Classifier Type", "wlan.tclas.class_type",
      FT_UINT8, BASE_DEC|BASE_RANGE_STRING, RVALS(classifier_type), 0,
      "Specifies the type of classifier parameters", HFILL }},

    {&hf_ieee80211_tclas_class_mask,
     {"Classifier Mask", "wlan.tclas.class_mask",
      FT_UINT8, BASE_HEX,  NULL, 0,
      "Specifies a bitmap where bits that are set to 1 identify a subset of the classifier parameters", HFILL }},

    {&hf_ieee80211_tclas_mask_reserved,
     {"Reserved", "wlan.tclas.class_mask.reserved",
      FT_UINT8, BASE_HEX, NULL, 0, "Class mask is reserved", HFILL }},

    {&hf_ieee80211_tclas_class_mask0_src_addr,
     {"Source Address", "wlan.tclas.class_mask.src_addr",
      FT_UINT8, BASE_HEX, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask0_dst_addr,
     {"Destination Address", "wlan.tclas.class_mask.dst_addr",
      FT_UINT8, BASE_HEX, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask0_type,
     {"Type", "wlan.tclas.class_mask.type",
      FT_UINT8, BASE_HEX, NULL, 0x04, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask1_ver,
     {"Version", "wlan.tclas.class_mask.version",
      FT_UINT8, BASE_HEX, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask1_src_ip,
     {"Source IP Address", "wlan.tclas.class_mask.src_ip",
      FT_UINT8, BASE_HEX, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask1_dst_ip,
     {"Destination IP Address", "wlan.tclas.class_mask.dst_ip",
      FT_UINT8, BASE_HEX, NULL, 0x04, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask1_src_port,
     {"Source Port", "wlan.tclas.class_mask.src_port",
      FT_UINT8, BASE_HEX, NULL, 0x08, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask1_dst_port,
     {"Destination Port", "wlan.tclas.class_mask.dst_port",
      FT_UINT8, BASE_HEX, NULL, 0x10, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask1_ipv4_dscp,
     {"DSCP", "wlan.tclas.class_mask.dscp",
      FT_UINT8, BASE_HEX, NULL, 0x20, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask1_ipv4_proto,
     {"Protocol", "wlan.tclas.class_mask.proto",
      FT_UINT8, BASE_HEX, NULL, 0x40, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask1_ipv6_flow,
     {"Flow Label", "wlan.tclas.class_mask.flow_label",
      FT_UINT8, BASE_HEX, NULL, 0x20, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask1_reserved,
     {"Reserved", "wlan.tclas.class_mask.reserved",
      FT_UINT8, BASE_HEX, NULL, 0x80, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask2_tci,
     {"802.1Q CLAN TCI", "wlan.tclas.class_mask.tci",
      FT_UINT8, BASE_HEX, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_tclas_src_mac_addr,
     {"Source address", "wlan.tclas.src_mac_addr",
      FT_ETHER, BASE_NONE, NULL, 0,
      "Classifier Parameters Ethernet Type", HFILL }},

    {&hf_ieee80211_tclas_dst_mac_addr,
     {"Destination address", "wlan.tclas.dat_mac_addr",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tclas_ether_type,
     {"Ethernet Type", "wlan.tclas.ether_type",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tclas_version,
     {"IP Version", "wlan.tclas.version",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tclas_ipv4_src,
     {"IPv4 Src Addr", "wlan.tclas.ipv4_src",
      FT_IPv4, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tclas_ipv4_dst,
     {"IPv4 Dst Addr", "wlan.tclas.ipv4_dst",
      FT_IPv4, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tclas_src_port,
     {"Source Port", "wlan.tclas.src_port",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tclas_dst_port,
     {"Destination Port", "wlan.tclas.dst_port",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tclas_dscp,
     {"IPv4 DSCP", "wlan.tclas.dscp",
      FT_UINT8, BASE_HEX, NULL, 0,
      "IPv4 Differentiated Services Code Point (DSCP) Field", HFILL }},

    {&hf_ieee80211_tclas_protocol,
     {"Protocol", "wlan.tclas.protocol",
      FT_UINT8, BASE_HEX, NULL, 0,
      "IPv4 Protocol", HFILL }},

    {&hf_ieee80211_tclas_ipv6_src,
     {"IPv6 Src Addr", "wlan.tclas.ipv6_src",
      FT_IPv6, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tclas_ipv6_dst,
     {"IPv6 Dst Addr", "wlan.tclas.ipv6_dst",
      FT_IPv6, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tclas_flow,
     {"Flow Label", "wlan.tclas.flow",
      FT_UINT24, BASE_HEX, NULL, 0,
      "IPv6 Flow Label", HFILL }},

    {&hf_ieee80211_tclas_tag_type,
     {"802.1Q Tag Type", "wlan.tclas.tag_type",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tclas_filter_offset,
     {"Filter Offset", "wlan.tclas.filter_offset",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas_filter_value,
     {"Filter Value", "wlan.tclas.filter_value",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas_filter_mask,
     {"Filter Mask", "wlan.tclas.filter_mask",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas4_version,
     {"Version", "wlan.tclas.class4.version",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask4_ver,
     {"Version", "wlan.tclas.class4.mask.version",
      FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x01, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask4_4_src_ip,
     {"Source IP (IPv4)", "wlan.tclas.class4.mask.ipv4_src",
      FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x02, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask4_4_dst_ip,
     {"Destination IP (IPv4)", "wlan.tclas.class4.mask.ipv4_dst",
      FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x04, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask4_src_port,
     {"Source Port", "wlan.tclas.class4.mask.src_port",
      FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x08, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask4_dst_port,
     {"Destination Port", "wlan.tclas.class4.mask.dst_port",
      FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x10, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask4_dscp,
     {"DSCP", "wlan.tclas.class4.mask.dscp",
      FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x20, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask4_ipv4_proto,
     {"Protocol", "wlan.tclas.class4.mask.protocol",
      FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x40, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask4_reserved,
     {"Reserved", "wlan.tclas.class4.mask.reserved",
      FT_UINT8, BASE_HEX, NULL, 0x80, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask4_6_src_ip,
     {"Source IP (IPv6)", "wlan.tclas.class4.mask.ipv6_src",
      FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x02, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask4_6_dst_ip,
     {"Destination IP (IPv6)", "wlan.tclas.class4.mask.ipv6_dst",
      FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x04, NULL, HFILL }},

    {&hf_ieee80211_tclas_reserved_bytes,
     {"Reserved", "wlan.tclas.reserved",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask4_next_hdr,
     {"Next Header", "wlan.tclas.class4.mask.next_header",
      FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x40, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask4_flow_label,
     {"Flow Label", "wlan.tclas.class4.mask.flow_label",
      FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x80, NULL, HFILL }},

    {&hf_ieee80211_tclas4_ipv4_src,
     {"Source IP (IPv4)", "wlan.tclas.class4.ipv4_src_ip",
      FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas4_ipv4_dst,
     {"Destination IP (IPv4)", "wlan.tclas.class4.ipv4_dst_ip",
      FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas4_src_port,
     {"Source Port", "wlan.tclas.class4.src_port",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas4_dst_port,
     {"Destination Port", "wlan.tclas.class4.dst_port",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas4_dscp,
     {"DSCP", "wlan.tclas.class4.dscp",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas4_protocol,
     {"Protocol", "wlan.tclas.class4.protocol",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas4_reserved,
     {"Reserved", "wlan.tclas.class4.reserved",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas4_ipv6_src,
     {"Source IP (IPv6)", "wlan.tclas.class4.ipv6_src_ip",
      FT_IPv6, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas4_ipv6_dst,
     {"Destination IP (IPv6)", "wlan.tclas.class4.ipv6_dst_ip",
      FT_IPv6, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas4_next_hdr,
     {"Next Header", "wlan.tclas.class4.next_header",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas4_flow,
     {"Flow Label", "wlan.tclas.class4.flow_label",
      FT_UINT24, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas_tclas_8021d_up_pcp,
     {"802.1D UP/802.1Q Priority Code Point", "wlan.tclas.class4.8021dq_up_pcp",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas_8021q_dei,
     {"802.1Q DEI", "wlan.tclas.class4.8021q_dei",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas_8021q_vid,
     {"802.1Q VID", "wlan.tclas.class4.8021q_vid",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask5_up_prio,
     {"802.1D UP/802.1Q PCP", "wlan.tclas.class5.mask.8021dq_up_prio",
      FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x01, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask5_dei,
     {"802.1Q DEI", "wlan.tclas.class4.mask.8021q_dei",
      FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x02, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask5_vid,
     {"802.1Q VID", "wlan.tclas.class4.mask.8021q_vid",
      FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask5_reserved,
     {"Reserved", "wlan.tclas.class5.mask.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xF8, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask6_a_above,
     {"Classifier Mask", "wlan.tclas.class6-9.mask",
      FT_UINT24, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask6_frame_control_match_spec,
     {"Frame Control", "wlan.tclas.class6.mask.frame_control",
      FT_UINT24, BASE_HEX, VALS(frame_control_mask_vals),
      0x000003, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask6_duration_id_match_spec,
     {"Duration ID", "wlan.tclas.class6.mask.duration_id",
      FT_UINT24, BASE_HEX, VALS(duration_id_mask_vals),
      0x0000C0, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask6_address_1_match_spec,
     {"Address 1", "wlan.tclas.class6.mask.address_1",
      FT_UINT24, BASE_HEX, VALS(address_1_mask_vals), 0x000300, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask6_address_2_match_spec,
     {"Address 2", "wlan.tclas.class6.mask.address_2",
      FT_UINT24, BASE_HEX, VALS(address_2_mask_vals), 0x000C00, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask6_address_3_match_spec,
     {"Address 3", "wlan.tclas.class6.mask.address_3",
      FT_UINT24, BASE_HEX, VALS(address_3_mask_vals), 0x003000, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask6_sequence_control_spec,
     {"Sequence Control", "wlan.tclas.class6.mask.sequence_control",
      FT_UINT24, BASE_HEX, VALS(sequence_control_mask_vals),
      0x00C000, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask6_address_4_match_spec,
     {"Address 4", "wlan.tclas.class6.mask.address_4",
      FT_UINT24, BASE_HEX, VALS(address_4_mask_vals), 0x030000, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask6_qos_control_spec,
     {"QoS Control", "wlan.tclas.class6.mask.qos_control",
      FT_UINT24, BASE_HEX, VALS(qos_control_mask_vals),
      0x0C0000, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask6_ht_control_spec,
     {"HT Control", "wlan.tclas.class6.mask.ht_control",
      FT_UINT24, BASE_HEX, VALS(ht_control_mask_vals), 0x300000, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask6_reserved,
     {"Reserved", "wlan.tclas.class6.mask.reserved",
      FT_UINT24, BASE_HEX, NULL, 0xC00000, NULL, HFILL }},

    {&hf_ieee80211_tclas6_frame_control_spec,
     {"Frame Control Spec", "wlan.tclas.class6.frame_control_spec",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas6_frame_control_mask,
     {"Frame Control Mask", "wlan.tclas.class6.frame_control_mask",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas6_duration_spec,
     {"Duration Spec", "wlan.tclas.class6.duration_spec",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas6_duration_mask,
     {"Duration Mask", "wlan.tclas.class6.duration_mask",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas6_address_1_spec,
     {"Address 1 Spec", "wlan.tclas.class6.address_1_spec",
      FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas6_address_1_mask,
     {"Address 1 Mask", "wlan.tclas.class6.address_1_mask",
      FT_UINT48, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas6_address_2_spec,
     {"Address 2 Spec", "wlan.tclas.class6.address_2_spec",
      FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas6_address_2_mask,
     {"Address 2 Mask", "wlan.tclas.class6.address_2_mask",
      FT_UINT48, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas6_address_3_spec,
     {"Address 3 Spec", "wlan.tclas.class6.address_3_spec",
      FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas6_address_3_mask,
     {"Address 3 Mask", "wlan.tclas.class6.address_3_mask",
      FT_UINT48, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas6_sequence_control_spec,
     {"Sequence Control Spec", "wlan.tclas.class6.sequence_control_spec",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas6_sequence_control_mask,
     {"Sequence Control Mask", "wlan.tclas.class6.sequence_control_mask",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas6_address_4_spec,
     {"Address 4 Spec", "wlan.tclas.class6.address_4_spec",
      FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas6_address_4_mask,
     {"Address 4 Mask", "wlan.tclas.class6.address_4_mask",
      FT_UINT48, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas6_qos_control_spec,
     {"QoS Control Spec", "wlan.tclas.class6.qos_control_spes",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas6_qos_control_mask,
     {"QoS Control Mask", "wlan.tclas.class6.qos_control_mask",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas6_ht_control_spec,
     {"HT Control Spec", "wlan.tclas.class6.ht_control_spec",
      FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas6_ht_control_mask,
     {"HT Control Mask", "wlan.tclas.class6.ht_control_mask",
      FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask7_frame_control_match_spec,
     {"Frame Control Match", "wlan.tclas.class7.frame_control_spec",
      FT_UINT24, BASE_HEX, VALS(frame_control_mask_vals),
      0x000003, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask7_address_1_sid_match_spec,
     {"Address 1 (SID) Spec", "wlan.tclas.class4.address_1_sid_spec",
      FT_UINT24, BASE_HEX, VALS(address_1_sid_mask_vals),
      0x00000C, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask7_address_2_match_spec,
     {"Address 2 Spec", "wlan.tclas.class7.address_2i_match_spec",
      FT_UINT24, BASE_HEX, VALS(address_2_mask_vals), 0x000030, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask7_sequence_control_spec,
     {"Sequence Control Spec", "wlan.tclas.class7.sequence_control_spec",
      FT_UINT24, BASE_HEX, VALS(sequence_control_mask_vals),
      0x0000C0, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask7_address_3_match_spec,
     {"Address 3 Spec", "wlan.tclas.class7.address_3_match_spec",
      FT_UINT24, BASE_HEX, VALS(address_3_mask_vals), 0x000c00, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask7_address_4_match_spec,
     {"Address 4 Spec", "wlan.tclas.class7.address_4_match_spec",
      FT_UINT24, BASE_HEX, VALS(address_4_mask_vals), 0x003000, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask7_reserved,
     {"Reserved", "wlan.tclas.class7.reserved",
      FT_UINT24, BASE_HEX, NULL, 0xFFC000, NULL, HFILL }},

    {&hf_ieee80211_tclas7_frame_control_spec,
     {"Frame Control Spec", "wlan.tclas.class7.frame_control_spec",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas7_frame_control_mask,
     {"Frame Control Mask", "wlan.tclas.class7.frame_control_mask",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas7_address_1_sid_spec,
     {"Address 1 (SID) Spec", "wlan.tclas.class7.address_1_sid_spec",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas7_address_1_sid_mask,
     {"Address 1 (SID) Mask", "wlan.tclas.class7.address_1_sid_mask",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas7_address_2_spec,
     {"Address 2 Spec", "wlan.tclas.class7.address_2_spec",
      FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas7_address_2_mask,
     {"Address 2 Mask", "wlan.tclas.class7.address_2_mask",
      FT_UINT48, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas7_sequence_control_spec,
     {"Sequence Control Spec", "wlan.tclas.class7.sequence_control_spec",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas7_sequence_control_mask,
     {"Sequence Control Mask", "wlan.tclas.class7.sequence_control_mask",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas7_address_3_spec,
     {"Address 3 Spec", "wlan.tclas.class7.address_3_spec",
      FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas7_address_3_mask,
     {"Address 3 Mask", "wlan.tclas.class7.address_3_mask",
      FT_UINT48, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas7_address_4_spec,
     {"Address 4 Spec", "wlan.tclas.class4.address_4_spec",
      FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas7_address_4_mask,
     {"Address 4 Mask", "wlan.tclas.class4.address_4_mask",
      FT_UINT48, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask8_frame_control_match_spec,
     {"Frame Control Spec", "wlan.tclas.class8.mask.frame_control_spec",
      FT_UINT24, BASE_HEX, VALS(frame_control_mask_vals),
      0x000003, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask8_address_1_bssid_match_spec,
     {"Address 1 (BSSID) Spec", "wlan.tclas.class8.mask.address_1_bssid_spec",
      FT_UINT24, BASE_HEX, VALS(address_1_bssid_mask_vals),
      0x00000C, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask8_address_2_sid_match_spec,
     {"Address 2 (SID) Spec", "wlan.tclas.class8.mask.address_2_sid_spec",
      FT_UINT24, BASE_HEX, VALS(address_2_mask_vals), 0x000030, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask8_sequence_control_spec,
     {"Sequence Control Spec", "wlan.tclas.class8.mask.sequence_control_spec",
      FT_UINT24, BASE_HEX, VALS(sequence_control_mask_vals),
      0x0000C0, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask8_address_3_match_spec,
     {"Address 3 Spec", "wlan.tclas.class8.mask.address_3_spec",
      FT_UINT24, BASE_HEX, VALS(address_3_mask_vals), 0x000300, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask8_address_4_match_spec,
     {"Address 4 Spec", "wlan.tclas.class8.mask.address_4_spec",
      FT_UINT24, BASE_HEX, VALS(address_4_mask_vals), 0x000C00, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask8_reserved,
     {"Reserved", "wlan.tclas.class8.reserved",
      FT_UINT24, BASE_HEX, NULL, 0xFFF000, NULL, HFILL }},

    {&hf_ieee80211_tclas8_frame_control_spec,
     {"Frame Control Spec", "wlan.tclas.class8.frame_control_spec",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas8_frame_control_mask,
     {"Frame Control Mask", "wlan.tclas.class8.frame_control_mask",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas8_address_1_bssid_spec,
     {"Address 1 (BSSID) Spec", "wlan.tclas.class8.address_1_bssid_spec",
      FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas8_address_1_bssid_mask,
     {"Address 1 (BSSID) Mask", "wlan.tclas.class8.address_1_bssid_mask",
      FT_UINT48, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas8_address_2_sid_spec,
     {"Address 2 (SID) Spec", "wlan.tclas.class8.address_2_sid_spec",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas8_address_2_sid_mask,
     {"Address 2 (SID) Spec", "wlan.tclas.class8.address_2_sid_spec",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas8_sequence_control_spec,
     {"Sequence Control Spec", "wlan.tclas.class8.sequence_control_spec",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas8_sequence_control_mask,
     {"Sequence Control Mask", "wlan.tclas.class8.sequence_control_mask",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas8_address_3_spec,
     {"Address 3 Spec", "wlan.tclas.class8.address_3_spec",
      FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas8_address_3_mask,
     {"Address 3 Mask", "wlan.tclas.class8.address_3_mask",
      FT_UINT48, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas8_address_4_spec,
     {"Address 4 Spec", "wlan.tclas.class8.address_4_spec",
      FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas8_address_4_mask,
     {"Address 4 Mask", "wlan.tclas.class8.address_4_mask",
      FT_UINT48, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask9_frame_control_match_spec,
     {"Frame Control Spec", "wlan.tclas.class9.frame_control_spec",
      FT_UINT24, BASE_HEX, VALS(frame_control_mask_vals), 0x000003, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask9_address_1_match_spec,
     {"Address 1 Spec", "wlan.tclas.class9.mask.address_1_spec",
      FT_UINT24, BASE_HEX, VALS(address_1_mask_vals), 0x00000C, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask9_address_2_match_spec,
     {"Address 2 Spec", "wlan.tclas.class9.mask.address_2_spec",
      FT_UINT24, BASE_HEX, VALS(address_2_mask_vals), 0x000030, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask9_sequence_control_spec,
     {"Sequence Control Spec", "wlan.tclas.class9.mask.sequence_control_spec",
      FT_UINT24, BASE_HEX, VALS(sequence_control_mask_vals),
      0x0000C0, NULL, HFILL }},

    {&hf_ieee80211_tclas_class_mask9_reserved,
     {"Reserved", "wlan.tclas.class9.mask.reserved",
      FT_UINT24, BASE_HEX, NULL, 0xFFFF00, NULL, HFILL }},

    {&hf_ieee80211_tclas9_frame_control_spec,
     {"Frame Control Spec", "wlan.tclas.class9.frame_control_spec",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas9_frame_control_mask,
     {"Frame Control Mask", "wlan.tclas.class9.frame_control_mask",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas9_address_1_spec,
     {"Address 1 Spec", "wlan.tclas.class9.address_1_spec",
      FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas9_address_1_mask,
     {"Address 1 Mask", "wlan.tclas.class9.address_1_mask",
      FT_UINT48, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas9_address_2_spec,
     {"Address 2 Spec", "wlan.tclas.class9.address_2_spec",
      FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas9_address_2_mask,
     {"Address 2 Mask", "wlan.tclas.class9.address_2_mask",
      FT_UINT48, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas9_sequence_control_spec,
     {"Sequence Control Spec", "wlan.tclas.class9.sequence_control_spec",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas9_sequence_control_mask,
     {"Sequence Control Mask", "wlan.tclas.class9.sequence_control_mask",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas10_protocol_instance,
     {"Protocol Instance", "wlan.tclas.class10.protocol_instance",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tclas10_protocol_num_next_hdr,
     {"Protocol Number or Next Header",
       "wlan.tclas.class10.proto_num_or_next_hdr",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_challenge_text,
     {"Challenge Text", "wlan.tag.challenge_text",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_oui_wfa_action_type,
     {"OUI Type", "wlan.action.oui_type",
      FT_UINT8, BASE_HEX, VALS(wfa_action_subtype_vals), 0x0, NULL, HFILL }},

    {&hf_ieee80211_oui_qos_subtype,
     {"OUI Subtype", "wlan.action.dscp_policy.oui_subtype",
      FT_UINT8, BASE_HEX, VALS(wfa_qos_subtype_vals), 0x0, NULL, HFILL }},

    {&hf_ieee80211_oui_qos_mgmt_dialog_token,
     {"Dialog Token", "wlan.action.dscp_policy.dialog_token",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_oui_qos_mgmt_rqst_control,
     {"Request Control", "wlan.action.dscp_policy.request.control",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_oui_qos_mgmt_rq_ctrl_more,
     {"More", "wlan.action.dscp_policy.request.control.more",
      FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_oui_qos_mgmt_rq_ctrl_reset,
     {"Reset", "wlan.action.dscp_policy.request.control.reset",
      FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_oui_qos_mgmt_rq_reserved,
     {"Reserved", "wlan.action.dscp_policy.request.control.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xFC, NULL, HFILL }},

    {&hf_ieee80211_dscp_policy_id,
     {"Policy ID", "wlan.action.dscp_policy_response.policy_id",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_dscp_policy_status,
     {"Status", "wlan.action.dscp_policy_response.policy_status",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_oui_qos_mgmt_resp_control,
     {"Response Control", "wlan.action.dscp_policy.request.control",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_oui_qos_mgmt_rsp_ctrl_more,
     {"More", "wlan.action.dscp_policy.response.control.more",
      FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_oui_qos_mgmt_rsp_ctrl_reset,
     {"Reset", "wlan.action.dscp_policy.response.control.reset",
      FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_oui_qos_mgmt_rsp_reserved,
     {"Reserved", "wlan.action.dscp_policy.response.control.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xFC, NULL, HFILL }},

    {&hf_ieee80211_dscp_policy_scs_sts_list,
     {"Status List", "wlan.action.dscp_policy_response.policy_status_list",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_oui_qos_mgmt_count,
     {"Count", "wlan.action.dscp_policy.response.count",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_tag_he_6ghz_cap_inf,
     {"Capabilities Information", "wlan.tag.he_6ghz.cap_inf",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_he_6ghz_cap_inf_b0_b2,
     {"Minimum MPDU Start Spacing", "wlan.tag.he_6ghz.cap_inf.b0_b2",
      FT_UINT16, BASE_HEX, VALS(s1g_min_mpdu_start_spacing_vals), 0x0007,
      NULL, HFILL }},

    {&hf_ieee80211_tag_he_6ghz_cap_inf_b3_b5,
     {"Maximum A-MPDU Length Exponent", "wlan.tag.he_6ghz.cap_inf.b3_b5",
      FT_UINT16, BASE_HEX, VALS(vht_max_ampdu_flag), 0x0038,
      "Octets", HFILL }},

    {&hf_ieee80211_tag_he_6ghz_cap_inf_b6_b7,
     {"Maximum MPDU Length", "wlan.tag.he_6ghz.cap_inf.b6_b7",
      FT_UINT16, BASE_HEX, VALS(vht_max_mpdu_length_flag), 0x00C0,
      "Octets", HFILL }},

    {&hf_ieee80211_tag_he_6ghz_cap_inf_b8,
     {"Reserved", "wlan.tag.he_6ghz.cap_inf.b8",
      FT_UINT16, BASE_HEX, NULL, 0x0100,
      NULL, HFILL }},

    {&hf_ieee80211_tag_he_6ghz_cap_inf_b9_b10,
     {"SM Power Save", "wlan.tag.he_6ghz.cap_inf.b9b_b10",
      FT_UINT16, BASE_HEX, VALS(ht_sm_pwsave_flag), 0x0600,
      NULL, HFILL }},

    {&hf_ieee80211_tag_he_6ghz_cap_inf_b11,
     {"RD Responder", "wlan.tag.he_6ghz.cap_inf.b11",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0800,
      NULL, HFILL }},

    {&hf_ieee80211_tag_he_6ghz_cap_inf_b12,
     {"Rx Antenna Pattern Consistency", "wlan.tag.he_6ghz.cap_inf.b12",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x1000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_he_6ghz_cap_inf_b13,
     {"Tx Antenna Pattern Consistency", "wlan.tag.he_6ghz.cap_inf.b13",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x2000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_he_6ghz_cap_inf_b14_b15,
     {"Reserved", "wlan.tag.he_6ghz.cap_inf.b14_b15",
      FT_UINT16, BASE_HEX, NULL, 0xC000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ftm_tsf_sync_info,
     {"TSF Sync Info", "wlan.tag.ftm_tsf_sync_info",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_version,
     {"RSN Version", "wlan.rsn.version",
      FT_UINT16, BASE_DEC, NULL, 0,
      "Indicates the version number of the RSNA protocol", HFILL }},

    {&hf_ieee80211_rsn_gcs,
     {"Group Cipher Suite", "wlan.rsn.gcs",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(rsn_gcs_base_custom), 0,
      "Contains the cipher suite selector used by the BSS to protect broadcast/multicast traffic", HFILL }},

    {&hf_ieee80211_rsn_gcs_oui,
     {"Group Cipher Suite OUI", "wlan.rsn.gcs.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_gcs_type,
     {"Group Cipher Suite type", "wlan.rsn.gcs.type",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_gcs_80211_type,
     {"Group Cipher Suite type", "wlan.rsn.gcs.type",
      FT_UINT8, BASE_DEC, VALS(ieee80211_rsn_cipher_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_pcs_count,
     {"Pairwise Cipher Suite Count", "wlan.rsn.pcs.count",
      FT_UINT16, BASE_DEC,  NULL, 0,
      "Indicates the number of pairwise cipher suite selectors that are contained in the Pairwise Cipher Suite List", HFILL }},

    {&hf_ieee80211_rsn_pcs_list,
     {"Pairwise Cipher Suite List", "wlan.rsn.pcs.list",
      FT_NONE, BASE_NONE, NULL, 0,
      "Contains a series of cipher suite selectors that indicate the pairwisecipher suites", HFILL }},

    {&hf_ieee80211_rsn_pcs,
     {"Pairwise Cipher Suite", "wlan.rsn.pcs",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(rsn_pcs_base_custom), 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_pcs_oui,
     {"Pairwise Cipher Suite OUI", "wlan.rsn.pcs.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_pcs_type,
     {"Pairwise Cipher Suite type", "wlan.rsn.pcs.type",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_pcs_80211_type,
     {"Pairwise Cipher Suite type", "wlan.rsn.pcs.type",
      FT_UINT8, BASE_DEC, VALS(ieee80211_rsn_cipher_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_akms_count,
     {"Auth Key Management (AKM) Suite Count", "wlan.rsn.akms.count",
      FT_UINT16, BASE_DEC, NULL, 0,
      "Indicates the number of Auth Key Management suite selectors that are contained in the Auth Key Management Suite List", HFILL }},

    {&hf_ieee80211_rsn_akms_list,
     {"Auth Key Management (AKM) List", "wlan.rsn.akms.list",
      FT_NONE, BASE_NONE, NULL, 0,
      "Contains a series of cipher suite selectors that indicate the AKM suites", HFILL }},

    {&hf_ieee80211_rsn_akms,
     {"Auth Key Management (AKM) Suite", "wlan.rsn.akms",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(rsn_akms_base_custom), 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_akms_oui,
     {"Auth Key Management (AKM) OUI", "wlan.rsn.akms.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_akms_type,
     {"Auth Key Management (AKM) type", "wlan.rsn.akms.type",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_akms_80211_type,
     {"Auth Key Management (AKM) type", "wlan.rsn.akms.type",
      FT_UINT8, BASE_DEC, VALS(ieee80211_rsn_keymgmt_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_cap,
     {"RSN Capabilities", "wlan.rsn.capabilities",
      FT_UINT16, BASE_HEX, NULL, 0,
      "RSN Capability information", HFILL }},

    {&hf_ieee80211_rsn_cap_preauth,
     {"RSN Pre-Auth capabilities", "wlan.rsn.capabilities.preauth",
      FT_BOOLEAN, 16, TFS(&rsn_preauth_flags), 0x0001,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_cap_no_pairwise,
     {"RSN No Pairwise capabilities", "wlan.rsn.capabilities.no_pairwise",
      FT_BOOLEAN, 16, TFS(&rsn_no_pairwise_flags), 0x0002,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_cap_ptksa_replay_counter,
     {"RSN PTKSA Replay Counter capabilities", "wlan.rsn.capabilities.ptksa_replay_counter",
      FT_UINT16, BASE_HEX, VALS(rsn_cap_replay_counter), 0x000C,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_cap_gtksa_replay_counter,
     {"RSN GTKSA Replay Counter capabilities", "wlan.rsn.capabilities.gtksa_replay_counter",
      FT_UINT16, BASE_HEX, VALS(rsn_cap_replay_counter), 0x0030,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_cap_mfpr,
     {"Management Frame Protection Required", "wlan.rsn.capabilities.mfpr",
      FT_BOOLEAN, 16, NULL, 0x0040,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_cap_mfpc,
     {"Management Frame Protection Capable", "wlan.rsn.capabilities.mfpc",
      FT_BOOLEAN, 16, NULL, 0x0080,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_cap_jmr,
     {"Joint Multi-band RSNA", "wlan.rsn.capabilities.jmr",
      FT_BOOLEAN, 16, NULL, 0x0100,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_cap_peerkey,
     {"PeerKey Enabled", "wlan.rsn.capabilities.peerkey",
      FT_BOOLEAN, 16, NULL, 0x0200,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_cap_extended_key_id_iaf,
     {"Extended Key ID for Individually Addressed Frames",
      "wlan.rsn.capabilities.extended_key_id_iaf",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x2000, NULL, HFILL }},

    {&hf_ieee80211_rsn_cap_ocvc,
     {"OCVC", "wlan.rsn.capabilities.ocvc",
      FT_BOOLEAN, 16, NULL, 0x4000,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_pmkid_count,
     {"PMKID Count", "wlan.rsn.pmkid.count",
      FT_UINT16, BASE_DEC, NULL, 0,
      "Indicates the number of PMKID  selectors that are contained in the PMKID Suite List", HFILL }},

    {&hf_ieee80211_rsn_pmkid_list,
     {"PMKID List", "wlan.rsn.pmkid.list",
      FT_NONE, BASE_NONE, NULL, 0,
      "Contains a series of cipher suite selectors that indicate the AKM suites", HFILL }},

    {&hf_ieee80211_rsn_pmkid,
     {"PMKID", "wlan.pmkid.akms",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_gmcs,
     {"Group Management Cipher Suite", "wlan.rsn.gmcs",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(rsn_gmcs_base_custom), 0,
      "Contains the cipher suite selector used by the BSS to protect broadcast/multicast traffic", HFILL }},

    {&hf_ieee80211_rsn_gmcs_oui,
     {"Group Management Cipher Suite OUI", "wlan.rsn.gmcs.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_gmcs_type,
     {"Group Management Cipher Suite type", "wlan.rsn.gmcs.type",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_gmcs_80211_type,
     {"Group Management Cipher Suite type", "wlan.rsn.gmcs.type",
      FT_UINT8, BASE_DEC, VALS(ieee80211_rsn_cipher_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_ht_pren_type,
     {"802.11n (Pre) Type", "wlan.vs.pren.type",
      FT_UINT8, BASE_DEC, VALS(ieee80211_ht_pren_type_vals), 0,
      "Vendor Specific HT Type", HFILL }},
    {&hf_ieee80211_ht_pren_unknown,
     {"802.11n (Pre) Unknown Data", "wlan.vs.pren.unknown_data",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ht_cap,
     {"HT Capabilities Info", "wlan.ht.capabilities",
      FT_UINT16, BASE_HEX, NULL, 0,
      "HT Capabilities information", HFILL }},

    {&hf_ieee80211_ht_vs_cap,
     {"HT Capabilities Info (VS)", "wlan.vs.ht.capabilities",
      FT_UINT16, BASE_HEX, NULL, 0,
      "Vendor Specific HT Capabilities information", HFILL }},

    {&hf_ieee80211_ht_ldpc_coding,
     {"HT LDPC coding capability", "wlan.ht.capabilities.ldpccoding",
      FT_BOOLEAN, 16, TFS(&ht_ldpc_coding_flag), 0x0001,
      NULL, HFILL }},

    {&hf_ieee80211_ht_chan_width,
     {"HT Support channel width", "wlan.ht.capabilities.width",
      FT_BOOLEAN, 16, TFS(&ht_chan_width_flag), 0x0002,
      NULL, HFILL }},

    {&hf_ieee80211_ht_sm_pwsave,
     {"HT SM Power Save", "wlan.ht.capabilities.sm",
      FT_UINT16, BASE_HEX, VALS(ht_sm_pwsave_flag), 0x000c,
      NULL, HFILL }},

    {&hf_ieee80211_ht_green,
     {"HT Green Field", "wlan.ht.capabilities.green",
      FT_BOOLEAN, 16, TFS(&ht_green_flag), 0x0010,
      NULL, HFILL }},

    {&hf_ieee80211_ht_short20,
     {"HT Short GI for 20MHz", "wlan.ht.capabilities.short20",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0020,
      NULL, HFILL }},

    {&hf_ieee80211_ht_short40,
     {"HT Short GI for 40MHz", "wlan.ht.capabilities.short40",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0040,
      NULL, HFILL }},

    {&hf_ieee80211_ht_tx_stbc,
     {"HT Tx STBC", "wlan.ht.capabilities.txstbc",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0080,
      NULL, HFILL }},

    {&hf_ieee80211_ht_rx_stbc,
     {"HT Rx STBC", "wlan.ht.capabilities.rxstbc",
      FT_UINT16, BASE_HEX, VALS(ht_rx_stbc_flag), 0x0300,
      "HT Tx STBC", HFILL }},

    {&hf_ieee80211_ht_delayed_block_ack,
     {"HT Delayed Block ACK", "wlan.ht.capabilities.delayedblockack",
      FT_BOOLEAN, 16, TFS(&ht_delayed_block_ack_flag), 0x0400,
      NULL, HFILL }},

    {&hf_ieee80211_ht_max_amsdu,
     {"HT Max A-MSDU length", "wlan.ht.capabilities.amsdu",
      FT_BOOLEAN, 16, TFS(&ht_max_amsdu_flag), 0x0800,
      NULL, HFILL }},

    {&hf_ieee80211_ht_dss_cck_40,
     {"HT DSSS/CCK mode in 40MHz", "wlan.ht.capabilities.dsscck",
      FT_BOOLEAN, 16, TFS(&ht_dss_cck_40_flag), 0x1000,
      "HT DSS/CCK mode in 40MHz", HFILL }},

    {&hf_ieee80211_ht_psmp,
     {"HT PSMP Support", "wlan.ht.capabilities.psmp",
      FT_BOOLEAN, 16, TFS(&ht_psmp_flag), 0x2000,
      NULL, HFILL }},

    {&hf_ieee80211_ht_40_mhz_intolerant,
     {"HT Forty MHz Intolerant", "wlan.ht.capabilities.40mhzintolerant",
      FT_BOOLEAN, 16, TFS(&ht_40_mhz_intolerant_flag), 0x4000,
      NULL, HFILL }},

    {&hf_ieee80211_ht_l_sig,
     {"HT L-SIG TXOP Protection support", "wlan.ht.capabilities.lsig",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x8000,
      NULL, HFILL }},

    {&hf_ieee80211_ext_bss_mu_mimo_capable_sta_count,
     {"MU-MIMO Capable STA Count", "wlan.ext_bss.mu_mimo_capable_sta_count",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ext_bss_ss_underutilization,
     {"Spatial Stream Underutilization", "wlan.ext_bss.ss_underutilization",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ext_bss_observable_sec_20mhz_utilization,
     {"Observable Secondary 20MHz Utilization", "wlan.ext_bss.observable_sec_20mhz_utilization",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ext_bss_observable_sec_40mhz_utilization,
     {"Observable Secondary 40MHz Utilization", "wlan.ext_bss.observable_sec_40mhz_utilization",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ext_bss_observable_sec_80mhz_utilization,
     {"Observable Secondary 80MHz Utilization", "wlan.ext_bss.observable_sec_80mhz_utilization",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wide_bw_new_channel_width,
     {"New Channel Width", "wlan.wide_bw.new_channel_width",
      FT_UINT8, BASE_HEX, VALS(vht_operation_info_channel_width), 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_wide_bw_new_channel_center_freq_segment0,
     {"New Channel Center Frequency Segment 0", "wlan.wide_bw.new_channel_center_freq_segment0",
      FT_UINT8, BASE_HEX_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_wide_bw_new_channel_center_freq_segment1,
     {"New Channel Center Frequency Segment 1", "wlan.wide_bw.new_channel_center_freq_segment1",
      FT_UINT8, BASE_HEX_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_operat_notification_mode,
     {"Operating Mode Notification", "wlan.operat_notification_mode",
      FT_UINT8, BASE_HEX, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_operat_mode_field_channel_width,
     {"Channel Width", "wlan.operat_mode_field.channelwidth",
      FT_UINT8, BASE_HEX, VALS(operating_mode_field_channel_width), 0x03,
      NULL, HFILL }},

    {&hf_ieee80211_operat_mode_field_reserved,
     {"Reserved", "wlan.operat_mode_field.reserved",
      FT_UINT8, BASE_HEX, NULL, 0x0C,
      NULL, HFILL }},

    {&hf_ieee80211_operat_mode_field_rxnss,
     {"Rx NSS", "wlan.operat_mode_field.rxnss",
      FT_UINT8, BASE_HEX, VALS(operat_mode_field_rxnss), 0x70,
      NULL, HFILL }},

    {&hf_ieee80211_operat_mode_field_rxnsstype,
     {"Rx NSS Type", "wlan.operat_mode_field.rxnsstype",
      FT_UINT8, BASE_HEX, NULL, 0x80,
      "Indicate that the Rx NSS subfield carries the maximum number of spatial streams that the STA can receive", HFILL }},

     {&hf_ieee80211_tbtt_info,
      {"TBTT Information Field", "wlan.rnr.tbtt_info",
       FT_UINT16, BASE_DEC, NULL, 0x03, NULL, HFILL }},

     {&hf_ieee80211_tbtt_filtered_nap,
      {"TBTT Filtered Neighbor AP", "wlan.rnr.tbtt_info.fna",
       FT_UINT16, BASE_DEC, NULL, 1<<2, NULL, HFILL }},

     {&hf_ieee80211_tbtt_info_count,
      {"TBTT Information Count", "wlan.rnr.tbtt_info.info_count",
       FT_UINT16, BASE_DEC, NULL, 0xf<<4, NULL, HFILL }},

     {&hf_ieee80211_tbtt_info_length,
      {"TBTT Information Length", "wlan.rnr.tbtt_info.info_len",
       FT_UINT16, BASE_DEC|BASE_RANGE_STRING, RVALS(tbtt_info_length),
       0xff<<8, NULL, HFILL }},

     {&hf_ieee80211_tbtt_operating_class,
      {"Operating Class", "wlan.rnr.tbtt_info.operating_class",
       FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

     {&hf_ieee80211_tbtt_channel_number,
      {"Channel Number", "wlan.rnr.tbtt_info.channel_num",
       FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

     {&hf_ieee80211_tbtt_offset,
      {"Neighbor AP TBTT Offset", "wlan.rnr.tbtt_info.tbtt_offset",
       FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

     {&hf_ieee80211_tbtt_bssid,
      {"BSSID", "wlan.rnr.tbtt_info.bssid",
       FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tbtt_short_ssid,
      {"Short SSID", "wlan.rnr.tbtt_info.sh_ssid",
       FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_rnr_bss_params,
     {"BSS Parameters", "wlan.rnr.tbtt_info.bss_parameters",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_rnr_oct_recommended,
     {"OCT Recommended", "wlan.rnr.tbtt_info.bss_parameters.oct_recommended",
      FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_rnr_same_ssid,
     {"Same SSID", "wlan.rnr.tbtt_info.bss_parameters.same_ssid",
      FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_rnr_multiple_bssid,
     {"Multiple BSSID", "wlan.rnr.tbtt_info.bss_parameters.multiple_bssid",
      FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},

    {&hf_ieee80211_rnr_transmitted_bssid,
     {"Transmitted BSSID", "wlan.rnr.tbtt_info.bss_parameters.transmitted_bssid",
      FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},

    {&hf_ieee80211_rnr_ess_with_colocated_ap,
     {"Member of ESS with 2.4/5 GHz Co-Located AP",
      "wlan.rnr.tbtt_info.bss_parameters.member_of_ess_with_2p4_5_ghz_colocated_ap",
      FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},

    {&hf_ieee80211_rnr_unsolicited_probe_responses,
     {"Unsolicited Probe Responses",
      "wlan.rnr.tbtt_info.bss_parameters.unsolicited_probe_responses",
      FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},

    {&hf_ieee80211_rnr_same_colocated_ap,
     {"Co-Located AP", "wlan.rnr.tbtt_info.bss_parameters.colocated_ap",
      FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},

    {&hf_ieee80211_rnr_same_reserved,
     {"Reserved", "wlan.rnr.tbtt_info.bss_parameters.reserved",
      FT_UINT8, BASE_HEX, NULL, 0x80, NULL, HFILL }},

    {&hf_ieee80211_rnr_20mhz_psd_subfield,
     {"PSD Subfield", "wlan.rnr.tbtt_info.psd_subfield",
      FT_UINT8, BASE_CUSTOM, CF_FUNC(tpe_psd_custom), 0, NULL, HFILL }},

    {&hf_ieee80211_rnr_reserved_data,
     {"Reserved", "wlan.rnr.tbtt_info.reserved",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rnr_mld_params,
     {"MLD Parameters", "wlan.rnr.tbtt_info.mld_parameters",
      FT_UINT24, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_rnr_mld_id,
     {"MLD ID", "wlan.rnr.tbtt_info.mld_parameters.mld_id",
      FT_UINT24, BASE_HEX, NULL, 0x0000FF, NULL, HFILL }},

    {&hf_ieee80211_rnr_mld_link_id,
     {"Link ID", "wlan.rnr.tbtt_info.mld_parameters.link_id",
      FT_UINT24, BASE_HEX, NULL, 0x000F00, NULL, HFILL }},

    {&hf_ieee80211_rnr_mld_bss_params_change_count,
     {"BSS Parameters Change Count",
      "wlan.rnr.tbtt_info.mld_parameters.bss_params_change_count",
      FT_UINT24, BASE_HEX, NULL, 0x0FF000, NULL, HFILL }},

    {&hf_ieee80211_rnr_mld_all_updates_included,
     {"All Updates Included",
      "wlan.rnr.tbtt_info.mld_parameters.all_updates_included",
      FT_BOOLEAN, 24, NULL, 0x100000, NULL, HFILL }},

    {&hf_ieee80211_rnr_mld_disabled_link_indication,
     {"Disabled Link Indication",
      "wlan.rnr.tbtt_info.mld_parameters.disabled_link_indication",
      FT_BOOLEAN, 24, NULL, 0x200000, NULL, HFILL }},

    {&hf_ieee80211_rnr_mld_reserved,
     {"Reserved", "wlan.rnr.tbtt_info.mld_parameters.reserved",
      FT_UINT24, BASE_HEX, NULL, 0xC00000, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_byte1,
     {"S1G Capabilities Byte 1", "wlan.s1g.capabilities.byte1",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_byte2,
     {"S1G Capabilities Byte 2", "wlan.s1g.capabilities.byte2",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_byte3,
     {"S1G Capabilities Byte 3", "wlan.s1g.capabilities.byte3",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_byte4,
     {"S1G Capabilities Byte 4", "wlan.s1g.capabilities.byte4",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_byte5,
     {"S1G Capabilities Byte 5", "wlan.s1g.capabilities.byte5",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_byte6,
     {"S1G Capabilities Byte 6", "wlan.s1g.capabilities.byte6",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_byte7,
     {"S1G Capabilities Byte 7", "wlan.s1g.capabilities.byte7",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_byte8,
     {"S1G Capabilities Byte 8", "wlan.s1g.capabilities.byte8",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_byte9,
     {"S1G Capabilities Byte 9", "wlan.s1g.capabilities.byte9",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_beacon_sequence,
     {"Beacon Sequence", "wlan.s1g.beacon_sequence",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_pentapartial_timestamp,
     {"Pentapartial Timestamp", "wlan.s1g.pentapartial_timestamp",
      FT_UINT40, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_tack_next_twt_info,
     {"Next TWT Info/Suspend Duration", "wlan.s1g.next_twt_info",
      FT_UINT40, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_tack_next_twt,
     {"Next TWT", "wlan.s1g.next_twt",
      FT_UINT40, BASE_HEX, NULL, 0x1FFFFFFFFF, NULL, HFILL }},

    {&hf_ieee80211_tack_flow_identifier,
     {"TWT Flow Identifier", "wlan.s1g.twt_flow_identifier",
      FT_UINT40, BASE_HEX, NULL, 0xE000000000, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_byte10,
     {"S1G Capabilities Byte 10", "wlan.s1g.capabilities.byte10",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_s1g_long_support,
     {"S1G_LONG Support", "wlan.s1g.capabilities.s1g_long_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_short_gi_for_1_mhz,
     {"Short GI for 1MHz", "wlan.s1g.capabilities.short_gi_for_1_mhz",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x02, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_short_gi_for_2_mhz,
     {"Short GI for 2MHz", "wlan.s1g.capabilities.short_gi_for_2_mhz",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x04, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_short_gi_for_4_mhz,
     {"Short GI for 4MHz", "wlan.s1g.capabilities.short_gi_for_4_mhz",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x08, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_short_gi_for_8_mhz,
     {"Short GI for 8MHz", "wlan.s1g.capabilities.short_gi_for_8_mhz",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x10, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_short_gi_for_16_mhz,
     {"Short GI for 16MHz", "wlan.s1g.capabilities.short_gi_for_16_mhz",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x20, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_supported_channel_width,
     {"Supported Channel Width", "wlan.s1g.capabilities.supported_channel_width",
      FT_UINT8, BASE_HEX, VALS(s1g_supported_channel_width_vals), 0xC0,
      NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_rx_lpdc,
     {"Rx LDPC", "wlan.s1g.capabilities.rx_ldpc",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_tx_stbc,
     {"Tx STBC", "wlan.s1g.capabilities.tx_stbc",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x02, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_rx_stbc,
     {"Rx STBC", "wlan.s1g.capabilities.rx_stbc",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x04, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_su_beamformer_capable,
     {"SU Beamformer Capable", "wlan.s1g.capabilities.su_beamformer_capable",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x08, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_su_beamformee_capable,
     {"SU Beamformee Capable", "wlan.s1g.capabilities.su_beamformee_capable",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x10, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_beamformee_sts_capability,
     {"Beamformee STS Capability", "wlan.s1g.capabilities.sts_beamformee_capability",
      FT_UINT8, BASE_DEC, NULL, 0xE0, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_number_sounding_dimensions,
     {"Number of Sounding Dimensions", "wlan.s1g.capabilities.number_sounding_dimensions",
      FT_UINT8, BASE_DEC, NULL, 0x07, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_mu_beamformer_capable,
     {"MU Beamformer Capable", "wlan.s1g.capabilities.beamformer_capable",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x08, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_mu_beamformee_capable,
     {"MU Beamformee Capable", "wlan.s1g.capabilities.beamformee_capable",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x10, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_htc_vht_capable,
     {"+HTC-VHT Capable", "wlan.s1g.capabilities.htc_vht_capable",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x20, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_travelling_pilot_support,
     {"Traveling Pilot Support", "wlan.s1g.capabilities.traveling_pilot_support",
      FT_UINT8, BASE_HEX, VALS(s1g_traveling_pilot_support_vals), 0xC0,
      NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_rd_responder,
     {"RD Responder", "wlan.s1g.capabilities.rd_responder",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_ht_delayed_block_ack,
     {"HT Delayed Block Ack", "wlan.s1g.capabilities.ht_delayed_block_ack",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x02, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_maximum_mpdu_length,
     {"Maximum MPDU Length", "wlan.s1g.capabilities.max_mpdu_length",
      FT_UINT8, BASE_DEC, VALS(s1g_max_mpdu_length_vals), 0x04, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_maximum_a_mpdu_length_exp,
     {"Maximum A-MPDU Length Exponent", "wlan.s1g.capabilities.max_a_mpdu_length_exp",
      FT_UINT8, BASE_DEC, NULL, 0x18, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_minimum_mpdu_start_spacing,
     {"Minimum MPDU Start Spacing", "wlan.s1g.capabilities.min_mpdu_start_spacing",
      FT_UINT8, BASE_DEC, VALS(s1g_min_mpdu_start_spacing_vals), 0xE0,
      NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_uplink_sync_capable,
     {"Uplink Sync Capable", "wlan.s1g.capabilities.uplink_sync_capable",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_dynamic_aid,
     {"Dynamic AID", "wlan.s1g.capabilities.dynamic_aid",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x02, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_bat_support,
     {"BAT Support", "wlan.s1g.capabilities.bat_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x04, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_tim_ade_support,
     {"TIM AID Support", "wlan.s1g.capabilities.tim_aid_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x08, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_non_tim_support,
     {"Non TIM Support", "wlan.s1g.capabilities.non_tim_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x10, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_group_aid_support,
     {"Group AID Support", "wlan.s1g.capabilities.group_aid_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x20, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_sta_type_support,
     {"STA Type Support", "wlan.s1g.capabilities.sta_type_support",
      FT_UINT8, BASE_HEX, VALS(s1g_sta_type_support_vals), 0xC0, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_centralized_authentication_control,
     {"Centralized Authentication Control", "wlan.s1g.capabilities.centralized_authentication_control",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_distributed_authentication_control,
     {"Distributed Authentication Control", "wlan.s1g.capabilities.distributed_authentication_control",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x02, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_a_msdu_support,
     {"A-MSDU Supported", "wlan.s1g.capabilities.a_msdu_supported",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x04, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_a_mpdu_support,
     {"A-MPDU Support", "wlan.s1g.capabilities.a_mpdu_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x08, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_asymmetic_block_ack_support,
     {"Asymmetric Block Ack Supported", "wlan.s1g.capabilities.asymmetric_block_ack_supported",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x10, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_flow_control_support,
     {"Flow Control Supported", "wlan.s1g.capabilities.flow_control_supported",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x20, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_sectorized_beam_capable,
     {"Sectorized Beam Capable", "wlan.s1g.capabilities.sectorized_beam_capable",
      FT_UINT8, BASE_HEX, VALS(s1g_sectorized_beam_capable_vals), 0xC0,
      NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_obss_mitigation_support,
     {"OBSS Mitigation Support", "wlan.s1g.capabilities.obss_mitigation_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_fragment_ba_support,
     {"Fragment BA Support", "wlan.s1g.capabilities.fragment_ba_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x02, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_ndp_ps_poll_supported,
     {"NDS PS-Poll Supported", "wlan.s1g.capabilities.nds_ps_poll_supported",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x04, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_raw_operation_support,
     {"Raw Operation Support", "wlan.s1g.capabilities.raw_operation_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x08, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_page_slicing_support,
     {"Page Slicing Support", "wlan.s1g.capabilities.page_slicing_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x10, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_txop_sharing_implicit_ack_support,
     {"TXOP Sharing Implicit Ack Support", "wlan.s1g.capabilities.txop_sharing_implicit_ack_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x20, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_vht_link_adaptation_capable,
     {"VHT Link Adaptation Capable", "wlan.s1g.capabilities.vht_link_adaptation_capable",
      FT_UINT8, BASE_HEX, VALS(s1g_vht_link_adaptation_vals), 0xC0,
      NULL, HFILL}},

    {&hf_ieee80211_s1g_cap_tack_support_as_ps_poll_response,
     {"TACK Support as PS-Poll Response", "wlan.s1g.capabilities.tack_support_as_ps_poll_response",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_duplicate_1_mhz_support,
     {"Duplicate 1 MHz Support", "wlan.s1g.capabilities.duplicate_1_mhz_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x02, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_mcs_negotiation_support,
     {"MCS Negotiation Support", "wlan.s1g.capabilities.ms_negotiation_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x04, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_1_mhz_control_response_preamble_support,
     {"1 MHz Control Response Preamble Supported",
      "wlan.s1g.capabilities.1_mhz_control_response_preamble_supported",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x08, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_ndp_beamforming_report_poll_support,
     {"NDP Beamforming Report Poll Supported",
      "wlan.s1g.capabilities.ndp_beamforming_report_poll_supported",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x10, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_unsolicited_dynamic_aid,
     {"Unsolicited Dynamic AID", "wlan.s1g.capabilities.unsolicited_dynamic_aid",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x20, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_sector_training_operation_supported,
     {"Sector Training Operation Supported",
      "wlan.s1g.capabilities.sector_training_operation_supported",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x40, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_temporary_ps_mode_switch,
     {"Temporary PS Mode Switch",
      "wlan.s1g.capabilities.temporary_ps_mode_switch",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x80, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_twt_grouping_support,
     {"TWT Grouping Support", "wlan.s1g.capabilities.twt_grouping_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_bdt_capable,
     {"BDT Capable", "wlan.s1g.capabilities.bdt_capable",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x02, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_color,
     {"COLOR", "wlan.s1g.capabilities.color",
      FT_UINT8, BASE_DEC, NULL, 0x1C, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_twt_requester_support,
     {"TWT Requester Support", "wlan.s1g.capabilities.twt_requester_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x20, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_twt_responder_support,
     {"TWT Responder Support", "wlan.s1g.capabilities.twt_responder_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x40, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_pv1_frame_support,
     {"PV1 Frame Support", "wlan.s1g.capabilities.pv1_frame_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x80, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_link_adaptation_per_normal_control_response_capable,
     {"Link Adaptation per Normal Control Response Capable",
      "wlan.s1g.capabilities.link_adaptation_per_normal_control_response_capable",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_cap_reserved,
     {"Reserved", "wlan.s1g.capabilities.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xFE, NULL, HFILL }},

    {&hf_ieee80211_s1g_mcs_and_nss_set,
     {"Supported S1G-MCS and NSS Set", "wlan.s1g.supported_mcs_nss_set",
      FT_UINT40, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_s1g_rx_s1g_mcs_map,
     {"Rx S1G-MCS Map", "wlan.s1g.supported_mcs_nss_set.rx_s1g_mcs_map",
      FT_UINT40, BASE_HEX, NULL, 0x00000000FF, NULL, HFILL }},

    {&hf_ieee80211_s1g_rx_highest_supported_long_gi_data_rate,
     {"Rx Highest Supported Long GI Data Rate",
      "wlan.s1g.supported_mcs_nss_set.rx_highest_supported_long_gi_data_rate",
     FT_UINT40, BASE_HEX, NULL, 0x000001FF00, NULL, HFILL }},

    {&hf_ieee80211_s1g_tx_s1g_mcs_map,
     {"Tx S1G-MCS Map", "wlan.s1g.supported_mcs_nss_set.tx_s1g_mcs_map",
      FT_UINT40, BASE_HEX, NULL, 0x0001FE0000, NULL, HFILL }},

    {&hf_ieee80211_s1g_tx_highest_supported_long_gi_data_rate,
     {"Tx Highest Supported Long GI Data Rate",
      "wlan.s1g.supported_mcs_nss_set.tx_highest_supported_long_gi_data_rate",
      FT_UINT40, BASE_HEX, NULL, 0x03FE000000, NULL, HFILL }},

    {&hf_ieee80211_s1g_rx_single_spatial_stream_map_for_1_mhz,
     {"Rx Single Spatial Stream and S1G-MCS Map for 1MHz",
      "wlan.s1g.supported_mcs_nss_set.rx_single_spatial_stream_1_mhz",
      FT_UINT40, BASE_HEX, NULL, 0x0C00000000, NULL, HFILL }},

    {&hf_ieee80211_s1g_tx_single_spatial_stream_map_for_1_mhz,
     {"Tx Single Spatial Stream and S1G-MCS Map for 1MHz",
      "wlan.s1g.supported_mcs_nss_set.tx_single_spatial_stream_1_mhz",
      FT_UINT40, BASE_HEX, NULL, 0x3000000000, NULL, HFILL }},

    {&hf_ieee80211_s1g_mcs_and_nss_reserved,
     {"Reserved", "wlan.s1g.supported_mcs_nss_set.reserved",
     FT_UINT40, BASE_HEX, NULL, 0xC000000000, NULL, HFILL }},

    {&hf_ieee80211_s1g_subchannel_selective_transmission,
     {"Channel Activity Schedule", "wlan.sst.channel_activity_schedule",
      FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_s1g_sst_sounding_option,
     {"Sounding Option", "wlan.sst.channel_activity_schedule.sounding_option",
      FT_UINT32, BASE_HEX, NULL, 0x00000001, NULL, HFILL }},

    {&hf_ieee80211_s1g_channel_activity_bitmap,
     {"Channel Activity Bitmap", "wlan.sst.channel_activity_schedule.channel_activity_bitmap",
      FT_UINT32, BASE_HEX, NULL, 0x000001FE, NULL, HFILL }},

    {&hf_ieee80211_s1g_ul_activity,
     {"UL Activity", "wlan.sst.channel_activity_schedule.ul_activity",
      FT_BOOLEAN, 32, NULL, 0x00000200, NULL, HFILL }},

    {&hf_ieee80211_s1g_dl_activity,
     {"DL Activity", "wlan.sst.channel_activity_schedule.dl_activity",
      FT_BOOLEAN, 32, NULL, 0x00000400, NULL, HFILL }},

    {&hf_ieee80211_s1g_max_trans_width,
     {"Maximum Transmission Width", "wlan.sst.channel_activity_schedule.max_trans_width",
      FT_UINT32, BASE_DEC, VALS(max_trans_width_vals),
      0x00001800, NULL, HFILL }},

    {&hf_ieee80211_s1g_activity_start_time,
     {"Activity Start Time", "wlan.sst.channel_activity_schedule.activity_start_time",
      FT_UINT32, BASE_DEC, NULL, 0xFFFFE000, NULL, HFILL }},

    {&hf_ieee80211_s1g_sst_sounding_option1,
     {"Sounding Option", "wlan.sst.channel_activity_schedule.sounding_option",
      FT_UINT16, BASE_HEX, NULL, 0x0001, NULL, HFILL }},

    {&hf_ieee80211_s1g_channel_activity_bitmap1,
     {"Channel Activity Bitmap", "wlan.sst.channel_activity_schedule.channel_activity_bitmap",
      FT_UINT16, BASE_HEX, NULL, 0x01FE, NULL, HFILL }},

    {&hf_ieee80211_s1g_sounding_start_time_present,
     {"Sounding Start Time Present", "wlan.sst.channel_activity_schedule.sounding_start_time_present",
      FT_BOOLEAN, 16, NULL, 0x0200, NULL, HFILL }},

    {&hf_ieee80211_s1g_channel_activity_reserved,
     { "Reserved", "wlan.sst.channel_activity_schedule.reserved",
      FT_UINT16, BASE_HEX, NULL, 0x3C00, NULL, HFILL }},

    {&hf_ieee80211_s1g_max_trans_width1,
     {"Maximum Transmission Width", "wlan.sst.channel_activity_schedule.max_trans_width",
      FT_UINT16, BASE_DEC, VALS(max_trans_width_vals),
      0xC000, NULL, HFILL }},

    {&hf_ieee80211_s1g_sounding_start_time,
     {"Sounding Start Time",
      "wlan.sst.channel_activity_schedule.sounding_start_time",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_s1g_open_loop_link_margin,
     {"Open-Loop Link Margin Index", "wlan.s1g.open_loop_link_margin_index",
      FT_UINT8, BASE_CUSTOM, CF_FUNC(s1g_open_loop_link_margin_custom),
      0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_control,
     {"RAW Control", "wlan.s1g.rps.raw_control",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_type,
     {"RAW Type", "wlan.s1g.rps.raw_control.raw_type",
      FT_UINT8, BASE_DEC, VALS(s1g_raw_control_raw_type), 0x03, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_type_options,
     {"RAW Type Options", "wlan.s1g.rps.raw_control.raw_type_options",
      FT_UINT8, BASE_CUSTOM, CF_FUNC(s1g_raw_type_options_custom),
      0x0C, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_start_time_indication,
     {"Start Time Indication", "wlan.s1g.rps.raw_control.start_time_indication",
      FT_BOOLEAN, 8, TFS(&tfs_present_not_present), 0x10, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_raw_group_indication,
     {"RAW Group Indication", "wlan.s1g.rps.raw_control.raw_group_indication",
      FT_BOOLEAN, 8, TFS(&tfs_present_not_present), 0x20, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_channel_indication_preference,
     {"Channel Indication Preference",
      "wlan.s1g.rps.raw_control.channel_indication_preference",
      FT_BOOLEAN, 8, TFS(&tfs_present_not_present), 0x40, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_periodic_raw_indication,
     {"Periodic RAW Indication",
      "wlan.s1g.rps.raw_control.periodic_raw_indication",
      FT_BOOLEAN, 8, TFS(&tfs_present_not_present), 0x80, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_slot_def,
     {"RAW Slot Definition", "wlan.s1g.rps.raw_slot_definition",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_slot_def_format_indication,
     {"Slot Definition Format Indication",
      "wlan.s1g.rps.raw_slot_definition.slot_definition_format_indication",
      FT_UINT16, BASE_DEC, NULL, 0x0001, NULL, HFILL }},

    {&hf_ieee80211_s1g_slot_def_cross_slot_boundary,
     {"Cross Slot Boundary",
      "wlan.s1g.rps.raw_slot_definition.cross_slot_boundary",
      FT_BOOLEAN, 16, TFS(&tfs_allowed_not_allowed), 0x0002, NULL, HFILL }},

    {&hf_ieee80211_s1g_slot_def_slot_duration_count8,
     {"Slot Duration Count",
      "wlan.s1g.rps.raw_slot_definition.slot_duration_count",
      FT_UINT16, BASE_CUSTOM, CF_FUNC(s1g_raw_slot_duration_custom), 0x03FC, NULL, HFILL }},

    {&hf_ieee80211_s1g_slot_def_num_slots6,
     {"Number of Slots",
      "wlan.s1g.rps.raw_slot_definition.number_of_slots",
      FT_UINT16, BASE_DEC, NULL, 0xFC00, NULL, HFILL }},

    {&hf_ieee80211_s1g_slot_def_slot_duration_count11,
     {"Slot Duration Count",
      "wlan.s1g.rps.raw_slot_definition.slot_duration_count",
      FT_UINT16, BASE_CUSTOM, CF_FUNC(s1g_raw_slot_duration_custom), 0x1FFC, NULL, HFILL }},

    {&hf_ieee80211_s1g_slot_def_num_slots3,
     {"Number of Slots",
      "wlan.s1g.rps.raw_slot_definition.number_of_slots",
      FT_UINT16, BASE_DEC, NULL, 0xE000, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_start_time,
     {"RAW Start Time", "wlan.s1g.raw_slot_definition.raw_start_time",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_group_subfield,
     {"RAW Group", "wlan.s1g.rps.raw_group",
      FT_UINT24, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_group_page_index,
     {"Page Index", "wlan.s1g.rps.raw_group.page_index",
      FT_UINT24, BASE_DEC, NULL, 0x000003, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_group_start_aid,
     {"RAW Start AID", "wlan.s1g.rps.raw_group.raw_start_aid",
      FT_UINT24, BASE_DEC, NULL, 0x001FFC, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_group_end_aid,
     {"RAW End AID", "wlan.s1g.rps.raw_group.raw_end_aid",
      FT_UINT24, BASE_DEC, NULL, 0xFFE000, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_channel_indication,
     {"Channel Indication", "wlan.s1g.rps.channel_indication",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_ci_channel_activity_bitmap,
     {"Channel Activity Bitmap",
      "wlan.s1g.rps.channel_indication.channel_activity_bitmap",
      FT_UINT16, BASE_HEX, NULL, 0x00FF, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_ci_max_trans_width,
     {"Maximum Transmission Width",
      "wlan.s1g.rps.channel_indication.maximum_transmission_width",
      FT_UINT16, BASE_DEC, VALS(max_trans_width_vals), 0x0300, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_ci_ul_activity,
     {"UL Activity", "wlan.s1g.rps.channel_indication.ul_activity",
      FT_BOOLEAN, 16, NULL, 0x0400, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_ci_dl_activity,
     {"DL Activity", "wlan.s1g.rps.channel_indication.dl_activity",
      FT_BOOLEAN, 16, NULL, 0x0800, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_ci_reserved,
     {"Reserved", "wlan.s1g.rps.channel_indication.reserved",
      FT_UINT16, BASE_HEX, NULL, 0xF000, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_praw_periodicity,
     {"PRAW Periodicity",
      "wlan.s1g.rps.periodic_operation_parameters.praw_periodicity",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_praw_validity,
     {"PRAW Validity",
      "wlan.s1g.rps.periodic_operation_parameters.praw_validity",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_raw_praw_start_offset,
     {"PRAW Start Offset",
      "wlan.s1g.rps.periodic_operation_parameters.praw_start_offset",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},


    {&hf_ieee80211_s1g_page_slice_page_period,
     {"Page Period", "wlan.page_slice.page_period",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_s1g_page_slice_control,
     {"Page Slice Control", "wlan.page_slice.page_slice_control",
      FT_UINT24, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_s1g_page_slice_page_index,
     {"Page Index", "wlan.page_slice.page_slice_control.page_index",
      FT_UINT24, BASE_DEC, NULL, 0x000003, NULL, HFILL }},

    {&hf_ieee80211_s1g_page_slice_page_slice_length,
     {"Page Slice Length", "wlan.page_slice.page_slice_control.page_slice_len",
      FT_UINT24, BASE_DEC, NULL, 0x00007C, NULL, HFILL }},

    {&hf_ieee80211_s1g_page_slice_page_slice_count,
     {"Page Slice Count", "wlan.page_slice.page_slice_control.page_slice_count",
      FT_UINT24, BASE_DEC, NULL, 0x000F80, NULL, HFILL }},

    {&hf_ieee80211_s1g_page_slice_block_offset,
     {"Block Offset", "wlan.page_slice.page_slice_control.block_offset",
      FT_UINT24, BASE_DEC, NULL, 0x01F000, NULL, HFILL }},

    {&hf_ieee80211_s1g_page_slice_tim_offset,
     {"TIM Offset", "wlan.page_slice.page_slice_control.tim_offset",
      FT_UINT24, BASE_DEC, NULL, 0x1E0000, NULL, HFILL }},

    {&hf_ieee80211_s1g_page_slice_reserved,
     {"Reserved", "wlan.page_slice.page_slice_control.reserved",
      FT_UINT24, BASE_HEX, NULL, 0xE00000, NULL, HFILL }},

    {&hf_ieee80211_s1g_page_slice_page_bitmap,
     {"Page Bitmap", "wlan.page_slice.page_bitmap",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_request_mode,
     {"AID Request Mode", "wlan.s1g.aid_request.aid_request_mode",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_request_interval_present,
     {"AID Request Interval Present",
      "wlan.s1g.aid_request.aid_request_mode.aid_request_interval_present",
      FT_BOOLEAN, 8, TFS(&tfs_present_not_present), 0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_request_per_sta_address_present,
     {"Per STA Address Present",
      "wlan.s1g.aid_request.aid_request_mode.per_sta_address_present",
      FT_BOOLEAN, 8, TFS(&tfs_present_not_present), 0x02, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_request_service_characteristic_present,
     {"Service Characteristic Present",
      "wlan.s1g.aid_request.aid_request_mode.service_characteristic_present",
      FT_BOOLEAN, 8, TFS(&tfs_present_not_present), 0x04, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_request_non_tim_mode_switch,
     {"Non-TIM Mode Switch",
      "wlan.s1g.aid_request.aid_request_mode.non_tim_mode_switch",
      FT_BOOLEAN, 8, TFS(&tfs_present_not_present), 0x08, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_request_tim_mode_switch,
     {"TIM Mode Switch",
      "wlan.s1g.aid_request.aid_request_mode.tim_mode_switch",
      FT_BOOLEAN, 8, TFS(&tfs_present_not_present), 0x10, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_request_group_address_present,
     {"Group Address Present",
      "wlan.s1g.aid_request.aid_request_mode.group_address_present",
      FT_BOOLEAN, 8, TFS(&tfs_present_not_present), 0x20, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_request_reserved,
     {"Reserved", "wlan.s1g.aid_request.aid_request_mode.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xC0, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_request_interval,
     {"AID Request Interval", "wlan.s1g.aid_request.aid_request_interval",
      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_request_characteristic_sensor,
     {"Sensor", "wlan.s1g.aid_request.service_characteristic.sensor",
      FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_request_characteristic_offload,
     {"Offload", "wlan.s1g.aid_request.service_characteristic.offload",
      FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_request_characteristic_official_service,
     {"Critical Service",
      "wlan.s1g.aid_request.service_characteristic.critical_service",
      FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_request_characteristic_reserved,
     {"Reserved", "wlan.s1g.aid_request.service_characteristic.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xF8, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_req_peer_sta_addr,
     {"Peer STA Address", "wlan.s1g.aid_request.peer_sta_address",
      FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_request_characteristic,
     {"Service Characteristic", "wlan.s1g.aid_request.service_characteristic",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_req_group_addr,
     {"Group Mac Address", "wlan.s1g.aid_request.group_mac_address",
      FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_rsp_aid_group_aid,
     {"AID/Group AID", "wlan.s1g.aid_response.aid_group_aid",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_rsp_aid_switch_count,
     {"AID Switch Count", "wlan.s1g.aid_response.aid_switch_count",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_rsp_aid_response_interval,
     {"AID Response Interval", "wlan.s1g.aid_response.aid_response_interval",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_sector_op_control_16b,
     {"Sector Operation Control", "wlan.s1g.sector_operation.control",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_sector_op_sectorization_type_b16,
     {"Sectorization Type",
      "wlan.s1g.sector_operation.control.sectorization_type",
      FT_BOOLEAN, 16, TFS(&sectorization_type_tfs), 0x0001, NULL, HFILL }},

    {&hf_ieee80211_s1g_sector_op_periodic_training_indicator,
     {"Periodic Training Indicator",
      "wlan.s1g.sector_operation.control.periodic_training_indicator",
      FT_BOOLEAN, 16, NULL, 0x0002, NULL, HFILL }},

    {&hf_ieee80211_s1g_sector_op_training_period,
     {"Training Period",
      "wlan.s1g.sector_operation.control.training_interval",
      FT_UINT16, BASE_DEC, NULL, 0x00FC, NULL, HFILL }},

    {&hf_ieee80211_s1g_sector_op_remaining_beacon_interval,
     {"Remaining Beacon Interval",
      "wlan.s1g.sector_operation.control.remaining_beacon_interval",
      FT_UINT16, BASE_DEC, NULL, 0x3F00, NULL, HFILL }},

    {&hf_ieee80211_s1g_sector_op_reserved_b16,
     {"Reserved", "wlan.s1g.sector_operation.reserved",
      FT_UINT16, BASE_HEX, NULL, 0xC000, NULL, HFILL }},

    {&hf_ieee80211_s1g_sector_op_control,
     {"Sector Operation Control", "wlan.s1g.sector_operation.control",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_sector_op_sectorization_type,
     {"Sectorization Type",
      "wlan.s1g.sector_operation.control.sectorization_type",
      FT_BOOLEAN, 8, TFS(&sectorization_type_tfs), 0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_sector_op_period,
     {"Period", "wlan.s1g.sector_operation.control.period",
      FT_UINT8, BASE_DEC, NULL, 0x7E, NULL, HFILL }},

    {&hf_ieee80211_s1g_sector_op_omni,
     {"Omni", "wlan.s1g.sector_operation.control.omni",
      FT_BOOLEAN, 8, TFS(&sectorization_omni_tfs), 0x80, NULL, HFILL }},

    {&hf_ieee80211_s1g_sector_op_group_info,
     {"Group Info", "wlan.s1g.sector_operation.group_info",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_short_beacon_interval,
     {"Short Beacon Interval", "wlan.sig.short_beacon_interval",
      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_change_sequence,
     {"Change Sequence", "wlan.s1g.change_sequence",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    /* Need to add a TFS for this and perhaps two versions */
    {&hf_ieee80211_s1g_auth_control_control,
     {"Control", "wlan.s1g.auth_control.control",
      FT_BOOLEAN, 16, NULL, 0x0001, NULL, HFILL }},

    {&hf_ieee80211_s1g_auth_control_deferral,
     {"Deferral", "wlan.s1g.auth_control.deferral",
      FT_BOOLEAN, 16, NULL, 0x0002, NULL, HFILL }},

    {&hf_ieee80211_s1g_auth_control_reserved,
     {"Reserved", "wlan.s1g.auth_control.reserved",
      FT_UINT16, BASE_HEX, NULL, 0x003C, NULL, HFILL }},

    {&hf_ieee80211_s1g_auth_control_thresh,
     {"Authentication Control Threshold", "wlan.s1g.auth_control.threshold",
      FT_UINT16, BASE_DEC, NULL, 0xFFC0, NULL, HFILL }},

    {&hf_ieee80211_s1g_auth_control_thresh_tus,
     {"Authentication Control Threshold", "wlan.s1g.auth_control.threshold",
      FT_UINT16, BASE_DEC|BASE_UNIT_STRING, UNS(&units_tu_tus),
      0xFFC0, NULL, HFILL }},

    {&hf_ieee80211_s1g_auth_slot_duration,
     {"Authentication Slot Duration", "wlan.s1g.auth_control.slot_duration",
      FT_UINT24, BASE_DEC|BASE_UNIT_STRING, UNS(&units_di_dis), 0x0000FE,
      NULL, HFILL }},

    {&hf_ieee80211_s1g_auth_max_trans_int,
     {"Maximum Transmission Interval",
      "wlan.s1g.distributed_auth_control.max_xmit_int",
      FT_UINT24, BASE_DEC|BASE_UNIT_STRING, UNS(&units_tu_tus), 0x00FF00,
      NULL, HFILL }},

    {&hf_ieee80211_s1g_auth_min_trans_int,
     {"Minimum Transmission Interval",
      "wlan.s1g.distributed_auth_control.min_xmit_int",
      FT_UINT24, BASE_DEC|BASE_UNIT_STRING, UNS(&units_tu_tus), 0xFF0000,
      NULL, HFILL }},

    {&hf_ieee80211_s1g_tsf_timer_accuracy,
     {"TSF Timer Accuracy", "wlan.s1g.tsf_timer_accuracy",
      FT_UINT8, BASE_DEC|BASE_UNIT_STRING, UNS(&units_ppm), 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_relay_control,
     {"Relay Control", "wlan.s1g.relay_control",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_relay_control_rootap_bssid,
     {"RootAP BSSID", "wlan.s1g.relay_control.rootap_bssid",
      FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_relay_function_activation_mode,
     {"Relay Activation Mode",
      "wlan.s1g.relay_activation.relay_activation_mode",
      FT_BOOLEAN, 8, TFS(&relay_activation_mode_tfs), 0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_relay_function_direction,
     {"Direction", "wlan.s1g.relay_activation.direction",
      FT_BOOLEAN, 8, TFS(&relay_direction_tfs), 0x02, NULL, HFILL }},

    {&hf_ieee80211_s1g_relay_function_enable_relay_function,
     {"Enable Relay Function",
      "wlan.s1g.relay_activation.enable_relay_function",
      FT_UINT8, BASE_CUSTOM, CF_FUNC(enable_relay_function_custom), 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_s1g_relay_function_stas_present_indic,
     {"Number of STAs Presence Indicator",
      "wlan.s1g.relay_activation.number_of_stas_presence_indicator",
      FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},

    {&hf_ieee80211_s1g_relay_function_reserved,
     {"Reserved", "wlan.s1g.relay_activation.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xF0, NULL, HFILL }},

    {&hf_ieee80211_s1g_number_of_stas,
     {"Number of STAs", "wlan.s1g.relay_activation.number_of_stas",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_initiator_mac_address,
     {"Initiator MAC Address",
      "wlan.s1g.reachable_address.initiator_mac_address",
      FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_address_count,
     {"Address Count", "wlan.s1g.reachable_address.address_count",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_reachable_add_remove,
     {"Add/Remove", "wlan.s1g.reachable_address.add_remove",
      FT_BOOLEAN, 8, TFS(&reachable_address_add_remove_tfs),
      0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_reachable_relay_capable,
     {"Relay Capable", "wlan.s1g.reachable_address.relay_capable",
      FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_s1g_reachable_reserved,
     {"Reserved", "wlan.s1g.reachable_address.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xFC, NULL, HFILL }},

    {&hf_ieee80211_s1g_reachable_mac_address,
     {"MAC Address", "wlan.s1g.reachable_address.mac_address",
      FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_relay_discovery_control,
     {"Relay Discovery Control", "wlan.s1g.relay_discovery_control",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_min_data_rate_included,
     {"Min Data Rate Included",
      "wlan.s1g.relay_discovery_control.min_data_rate_included",
      FT_BOOLEAN, 8, TFS(&tfs_included_not_included), 0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_mean_data_rate_included,
     {"Mean Data Rate Included",
      "wlan.s1g.relay_discovery_control.mean_data_rate_included",
      FT_BOOLEAN, 8, TFS(&tfs_included_not_included), 0x02, NULL, HFILL }},

    {&hf_ieee80211_s1g_max_data_rate_included,
     {"Max Data Rate Included",
      "wlan.s1g.relay_discovery_control.max_data_rate_included",
      FT_BOOLEAN, 8, TFS(&tfs_included_not_included), 0x04, NULL, HFILL }},

    {&hf_ieee80211_s1g_delay_and_min_phy_rate,
     {"Delay and Min Phy Rate Included",
      "wlan.s1g.relay_discovery_control.delay_and_min_phy_rate_included",
      FT_BOOLEAN, 8, TFS(&tfs_included_not_included), 0x08, NULL, HFILL }},

    {&hf_ieee80211_s1g_information_not_available,
     {"Information Not Available",
      "wlan.s1g.relay_discovery_control.information_not_available",
      FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},

    {&hf_ieee80211_s1g_relay_control_ul_min,
     {"UL Min Data Rate (100kbps)", "wlan.s1g.relay_discovery.ul_min_data_rate",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_relay_control_ul_mean,
     {"UL Mean Data Rate (100kbps)",
      "wlan.s1g.relay_discovery.ul_mean_data_rate",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_relay_control_ul_max,
     {"UL Max Data Rate (100kbps)", "wlan.s1g.relay_discovery.ul_max_data_rate",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_relay_control_dl_min,
     {"DL Min Data Rate (100kbps)", "wlan.s1g.relay_discovery.dl_min_data_rate",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_relay_control_dl_mean,
     {"DL Mean Data Rate (100kbps)",
      "wlan.s1g.relay_discovery.dl_mean_data_rate",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_relay_control_dl_max,
     {"DL Max Data Rate (100kbps)", "wlan.s1g.relay_discovery.dl_max_data_rate",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_relay_discovery_reserved,
     {"Reserved", "wlan.s1g.relay_discovery_control.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xE0, NULL, HFILL }},

    {&hf_ieee80211_s1g_relay_hierarchy_identifier,
     {"Relay Hierarchy Identifier",
      "wlan.s1g.relay_control.relay_hierarchy_identifier",
      FT_UINT8, BASE_DEC|BASE_RANGE_STRING, RVALS(relay_hierarchy_rstrs),
      0x7F, NULL, HFILL }},

    {&hf_ieee80211_s1g_relay_no_more_relay_flag,
     {"No More Relay Flag", "wlan.s1g.relay_control.no_more_relay_flag",
      FT_BOOLEAN, 8, TFS(&no_more_relay_flag_tfs), 0x80, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_entry_mac_addr,
     {"STA MAC Address", "wlan.s1g.aid_entry.sta_mac_address",
      FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_aid_entry_assoc_id,
     {"Association ID", "wlan.s1g.aid_entry.association_id",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_beacon_compatibility_info,
     {"Compatibility Information", "wlan.s1g.beacon_compatibility_info",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_beacon_interval,
     {"Beacon Interval", "wlan.s1g.beacon_interval",
      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_tsf_completion,
     {"TSF Completion", "wlan.s1g.tsf_completion",
      FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_channel_width,
     {"Channel Width", "wlan.s1g.channel_width",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_primary_channel_width,
     {"Primary Channel Width", "wlan.s1g.channel_width.primary_channel_width",
      FT_UINT8, BASE_DEC, VALS(primary_channel_width_vals),
      0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_bss_operating_channel_width,
     {"BSS Operating Channel Width",
      "wlan.s1g.channel_width.bss_operating_channel_width",
      FT_UINT8, BASE_DEC, NULL, 0x1e, NULL, HFILL }},

    {&hf_ieee80211_s1g_primary_channel_location,
     {"1MHz Primary Channel Location",
      "wlan.s1g.channel_width.1mhz_primary_channel_location",
      FT_UINT8, BASE_DEC,
      VALS(one_mhz_primary_channel_location_vals), 0x20, NULL, HFILL }},

    {&hf_ieee80211_s1g_reserved_b6,
     {"Reserved", "wlan.s1g.channel_width.reserved_b6",
      FT_UINT8, BASE_DEC, NULL, 0x40, NULL, HFILL }},

    {&hf_ieee80211_s1g_mcs10_use,
     {"MCS10 Use", "wlan.s1g.channel_width.mcs10_use",
      FT_UINT8, BASE_DEC, VALS(mcs10_use_vals), 0x80,
      NULL, HFILL }},

    {&hf_ieee80211_s1g_operating_class,
     {"Operating Class", "wlan.s1g.operating_class",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_primary_channel_number,
     {"Primary Channel Number", "wlan.s1g.primary_channel_number",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_channel_center_frequency,
     {"Channel Center Frequency", "wlan.s1g.channel_center_frequency",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_basic_mcs_and_nss_set,
     {"Basic S1G-MCS and NSS Set", "wlan.s1g.basic_s1g_mcs_and_nss",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_sst_enabled_channel_bitmap,
     {"SST Enabled Channel Bitmap", "wlan.s1g.sst_enabled_channel_bitmap",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_sst_primary_channel_offset,
     {"Primary Channel Offset", "wlan.s1g.primary_channel_offset",
      FT_UINT8, BASE_DEC, NULL, 0x07, NULL, HFILL }},

    {&hf_ieee80211_s1g_sst_channel_unit,
     {"SST Channel Unit", "wlan.s1g.sst_channel_unit",
      FT_UINT8, BASE_DEC, VALS(sst_channel_unit_vals), 0x08, NULL, HFILL }},

    {&hf_ieee80211_s1g_sst_reserved,
     {"Reserved", "wlan.s1g.sst_reserved",
      FT_UINT8, BASE_HEX, NULL, 0xF0, NULL, HFILL }},

    {&hf_ieee80211_s1g_max_away_duration,
     {"Max Away Duration", "wlan.s1g.max_away_duration",
      FT_UINT16, BASE_DEC | BASE_UNIT_STRING, UNS(&units_tu_tus),
      0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_tim_bmapctrl,
     {"Bitmap Control", "wlan.s1g.tim.bitmap_control",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_tim_bmapctl_traffic_indicator,
     {"Traffic Indication", "wlan.s1g.tim.traffic_indication",
      FT_UINT8, BASE_HEX, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_tim_page_slice_number,
     {"Page Slice Number", "wlan.s1g.tim.page_slice_number",
      FT_UINT8, BASE_DEC, NULL, 0x3E, NULL, HFILL }},

    {&hf_ieee80211_s1g_tim_page_index,
     {"Page Index", "wlan.s1g.tim.page_index",
      FT_UINT8, BASE_DEC, NULL, 0xC0, NULL, HFILL }},

    {&hf_ieee80211_s1g_pvb_block_control_byte,
     {"Block Control Byte", "wlan.s1g.tim.pvb.block_control",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_pvb_encoding_mode,
     {"Encoding Mode", "wlan.s1g.tim.pvb.block_control.encoding_mode",
      FT_UINT8, BASE_HEX, VALS(s1g_block_control_encoding_mode_vals),
      0x03, NULL, HFILL }},

    {&hf_ieee80211_s1g_pvb_inverse_bitmap,
     {"Inverse Bitmap", "wlan.s1g.tim.pvb.block_control.inverse_bitmap",
      FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},

    {&hf_ieee80211_s1g_pvb_block_offset,
     {"Block Offset", "wlan.s1g.tim.pvb.block_offset",
      FT_UINT8, BASE_DEC, NULL, 0xF8, NULL, HFILL }},

    {&hf_ieee80211_s1g_block_bitmap,
     {"Block Bitmap", "wlan.s1g.tim.pvb.block_bitmap.bitmap",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_block_bitmap_sta_aid13,
     {"STA AID13", "wlan.s1g.tim.pvb.block_bitmap.subblock.aid13",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_block_bitmap_ade,
     {"ADE Control", "wlan.s1g.tim.pvb.block_bitmap.ade.control",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_block_bitmap_ewl,
     {"EWL", "wlan.s1g.tim.pvb.block_bitmap.ade.ewl",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_block_bitmap_len,
     {"Length", "wlan.s1g.tim.pvb.block_bitmap.ade.length",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_block_bitmap_ade_bytes,
     {"Bitmap", "wlan.s1g.tim.pvb.block_bitmap.ade.bitmap",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_block_bitmap_single_aid,
     {"Single AID13", "wlan.s1g.tim.pvb.single_aid",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_block_bitmap_olb_length,
     {"Length", "wlan.s1g.tim.pvb.olb.length",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_probe_response_group_bitmap,
     {"Probe Response Group Bitmap", "wlan.s1g.probe_response_group_bitmap",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_probe_resp_subfield_0,
     {"Probe Response Option Default Bitmap",
      "wlan.s1g.probe_response_option_default_bitmap",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_pv1_probe_response_req_full_ssid,
     {"Request Full SSID", "wlan.s1g.probe_response_option_request_full_ssid",
      FT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x01, NULL, HFILL }},

    {&hf_ieee80211_pv1_probe_response_req_next_tbtt,
     {"Request Next TBTT", "wlan.s1g.probe_response_option_request_next_tbtt",
      FT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x02, NULL, HFILL }},

    {&hf_ieee80211_pv1_probe_response_req_access_network_option,
     {"Request Access Network Options",
      "wlan.s1g.probe_response_option_request_access_network_options",
      FT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x04, NULL, HFILL }},

    {&hf_ieee80211_pv1_probe_response_req_s1g_beacon_compatibility,
     {"Request S1G Beacon Compatibility",
      "wlan.s1g.probe_response_option_request_s1g_beacon_compatibility",
      FT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x08, NULL, HFILL }},

    {&hf_ieee80211_pv1_probe_response_req_supported_rates,
     {"Request Supported Rates",
      "wlan.s1g.probe_response_option_request_supported_rates",
      FT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x10, NULL, HFILL }},

    {&hf_ieee80211_pv1_probe_response_req_s1g_capability,
     {"Request S1G Capability",
      "wlan.s1g.probe_response_option_request_s1g_capability",
      FT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x20, NULL, HFILL }},

    {&hf_ieee80211_pv1_probe_response_req_s1g_operation,
     {"Request S1G Operation",
      "wlan.s1g.probe_response_option_request_s1g_operation",
      FT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x40, NULL, HFILL }},

    {&hf_ieee80211_pv1_probe_response_req_rsn,
     {"Request RSN", "wlan.s1g.probe_response_option_request_rsn",
      FT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x80, NULL, HFILL }},

    {&hf_ieee80211_s1g_el_op_max_awake_duration,
     {"Max Awake Duration", "wlan.s1g.el_operation.max_awake_duration",
      FT_UINT16, BASE_CUSTOM, CF_FUNC(s1g_max_awake_duration_custom),
      0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_el_op_recovery_time_duration,
     {"Recovery Time Duration", "wlan.s1g.el_operation.recovery_time_duration",
      FT_UINT16, BASE_CUSTOM, CF_FUNC(s1g_recovery_time_duration_custom),
      0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_sectorized_group_id_list,
     {"Sectorized Group List", "wlan.s1g.sectorized_group_list",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_header_comp_control,
     {"Header Compression Control",
      "wlan.s1g.header_compression.header_compression_control",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_header_comp_req_resp,
     {"Request/Response",
      "wlan.s1g.header_compression.header_compression_control.request_response",
      FT_BOOLEAN, 8, TFS(&tfs_response_request), 0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_header_comp_store_a3,
     {"Store A3",
      "wlan.s1g.header_compression.header_compression_control.store_a3",
      FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_s1g_header_comp_store_a4,
     {"Store A4",
      "wlan.s1g.header_compression.header_compression_control.store_a4",
      FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},

    {&hf_ieee80211_s1g_header_comp_ccmp_update_present,
     {"CCMP Update Present",
      "wlan.s1g.header_compression.header_compression_control.ccmp_update_present",
      FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},

    {&hf_ieee80211_s1g_header_comp_pv1_data_type_3_supported,
     {"PV1 Data Type 3 Supported",
      "wlan.s1g.header_compression.header_compression_control.pv1_data_type_3_supported",
      FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},

    {&hf_ieee80211_s1g_header_comp_reserved,
     {"Reserved",
      "wlan.s1g.header_compression.header_compression_control.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xE0, NULL, HFILL }},

    {&hf_ieee80211_s1g_header_comp_a3,
     {"A3", "wlan.s1g.header_compression.a3",
      FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_header_comp_a4,
     {"A4", "wlan.s1g.header_compression.a4",
      FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_header_comp_ccmp_update,
     {"CCMP Update", "wlan.s1g.header_compression.ccmp_update",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_ampduparam,
     {"A-MPDU Parameters", "wlan.ht.ampduparam",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ampduparam_vs,
     {"A-MPDU Parameters (VS)", "wlan.vs.ht.ampduparam",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Vendor Specific A-MPDU Parameters", HFILL }},

    {&hf_ieee80211_ampduparam_mpdu,
     {"Maximum Rx A-MPDU Length", "wlan.ht.ampduparam.maxlength",
      FT_UINT8, BASE_HEX, NULL, 0x03,
      NULL, HFILL }},

    {&hf_ieee80211_ampduparam_mpdu_start_spacing,
     {"MPDU Density", "wlan.ht.ampduparam.mpdudensity",
      FT_UINT8, BASE_HEX, VALS(ampduparam_mpdu_start_spacing_flags), 0x1c,
      NULL, HFILL }},

    {&hf_ieee80211_ampduparam_reserved,
     {"Reserved", "wlan.ht.ampduparam.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xE0,
      NULL, HFILL }},

    {&hf_ieee80211_mcsset,
     {"Rx Supported Modulation and Coding Scheme Set", "wlan.ht.mcsset",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_mcsset_vs,
     {"Rx Supported Modulation and Coding Scheme Set (VS)", "wlan.vs.ht.mcsset",
      FT_NONE, BASE_NONE, NULL, 0,
      "Vendor Specific Rx Supported Modulation and Coding Scheme Set", HFILL }},

    {&hf_ieee80211_mcsset_rx_bitmask,
     {"Rx Modulation and Coding Scheme (One bit per modulation)", "wlan.ht.mcsset.rxbitmask",
      FT_NONE, BASE_NONE, NULL, 0,
      "One bit per modulation", HFILL }},

    {&hf_ieee80211_mcsset_rx_bitmask_0to7,
     {"Rx Bitmask Bits 0-7", "wlan.ht.mcsset.rxbitmask.0to7",
      FT_UINT32, BASE_HEX, NULL, 0x000000ff,
      NULL, HFILL }},

    {&hf_ieee80211_mcsset_rx_bitmask_8to15,
     {"Rx Bitmask Bits 8-15", "wlan.ht.mcsset.rxbitmask.8to15",
      FT_UINT32, BASE_HEX, NULL, 0x0000ff00,
      NULL, HFILL }},

    {&hf_ieee80211_mcsset_rx_bitmask_16to23,
     {"Rx Bitmask Bits 16-23", "wlan.ht.mcsset.rxbitmask.16to23",
      FT_UINT32, BASE_HEX, NULL, 0x00ff0000,
      NULL, HFILL }},

    {&hf_ieee80211_mcsset_rx_bitmask_24to31,
     {"Rx Bitmask Bits 24-31", "wlan.ht.mcsset.rxbitmask.24to31",
      FT_UINT32, BASE_HEX, NULL, 0xff000000,
      NULL, HFILL }},

    {&hf_ieee80211_mcsset_rx_bitmask_32,
     {"Rx Bitmask Bit 32", "wlan.ht.mcsset.rxbitmask.32",
      FT_UINT32, BASE_HEX, NULL, 0x000001,
      NULL, HFILL }},

    {&hf_ieee80211_mcsset_rx_bitmask_33to38,
     {"Rx Bitmask Bits 33-38", "wlan.ht.mcsset.rxbitmask.33to38",
      FT_UINT32, BASE_HEX, NULL, 0x00007e,
      NULL, HFILL }},

    {&hf_ieee80211_mcsset_rx_bitmask_39to52,
     {"Rx Bitmask Bits 39-52", "wlan.ht.mcsset.rxbitmask.39to52",
      FT_UINT32, BASE_HEX, NULL, 0x1fff80,
      NULL, HFILL }},

    {&hf_ieee80211_mcsset_rx_bitmask_53to76,
     {"Rx Bitmask Bits 53-76", "wlan.ht.mcsset.rxbitmask.53to76",
      FT_UINT32, BASE_HEX, NULL, 0x1fffffe0,
      NULL, HFILL }},

    {&hf_ieee80211_mcsset_highest_data_rate,
     {"Highest Supported Data Rate", "wlan.ht.mcsset.highestdatarate",
      FT_UINT16, BASE_HEX, NULL, 0x03ff,
      NULL, HFILL }},

    {&hf_ieee80211_mcsset_tx_mcs_set_defined,
     {"Tx Supported MCS Set", "wlan.ht.mcsset.txsetdefined",
      FT_BOOLEAN, 16, TFS(&tfs_defined_not_defined), 0x0001,
      NULL, HFILL }},

    {&hf_ieee80211_mcsset_tx_rx_mcs_set_not_equal,
     {"Tx and Rx MCS Set", "wlan.ht.mcsset.txrxmcsnotequal",
      FT_BOOLEAN, 16, TFS(&mcsset_tx_rx_mcs_set_not_equal_flag), 0x0002,
      NULL, HFILL }},

    {&hf_ieee80211_mcsset_tx_max_spatial_streams,
     {"Maximum Number of Tx Spatial Streams Supported", "wlan.ht.mcsset.txmaxss",
      FT_UINT16, BASE_HEX, NULL, 0x000c,
      NULL, HFILL }},

    {&hf_ieee80211_mcsset_tx_unequal_modulation,
     {"Unequal Modulation", "wlan.ht.mcsset.txunequalmod",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0010,
      NULL, HFILL }},

    {&hf_ieee80211_htex_cap,
     {"HT Extended Capabilities", "wlan.htex.capabilities",
      FT_UINT16, BASE_HEX, NULL, 0,
      "HT Extended Capability information", HFILL }},

    {&hf_ieee80211_htex_vs_cap,
     {"HT Extended Capabilities (VS)", "wlan.vs.htex.capabilities",
      FT_UINT16, BASE_HEX, NULL, 0,
      "Vendor Specific HT Extended Capability information", HFILL }},

    {&hf_ieee80211_htex_pco,
     {"Transmitter supports PCO", "wlan.htex.capabilities.pco",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0001,
      NULL, HFILL }},

    {&hf_ieee80211_htex_transtime,
     {"Time needed to transition between 20MHz and 40MHz", "wlan.htex.capabilities.transtime",
      FT_UINT16, BASE_HEX, VALS(htex_transtime_flags), 0x0006,
      NULL, HFILL }},

    {&hf_ieee80211_htex_mcs,
     {"MCS Feedback capability", "wlan.htex.capabilities.mcs",
      FT_UINT16, BASE_HEX, VALS(htex_mcs_flags), 0x0300,
      NULL, HFILL }},

    {&hf_ieee80211_htex_htc_support,
     {"High Throughput", "wlan.htex.capabilities.htc",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0400,
      NULL, HFILL }},

    {&hf_ieee80211_htex_rd_responder,
     {"Reverse Direction Responder", "wlan.htex.capabilities.rdresponder",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0800,
      NULL, HFILL }},

    {&hf_ieee80211_txbf,
     {"Transmit Beam Forming (TxBF) Capabilities", "wlan.txbf",
      FT_UINT32, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_txbf_vs,
     {"Transmit Beam Forming (TxBF) Capabilities (VS)", "wlan.vs.txbf",
      FT_UINT32, BASE_HEX, NULL, 0,
      "Vendor Specific Transmit Beam Forming (TxBF) Capabilities", HFILL }},

    {&hf_ieee80211_txbf_cap,
     {"Transmit Beamforming", "wlan.txbf.txbf",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00000001,
      NULL, HFILL }},

    {&hf_ieee80211_txbf_rcv_ssc,
     {"Receive Staggered Sounding", "wlan.txbf.rxss",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00000002,
      NULL, HFILL }},

    {&hf_ieee80211_txbf_tx_ssc,
     {"Transmit Staggered Sounding", "wlan.txbf.txss",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00000004,
      NULL, HFILL }},

    {&hf_ieee80211_txbf_rcv_ndp,
     {"Receive Null Data packet (NDP)", "wlan.txbf.rxndp",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00000008,
      NULL, HFILL }},

    {&hf_ieee80211_txbf_tx_ndp,
     {"Transmit Null Data packet (NDP)", "wlan.txbf.txndp",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00000010,
      NULL, HFILL }},

    {&hf_ieee80211_txbf_impl_txbf,
     {"Implicit TxBF capable", "wlan.txbf.impltxbf",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00000020,
      "Implicit Transmit Beamforming (TxBF) capable", HFILL }},

    {&hf_ieee80211_txbf_calib,
     {"Calibration", "wlan.txbf.calibration",
      FT_UINT32, BASE_HEX, VALS(txbf_calib_flag), 0x000000c0,
      NULL, HFILL }},

    {&hf_ieee80211_txbf_expl_csi,
     {"STA can apply TxBF using CSI explicit feedback", "wlan.txbf.csi",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00000100,
      "Station can apply TxBF using CSI explicit feedback", HFILL }},

    {&hf_ieee80211_txbf_expl_uncomp_fm,
     {"STA can apply TxBF using uncompressed beamforming feedback matrix", "wlan.txbf.fm.uncompressed.tbf",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00000200,
      "Station can apply TxBF using uncompressed beamforming feedback matrix", HFILL }},

    {&hf_ieee80211_txbf_expl_comp_fm,
     {"STA can apply TxBF using compressed beamforming feedback matrix", "wlan.txbf.fm.compressed.tbf",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00000400,
      "Station can apply TxBF using compressed beamforming feedback matrix", HFILL }},

    {&hf_ieee80211_txbf_expl_bf_csi,
     {"Receiver can return explicit CSI feedback", "wlan.txbf.rcsi",
      FT_UINT32, BASE_HEX, VALS(txbf_feedback_flags), 0x00001800,
      NULL, HFILL }},

    {&hf_ieee80211_txbf_expl_uncomp_fm_feed,
     {"Receiver can return explicit uncompressed Beamforming Feedback Matrix", "wlan.txbf.fm.uncompressed.rbf",
      FT_UINT32, BASE_HEX, VALS(txbf_feedback_flags), 0x00006000,
      NULL, HFILL }},

    {&hf_ieee80211_txbf_expl_comp_fm_feed,
     {"STA can compress and use compressed Beamforming Feedback Matrix", "wlan.txbf.fm.compressed.bf",
      FT_UINT32, BASE_HEX, VALS(txbf_feedback_flags), 0x00018000,
      "Station can compress and use compressed Beamforming Feedback Matrix", HFILL }},

    {&hf_ieee80211_txbf_min_group,
     {"Minimal grouping used for explicit feedback reports", "wlan.txbf.mingroup",
      FT_UINT32, BASE_HEX, VALS(txbf_min_group_flags), 0x00060000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_cap,
     {"VHT Capabilities Info", "wlan.vht.capabilities",
      FT_UINT32, BASE_HEX, NULL, 0,
      "VHT Capabilities information", HFILL }},

    {&hf_ieee80211_vht_max_mpdu_length,
     {"Maximum MPDU Length", "wlan.vht.capabilities.maxmpdulength",
      FT_UINT32, BASE_HEX, VALS(vht_max_mpdu_length_flag), 0x00000003,
      "Octets", HFILL }},

    {&hf_ieee80211_vht_supported_chan_width_set,
     {"Supported Channel Width Set", "wlan.vht.capabilities.supportedchanwidthset",
      FT_UINT32, BASE_HEX, VALS(vht_supported_chan_width_set_flag), 0x0000000c,
      NULL, HFILL }},

    {&hf_ieee80211_vht_rx_ldpc,
     {"Rx LDPC", "wlan.vht.capabilities.rxldpc",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00000010,
      NULL, HFILL }},

    {&hf_ieee80211_vht_short_gi_for_80,
     {"Short GI for 80MHz/TVHT_MODE_4C", "wlan.vht.capabilities.short80",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00000020,
      NULL, HFILL }},

    {&hf_ieee80211_vht_short_gi_for_160,
     {"Short GI for 160MHz and 80+80MHz", "wlan.vht.capabilities.short160",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00000040,
      NULL, HFILL }},

    {&hf_ieee80211_vht_tx_stbc,
     {"Tx STBC", "wlan.vht.capabilities.txstbc",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00000080,
      NULL, HFILL }},

    {&hf_ieee80211_vht_rx_stbc,
     {"Rx STBC", "wlan.vht.capabilities.rxstbc",
      FT_UINT32, BASE_HEX, VALS(vht_rx_stbc_flag), 0x00000700,
      NULL, HFILL }},

    {&hf_ieee80211_vht_su_beamformer_cap,
     {"SU Beamformer Capable", "wlan.vht.capabilities.subeamformer",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00000800,
      NULL, HFILL }},

    {&hf_ieee80211_vht_su_beamformee_cap,
     {"SU Beamformee Capable", "wlan.vht.capabilities.subeamformee",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00001000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_beamformer_antennas,
     {"Beamformee STS Capability", "wlan.vht.capabilities.beamformee_sts_cap",
      FT_UINT32, BASE_HEX, VALS(num_plus_one_3bit_flag), 0x0000e000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_sounding_dimensions,
     {"Number of Sounding Dimensions", "wlan.vht.capabilities.soundingdimensions",
      FT_UINT32, BASE_HEX, VALS(num_plus_one_3bit_flag), 0x00070000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mu_beamformer_cap,
     {"MU Beamformer Capable", "wlan.vht.capabilities.mubeamformer",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00080000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mu_beamformee_cap,
     {"MU Beamformee Capable", "wlan.vht.capabilities.mubeamformee",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00100000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_txop_ps,
     {"TXOP PS", "wlan.vht.capabilities.vhttxopps",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00200000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_var_htc_field,
     {"+HTC-VHT Capable", "wlan.vht.capabilities.vhthtc",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x00400000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_max_ampdu,
     {"Max A-MPDU Length Exponent", "wlan.vht.capabilities.maxampdu",
      FT_UINT32, BASE_HEX, VALS(vht_max_ampdu_flag), 0x03800000,
      "Octets", HFILL }},

    {&hf_ieee80211_vht_link_adaptation_cap,
     {"VHT Link Adaptation", "wlan.vht.capabilities.linkadapt",
      FT_UINT32, BASE_HEX, VALS(vht_link_adapt_flag), 0x0c000000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_rx_pattern,
     {"Rx Antenna Pattern Consistency", "wlan.vht.capabilities.rxpatconsist",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x10000000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_tx_pattern,
     {"Tx Antenna Pattern Consistency", "wlan.vht.capabilities.txpatconsist",
      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), 0x20000000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_ext_nss_bw_support,
     {"Extended NSS BW Support", "wlan.vht.capabilities.ext_nss_bw_support",
      FT_UINT32, BASE_HEX, NULL, 0xc0000000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset,
     {"VHT Supported MCS Set", "wlan.vht.mcsset",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_rx_mcs_map,
     {"Rx MCS Map", "wlan.vht.mcsset.rxmcsmap",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_rx_max_mcs_for_1_ss,
     {"Rx 1 SS", "wlan.vht.mcsset.rxmcsmap.ss1",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x0003,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_rx_max_mcs_for_2_ss,
     {"Rx 2 SS", "wlan.vht.mcsset.rxmcsmap.ss2",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x000c,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_rx_max_mcs_for_3_ss,
     {"Rx 3 SS", "wlan.vht.mcsset.rxmcsmap.ss3",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x0030,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_rx_max_mcs_for_4_ss,
     {"Rx 4 SS", "wlan.vht.mcsset.rxmcsmap.ss4",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x00c0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_rx_max_mcs_for_5_ss,
     {"Rx 5 SS", "wlan.vht.mcsset.rxmcsmap.ss5",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x0300,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_rx_max_mcs_for_6_ss,
     {"Rx 6 SS", "wlan.vht.mcsset.rxmcsmap.ss6",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x0c00,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_rx_max_mcs_for_7_ss,
     {"Rx 7 SS", "wlan.vht.mcsset.rxmcsmap.ss7",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x3000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_rx_max_mcs_for_8_ss,
     {"Rx 8 SS", "wlan.vht.mcsset.rxmcsmap.ss8",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0xc000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_max_nsts_total,
     {"MaX NSTS Total", "wlan.vht.mcsset.max_nsts_total",
      FT_UINT16, BASE_DEC, NULL, 0xe000, NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_rx_highest_long_gi,
     {"Rx Highest Long GI Data Rate (in Mb/s, 0 = subfield not in use)", "wlan.vht.mcsset.rxhighestlonggirate",
      FT_UINT16, BASE_HEX, NULL, 0x1fff,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_tx_mcs_map,
     {"Tx MCS Map", "wlan.vht.mcsset.txmcsmap",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_tx_max_mcs_for_1_ss,
     {"Tx 1 SS", "wlan.vht.mcsset.txmcsmap.ss1",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x0003,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_tx_max_mcs_for_2_ss,
     {"Tx 2 SS", "wlan.vht.mcsset.txmcsmap.ss2",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x000c,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_tx_max_mcs_for_3_ss,
     {"Tx 3 SS", "wlan.vht.mcsset.txmcsmap.ss3",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x0030,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_tx_max_mcs_for_4_ss,
     {"Tx 4 SS", "wlan.vht.mcsset.txmcsmap.ss4",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x00c0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_tx_max_mcs_for_5_ss,
     {"Tx 5 SS", "wlan.vht.mcsset.txmcsmap.ss5",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x0300,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_tx_max_mcs_for_6_ss,
     {"Tx 6 SS", "wlan.vht.mcsset.txmcsmap.ss6",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x0c00,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_tx_max_mcs_for_7_ss,
     {"Tx 7 SS", "wlan.vht.mcsset.txmcsmap.ss7",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x3000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_tx_max_mcs_for_8_ss,
     {"Tx 8 SS", "wlan.vht.mcsset.txmcsmap.ss8",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0xc000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_tx_highest_long_gi,
     {"Tx Highest Long GI Data Rate  (in Mb/s, 0 = subfield not in use)", "wlan.vht.mcsset.txhighestlonggirate",
      FT_UINT16, BASE_HEX, NULL, 0x1fff,
      NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_extended_nss_bw_capable,
     {"VHT Extended NSS BW Capable", "wlan.vht.mcsset.vht_ext_nss_bw_capable",
      FT_BOOLEAN, 16, TFS(&tfs_capable_not_capable), 0x2000, NULL, HFILL }},

    {&hf_ieee80211_vht_mcsset_reserved,
     {"Reserved", "wlan.vht.mcsset.reserved",
      FT_UINT16, BASE_HEX, NULL, 0xc000, NULL, HFILL }},

    {&hf_ieee80211_vht_op,
     {"VHT Operation Info", "wlan.vht.op",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_op_channel_width,
     {"Channel Width", "wlan.vht.op.channelwidth",
      FT_UINT8, BASE_DEC, VALS(channel_width_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_op_channel_center0,
     {"Channel Center Segment 0", "wlan.vht.op.channelcenter0",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_op_channel_center1,
     {"Channel Center Segment 1", "wlan.vht.op.channelcenter1",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_op_basic_mcs_map,
     {"Basic MCS Map", "wlan.vht.op.basicmcsmap",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_op_max_basic_mcs_for_1_ss,
     {"Basic 1 SS", "wlan.vht.op.basicmcsmap.ss1",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x0003,
      NULL, HFILL }},

    {&hf_ieee80211_vht_op_max_basic_mcs_for_2_ss,
     {"Basic 2 SS", "wlan.vht.op.basicmcsmap.ss2",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x000c,
      NULL, HFILL }},

    {&hf_ieee80211_vht_op_max_basic_mcs_for_3_ss,
     {"Basic 3 SS", "wlan.vht.op.basicmcsmap.ss3",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x0030,
      NULL, HFILL }},

    {&hf_ieee80211_vht_op_max_basic_mcs_for_4_ss,
     {"Basic 4 SS", "wlan.vht.op.basicmcsmap.ss4",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x00c0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_op_max_basic_mcs_for_5_ss,
     {"Basic 5 SS", "wlan.vht.op.basicmcsmap.ss5",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x0300,
      NULL, HFILL }},

    {&hf_ieee80211_vht_op_max_basic_mcs_for_6_ss,
     {"Basic 6 SS", "wlan.vht.op.basicmcsmap.ss6",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x0c00,
      NULL, HFILL }},

    {&hf_ieee80211_vht_op_max_basic_mcs_for_7_ss,
     {"Basic 7 SS", "wlan.vht.op.basicmcsmap.ss7",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0x3000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_op_max_basic_mcs_for_8_ss,
     {"Basic 8 SS", "wlan.vht.op.basicmcsmap.ss8",
      FT_UINT16, BASE_HEX, VALS(vht_supported_mcs_flag), 0xc000,
      NULL, HFILL }},

    {&hf_ieee80211_vht_tpe_pwr_info,
     {"Tx Pwr Info", "wlan.vht.tpe.pwr_info",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_tpe_pwr_info_count,
     {"Max Tx Pwr Count", "wlan.vht.tpe.pwr_info.count",
      FT_UINT8, BASE_DEC, NULL , 0x07,
      NULL, HFILL }},

    {&hf_ieee80211_vht_tpe_pwr_info_unit,
     {"Max Tx Pwr Unit Interpretation", "wlan.vht.tpe.pwr_info.unit",
      FT_UINT8, BASE_DEC, VALS(vht_tpe_pwr_units) , 0x38,
      NULL, HFILL }},

    {&hf_ieee80211_vht_tpe_pwr_info_category,
     {"Max Tx Pwr Category", "wlan.vht.tpe.pwr_info.category",
      FT_UINT8, BASE_DEC, NULL , 0xC0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_tpe_pwr_constr_20,
     {"Local Max Tx Pwr Constraint 20MHz", "wlan.vht.tpe.pwr_constr_20",
      FT_INT8, BASE_CUSTOM, CF_FUNC(vht_tpe_custom), 0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_tpe_pwr_constr_40,
     {"Local Max Tx Pwr Constraint 40MHz", "wlan.vht.tpe.pwr_constr_40",
      FT_INT8, BASE_CUSTOM, CF_FUNC(vht_tpe_custom), 0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_tpe_pwr_constr_80,
     {"Local Max Tx Pwr Constraint 80MHz", "wlan.vht.tpe.pwr_constr_80",
      FT_INT8, BASE_CUSTOM, CF_FUNC(vht_tpe_custom), 0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_tpe_pwr_constr_160,
     {"Local Max Tx Pwr Constraint 160MHz/80+80 MHz", "wlan.vht.tpe.pwr_constr_160",
      FT_INT8, BASE_CUSTOM, CF_FUNC(vht_tpe_custom), 0,
      NULL, HFILL }},

    {&hf_ieee80211_vht_tpe_any_bw_psd,
     {"Max Tx Power Spectral Density", "wlan.vht.tpe.max_tx_psd",
      FT_INT8, BASE_CUSTOM, CF_FUNC(tpe_psd_custom), 0, NULL, HFILL }},

    {&hf_ieee80211_vht_tpe_psd,
     {"Power Spectral Density", "wlan.vht.tpe.psd",
      FT_INT8, BASE_CUSTOM, CF_FUNC(tpe_psd_custom), 0, NULL, HFILL }},

    {&hf_ieee80211_txbf_csi_num_bf_ant,
     {"Max antennae STA can support when CSI feedback required", "wlan.txbf.csinumant",
      FT_UINT32, BASE_HEX, VALS(txbf_antenna_flags), 0x00180000,
      "Max antennae station can support when CSI feedback required", HFILL }},

    {&hf_ieee80211_txbf_uncomp_sm_bf_ant,
     {"Max antennae STA can support when uncompressed Beamforming feedback required", "wlan.txbf.fm.uncompressed.maxant",
      FT_UINT32, BASE_HEX, VALS(txbf_antenna_flags), 0x00600000,
      "Max antennae station can support when uncompressed Beamforming feedback required", HFILL }},

    {&hf_ieee80211_txbf_comp_sm_bf_ant,
     {"Max antennae STA can support when compressed Beamforming feedback required", "wlan.txbf.fm.compressed.maxant",
      FT_UINT32, BASE_HEX, VALS(txbf_antenna_flags), 0x01800000,
      "Max antennae station can support when compressed Beamforming feedback required", HFILL }},

    {&hf_ieee80211_txbf_csi_max_rows_bf,
     {"Maximum number of rows of CSI explicit feedback", "wlan.txbf.csi.maxrows",
      FT_UINT32, BASE_HEX, VALS(txbf_csi_max_rows_bf_flags), 0x06000000,
      NULL, HFILL }},

    {&hf_ieee80211_txbf_chan_est,
     {"Maximum number of space time streams for which channel dimensions can be simultaneously estimated", "wlan.txbf.channelest",
      FT_UINT32, BASE_HEX, VALS(txbf_chan_est_flags), 0x18000000,
      NULL, HFILL }},

    {&hf_ieee80211_txbf_resrv,
     {"Reserved", "wlan.txbf.reserved",
      FT_UINT32, BASE_HEX, NULL, 0xe0000000,
      NULL, HFILL }},

    {&hf_ieee80211_hta_cc,
     {"HT Control Channel", "wlan.hta.control_channel",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_hta_cap1,
     {"HT Additional Capabilities", "wlan.hta.capabilities",
      FT_UINT8, BASE_HEX, NULL, 0,
      "HT Additional Capability information", HFILL }},

    {&hf_ieee80211_hta_cap2,
     {"HT Additional Capabilities", "wlan.hta.capabilities",
      FT_UINT16, BASE_HEX, NULL, 0,
      "HT Additional Capability information", HFILL }},

    {&hf_ieee80211_hta_ext_chan_offset,
     {"Extension Channel Offset", "wlan.hta.capabilities.ext_chan_offset",
      FT_UINT16, BASE_HEX, VALS(hta_ext_chan_offset_flag), 0x0003,
      NULL, HFILL }},

    {&hf_ieee80211_hta_rec_tx_width,
     {"Recommended Tx Channel Width", "wlan.hta.capabilities.rec_tx_width",
      FT_BOOLEAN, 16, TFS(&hta_rec_tx_width_flag), 0x0004,
      "Recommended Transmit Channel Width", HFILL }},

    {&hf_ieee80211_hta_rifs_mode,
     {"Reduced Interframe Spacing (RIFS) Mode", "wlan.hta.capabilities.rifs_mode",
      FT_BOOLEAN, 16, TFS(&hta_rifs_mode_flag), 0x0008,
      NULL, HFILL }},

    {&hf_ieee80211_hta_controlled_access,
     {"Controlled Access Only", "wlan.hta.capabilities.controlled_access",
      FT_BOOLEAN, 16, TFS(&hta_controlled_access_flag), 0x0010,
      NULL, HFILL }},

    {&hf_ieee80211_hta_service_interval,
     {"Service Interval Granularity", "wlan.hta.capabilities.service_interval",
      FT_UINT16, BASE_HEX, VALS(hta_service_interval_flag), 0x00E0,
      NULL, HFILL }},

    {&hf_ieee80211_hta_operating_mode,
     {"Operating Mode", "wlan.hta.capabilities.operating_mode",
      FT_UINT16, BASE_HEX, VALS(hta_operating_mode_flag), 0x0003,
      NULL, HFILL }},

    {&hf_ieee80211_hta_non_gf_devices,
     {"Non Greenfield (GF) devices Present", "wlan.hta.capabilities.non_gf_devices",
      FT_BOOLEAN, 16, TFS(&hta_non_gf_devices_flag), 0x0004,
      "on Greenfield (GF) devices Present", HFILL }},

    {&hf_ieee80211_hta_basic_stbc_mcs,
     {"Basic STB Modulation and Coding Scheme (MCS)", "wlan.hta.capabilities.basic_stbc_mcs",
      FT_UINT16, BASE_HEX, NULL , 0x007f,
      NULL, HFILL }},

    {&hf_ieee80211_hta_dual_stbc_protection,
     {"Dual Clear To Send (CTS) Protection", "wlan.hta.capabilities.dual_stbc_protection",
      FT_BOOLEAN, 16, TFS(&hta_dual_stbc_protection_flag), 0x0080,
      NULL, HFILL }},

    {&hf_ieee80211_hta_secondary_beacon,
     {"Secondary Beacon", "wlan.hta.capabilities.secondary_beacon",
      FT_BOOLEAN, 16, TFS(&hta_secondary_beacon_flag), 0x0100,
      NULL, HFILL }},

    {&hf_ieee80211_hta_lsig_txop_protection,
     {"L-SIG TXOP Protection Support", "wlan.hta.capabilities.lsig_txop_protection",
      FT_BOOLEAN, 16, TFS(&hta_lsig_txop_protection_flag), 0x0200,
      NULL, HFILL }},

    {&hf_ieee80211_hta_pco_active,
     {"Phased Coexistence Operation (PCO) Active", "wlan.hta.capabilities.pco_active",
      FT_BOOLEAN, 16, TFS(&hta_pco_active_flag), 0x0400,
      NULL, HFILL }},

    {&hf_ieee80211_hta_pco_phase,
     {"Phased Coexistence Operation (PCO) Phase", "wlan.hta.capabilities.pco_phase",
      FT_BOOLEAN, 16, TFS(&hta_pco_phase_flag), 0x0800,
      NULL, HFILL }},

    {&hf_ieee80211_antsel,
     {"Antenna Selection (ASEL) Capabilities", "wlan.asel",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_antsel_vs,
     {"Antenna Selection (ASEL) Capabilities (VS)", "wlan.vs.asel",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Vendor Specific Antenna Selection (ASEL) Capabilities", HFILL }},

    {&hf_ieee80211_antsel_b0,
     {"Antenna Selection Capable", "wlan.asel.capable",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_antsel_b1,
     {"Explicit CSI Feedback Based Tx ASEL", "wlan.asel.txcsi",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_antsel_b2,
     {"Antenna Indices Feedback Based Tx ASEL", "wlan.asel.txif",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_antsel_b3,
     {"Explicit CSI Feedback", "wlan.asel.csi",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_antsel_b4,
     {"Antenna Indices Feedback", "wlan.asel.if",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_antsel_b5,
     {"Rx ASEL", "wlan.asel.rx",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x20,
      NULL, HFILL }},

    {&hf_ieee80211_antsel_b6,
     {"Tx Sounding PPDUs", "wlan.asel.sppdu",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x40,
      NULL, HFILL }},

    {&hf_ieee80211_antsel_b7,
     {"Reserved", "wlan.asel.reserved",
      FT_UINT8, BASE_HEX, NULL, 0x80,
      NULL, HFILL }},

    {&hf_ieee80211_ht_info_delimiter1,
     {"HT Information Subset (1 of 3)", "wlan.ht.info.delim1",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ht_info_primary_channel,
     {"Primary Channel", "wlan.ht.info.primarychannel",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ht_info_secondary_channel_offset,
     {"Secondary channel offset", "wlan.ht.info.secchanoffset",
      FT_UINT8, BASE_HEX, VALS(ht_info_secondary_channel_offset_flags), 0x03,
      NULL, HFILL }},

    {&hf_ieee80211_ht_info_sta_channel_width,
     {"Supported channel width", "wlan.ht.info.chanwidth",
      FT_BOOLEAN, 8, TFS(&ht_info_channel_sta_width_flag), 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_ht_info_rifs_mode,
     {"Reduced Interframe Spacing (RIFS)", "wlan.ht.info.rifs",
      FT_BOOLEAN, 8, TFS(&ht_info_rifs_mode_flag), 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_ht_info_reserved_b4_b7,
     {"Reserved", "wlan.ht.info.reserved_b4_b7",
      FT_UINT8, BASE_HEX, NULL, 0xf0, NULL, HFILL }},

    {&hf_ieee80211_ht_info_delimiter2,
     {"HT Information Subset (2 of 3)", "wlan.ht.info.delim2",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ht_info_protection,
     {"HT Protection", "wlan.ht.info.ht_protection",
      FT_UINT16, BASE_HEX, VALS(ht_info_operating_protection_mode_flags), 0x0003,
      NULL, HFILL }},

    {&hf_ieee80211_ht_info_non_greenfield_sta_present,
     {"Non-greenfield STAs present", "wlan.ht.info.greenfield",
      FT_BOOLEAN, 16, TFS(&ht_info_non_greenfield_sta_present_flag), 0x0004,
      NULL, HFILL }},

    {&hf_ieee80211_ht_info_reserved_b11,
     {"Reserved", "wlan.ht.info.reserved_b11",
      FT_UINT16, BASE_HEX, NULL, 0x0008, NULL, HFILL }},

    {&hf_ieee80211_ht_info_obss_non_ht_stas_present,
     {"OBSS non-HT STAs present", "wlan.ht.info.obssnonht",
      FT_BOOLEAN, 16, TFS(&ht_info_obss_non_ht_stas_present_flag), 0x0010,
      NULL, HFILL }},

    {&hf_ieee80211_ht_info_channel_center_freq_seg_2,
     {"Channel Center Frequency Segment 2", "wlan.ht.info.chan_center_freq_seg_2",
      FT_UINT16, BASE_DEC, NULL, 0x1fe0, NULL, HFILL }},

    {&hf_ieee80211_ht_info_reserved_b21_b23,
     {"Reserved", "wlan.ht.info.reserved_b21_b23",
      FT_UINT16, BASE_HEX, NULL, 0xe000,
      NULL, HFILL }},

    {&hf_ieee80211_ht_info_delimiter3,
     {"HT Information Subset (3 of 3)", "wlan.ht.info.delim3",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ht_info_reserved_b24_b29,
     {"Reserved", "wlan.ht.info.reserved_b24_b29",
      FT_UINT16, BASE_HEX, NULL, 0x003f, NULL, HFILL }},

    {&hf_ieee80211_ht_info_dual_beacon,
     {"Dual beacon", "wlan.ht.info.dualbeacon",
      FT_BOOLEAN, 16, TFS(&ht_info_dual_beacon_flag), 0x0040,
      NULL, HFILL }},

    {&hf_ieee80211_ht_info_dual_cts_protection,
     {"Dual Clear To Send (CTS) protection", "wlan.ht.info.dualcts",
      FT_BOOLEAN, 16, TFS(&tfs_required_not_required), 0x0080,
      NULL, HFILL }},

    {&hf_ieee80211_ht_info_secondary_beacon,
     {"Beacon ID", "wlan.ht.info.secondarybeacon",
      FT_BOOLEAN, 16, TFS(&ht_info_secondary_beacon_flag), 0x0100,
      NULL, HFILL }},

    {&hf_ieee80211_ht_info_lsig_txop_protection_full_support,
     {"L-SIG TXOP Protection Full Support", "wlan.ht.info.lsigprotsupport",
      FT_BOOLEAN, 16, TFS(&ht_info_lsig_txop_protection_full_support_flag), 0x0200,
      NULL, HFILL }},

    {&hf_ieee80211_ht_info_pco_active,
     {"Phased Coexistence Operation (PCO)", "wlan.ht.info.pco.active",
      FT_BOOLEAN, 16, TFS(&tfs_active_inactive), 0x0400,
      NULL, HFILL }},

    {&hf_ieee80211_ht_info_pco_phase,
     {"Phased Coexistence Operation (PCO) Phase", "wlan.ht.info.pco.phase",
      FT_BOOLEAN, 16, TFS(&ht_info_pco_phase_flag), 0x0800,
      NULL, HFILL }},

    {&hf_ieee80211_ht_info_reserved_b36_b39,
     {"Reserved", "wlan.ht.info.reserved_b36_b39",
      FT_UINT16, BASE_HEX, NULL, 0xf000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ap_channel_report_operating_class,
     {"Operating Class", "wlan.ap_channel_report.operating_class",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ap_channel_report_channel_list,
     {"Channel List", "wlan.ap_channel_report.channel_list",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_secondary_channel_offset,
     {"Secondary Channel Offset", "wlan.secchanoffset",
      FT_UINT8, BASE_HEX, VALS(ieee80211_tag_secondary_channel_offset_flags), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_ap_avg_access_delay,
     {"AP Average Access Delay", "wlan.bss_ap_avg_access_delay",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_antenna_id,
     {"Antenna ID", "wlan.antenna.id",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rsni,
     {"RSNI", "wlan.rsni",
      FT_UINT8, BASE_CUSTOM, CF_FUNC(rsni_base_custom), 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_bitmask,
     {"Available Admission Capacity Bitmask", "wlan.bss_avb_adm_cap.bitmask",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up0,
     {"UP0 (bit0)", "wlan.bss_avb_adm_cap.bitmask.up0",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), BSS_BITMASK_UP0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up1,
     {"UP1 (bit1)", "wlan.bss_avb_adm_cap.bitmask.up1",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), BSS_BITMASK_UP1,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up2,
     {"UP2 (bit2)", "wlan.bss_avb_adm_cap.bitmask.up2",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), BSS_BITMASK_UP2,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up3,
     {"UP3 (bit3)", "wlan.bss_avb_adm_cap.bitmask.up3",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), BSS_BITMASK_UP3,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up4,
     {"UP4 (bit4)", "wlan.bss_avb_adm_cap.bitmask.up4",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), BSS_BITMASK_UP4,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up5,
     {"UP5 (bit5)", "wlan.bss_avb_adm_cap.bitmask.up5",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), BSS_BITMASK_UP5,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up6,
     {"UP6 (bit6)", "wlan.bss_avb_adm_cap.bitmask.up6",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), BSS_BITMASK_UP6,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_bitmask_up7,
     {"UP7 (bit7)", "wlan.bss_avb_adm_cap.bitmask.up7",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), BSS_BITMASK_UP7,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_bitmask_ac0,
     {"AC0 (bit8)", "wlan.bss_avb_adm_cap.bitmask.ac0",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), BSS_BITMASK_AC0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_bitmask_ac1,
     {"AC1 (bit9)", "wlan.bss_avb_adm_cap.bitmask.AC1",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), BSS_BITMASK_AC1,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_bitmask_ac2,
     {"AC2 (bit10)", "wlan.bss_avb_adm_cap.bitmask.ac2",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), BSS_BITMASK_AC2,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_bitmask_ac3,
     {"AC3 (bit11)", "wlan.bss_avb_adm_cap.bitmask.ac3",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), BSS_BITMASK_AC3,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_bitmask_rsv,
     {"Reserved", "wlan.bss_avb_adm_cap.bitmask.rsv",
      FT_UINT16, BASE_HEX, NULL, BSS_BITMASK_RSV,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_up0,
     {"UP0", "wlan.bss_avb_adm_cap.up0",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_up1,
     {"UP1", "wlan.bss_avb_adm_cap.up1",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_up2,
     {"UP2", "wlan.bss_avb_adm_cap.up2",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_up3,
     {"UP3", "wlan.bss_avb_adm_cap.up3",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_up4,
     {"UP4", "wlan.bss_avb_adm_cap.up4",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_up5,
     {"UP5", "wlan.bss_avb_adm_cap.up5",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_up6,
     {"UP6", "wlan.bss_avb_adm_cap.up6",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_up7,
     {"UP7", "wlan.bss_avb_adm_cap.up7",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_ac0,
     {"AC0", "wlan.bss_avb_adm_cap.ac0",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_ac1,
     {"AC1", "wlan.bss_avb_adm_cap.ac1",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_ac2,
     {"AC2", "wlan.bss_avb_adm_cap.ac2",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avb_adm_cap_ac3,
     {"AC3", "wlan.bss_avb_adm_cap.ac3",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avg_ac_access_delay_be,
     {"AC Average Access Delay for Best Effort", "wlan.bss_avg_ac_access_delay.be",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avg_ac_access_delay_bk,
     {"AC Average Access Delay for Best Background", "wlan.bss_avg_ac_access_delay.bk",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avg_ac_access_delay_vi,
     {"AC Average Access Delay for Video", "wlan.bss_avg_ac_access_delay_vi",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_bss_avg_ac_access_delay_vo,
     {"AC Average Access Delay for Voice", "wlan.bss_avg_ac_access_delay_vo",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},


    /* 802.11-2012 Table 8-119-RM Enabled Capabilities definition */
    {&hf_ieee80211_tag_rm_enabled_capabilities,
     {"RM Capabilities", "wlan.rmcap",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Signals support for radio measurements in a device", HFILL }},

    /* RM Enabled Capability octet 1 */
    {&hf_ieee80211_tag_rm_enabled_capabilities_b0,
     {"Link Measurement", "wlan.rmcap.b0",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b1,
     {"Neighbor Report", "wlan.rmcap.b1",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b2,
     {"Parallel Measurements", "wlan.rmcap.b2",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b3,
     {"Repeated Measurements", "wlan.rmcap.b3",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b4,
     {"Beacon Passive Measurement", "wlan.rmcap.b4",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b5,
     {"Beacon Active Measurement", "wlan.rmcap.b5",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x20,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b6,
     {"Beacon Table Measurement", "wlan.rmcap.b6",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x40,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b7,
     {"Beacon Measurement Reporting Conditions", "wlan.rmcap.b7",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x80,
      NULL, HFILL }},

    /* RM Enabled Capability octet 2 */
    {&hf_ieee80211_tag_rm_enabled_capabilities_b8,
     {"Frame Measurement", "wlan.rmcap.b8",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b9,
     {"Channel Load Measurement", "wlan.rmcap.b9",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b10,
     {"Noise Histogram Measurement", "wlan.rmcap.b10",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b11,
     {"Statistics Measurement", "wlan.rmcap.b11",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b12,
     {"LCI Measurement", "wlan.rmcap.b12",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b13,
     {"LCI Azimuth capability", "wlan.rmcap.b13",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x20,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b14,
     {"Transmit Stream/Category Measurement", "wlan.rmcap.b14",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x40,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b15,
     {"Triggered Transmit Stream/Category Measurement", "wlan.rmcap.b15",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x80,
      NULL, HFILL }},

    /* RM Enabled Capability octet 3 */
    {&hf_ieee80211_tag_rm_enabled_capabilities_b16,
     {"AP Channel Report capability", "wlan.rmcap.b16",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b17,
     {"RM MIB capability", "wlan.rmcap.b17",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b18to20,
     {"Operating Channel Max Measurement Duration", "wlan.rmcap.b18to20",
      FT_UINT8, BASE_DEC, NULL, 0x1C,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b21to23,
     {"Nonoperating Channel Max Measurement Duration", "wlan.rmcap.b21to23",
      FT_UINT8, BASE_DEC, NULL, 0xE0,
      NULL, HFILL }},

    /* RM Enabled Capability octet 4 */
    {&hf_ieee80211_tag_rm_enabled_capabilities_b24to26,
     {"Measurement Pilotcapability", "wlan.rmcap.b24to26",
      FT_UINT8, BASE_DEC, NULL, 0x07,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b27,
     {"Measurement Pilot Transmission Information", "wlan.rmcap.b27",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b28,
     {"Neighbor Report TSF Offset", "wlan.rmcap.b28",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b29,
     {"RCPI Measurement capability", "wlan.rmcap.b29",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x20,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b30,
     {"RSNI Measurement capability", "wlan.rmcap.b30",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x40,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b31,
     {"BSS Average Access Delay capability", "wlan.rmcap.b31",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x80,
      NULL, HFILL }},

    /* RM Enabled Capability octet 5 */
    {&hf_ieee80211_tag_rm_enabled_capabilities_b32,
     {"BSS Available Admission Capacity capability", "wlan.rmcap.b32",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b33,
     {"Antenna capability", "wlan.rmcap.b33",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b34,
     {"FTM Range Report Capability", "wlan.rmcap.b34",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_b35,
     {"Civic Location Measurement Capability", "wlan.rmcap.b35",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_tag_rm_enabled_capabilities_o5,
     {"Reserved", "wlan.rmcap.o5",
      FT_UINT8, BASE_HEX, NULL, 0xF0,
      "Must be zero", HFILL }},

    {&hf_ieee80211_tag_rcpi,
     {"RCPI", "wlan.rcpi",
      FT_UINT8, BASE_CUSTOM, CF_FUNC(rcpi_and_power_level_custom), 0,
      "Received channel power indicator", HFILL }},

    /* Multiple BSSID */
    {&hf_ieee80211_tag_multiple_bssid,
     {"Max BSSID Indicator", "wlan.multiple_bssid",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_multiple_bssid_subelem_id,
     {"Subelement ID", "wlan.multiple_bssid.subelem.id",
      FT_UINT8, BASE_DEC, VALS(multiple_bssid_subelem_ids), 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_multiple_bssid_subelem_len,
     {"Length", "wlan.multiple_bssid.subelem.len",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_multiple_bssid_subelem_reserved,
     {"Reserved", "wlan.multiple_bssid.subelem.reserved",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_multiple_bssid_subelem_nontrans_profile,
     {"Nontransmitted Profile", "wlan.multiple_bssid.subelem.nontrans_profile",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    /* 20/40 BSS Coexistence */
    {&hf_ieee80211_tag_20_40_bc,
     {"20/40 BSS Coexistence Flags", "wlan.20_40_bc",
      FT_UINT8, BASE_HEX, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_20_40_bc_information_request,
     {"Information Request", "wlan.20_40_bc.information_request",
      FT_BOOLEAN, 8, NULL, 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_20_40_bc_forty_mhz_intolerant,
     {"Forty MHz Intolerant", "wlan.20_40_bc.forty_mhz_intolerant",
      FT_BOOLEAN, 8, NULL, 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_20_40_bc_20_mhz_bss_width_request,
     {"20 MHz BSS Width Request", "wlan.20_40_bc.20_mhz_bss_width_request",
      FT_BOOLEAN, 8, NULL, 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_20_40_bc_obss_scanning_exemption_request,
     {"OBSS Scanning Exemption Request", "wlan.20_40_bc.obss_scanning_exemption_request",
      FT_BOOLEAN, 8, NULL, 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_tag_20_40_bc_obss_scanning_exemption_grant,
     {"OBSS Scanning Exemption Grant", "wlan.20_40_bc.obss_scanning_exemption_grant",
      FT_BOOLEAN, 8, NULL, 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_tag_20_40_bc_reserved,
     {"Reserved", "wlan.20_40_bc.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xE0,
      "Must be zero", HFILL }},

    {&hf_ieee80211_tag_intolerant_operating_class,
     {"Intolerant Operating Class", "wlan.tag.intolerant.operating_class",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_intolerant_channel_list,
     {"Intolerant Channel List", "wlan.tag.intolerant.channel_list",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_intolerant_channel,
     {"Intolerant Channel", "wlan.tag.intolerant.channel",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_power_constraint_local,
     {"Local Power Constraint", "wlan.powercon.local",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Value that allows the mitigation requirements to be satisfied in the current channel", HFILL }},

    {&hf_ieee80211_tag_power_capability_min,
     {"Minimum Transmit Power", "wlan.powercap.min",
      FT_INT8, BASE_DEC|BASE_UNIT_STRING, UNS(&units_dbm), 0,
      "The nominal minimum transmit power with which the STA is capable of transmitting in the current channel", HFILL }},

    {&hf_ieee80211_tag_power_capability_max,
     {"Maximum Transmit Power", "wlan.powercap.max",
      FT_INT8, BASE_DEC|BASE_UNIT_STRING, UNS(&units_dbm), 0,
      "The nominal maximum transmit power with which the STA is capable of transmitting in the current channel", HFILL }},

    {&hf_ieee80211_tag_tpc_report_trsmt_pow,
     {"Transmit Power", "wlan.tpcrep.trsmt_pow",
      FT_INT8, BASE_DEC|BASE_UNIT_STRING, UNS(&units_dbm), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_tpc_report_link_mrg,
     {"Link Margin", "wlan.tpcrep.link_mrg",
      FT_INT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_tpc_report_reserved,
     {"Reserved", "wlan.tpcrep.reserved",
      FT_INT8, BASE_DEC, NULL, 0,
      "TPC Link Margin field is reserved in a Beacon or Probe Response frame", HFILL }},

    {&hf_ieee80211_tag_supported_channels,
     {"Supported Channels Set", "wlan.supchan",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_supported_channels_first,
     {"First Supported Channel", "wlan.supchan.first",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_supported_channels_range,
     {"Supported Channel Range", "wlan.supchan.range",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_csa_channel_switch_mode,
     {"Channel Switch Mode", "wlan.csa.channel_switch_mode",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Indicates any restrictions on transmission until a channel switch", HFILL }},

    {&hf_ieee80211_csa_new_channel_number,
     {"New Channel Number", "wlan.csa.new_channel_number",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Set to the number of the channel to which the STA is moving", HFILL }},

    {&hf_ieee80211_csa_channel_switch_count,
     {"Channel Switch Count", "wlan.csa.channel_switch.count",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Set to the number of TBTTs until the STA sending the Channel Switch Announcement element switches to the new channel or shall be set to 0", HFILL }},

    {&hf_ieee80211_mesh_channel_switch_ttl,
     {"Mesh Channel Switch TTL", "wlan.csa.mesh_channel_switch.ttl",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_channel_switch_flag,
     {"Mesh Channel Switch Flag", "wlan.csa.mesh_channel_switch.flag",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_chswitch_flag_txrestrict,
     {"CSA Tx Restrict", "wlan.csa.mesh_channel_switch.flag.txrestrict",
      FT_BOOLEAN, 16, TFS(&csa_txrestrict_flags), 0x0001,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_chswitch_flag_initiator,
     {"CSA Initiator", "wlan.csa.mesh_channel_switch.flag.initiator",
      FT_BOOLEAN, 16, TFS(&csa_initiator_flags), 0x0002,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_channel_switch_reason_code,
     {"Mesh Channel Switch Reason Code", "wlan.csa.mesh_channel_switch.reason_code",
      FT_UINT16, BASE_HEX|BASE_EXT_STRING, &ieee80211_reason_code_ext, 0,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_channel_switch_precedence_value,
     {"Mesh Channel Switch Precedence Value", "wlan.csa.mesh_channel_switch.pre_value",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_mesh_awake_window,
     {"Mesh Awake Window", "wlan.mesh.mesh_awake_window",
      FT_UINT16, BASE_CUSTOM, CF_FUNC(mesh_active_window_base_custom), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_token,
     {"Measurement Token", "wlan.measure.req.token",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_mode,
     {"Measurement Request Mode", "wlan.measure.req.mode",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_mode_parallel,
     {"Parallel", "wlan.measure.req.reqmode.parallel",
      FT_BOOLEAN, 8, NULL, 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_mode_enable,
     {"Measurement Request Mode Field", "wlan.measure.req.reqmode.enable",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_mode_request,
     {"Measurement Reports", "wlan.measure.req.reqmode.request",
      FT_BOOLEAN, 8, TFS(&tfs_accepted_not_accepted), 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_mode_report,
     {"Autonomous Measurement Reports", "wlan.measure.req.reqmode.report",
      FT_BOOLEAN, 8, TFS(&tfs_accepted_not_accepted), 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_mode_duration_mandatory,
     {"Duration Mandatory", "wlan.measure.req.reqmode.duration_mandatory",
      FT_BOOLEAN, 8, TFS(&tfs_accepted_not_accepted), 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_mode_reserved,
     {"Reserved", "wlan.measure.req.reqmode.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xE0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_type,
     {"Measurement Request Type", "wlan.measure.req.reqtype",
      FT_UINT8, BASE_HEX|BASE_EXT_STRING, &ieee80211_tag_measure_request_type_flags_ext, 0x00,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_channel_number,
     {"Measurement Channel Number", "wlan.measure.req.channelnumber",
      FT_UINT8, BASE_CUSTOM, CF_FUNC(channel_number_custom), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_start_time,
     {"Measurement Start Time", "wlan.measure.req.starttime",
      FT_UINT64, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_duration,
     {"Measurement Duration", "wlan.measure.req.duration",
      FT_UINT16, BASE_HEX, NULL, 0,
      "in TU (1 TU = 1024 us)", HFILL }},

    {&hf_ieee80211_tag_measure_request_operating_class,
     {"Operating Class", "wlan.measure.req.operatingclass",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_randomization_interval,
     {"Randomization Interval", "wlan.measure.req.randint",
      FT_UINT16, BASE_HEX, NULL, 0,
      "in TU (1 TU = 1024 us)", HFILL }},

    {&hf_ieee80211_tag_measure_request_measurement_mode,
     {"Measurement Mode", "wlan.measure.req.measurementmode",
      FT_UINT8, BASE_HEX, VALS(ieee80211_tag_measure_request_measurement_mode_flags), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_bssid,
     {"BSSID", "wlan.measure.req.bssid",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_subelement_length,
     {"Length", "wlan.measure.req.sub.length",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_beacon_sub_id,
     {"SubElement ID", "wlan.measure.req.beacon.sub.id",
      FT_UINT8, BASE_DEC, VALS(ieee80211_tag_measure_request_beacon_sub_id_flags), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_beacon_sub_ssid,
     {"SSID", "wlan.measure.req.beacon.sub.ssid",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_beacon_sub_bri_reporting_condition,
     {"Reporting Condition", "wlan.measure.req.beacon.sub.bri.repcond",
      FT_UINT8, BASE_HEX, VALS(ieee80211_tag_measure_request_beacon_sub_bri_reporting_condition_flags), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_beacon_sub_bri_threshold_offset,
     {"Threshold/Offset", "wlan.measure.req.beacon.sub.bri.threshold_offset",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_beacon_sub_reporting_detail,
     {"Reporting Detail", "wlan.measure.req.beacon.sub.bri.reporting_detail",
      FT_UINT8, BASE_HEX, VALS(ieee80211_tag_measure_request_beacon_sub_reporting_detail_flags), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_beacon_sub_last_report_indication_request,
     {"Request Indication", "wlan.measure.req.beacon.sub.last_report_ind_req",
      FT_BOOLEAN, BASE_NONE, TFS(&tfs_yes_no), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_beacon_unknown,
     {"Unknown Data", "wlan.measure.req.beacon.unknown",
      FT_BYTES, BASE_NONE, NULL, 0,
      "(not interpreted)", HFILL }},

    {&hf_ieee80211_tag_measure_request_channel_load_sub_id,
     {"SubElement ID", "wlan.measure.req.channel_load.sub.id",
      FT_UINT8, BASE_DEC, VALS(ieee80211_tag_measure_request_channel_load_sub_id_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_channel_load_sub_reporting_condition,
     {"Reporting Condition", "wlan.measure.req.channel_load.sub.repcond",
      FT_UINT8, BASE_HEX, VALS(ieee80211_tag_measure_request_channel_load_sub_reporting_condition_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_channel_load_sub_reporting_ref,
     {"Reference Value", "wlan.measure.req.channel_load.sub.ref",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},


    {&hf_ieee80211_tag_measure_request_noise_histogram_sub_id,
     {"SubElement ID", "wlan.measure.req.noise_histogram.sub.id",
      FT_UINT8, BASE_DEC, VALS(ieee80211_tag_measure_request_noise_histogram_sub_id_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_noise_histogram_sub_reporting_condition,
     {"Reporting Condition", "wlan.measure.reqnoise_histogram.sub.repcond",
      FT_UINT8, BASE_HEX, VALS(ieee80211_tag_measure_request_noise_histogram_sub_reporting_condition_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_noise_histogram_sub_reporting_anpi_ref,
     {"ANPI Reference Value", "wlan.measure.req.noise_histogram.sub.anpiref",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},


    {&hf_ieee80211_tag_measure_request_frame_request_type,
     {"Frame Request Type", "wlan.measure.req.frame_request_type",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_mac_address,
     {"MAC Address", "wlan.measure.req.mac_address",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_peer_mac_address,
     {"Peer MAC Address", "wlan.measure.req.peer_mac_address",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_group_id,
     {"Group ID", "wlan.measure.req.groupid",
      FT_UINT8, BASE_HEX|BASE_EXT_STRING, &ieee80211_tag_measure_request_group_id_flags_ext, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_location_subject,
     {"Location Subject", "wlan.measure.req.location_subject",
      FT_UINT8, BASE_DEC, VALS(ieee80211_tag_measure_request_location_subject), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_civic_location_type,
     {"Civic Location Type", "wlan.measure.req.location_type",
      FT_UINT8, BASE_DEC, VALS(ieee80211_tag_measure_request_civic_location_type), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_location_service_interval_units,
     {"Location Service Interval Units", "wlan.measure.req.location_service_interval_units",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_location_service_interval,
     {"Location Service Interval", "wlan.measure.req.location_service_interval",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_request_unknown,
     {"Unknown Data", "wlan.measure.req.unknown",
      FT_BYTES, BASE_NONE, NULL, 0,
      "(not interpreted)", HFILL }},

    {&hf_ieee80211_tag_measure_report_measurement_token,
     {"Measurement Token", "wlan.measure.rep.token",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_mode,
     {"Measurement Report Mode", "wlan.measure.rep.mode",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_mode_late,
     {"Late", "wlan.measure.rep.repmode.late",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_mode_incapable,
     {"Incapable", "wlan.measure.rep.repmode.incapable",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_mode_refused,
     {"Refused", "wlan.measure.rep.repmode.refused",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_mode_reserved,
     {"Reserved", "wlan.measure.rep.repmode.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xf8,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_type,
     {"Measurement Report Type", "wlan.measure.rep.reptype",
      FT_UINT8, BASE_HEX|BASE_EXT_STRING, &ieee80211_tag_measure_report_type_flags_ext, 0x00,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_channel_number,
     {"Measurement Channel Number", "wlan.measure.rep.channelnumber",
      FT_UINT8, BASE_CUSTOM, CF_FUNC(channel_number_custom), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_start_time,
     {"Measurement Start Time", "wlan.measure.rep.starttime",
      FT_UINT64, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_duration,
     {"Measurement Duration", "wlan.measure.rep.duration",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_beacon_unknown,
     {"Unknown Data", "wlan.measure.rep.beacon.unknown",
      FT_BYTES, BASE_NONE, NULL, 0,
      "(not interpreted)", HFILL }},

    {&hf_ieee80211_tag_measure_reported_frame_frag_id,
     {"Fragment ID", "wlan.measure.rep.beacon.frag_id",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL}},

    {&hf_ieee80211_tag_measure_reported_frame_frag_rep_id,
     {"Beacon Report ID", "wlan.measure.rep.beacon.frag_id.report_id",
      FT_UINT16, BASE_HEX, NULL, 0x00ff,
      NULL, HFILL}},

    {&hf_ieee80211_tag_measure_reported_frame_frag_number,
     {"Fragment ID Number", "wlan.measure.rep.beacon.frag_id.number",
      FT_UINT16, BASE_HEX, NULL, 0x7f00,
      NULL, HFILL}},

    {&hf_ieee80211_tag_measure_reported_frame_frag_more,
     {"More Frame Body Fragments", "wlan.measure.rep.beacon.frag_id.more",
      FT_UINT16, BASE_HEX, NULL, 0x8000,
      NULL, HFILL}},

    {&hf_ieee80211_tag_measure_cca_busy_fraction,
     {"CCA Busy Fraction", "wlan.measure.rep.ccabusy",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_basic_map_field,
     {"Map Field", "wlan.measure.rep.mapfield",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_map_field_bss,
     {"BSS", "wlan.measure.rep.repmode.mapfield.bss",
      FT_BOOLEAN, 8, TFS(&ieee80211_tag_measure_map_field_bss_flag), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_map_field_ofdm,
     {"Orthogonal Frequency Division Multiplexing (OFDM) Preamble", "wlan.measure.rep.repmode.mapfield.ofdm_preamble",
      FT_BOOLEAN, 8, TFS(&tfs_detected_not_detected), 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_map_field_unident_signal,
     {"Unidentified Signal", "wlan.measure.rep.repmode.mapfield.unidentsig",
      FT_BOOLEAN, 8, TFS(&tfs_detected_not_detected), 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_map_field_radar,
     {"Radar", "wlan.measure.rep.repmode.mapfield.radar",
      FT_BOOLEAN, 8, TFS(&tfs_detected_not_detected), 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_map_field_unmeasured,
     {"Unmeasured", "wlan.measure.rep.repmode.mapfield.unmeasured",
      FT_BOOLEAN, 8, NULL, 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_map_field_reserved,
     {"Reserved", "wlan.measure.rep.repmode.mapfield.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xe0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_rpi_histogram_report,
     {"Receive Power Indicator (RPI) Histogram Report", "wlan.measure.rep.rpi.histogram_report",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_rpi_histogram_report_0,
     {"RPI 0 Density", "wlan.measure.rep.rpi.rpi0density",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Receive Power Indicator (RPI) 0 Density", HFILL }},

    {&hf_ieee80211_tag_measure_rpi_histogram_report_1,
     {"RPI 1 Density", "wlan.measure.rep.rpi.rpi1density",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Receive Power Indicator (RPI) 1 Density", HFILL }},

    {&hf_ieee80211_tag_measure_rpi_histogram_report_2,
     {"RPI 2 Density", "wlan.measure.rep.rpi.rpi2density",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Receive Power Indicator (RPI) 2 Density", HFILL }},

    {&hf_ieee80211_tag_measure_rpi_histogram_report_3,
     {"RPI 3 Density", "wlan.measure.rep.rpi.rpi3density",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Receive Power Indicator (RPI) 3 Density", HFILL }},

    {&hf_ieee80211_tag_measure_rpi_histogram_report_4,
     {"RPI 4 Density", "wlan.measure.rep.rpi.rpi4density",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Receive Power Indicator (RPI) 4 Density", HFILL }},

    {&hf_ieee80211_tag_measure_rpi_histogram_report_5,
     {"RPI 5 Density", "wlan.measure.rep.rpi.rpi5density",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Receive Power Indicator (RPI) 5 Density", HFILL }},

    {&hf_ieee80211_tag_measure_rpi_histogram_report_6,
     {"RPI 6 Density", "wlan.measure.rep.rpi.rpi6density",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Receive Power Indicator (RPI) 6 Density", HFILL }},

    {&hf_ieee80211_tag_measure_rpi_histogram_report_7,
     {"RPI 7 Density", "wlan.measure.rep.rpi.rpi7density",
      FT_UINT8, BASE_HEX, NULL, 0,
      "Receive Power Indicator (RPI) 7 Density", HFILL }},

    {&hf_ieee80211_tag_measure_report_operating_class,
     {"Operating Class", "wlan.measure.rep.operatingclass",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_channel_load,
     {"Channel Load", "wlan.measure.rep.chanload",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_frame_info,
     {"Reported Frame Information", "wlan.measure.rep.frameinfo",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_frame_info_phy_type,
     {"Condensed PHY", "wlan.measure.rep.frameinfo.phytype",
      FT_UINT8, BASE_HEX, NULL, 0x7F,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_frame_info_frame_type,
     {"Reported Frame Type", "wlan.measure.rep.frameinfo.frametype",
      FT_BOOLEAN, 8, TFS(&ieee80211_tag_measure_report_frame_info_frame_type_flag), 0x80,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_rcpi,
     {"Received Channel Power Indicator (RCPI)", "wlan.measure.rep.rcpi",
      FT_UINT8, BASE_CUSTOM, CF_FUNC(rcpi_and_power_level_custom), 0,
      "in dBm", HFILL }},

    {&hf_ieee80211_tag_measure_report_rsni,
     {"Received Signal to Noise Indicator (RSNI)", "wlan.measure.rep.rsni",
      FT_UINT8, BASE_CUSTOM, CF_FUNC(rsni_base_custom), 0,
      "in dB", HFILL }},

    {&hf_ieee80211_tag_measure_report_bssid,
     {"BSSID Being Reported", "wlan.measure.rep.bssid",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_ant_id,
     {"Antenna ID", "wlan.measure.rep.antid",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_anpi,
     {"ANPI", "wlan.measure.rep.anpi",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_ipi_density_0,
     {"IPI Density 0", "wlan.measure.rep.ipi_density0",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_ipi_density_1,
     {"IPI Density 1", "wlan.measure.rep.ipi_density1",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_ipi_density_2,
     {"IPI Density 2", "wlan.measure.rep.ipi_density2",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_ipi_density_3,
     {"IPI Density 3", "wlan.measure.rep.ipi_density3",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_ipi_density_4,
     {"IPI Density 4", "wlan.measure.rep.ipi_density4",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_ipi_density_5,
     {"IPI Density 5", "wlan.measure.rep.ipi_density5",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_ipi_density_6,
     {"IPI Density 6", "wlan.measure.rep.ipi_density6",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_ipi_density_7,
     {"IPI Density 7", "wlan.measure.rep.ipi_density7",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_ipi_density_8,
     {"IPI Density 8", "wlan.measure.rep.ipi_density8",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_ipi_density_9,
     {"IPI Density 9", "wlan.measure.rep.ipi_density9",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_ipi_density_10,
     {"IPI Density 10", "wlan.measure.rep.ipi_density10",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_parent_tsf,
     {"Parent Timing Synchronization Function (TSF)", "wlan.measure.rep.parenttsf",
      FT_UINT32, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_subelement_length,
     {"Length", "wlan.measure.rep.sub.length",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_beacon_sub_id,
     {"SubElement ID", "wlan.measure.rep.beacon.sub.id",
      FT_UINT8, BASE_DEC, VALS(ieee80211_tag_measure_report_beacon_sub_id_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_unknown,
     {"Unknown Data", "wlan.measure.rep.unknown",
      FT_BYTES, BASE_NONE, NULL, 0,
      "(not interpreted)", HFILL }},

    {&hf_ieee80211_tag_measure_report_beacon_sub_last_report_indication,
     {"Last Report", "wlan.measure.req.beacon.sub.last_report",
      FT_BOOLEAN, BASE_NONE, TFS(&tfs_yes_no), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_lci_sub_id,
     {"SubElement ID", "wlan.measure.req.lci.sub.id",
      FT_UINT8, BASE_DEC, VALS(ieee80211_tag_measure_report_lci_sub_id_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_lci_lci,
     {"LCI", "wlan.measure.req.lci.lci",
      FT_BYTES, BASE_NONE, NULL, 0,
      "Location Configuration Information", HFILL }},

    {&hf_ieee80211_tag_measure_report_lci_z_sta_floor_info,
     {"STA Floor Info", "wlan.measure.req.lci.z.sta_floor_info",
      FT_UINT16, BASE_HEX, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_lci_z_sta_floor_info_expected_to_move,
     {"Expected To Move", "wlan.measure.req.lci.z.sta_floor_info.expected_to_move",
      FT_UINT16, BASE_DEC, NULL, 0x0003,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_lci_z_sta_floor_info_sta_floor_number,
     {"STA Floor Number", "wlan.measure.req.lci.z.sta_floor_info.sta_floor_number",
      FT_UINT16, BASE_DEC, NULL, 0xFFFC,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_lci_z_sta_height_above_floor,
     {"STA Height Above Floor", "wlan.measure.req.lci.z.sta_height_above_floor",
      FT_UINT24, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_lci_z_sta_height_above_floor_uncertainty,
     {"STA Height Above Floor Uncertainty", "wlan.measure.req.lci.z.sta_height_above_floor_uncertainty",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_lci_urp,
     {"Usage Rules/Policy Parameters", "wlan.measure.req.lci.urp",
      FT_UINT8, BASE_HEX, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_lci_urp_retransmission_allowed,
     {"Retransmission Allowed", "wlan.measure.req.lci.urp.retransmission_allowed",
      FT_BOOLEAN, 8, NULL, 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_lci_urp_retention_expires_relative_present,
     {"Retention Expires Relative Present", "wlan.measure.req.lci.urp.retention_expires_relative_present",
      FT_BOOLEAN, 8, NULL, 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_lci_urp_sta_location_policy,
     {"STA Location Policy", "wlan.measure.req.lci.urp.sta_location_policy",
      FT_BOOLEAN, 8, NULL, 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_lci_urp_reserved,
     {"Reserved", "wlan.measure.req.lci.urp.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xF8,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_lci_urp_retention_expires_relative,
     {"Retention Expires Relative", "wlan.measure.req.lci.urp.retention_expires_relative",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_lci_unknown,
     {"Unknown Data", "wlan.measure.rep.lci.unknown",
      FT_BYTES, BASE_NONE, NULL, 0,
      "(not interpreted)", HFILL }},

    {&hf_ieee80211_tag_measure_report_civic_location_type,
     {"Civic Location Type", "wlan.measure.rep.location_subject",
      FT_UINT8, BASE_DEC, VALS(ieee80211_tag_measure_request_civic_location_type), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_civic_sub_id,
     {"SubElement ID", "wlan.measure.rep.civic.sub.id",
      FT_UINT8, BASE_DEC, VALS(ieee80211_tag_measure_report_civic_sub_id_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_location_civic_country,
     {"Country", "wlan.measure.rep.civic.sub.country",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_location_civic_type,
     {"Type", "wlan.measure.rep.civic.sub.type",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_location_civic_length,
     {"Length", "wlan.measure.rep.civic.sub.length",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_measure_report_location_civic,
     {"Location Civic", "wlan.measure.rep.civic.sub.location_civic",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_quiet_count,
     {"Count", "wlan.quiet.count",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Set to the number of TBTTs until the beacon interval during which the next quiet interval shall start", HFILL }},

    {&hf_ieee80211_tag_quiet_period,
     {"Period", "wlan.quiet.period",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Set to the number of beacon intervals between the start of regularly scheduled quiet intervals", HFILL }},

    {&hf_ieee80211_tag_quiet_duration,
     {"Duration", "wlan.quiet.duration",
      FT_UINT16, BASE_DEC, NULL, 0,
      "Set to the duration of the quiet interval", HFILL }},

    {&hf_ieee80211_tag_quiet_offset,
     {"Offset", "wlan.quiet.offset",
      FT_UINT16, BASE_DEC, NULL, 0,
      "Set to the offset of the start of the quiet interval from the TBTT", HFILL }},

    {&hf_ieee80211_tag_dfs_owner,
     {"Owner", "wlan.dfs.owner",
      FT_ETHER, BASE_NONE, NULL, 0,
      "Set to the individual IEEE MAC address of the STA that is the currently known DFS Owner in the IBSS", HFILL  }},

    {&hf_ieee80211_tag_dfs_recovery_interval,
     {"Recovery Interval", "wlan.dfs.recovery_interval",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Indicates the time interval that shall be used for DFS owner recovery", HFILL  }},

    {&hf_ieee80211_tag_dfs_channel_map,
     {"Channel Map", "wlan.dfs.channel_map",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL  }},

    {&hf_ieee80211_tag_dfs_channel_number,
     {"Channel Number", "wlan.dfs.channel_number",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL  }},

    {&hf_ieee80211_tag_dfs_map,
     {"Map", "wlan.dfs.map",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL  }},

    {&hf_ieee80211_tag_erp_info,
     {"ERP Information", "wlan.erp_info",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL  }},

    {&hf_ieee80211_tag_erp_info_erp_present,
     {"Non ERP Present", "wlan.erp_info.erp_present",
      FT_BOOLEAN, 8, TFS(&tfs_set_notset), 0x01,
      NULL, HFILL  }},

    {&hf_ieee80211_tag_erp_info_use_protection,
     {"Use Protection", "wlan.erp_info.use_protection",
      FT_BOOLEAN, 8, TFS(&tfs_set_notset), 0x02,
      NULL, HFILL  }},

    {&hf_ieee80211_tag_erp_info_barker_preamble_mode,
     {"Barker Preamble Mode", "wlan.erp_info.barker_preamble_mode",
      FT_BOOLEAN, 8, TFS(&tfs_set_notset), 0x04,
      NULL, HFILL  }},

    {&hf_ieee80211_tag_erp_info_reserved,
     {"Reserved", "wlan.erp_info.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xF8,
      NULL, HFILL  }},

    /* IEEE Std 802.11 2016 */
    /* Table 9-135-Extended Capabilities field */
    {&hf_ieee80211_tag_extended_capabilities,
     {"Extended Capabilities", "wlan.extcap",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    /* Extended Capability octet 1 */
    {&hf_ieee80211_tag_extended_capabilities_b0,
     {"20/40 BSS Coexistence Management Support", "wlan.extcap.b0",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01,
      "HT Information Exchange Support", HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b1,
     {"General Link (GLK)", "wlan.extcap.b1",
      FT_UINT8, BASE_HEX, NULL, 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b2,
     {"Extended Channel Switching", "wlan.extcap.b2",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b3,
     {"GLK-GCR", "wlan.extcap.b3",
      FT_UINT8, BASE_HEX, NULL, 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b4,
     {"PSMP Capability", "wlan.extcap.b4",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b5,
     {"Reserved", "wlan.extcap.b5",
      FT_UINT8, BASE_HEX, NULL, 0x20,
      "Must be zero", HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b6,
     {"S-PSMP Support", "wlan.extcap.b6",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x40,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b7,
     {"Event", "wlan.extcap.b7",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x80,
      NULL, HFILL }},


    /* Extended Capability octet 2 */
    {&hf_ieee80211_tag_extended_capabilities_b8,
     {"Diagnostics", "wlan.extcap.b8",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b9,
     {"Multicast Diagnostics", "wlan.extcap.b9",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b10,
     {"Location Tracking", "wlan.extcap.b10",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b11,
     {"FMS", "wlan.extcap.b11",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b12,
     {"Proxy ARP Service", "wlan.extcap.b12",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b13,
     {"Colocated Interference Reporting", "wlan.extcap.b13",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x20,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b14,
     {"Civic Location", "wlan.extcap.b14",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x40,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b15,
     {"Geospatial Location", "wlan.extcap.b15",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x80,
      NULL, HFILL }},


    /* Extended Capability octet 3 */
    {&hf_ieee80211_tag_extended_capabilities_b16,
     {"TFS", "wlan.extcap.b16",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b17,
     {"WNM Sleep Mode", "wlan.extcap.b17",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b18,
     {"TIM Broadcast", "wlan.extcap.b18",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b19,
     {"BSS Transition", "wlan.extcap.b19",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b20,
     {"QoS Traffic Capability", "wlan.extcap.b20",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b21,
     {"AC Station Count", "wlan.extcap.b21",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x20,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b22,
     {"Multiple BSSID", "wlan.extcap.b22",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x40,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b23,
     {"Timing Measurement", "wlan.extcap.b23",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x80,
      NULL, HFILL }},


    /* Extended Capability octet 4 */
    {&hf_ieee80211_tag_extended_capabilities_b24,
     {"Channel Usage", "wlan.extcap.b24",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b25,
     {"SSID List", "wlan.extcap.b25",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b26,
     {"DMS", "wlan.extcap.b26",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b27,
     {"UTC TSF Offset", "wlan.extcap.b27",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b28,
     {"TPU Buffer STA Support", "wlan.extcap.b28",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b29,
     {"TDLS Peer PSM Support", "wlan.extcap.b29",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x20,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b30,
     {"TDLS Channel Switching", "wlan.extcap.b30",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x40,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b31,
     {"Interworking", "wlan.extcap.b31",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x80,
      NULL, HFILL }},


    /* Extended Capability octet 5 */
    {&hf_ieee80211_tag_extended_capabilities_b32,
     {"QoS Map", "wlan.extcap.b32",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b33,
     {"EBR", "wlan.extcap.b33",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b34,
     {"SSPN Interface", "wlan.extcap.b34",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b35,
     {"Reserved", "wlan.extcap.b35",
      FT_UINT8, BASE_HEX, NULL, 0x08,
      "Must be zero", HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b36,
     {"MSGCF Capability", "wlan.extcap.b36",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b37,
     {"TDLS Support", "wlan.extcap.b37",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x20,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b38,
     {"TDLS Prohibited", "wlan.extcap.b38",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x40,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b39,
     {"TDLS Channel Switching Prohibited", "wlan.extcap.b39",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x80,
      NULL, HFILL }},

    /* Extended Capability octet 6 */
    {&hf_ieee80211_tag_extended_capabilities_b40,
     {"Reject Unadmitted Frame", "wlan.extcap.b40",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_serv_int_granularity,
     {"Service Interval Granularity",
      "wlan.extcap.serv_int_granularity",
      FT_UINT8, BASE_DEC, VALS(service_interval_granularity_vals), 0x0e,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b44,
     {"Identifier Location", "wlan.extcap.b44",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b45,
     {"U-APSD Coexistence", "wlan.extcap.b45",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x20,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b46,
     {"WNM Notification", "wlan.extcap.b46",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x40,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b47,
     {"QAB Capability", "wlan.extcap.b47",
      FT_UINT8, BASE_HEX, NULL, 0x80,
      "AP supports QAB", HFILL }},

    /* Extended Capability octet 7 */
    {&hf_ieee80211_tag_extended_capabilities_b48,
     {"UTF-8 SSID", "wlan.extcap.b48",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01,
      "The SSID in this BSS is interpreted using UTF-8 encoding", HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b49,
     {"QMF Activated", "wlan.extcap.b49",
      FT_BOOLEAN, 8, NULL, 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b50,
     {"QMF Reconfiguration Activated", "wlan.extcap.b50",
      FT_BOOLEAN, 8, NULL, 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b51,
     {"Robust AV Streaming", "wlan.extcap.b51",
      FT_BOOLEAN, 8, NULL, 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b52,
     {"Advanced GCR", "wlan.extcap.b52",
      FT_BOOLEAN, 8, NULL, 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b53,
     {"Mesh GCR", "wlan.extcap.b53",
      FT_BOOLEAN, 8, NULL, 0x20,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b54,
     {"SCS", "wlan.extcap.b54",
      FT_BOOLEAN, 8, NULL, 0x40,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b55,
     {"QLoad Report", "wlan.extcap.b55",
      FT_BOOLEAN, 8, NULL, 0x80,
      NULL, HFILL }},

    /* Extended Capability octet 8 */
    {&hf_ieee80211_tag_extended_capabilities_b56,
     {"Alternate EDCA", "wlan.extcap.b56",
      FT_BOOLEAN, 8, NULL, 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b57,
     {"Unprotected TXOP Negotiation", "wlan.extcap.b57",
      FT_BOOLEAN, 8, NULL, 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b58,
     {"Protected TXOP Negotiation", "wlan.extcap.b58",
      FT_BOOLEAN, 8, NULL, 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b59,
     {"Reserved", "wlan.extcap.b59",
      FT_UINT8, BASE_HEX, NULL, 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b60,
     {"Protected QLoad Report", "wlan.extcap.b60",
      FT_BOOLEAN, 8, NULL, 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b61,
     {"TDLS Wider Bandwidth", "wlan.extcap.b61",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x20,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b62,
     {"Operating Mode Notification", "wlan.extcap.b62",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x40,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b63,
     {"Max Number Of MSDUs In A-MSDU", "wlan.extcap.b63",
      FT_UINT8, BASE_DEC, NULL, 0x80,
      "Part 1 (bit63)", HFILL }},

    /* Extended Capability octets 8 & 9 */
    {&hf_ieee80211_tag_extended_capabilities_2,
     {"Extended Capabilities", "wlan.extcap",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b56_2,
     {"Alternate EDCA", "wlan.extcap.b56",
      FT_BOOLEAN, 16, NULL, 0x0001,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b57_2,
     {"Unprotected TXOP Negotiation", "wlan.extcap.b57",
      FT_BOOLEAN, 16, NULL, 0x0002,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b58_2,
     {"Protected TXOP Negotiation", "wlan.extcap.b58",
      FT_BOOLEAN, 16, NULL, 0x0004,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b59_2,
     {"Reserved", "wlan.extcap.b59",
      FT_UINT16, BASE_HEX, NULL, 0x0008,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b60_2,
     {"Protected QLoad Report", "wlan.extcap.b60",
      FT_BOOLEAN, 16, NULL, 0x0010,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b61_2,
     {"TDLS Wider Bandwidth", "wlan.extcap.b61",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0020,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b62_2,
     {"Operating Mode Notification", "wlan.extcap.b62",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0040,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_max_num_msdus,
     {"Max Number Of MSDUs In A-MSDU", "wlan.extcap.b63",
      FT_UINT16, BASE_DEC, VALS(vht_max_mpdu_in_amsdu), 0x0180,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b65_2,
     {"Channel Schedule Management", "wlan.extcap.b65",
      FT_BOOLEAN, 16, NULL, 0x0200,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b66_2,
     {"Geodatabase Inband Enabling Signal", "wlan.extcap.b66",
      FT_BOOLEAN, 16, NULL, 0x0400,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b67_2,
     {"Network Channel Control", "wlan.extcap.b67",
      FT_BOOLEAN, 16, NULL, 0x0800,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b68_2,
     {"White Space Map", "wlan.extcap.b68",
      FT_BOOLEAN, 16, NULL, 0x1000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b69_2,
     {"Channel Availability Query", "wlan.extcap.b69",
      FT_BOOLEAN, 16, NULL, 0x2000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b70_2,
     {"Fine Timing Measurement Responder", "wlan.extcap.b70",
      FT_BOOLEAN, 16, NULL, 0x4000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b71_2,
     {"Fine Timing Measurement Initiator", "wlan.extcap.b71",
      FT_BOOLEAN, 16, NULL, 0x8000,
      NULL, HFILL }},

    /* Extended Capability Octet 10 */
    {&hf_ieee80211_tag_extended_capabilities_b72,
     {"FILS Capability", "wlan.extcap.b72",
      FT_BOOLEAN, 8, NULL, 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b73,
     {"Extended Spectrum Management Capable", "wlan.extcap.b73",
      FT_BOOLEAN, 8, NULL, 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b74,
     {"Future Channel Guidance", "wlan.extcap.b74",
      FT_BOOLEAN, 8, NULL, 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b75,
     {"Preassociation discovery (PAD)", "wlan.extcap.b75",
      FT_UINT8, BASE_HEX, NULL, 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b76,
     {"Reserved", "wlan.extcap.b76",
      FT_UINT8, BASE_HEX, NULL, 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b77,
     {"TWT Requester Support", "wlan.extcap.b77",
      FT_BOOLEAN, 8, NULL, 0x20,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b78,
     {"TWT Responder Support", "wlan.extcap.b78",
      FT_BOOLEAN, 8, NULL, 0x40,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b79,
     {"OBSS Narrow Bandwidth RU in OFDMA Tolerance Support", "wlan.extcap.b79",
      FT_BOOLEAN, 8, NULL, 0x80,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b80,
     {"Complete List of NonTxBSSID Profiles", "wlan.extcap.b80",
      FT_BOOLEAN, 8, NULL, 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b81,
     {"SAE Password Identifiers In Use", "wlan.extcap.b81",
      FT_BOOLEAN, 8, NULL, 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b82,
     {"SAE Passwords Used Exclusively", "wlan.extcap.b82",
      FT_BOOLEAN, 8, NULL, 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b83,
     {"Enhanced Multi-BSSID Advertisement Support", "wlan.extcap.b83",
      FT_BOOLEAN, 8, NULL, 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b84,
     {"Beacon Protection Enabled", "wlan.extcap.b84",
      FT_BOOLEAN, 8, NULL, 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b85,
     {"Mirrored SCS", "wlan.extcap.b85",
      FT_BOOLEAN, 8, NULL, 0x20,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b86,
     {"OCT", "wlan.extcap.b86",
      FT_BOOLEAN, 8, NULL, 0x40,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b87,
     {"Local MAC Address Policy", "wlan.extcap.b87",
      FT_BOOLEAN, 8, NULL, 0x80,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b88,
     {"SAE-PK Passwords Used Exclusively", "wlan.extcap.b88",
      FT_BOOLEAN, 8, NULL, 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b89,
     {"TWT Parameters Range Support", "wlan.extcap.b89",
      FT_UINT8, BASE_HEX, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b90,
     {"non-TB Ranging Responder", "wlan.extcap.b90",
      FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b91,
     {"TB Ranging Responder", "wlan.extcap.b91",
      FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b92,
     {"TB Ranging Responder Measurement Support", "wlan.extcap.b92",
      FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b93,
     {"TB Ranging Initiator Measurement Support", "wlan.extcap.b93",
      FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b94,
     {"AOA Measurement Available", "wlan.extcap.b94",
      FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b95,
     {"Phase Shift Feedback Support", "wlan.extcap.b95",
      FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b96,
     {"DMG/location supporting APs in the area", "wlan.extcap.dmg_location",
      FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_b97,
     {"I2R LMR Feedback Policy", "wlan.extcap.i2r_lmr_feedback_policy",
      FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_tag_extended_capabilities_reserved2,
     {"Reserved", "wlan.extcap.reserved2",
      FT_UINT8, BASE_HEX, NULL, 0xFC, NULL, HFILL }},

    {&hf_ieee80211_tag_cisco_ccx1_unknown,
     {"Unknown", "wlan.cisco.ccx1.unknown",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_cisco_ccx1_name,
     {"Name", "wlan.cisco.ccx1.name",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_cisco_ccx1_clients,
     {"Clients", "wlan.cisco.ccx1.clients",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_cisco_ccx1_unknown2,
     {"Unknown2", "wlan.cisco.ccx1.unknown2",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid,
     {"BSSID", "wlan.nreport.bssid",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info,
     {"BSSID Information", "wlan.nreport.bssid.info",
      FT_UINT32, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_reachability,
     {"AP Reachability", "wlan.nreport.bssid.info.reachability",
      FT_UINT32, BASE_HEX, VALS(ieee80211_neighbor_report_bssid_info_reachability_vals), 0x00000003,
      "Indicates whether the AP identified by this BSSID is reachable by the STA that requested the neighbor report", HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_security,
     {"Security", "wlan.nreport.bssid.info.security",
      FT_BOOLEAN, 32, NULL, 0x00000004,
      "Indicates that the AP identified by this BSSID supports the same security provisioning as used by the STA in its current association", HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_key_scope,
     {"Key Scope", "wlan.nreport.bssid.info.keyscope",
      FT_BOOLEAN, 32, NULL, 0x00000008,
      "indicates the AP indicated by this BSSID has the same authenticator as the AP sending the report", HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_capability,
     {"Capability", "wlan.nreport.bssid.info.capability",
      FT_UINT32, BASE_HEX, NULL, 0x000003F0,
      "Contains selected capability information for the AP indicated by this BSSID", HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_capability_spec_mng,
     {"Spectrum Management", "wlan.nreport.bssid.info.capability.specmngt",
      FT_BOOLEAN, 32, NULL, 0x00000010,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_capability_qos,
     {"QoS", "wlan.nreport.bssid.info.capability.qos",
      FT_BOOLEAN, 32, NULL, 0x00000020,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_capability_apsd,
     {"APSD", "wlan.nreport.bssid.info.capability.apsd",
      FT_BOOLEAN, 32, NULL, 0x00000040,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_capability_radio_msnt,
     {"Radio Measurement", "wlan.nreport.bssid.info.capability.radiomsnt",
      FT_BOOLEAN, 32, NULL, 0x00000080,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_capability_dback,
     {"Delayed Block Ack", "wlan.nreport.bssid.info.capability.dback",
      FT_BOOLEAN, 32, NULL, 0x00000100,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_capability_iback,
     {"Immediate Block Ack", "wlan.nreport.bssid.info.capability.iback",
      FT_BOOLEAN, 32, NULL, 0x00000200,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_mobility_domain,
     {"Mobility Domain", "wlan.nreport.bssid.info.mobilitydomain",
      FT_BOOLEAN, 32, NULL, 0x00000400,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_high_throughput,
     {"High Throughput Control (+HTC)", "wlan.nreport.bssid.info.hthroughput",
      FT_BOOLEAN, 32, NULL, 0x00000800,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_very_high_throughput,
     {"Very High Throughput (+VHT)", "wlan.nreport.bssid.info.vht",
      FT_BOOLEAN, 32, NULL, 0x00001000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_ftm,
     {"Fine Timing Measurement (FTM)", "wlan.nreport.bssid.info.ftm",
      FT_BOOLEAN, 32, NULL, 0x00002000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_high_efficiency,
     {"High Efficiency (HE AP)", "wlan.nreport.bssid.info.he",
      FT_BOOLEAN, 32, NULL, 0x00004000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_er_bss,
     {"Extended Range BSS", "wlan.nreport.bssid.info.er_bss",
      FT_BOOLEAN, 32, NULL, 0x00008000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_colocated_ap,
     {"Co-Located AP", "wlan.nreport.bssid.info.colocated_ap",
      FT_BOOLEAN, 32, NULL, 0x00010000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_unsolicited_probe_responses_active,
     {"Unsolicited Probe Responses Active", "wlan.nreport.bssid.info.unsolicited_probe_responses",
      FT_BOOLEAN, 32, NULL, 0x00020000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_ess_with_colocated_ap,
     {"Members Of ESS With 2.4/5 GHz Co-Located AP", "wlan.nreport.bssid.info.member_of_ess_with_2p4_5_ghz_colocated_ap",
      FT_BOOLEAN, 32, NULL, 0x00040000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_oct_supported_with_reporting_ap,
     {"OCT Supported With Reporting AP", "wlan.nreport.bssid.info.oct_supported_with_reporting_ap",
      FT_BOOLEAN, 32, NULL, 0x00080000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_colocated_6ghz_ap,
     {"Co-Located With 6 GHz AP", "wlan.nreport.bssid.info.colocated_6ghz_ap",
      FT_BOOLEAN, 32, NULL, 0x00100000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_eht,
     {"Extremely High Throughput", "wlan.nreport.bssid.info.eht",
      FT_BOOLEAN, 32, NULL, 0x00200000,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_bssid_info_reserved,
     {"Reserved", "wlan.nreport.bssid.info.reserved",
      FT_UINT32, BASE_HEX, NULL, 0xFFC00000,
      "Must be zero", HFILL }},

    {&hf_ieee80211_tag_neighbor_report_ope_class,
     {"Operating Class", "wlan.nreport.opeclass",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_channel_number,
     {"Channel Number", "wlan.nreport.channumber",
      FT_UINT8, BASE_CUSTOM, CF_FUNC(channel_number_custom), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_phy_type,
     {"PHY Type", "wlan.nreport.phytype",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_subelement_id,
     {"ID", "wlan.nreport.subelem.id",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_subelement_length,
     {"Length", "wlan.nreport.subelem.len",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_subelement_data,
     {"Data", "wlan.nreport.subelem.data",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_subelement_bss_trn_can_pref,
     {"Preference", "wlan.nreport.subelem.bss_trn_can_pref",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_subelement_bss_ter_tsf,
     {"BSS Termination TSF", "wlan.nreport.subelem.bss_ter_tsf",
      FT_UINT64, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_subelement_bss_dur,
     {"Duration", "wlan.nreport.subelem.bss_dur",
      FT_UINT16, BASE_DEC|BASE_UNIT_STRING, UNS(&units_minutes), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_neighbor_report_subelement_tsf_offset,
     {"TSF Offset", "wlan.nreport.subelem.tsf_offset",
      FT_UINT16, BASE_DEC, NULL, 0,
      "TSF Offset in TU units", HFILL } },

    {&hf_ieee80211_tag_neighbor_report_subelement_beacon_interval,
     {"Beacon Interval", "wlan.nreport.subelem.beacon_interval",
      FT_UINT16, BASE_DEC, NULL, 0,
      "Beacon Interval in TUs", HFILL } },

    {&hf_ieee80211_tag_neighbor_report_subelement_country_code,
     {"Country Code", "wlan.nreport.subelem.country_code",
      FT_STRING, BASE_NONE, NULL, 0x0,
      "ISO 3166-1 Alpha-2 Country Code", HFILL }},

    {&hf_ieee80211_tag_supported_ope_classes_current,
     {"Current Operating Class", "wlan.supopeclass.current",
      FT_UINT8, BASE_DEC | BASE_RANGE_STRING, RVALS(oper_class_rvals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_supported_ope_classes_alternate,
     {"Alternate Operating Classes", "wlan.supopeclass.alt",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_type,
     {"Type", "wlan.wfa.ie.type",
      FT_UINT8, BASE_HEX, VALS(ieee802111_wfa_ie_type_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wpa_version,
     {"WPA Version", "wlan.wfa.ie.wpa.version",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wpa_mcs,
     {"Multicast Cipher Suite", "wlan.wfa.ie.wpa.mcs",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(wpa_mcs_base_custom), 0,
      "Contains the cipher suite selector used by the BSS to protect broadcast/multicasttraffic", HFILL }},

    {&hf_ieee80211_wfa_ie_wpa_mcs_oui,
     {"Multicast Cipher Suite OUI", "wlan.wfa.ie.wpa.mcs.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wpa_mcs_type,
     {"Multicast Cipher Suite type", "wlan.wfa.ie.wpa.mcs.type",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wpa_mcs_wfa_type,
     {"Multicast Cipher Suite type", "wlan.wfa.ie.wpa.mcs.type",
      FT_UINT8, BASE_DEC, VALS(ieee80211_wfa_ie_wpa_cipher_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wpa_ucs_count,
     {"Unicast Cipher Suite Count", "wlan.wfa.ie.wpa.ucs.count",
      FT_UINT16, BASE_DEC, NULL, 0,
      "Indicates the number of pairwise cipher suite selectors that are contained in the Unicast Cipher Suite List", HFILL }},

    {&hf_ieee80211_wfa_ie_wpa_ucs_list,
     {"Unicast Cipher Suite List", "wlan.wfa.ie.wpa.ucs.list",
      FT_NONE, BASE_NONE, NULL, 0,
      "Contains a series of cipher suite selectors that indicate the Unicast cipher suites", HFILL }},

    {&hf_ieee80211_wfa_ie_wpa_ucs,
     {"Unicast Cipher Suite", "wlan.wfa.ie.wpa.ucs",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(wpa_ucs_base_custom), 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wpa_ucs_oui,
     {"Unicast Cipher Suite OUI", "wlan.wfa.ie.wpa.ucs.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wpa_ucs_type,
     {"Unicast Cipher Suite type", "wlan.wfa.ie.wpa.ucs.type",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wpa_ucs_wfa_type,
     {"Unicast Cipher Suite type", "wlan.wfa.ie.wpa.ucs.type",
      FT_UINT8, BASE_DEC, VALS(ieee80211_wfa_ie_wpa_cipher_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wpa_akms_count,
     {"Auth Key Management (AKM) Suite Count", "wlan.wfa.ie.wpa.akms.count",
      FT_UINT16, BASE_DEC, NULL, 0,
      "Indicates the number of Auth Key Management suite selectors that are contained in the Auth Key Management Suite List", HFILL }},

    {&hf_ieee80211_wfa_ie_wpa_akms_list,
     {"Auth Key Management (AKM) List", "wlan.wfa.ie.wpa.akms.list",
      FT_NONE, BASE_NONE, NULL, 0,
      "Contains a series of cipher suite selectors that indicate the AKM suites", HFILL }},

    {&hf_ieee80211_wfa_ie_wpa_akms,
     {"Auth Key Management (AKM) Suite", "wlan.wfa.ie.wpa.akms",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(wpa_akms_base_custom), 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wpa_akms_oui,
     {"Auth Key Management (AKM) OUI", "wlan.wfa.ie.wpa.akms.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wpa_akms_type,
     {"Auth Key Management (AKM) type", "wlan.wfa.ie.wpa.akms.type",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wpa_akms_wfa_type,
     {"Auth Key Management (AKM) type", "wlan.wfa.ie.wpa.type",
      FT_UINT8, BASE_DEC, VALS(ieee80211_wfa_ie_wpa_keymgmt_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_subtype,
     {"WME Subtype", "wlan.wfa.ie.wme.subtype",
      FT_UINT8, BASE_DEC, VALS(ieee802111_wfa_ie_wme_type), 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_version,
     {"WME Version", "wlan.wfa.ie.wme.version",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_qos_info,
     {"WME QoS Info", "wlan.wfa.ie.wme.qos_info",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_qos_info_sta_max_sp_length,
     {"Max SP Length", "wlan.wfa.ie.wme.qos_info.sta.max_sp_length",
      FT_UINT8, BASE_HEX, VALS(ieee802111_wfa_ie_wme_qos_info_sta_max_sp_length_vals), 0x60,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_qos_info_sta_ac_be,
     {"AC_BE", "wlan.wfa.ie.wme.qos_info.sta.ac_be",
      FT_BOOLEAN, 8, TFS(&ieee802111_wfa_ie_wme_qos_info_sta_ac_tfs), 0x08,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_qos_info_sta_ac_bk,
     {"AC_BK", "wlan.wfa.ie.wme.qos_info.sta.ac_bk",
      FT_BOOLEAN, 8, TFS(&ieee802111_wfa_ie_wme_qos_info_sta_ac_tfs), 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_qos_info_sta_ac_vi,
     {"AC_VI", "wlan.wfa.ie.wme.qos_info.sta.ac_vi",
      FT_BOOLEAN, 8, TFS(&ieee802111_wfa_ie_wme_qos_info_sta_ac_tfs), 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_qos_info_sta_ac_vo,
     {"AC_VO", "wlan.wfa.ie.wme.qos_info.sta.ac_vo",
      FT_BOOLEAN, 8, TFS(&ieee802111_wfa_ie_wme_qos_info_sta_ac_tfs), 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_qos_info_sta_reserved,
     {"Reserved", "wlan.wfa.ie.wme.qos_info.sta.reserved",
      FT_UINT8, BASE_HEX, NULL, 0x90,
      "Must Be Zero", HFILL }},

    {&hf_ieee80211_wfa_ie_wme_qos_info_ap_u_apsd,
     {"U-APSD", "wlan.wfa.ie.wme.qos_info.ap.u_apsd",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x80,
      "Indicates the WMM AP is currently supporting unscheduled automatic power save delivery", HFILL }},

    {&hf_ieee80211_wfa_ie_wme_qos_info_ap_parameter_set_count,
     {"Parameter Set Count", "wlan.wfa.ie.wme.qos_info.ap.parameter_set_count",
      FT_UINT8, BASE_HEX, NULL, 0x0F,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_qos_info_ap_reserved,
     {"Reserved", "wlan.wfa.ie.wme.qos_info.ap.reserved",
      FT_UINT8, BASE_HEX, NULL, 0x70,
      "Must Be Zero", HFILL }},

    {&hf_ieee80211_wfa_ie_wme_reserved,
     {"Reserved", "wlan.wfa.ie.wme.reserved",
      FT_BYTES, BASE_NONE, NULL, 0,
      "Must Be Zero", HFILL }},

    {&hf_ieee80211_wfa_ie_wme_ac_parameters,
     {"Ac Parameters", "wlan.wfa.ie.wme.acp",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_aci_aifsn,
     {"ACI / AIFSN Field", "wlan.wfa.ie.wme.acp.aci_aifsn",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_aci_be,
     {"ACI", "wlan.wfa.ie.wme.acp.aci_be",
      FT_UINT8, BASE_DEC, VALS(ieee80211_wfa_ie_wme_acs_vals), 0x60,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_aci_bk,
     {"ACI", "wlan.wfa.ie.wme.acp.aci_bk",
      FT_UINT8, BASE_DEC, VALS(ieee80211_wfa_ie_wme_acs_vals), 0x60,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_aci_vi,
     {"ACI", "wlan.wfa.ie.wme.acp.aci_vi",
      FT_UINT8, BASE_DEC, VALS(ieee80211_wfa_ie_wme_acs_vals), 0x60,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_aci_vo,
     {"ACI", "wlan.wfa.ie.wme.acp.aci_vo",
      FT_UINT8, BASE_DEC, VALS(ieee80211_wfa_ie_wme_acs_vals), 0x60,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_acm_be,
     {"Admission Control Mandatory", "wlan.wfa.ie.wme.acp.acm_be",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_acm_bk,
     {"Admission Control Mandatory", "wlan.wfa.ie.wme.acp.acm_bk",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_acm_vi,
     {"Admission Control Mandatory", "wlan.wfa.ie.wme.acp.acm_vi",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_acm_vo,
     {"Admission Control Mandatory", "wlan.wfa.ie.wme.acp.acm_vo",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_aifsn_be,
     {"AIFSN", "wlan.wfa.ie.wme.acp.aifsn_be",
      FT_UINT8, BASE_DEC, NULL, 0x0F,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_aifsn_bk,
     {"AIFSN", "wlan.wfa.ie.wme.acp.aifsn_bk",
      FT_UINT8, BASE_DEC, NULL, 0x0F,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_aifsn_vi,
     {"AIFSN", "wlan.wfa.ie.wme.acp.aifsn_vi",
      FT_UINT8, BASE_DEC, NULL, 0x0F,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_aifsn_vo,
     {"AIFSN", "wlan.wfa.ie.wme.acp.aifsn_vo",
      FT_UINT8, BASE_DEC, NULL, 0x0F,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_reserved_be,
     {"Reserved", "wlan.wfa.ie.wme.acp.reserved_be",
      FT_UINT8, BASE_DEC, NULL, 0x80,
      "Must be Zero", HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_reserved_bk,
     {"Reserved", "wlan.wfa.ie.wme.acp.reserved_bk",
      FT_UINT8, BASE_DEC, NULL, 0x80,
      "Must be Zero", HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_reserved_vi,
     {"Reserved", "wlan.wfa.ie.wme.acp.reserved_vi",
      FT_UINT8, BASE_DEC, NULL, 0x80,
      "Must be Zero", HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_reserved_vo,
     {"Reserved", "wlan.wfa.ie.wme.acp.reserved_vo",
      FT_UINT8, BASE_DEC, NULL, 0x80,
      "Must be Zero", HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_ecw,
     {"ECW", "wlan.wfa.ie.wme.acp.ecw",
      FT_UINT8, BASE_HEX, NULL, 0x00,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_ecw_max_be,
     {"ECW Max", "wlan.wfa.ie.wme.acp.ecw.max_be",
      FT_UINT8, BASE_DEC, NULL, 0xF0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_ecw_max_bk,
     {"ECW Max", "wlan.wfa.ie.wme.acp.ecw.max_bk",
      FT_UINT8, BASE_DEC, NULL, 0xF0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_ecw_max_vo,
     {"ECW Max", "wlan.wfa.ie.wme.acp.ecw.max_vo",
      FT_UINT8, BASE_DEC, NULL, 0xF0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_ecw_max_vi,
     {"ECW Max", "wlan.wfa.ie.wme.acp.ecw.max_vi",
      FT_UINT8, BASE_DEC, NULL, 0xF0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_ecw_min_be,
     {"ECW Min", "wlan.wfa.ie.wme.acp.ecw.min_be",
      FT_UINT8, BASE_DEC, NULL, 0x0F,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_ecw_min_bk,
     {"ECW Min", "wlan.wfa.ie.wme.acp.ecw.min_bk",
      FT_UINT8, BASE_DEC, NULL, 0x0F,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_ecw_min_vo,
     {"ECW Min", "wlan.wfa.ie.wme.acp.ecw.min_vo",
      FT_UINT8, BASE_DEC, NULL, 0x0F,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_ecw_min_vi,
     {"ECW Min", "wlan.wfa.ie.wme.acp.ecw.min_vi",
      FT_UINT8, BASE_DEC, NULL, 0x0F,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_txop_limit_be,
     {"TXOP Limit", "wlan.wfa.ie.wme.acp.txop_limit_be",
      FT_UINT16, BASE_DEC, NULL, 0x00,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_txop_limit_bk,
     {"TXOP Limit", "wlan.wfa.ie.wme.acp.txop_limit_bk",
      FT_UINT16, BASE_DEC, NULL, 0x00,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_txop_limit_vo,
     {"TXOP Limit", "wlan.wfa.ie.wme.acp.txop_limit_vo",
      FT_UINT16, BASE_DEC, NULL, 0x00,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_acp_txop_limit_vi,
     {"TXOP Limit", "wlan.wfa.ie.wme.acp.txop_limit_vi",
      FT_UINT16, BASE_DEC, NULL, 0x00,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_tsinfo,
     {"TS Info", "wlan.wfa.ie.wme.tspec.ts_info",
      FT_UINT24, BASE_HEX, NULL, 0,
      "Traffic Stream (TS) Info", HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_tsinfo_tid,
     {"TID", "wlan.wfa.ie.wme.tspec.ts_info.tid",
      FT_UINT24, BASE_DEC, NULL, 0x00001E,
      "Traffic Stream Info ID (TID)", HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_tsinfo_direction,
     {"Direction", "wlan.wfa.ie.wme.tspec.ts_info.dir",
      FT_UINT24, BASE_DEC, VALS(ieee80211_wfa_ie_wme_tspec_tsinfo_direction_vals), 0x000060,
      "Traffic Stream (TS) Info Direction", HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_tsinfo_psb,
     {"PSB", "wlan.wfa.ie.wme.tspec.ts_info.psb",
      FT_UINT24, BASE_DEC, VALS(ieee80211_wfa_ie_wme_tspec_tsinfo_psb_vals), 0x000400,
      "Traffic Stream (TS) Info Power Save Behavior (PSB)", HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_tsinfo_up,
     {"UP", "wlan.wfa.ie.wme.tspec.ts_info.up",
      FT_UINT24, BASE_DEC, VALS(ieee80211_wfa_ie_wme_tspec_tsinfo_up_vals), 0x003800,
      "Traffic Stream (TS) Info User Priority (UP)", HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_tsinfo_reserved,
     {"Reserved", "wlan.wfa.ie.wme.tspec.ts_info.reserved",
      FT_UINT24, BASE_HEX, NULL, 0xFFC381,
      "Must be Zero", HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_nor_msdu,
     {"Normal MSDU Size", "wlan.wfa.ie.wme.tspec.nor_msdu",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_max_msdu,
     {"Maximum MSDU Size", "wlan.wfa.ie.wme.tspec.max_msdu",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_min_srv,
     {"Minimum Service Interval", "wlan.wfa.ie.wme.tspec.min_srv",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_max_srv,
     {"Maximum Service Interval", "wlan.wfa.ie.wme.tspec.max_srv",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_inact_int,
     {"Inactivity Interval", "wlan.wfa.ie.wme.tspec.inact_int",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_susp_int,
     {"Suspension Interval", "wlan.wfa.ie.wme.tspec.susp_int",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_srv_start,
     {"Service Start Time", "wlan.wfa.ie.wme.tspec.srv_start",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_min_data,
     {"Minimum Data Rate", "wlan.wfa.ie.wme.tspec.min_data",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_mean_data,
     {"Mean Data Rate", "wlan.wfa.ie.wme.tspec.mean_data",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_peak_data,
     {"Peak Data Rate", "wlan.wfa.ie.wme.tspec.peak_data",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_burst_size,
     {"Burst Size", "wlan.wfa.ie.wme.tspec.burst_size",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_delay_bound,
     {"Delay Bound", "wlan.wfa.ie.wme.tspec.delay_bound",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_min_phy,
     {"Minimum PHY Rate", "wlan.wfa.ie.wme.tspec.min_phy",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_surplus,
     {"Surplus Bandwidth Allowance", "wlan.wfa.ie.wme.tspec.surplus",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_wme_tspec_medium,
     {"Medium Time", "wlan.wfa.ie.wme.tspec.medium",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_owe_bssid,
     {"BSSID", "wlan.wfa.ie.owe.bssid",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_owe_ssid_length,
     {"SSID length", "wlan.wfa.ie.owe.ssid_length",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_owe_ssid,
     {"SSID", "wlan.wfa.ie.owe.ssid",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_owe_band_info,
     {"Band info", "wlan.wfa.ie.owe.band_info",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_owe_channel_info,
     {"Channel info", "wlan.wfa.ie.owe.channel_info",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_mbo_oce_attr,
     {"MBO/OCE attribute", "wlan.wfa.ie.mbo_oce.attr",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_mbo_oce_attr_id,
     {"ID", "wlan.wfa.ie.mbo_oce.attr_id",
      FT_UINT8, BASE_DEC, VALS(wfa_mbo_oce_attr_id_vals), 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_mbo_oce_attr_len,
     {"Length", "wlan.wfa.ie.mbo_oce.attr_len",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_mbo_ap_cap,
     {"MBO Capability Indication", "wlan.wfa.ie.mbo_oce.ap_cap",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_mbo_ap_cap_cell,
     {"AP is cellular data aware", "wlan.wfa.ie.mbo.ap_cap.cell",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x40, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_mbo_ap_cap_reserved,
     {"Reserved", "wlan.wfa.ie.mbo.ap_cap.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xBF, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_mbo_non_pref_chan_op_class,
     {"Operating Class", "wlan.wfa.ie.mbo.non_pref_chan.op_class",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_mbo_non_pref_chan_chan,
     {"Channel", "wlan.wfa.ie.mbo.non_pref_chan.chan",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_mbo_non_pref_chan_pref,
     {"Preference", "wlan.wfa.ie.mbo.non_pref_chan.pref",
      FT_UINT8, BASE_DEC, VALS(wfa_mbo_non_pref_chan_pref_vals), 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_mbo_non_pref_chan_reason,
     {"Reason Code", "wlan.wfa.ie.mbo.non_pref_chan.reason",
      FT_UINT8, BASE_DEC, VALS(wfa_mbo_non_pref_chan_reason_vals), 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_mbo_cellular_cap,
     {"Cellular Data Connectivity", "wlan.wfa.ie.mbo.cellular_cap",
      FT_UINT8, BASE_DEC, VALS(wfa_mbo_cellular_cap_vals), 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_mbo_assoc_disallow_reason,
     {"Reason Code", "wlan.wfa.ie.mbo.assoc_disallow.reason",
      FT_UINT8, BASE_DEC, VALS(wfa_mbo_assoc_dissallow_reason_vals),
      0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_mbo_cellular_pref,
     {"Cellular Data Preference", "wlan.wfa.ie.mbo.cellular_pref",
      FT_UINT8, BASE_DEC, VALS(wfa_mbo_cellular_pref_vals), 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_mbo_transition_reason,
     {"Transition Reason Code", "wlan.wfa.ie.mbo.transition.reason",
      FT_UINT8, BASE_DEC, VALS(wfa_mbo_transition_reason_vals), 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_mbo_transition_rej_reason,
     {"Transition Rejection Reason Code", "wlan.wfa.ie.mbo.transition_rej.reason",
      FT_UINT8, BASE_DEC, VALS(wfa_mbo_transition_rej_reason_vals), 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_mbo_assoc_retry_delay,
     {"Re-association Delay", "wlan.wfa.ie.mbo.assoc_retry.delay",
      FT_UINT16, BASE_DEC|BASE_UNIT_STRING, UNS(&units_seconds), 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_oce_cap_ctrl,
     {"OCE Control", "wlan.wfa.ie.oce.cap.ctrl",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_oce_cap_release,
     {"OCE Release", "wlan.wfa.ie.oce.cap.release",
      FT_UINT8, BASE_HEX, NULL, 0x3, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_oce_cap_sta_cfon,
     {"is STA CFON", "wlan.wfa.ie.oce.cap.sta_cfon",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x4, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_oce_cap_11b_only_ap,
     {"11b only AP present on operating channel", "wlan.wfa.ie.oce.cap.11b_only_ap",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x10, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_oce_cap_hlp,
     {"FILS Higher Layer Setup with Higher Layer Protocol Encapsulation enabled",
      "wlan.wfa.ie.oce.cap.hlp", FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x20, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_oce_cap_non_oce_ap,
     {"non OCE AP present on operating channel", "wlan.wfa.ie.oce.cap.non_oce_ap",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x40, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_oce_cap_reserved,
     {"Reserved", "wlan.wfa.ie.oce.cap.reserved",
      FT_UINT8, BASE_HEX, NULL, 0x80, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_oce_rssi_assoc_rej_delta,
     {"Delta RSSI", "wlan.wfa.ie.oce.rssi_assoc_rej.delta",
      FT_UINT8, BASE_DEC|BASE_UNIT_STRING, UNS(&units_decibels), 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_oce_rssi_assoc_rej_delay,
     {"Retry Delay", "wlan.wfa.ie.oce.rssi_assoc_rej.delay",
      FT_UINT8, BASE_DEC|BASE_UNIT_STRING, UNS(&units_seconds), 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_oce_wan_metrics_avail_cap,
     {"Available Capacity", "wlan.wfa.ie.oce.wan_metrics.avail_cap",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_oce_wan_metrics_avail_cap_downlink,
     {"Downlink", "wlan.wfa.ie.oce.wan_metrics.avail_cap_downlink",
      FT_UINT8, BASE_HEX, NULL, 0xf, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_oce_wan_metrics_avail_cap_uplink,
     {"Uplink", "wlan.wfa.ie.oce.wan_metrics.avail_cap_uplink",
      FT_UINT8, BASE_HEX, NULL, 0xf0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_oce_rnr_completeness_short_ssid,
     {"Short SSID", "wlan.wfa.ie.oce.rnr_completeness.short_ssid",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_oce_probe_suppr_bssid,
     {"BSSID", "wlan.wfa.ie.oce.probe_suppr.bssid",
      FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_oce_probe_suppr_ssid,
     {"SSID", "wlan.wfa.ie.oce.probe_suppr.ssid",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_anqp_mbo_subtype,
     {"Subtype", "wlan.wfa.anqp.mbo.subtype",
      FT_UINT8, BASE_DEC, VALS(mbo_anqp_subtype_vals), 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_anqp_mbo_query,
     {"Query Subtype", "wlan.wfa.anqp.mbo.query",
      FT_UINT8, BASE_DEC, VALS(mbo_anqp_subtype_vals), 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_anqp_mbo_cellular_pref,
     {"Cellular Data Preference", "wlan.wfa.anqp.mbo.cellular_pref",
      FT_UINT8, BASE_DEC, VALS(wfa_mbo_cellular_pref_vals), 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_ptk_keyid,
     {"KeyID", "wlan.rsn.ie.ptk.keyid",
      FT_UINT8, BASE_DEC, NULL, 0x03,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_pmkid,
     {"PMKID", "wlan.rsn.ie.pmkid",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_gtk_kde_data_type,
     {"Data Type", "wlan.rsn.ie.data_type",
      FT_UINT8, BASE_DEC|BASE_RANGE_STRING, RVALS(kde_selectors_rvals),
      0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_gtk_kde_key_id,
     {"Key ID", "wlan.rsn.ie.gtk_kde.key_id",
      FT_UINT8, BASE_HEX, NULL, 0x03, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_gtk_kde_tx,
     {"Tx", "wlan.rsn.ie.gtk_kde.tx",
      FT_BOOLEAN, 8, TFS(&tfs_rsn_gtk_kde_tx), 0x04, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_gtk_kde_reserved1,
     {"Reserved", "wlan.rsn.ie.gtk_kde.res1",
      FT_UINT8, BASE_HEX, NULL, 0xF8, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_gtk_kde_reserved2,
     {"Reserved", "wlan.rsn.ie.gtk_kde.res2",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_gtk_kde_gtk,
     {"GTK", "wlan.rsn.ie.gtk_kde.gtk",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mac_address_kde_mac,
     {"MAC Address", "wlan.rsn.ie.mac_address_kde.mac_address",
      FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_gtk_kde_nonce,
     {"Key Nonce", "wlan.rsn.ie.key_nonce_kde.nonce",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_gtk_kde_lifetime,
     {"Key Lifetime", "wlan.rsn.ie.key_lifetime_kde.lifetime",
      FT_UINT32, BASE_DEC|BASE_UNIT_STRING, UNS(&units_seconds), 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_error_kde_res,
     {"Reserved", "wlan.rsn.ie.error_kde.reserved",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_error_kde_error_type,
     {"Error Type", "wlan.rsn.ie.error_kde.error_type",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_igtk_kde_keyid,
     {"KeyId", "wlan.rsn.ie.igtk.kde.keyid",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_igtk_kde_ipn,
     {"IPN", "wlan.rsn.ie.igtk.kde.ipn",
      FT_UINT48, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_igtk_kde_igtk,
     {"IGTK", "wlan.rsn.ie.igtk.kde.igtk",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_oci_operating_class,
     {"Operating Class", "wlan.rsn.ie.oci_kde.operating_class",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_oci_primary_channel_number,
     {"Primary Channel Number", "wlan.rsn.ie.oci_kde.primary_channel_number",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_oci_frequency_segment_1,
     {"Frequency Segment 1 Channel Number",
      "wlan.rsn.ie.oci_kde.frequency_segment_1_channel_number",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_bigtk_key_id,
     {"Key ID", "wlan.rsn.ie.bigtk_kde.key_id",
      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_bigtk_bipn,
     {"BIPN", "wlan.rsn.ie.bigtk_kde.bipn",
      FT_UINT48, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_bigtk_bigtk,
     {"Key ID", "wlan.rsn.ie.bigtk_kde.bigtk",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_link_info,
     {"Link Information", "wlan.rsn.ie.mlo_link.link_info",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_linkid,
     {"LinkID", "wlan.rsn.ie.mlo_link.link_info.linkid",
      FT_UINT8, BASE_DEC, NULL, 0x0F, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_rnse_present,
     {"RSNEInfo", "wlan.rsn.ie.mlo_link.link_info.rsneinfo",
      FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_rnsxe_present,
     {"RSNXEInfo", "wlan.rsn.ie.mlo_link.link_info.rsnxeinfo",
      FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_reserved,
     {"Reserved", "wlan.rsn.ie.mlo_link.link_info.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xC0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_mac_addr,
     {"MAC Address", "wlan.rsn.ie.mlo_link.mac_addr",
      FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_gtk_kde_key_id,
     {"Key ID", "wlan.rsn.ie.mlo_gtk.key_id",
      FT_UINT8, BASE_HEX, NULL, 0x03, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_gtk_kde_tx,
     {"Tx", "wlan.rsn.ie.mlo_gtk.tx",
      FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_gtk_kde_reserved,
     {"Reserved", "wlan.rsn.ie.mlo_gtk.reserved",
      FT_UINT8, BASE_HEX, NULL, 0x08, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_gtk_kde_linkid,
     {"LinkID", "wlan.rsn.ie.mlo_gtk.linkid",
      FT_UINT8, BASE_HEX, NULL, 0xF0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_gtk_kde_pn,
     {"PN", "wlan.rsn.ie.mlo_gtk.pn",
      FT_UINT48, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_gtk_kde_gtk,
     {"GTK", "wlan.rsn.ie.mlo_gtk.gtk",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_igtk_kde_key_id,
     {"Key ID", "wlan.rsn.ie.mlo_igtk.key_id",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_igtk_kde_ipn,
     {"IPN", "wlan.rsn.ie.mlo_igtk.ipn",
      FT_UINT48, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_igtk_kde_reserved,
     {"Reserved", "wlan.rsn.ie.mlo_igtk.reserved",
      FT_UINT8, BASE_HEX, NULL, 0x0F, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_igtk_kde_linkid,
     {"LinkID", "wlan.rsn.ie.mlo_igtk.linkid",
      FT_UINT8, BASE_HEX, NULL, 0xF0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_igtk_kde_igtk,
     {"IGTK", "wlan.rsn.ie.mlo_igtk.igtk",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_bigtk_kde_key_id,
     {"Key ID", "wlan.rsn.ie.mlo_bigtk.key_id",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_bigtk_kde_ipn,
     {"IPN", "wlan.rsn.ie.mlo_bigtk.ipn",
      FT_UINT48, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_bigtk_kde_reserved,
     {"Reserved", "wlan.rsn.ie.mlo_bigtk.reserved",
      FT_UINT8, BASE_HEX, NULL, 0x0F, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_bigtk_kde_linkid,
     {"LinkID", "wlan.rsn.ie.mlo_bigtk.linkid",
      FT_UINT8, BASE_HEX, NULL, 0xF0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_mlo_bigtk_kde_bigtk,
     {"BIGTK", "wlan.rsn.ie.mlo_bigtk.bigtk",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rsn_ie_unknown,
     {"RSN Unknown", "wlan.rsn.ie.unknown",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_marvell_ie_type,
     {"Type", "wlan.marvell.ie.type",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_marvell_ie_mesh_subtype,
     {"Subtype", "wlan.marvell.ie.subtype",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_marvell_ie_mesh_version,
     {"Version", "wlan.marvell.ie.version",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_marvell_ie_mesh_active_proto_id,
     {"Path Selection Protocol", "wlan.marvell.ie.proto_id",
      FT_UINT8, BASE_HEX, VALS(mesh_path_selection_codes), 0,
      NULL, HFILL }},

    {&hf_ieee80211_marvell_ie_mesh_active_metric_id,
     {"Path Selection Metric", "wlan.marvell.ie.metric_id",
      FT_UINT8, BASE_HEX, VALS(mesh_metric_codes), 0,
      NULL, HFILL }},

    {&hf_ieee80211_marvell_ie_mesh_cap,
     {"Mesh Capabilities", "wlan.marvell.ie.cap",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_marvell_ie_data,
     { "Marvell IE data", "wlan.marvell.data",
       FT_BYTES, BASE_NONE, NULL, 0x0,
       NULL, HFILL }},

   {&hf_ieee80211_extreme_mesh_ie_type,
     { "Type", "wlan.extreme_mesh.ie.type",
       FT_UINT8, BASE_HEX, VALS(extreme_mesh_ie_type_vals), 0,
       NULL, HFILL }},
   {&hf_ieee80211_extreme_mesh_ie_services,
     { "Services", "wlan.extreme_mesh.ie.services",
       FT_UINT8, BASE_HEX, NULL, 0,
       NULL, HFILL }},
   {&hf_ieee80211_extreme_mesh_ie_hello_f_root,
     { "Root", "wlan.extreme_mesh.ie.services.root",
       FT_BOOLEAN, 8, NULL, EXTREME_MESH_IE_SERVICES_ROOT,
       NULL, HFILL }},
   {&hf_ieee80211_extreme_mesh_ie_hello_f_proxy,
     { "Proxy", "wlan.extreme_mesh.ie.services.proxy",
       FT_BOOLEAN, 8, NULL, EXTREME_MESH_IE_SERVICES_PROXY,
       NULL, HFILL }},
   {&hf_ieee80211_extreme_mesh_ie_hello_f_geo,
     { "Geo", "wlan.extreme_mesh.ie.services.geo",
       FT_BOOLEAN, 8, NULL, EXTREME_MESH_IE_SERVICES_GEO,
       NULL, HFILL }},
   {&hf_ieee80211_extreme_mesh_ie_hello_f_path_pref,
     { "Path Preference", "wlan.extreme_mesh.ie.services.path_pref",
       FT_BOOLEAN, 8, NULL, EXTREME_MESH_IE_SERVICES_PATH_PREF,
       NULL, HFILL }},
   {&hf_ieee80211_extreme_mesh_ie_hello_f_mobile,
     { "Mobile", "wlan.extreme_mesh.ie.services.mobile",
       FT_BOOLEAN, 8, NULL, EXTREME_MESH_IE_SERVICES_MOBILE,
       NULL, HFILL }},
   {&hf_ieee80211_extreme_mesh_ie_htr,
     { "Hops to Root", "wlan.extreme_mesh.ie.htr",
       FT_UINT8, BASE_HEX, NULL, 0,
       NULL, HFILL }},
   {&hf_ieee80211_extreme_mesh_ie_mtr,
     { "Metric to Root", "wlan.extreme_mesh.ie.mtr",
       FT_UINT16, BASE_HEX, NULL, 0,
       NULL, HFILL }},
   {&hf_ieee80211_extreme_mesh_ie_root,
     { "Root Id", "wlan.extreme_mesh.ie.root",
       FT_ETHER, BASE_NONE, NULL, 0,
       NULL, HFILL }},
   {&hf_ieee80211_extreme_mesh_ie_nh,
     { "Next Hop", "wlan.extreme_mesh.ie.nh",
       FT_ETHER, BASE_NONE, NULL, 0,
       NULL, HFILL }},
   {&hf_ieee80211_extreme_mesh_ie_mesh_id,
     { "Mesh Id", "wlan.extreme_mesh.ie.mesh_id",
       FT_STRING, BASE_NONE, NULL, 0,
       NULL, HFILL }},
   {&hf_ieee80211_extreme_mesh_ie_mp_id,
     { "Mesh Point Id", "wlan.extreme_mesh.ie.mp_id",
       FT_ETHER, BASE_NONE, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_type,
     {"Type", "wlan.atheros.ie.type",
      FT_UINT8, BASE_HEX, VALS(atheros_ie_type_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_subtype,
     {"Subtype", "wlan.atheros.ie.subtype",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_version,
     {"Version", "wlan.atheros.ie.version",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_cap_f_turbop,
     {"Turbo Prime", "wlan.ie.atheros.capabilities.turbop",
      FT_BOOLEAN, 8, NULL, ATHEROS_IE_CAP_TURBOP,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_cap_f_comp,
     {"Compression", "wlan.ie.atheros.capabilities.comp",
      FT_BOOLEAN, 8, NULL, ATHEROS_IE_CAP_COMP,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_cap_f_ff,
     {"Fast Frames", "wlan.ie.atheros.capabilities.ff",
      FT_BOOLEAN, 8, NULL, ATHEROS_IE_CAP_FF,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_cap_f_xr,
     {"eXtended Range", "wlan.ie.atheros.capabilities.xr",
      FT_BOOLEAN, 8, NULL, ATHEROS_IE_CAP_XR,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_cap_f_ar,
     {"Advanced Radar", "wlan.ie.atheros.capabilities.ar",
      FT_BOOLEAN, 8, NULL, ATHEROS_IE_CAP_AR,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_cap_f_burst,
     {"Burst", "wlan.ie.atheros.capabilities.burst",
      FT_BOOLEAN, 8, NULL, ATHEROS_IE_CAP_BURST,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_cap_f_wme,
     {"CWMin tuning", "wlan.ie.atheros.capabilities.wme",
      FT_BOOLEAN, 8, NULL, ATHEROS_IE_CAP_WME,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_cap_f_boost,
     {"Boost", "wlan.ie.atheros.capabilities.boost",
      FT_BOOLEAN, 8, NULL, ATHEROS_IE_CAP_BOOST,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_advcap_cap,
     {"Capabilities", "wlan.atheros.ie.advcap.cap",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_advcap_defkey,
     {"Default key index", "wlan.atheros.ie.advcap.defkey",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_xr_info,
     {"Info", "wlan.atheros.ie.xr.info",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_xr_base_bssid,
     {"Base BSS Id", "wlan.atheros.ie.xr.base_bssid",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_xr_xr_bssid,
     {"XR BSS Id", "wlan.atheros.ie.xr.xr_bssid",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_xr_xr_beacon,
     {"XR Beacon Interval", "wlan.atheros.ie.xr.xr_beacon",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(beacon_interval_base_custom), 0,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_xr_base_cap,
     {"Base capabilities", "wlan.atheros.ie.xr.base_cap",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_xr_xr_cap,
     {"XR capabilities", "wlan.atheros.ie.xr.xr_cap",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_atheros_ie_data,
     {"Atheros IE data", "wlan.atheros.data",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_aironet_ie_type,
     {"Aironet IE type", "wlan.aironet.type",
      FT_UINT8, BASE_DEC, VALS(aironet_ie_type_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_aironet_ie_dtpc,
     {"Aironet IE CCX DTCP", "wlan.aironet.dtpc",
      FT_INT8, BASE_DEC|BASE_UNIT_STRING, UNS(&units_dbm), 0,
      NULL, HFILL }},

    {&hf_ieee80211_aironet_ie_dtpc_unknown,
     {"Aironet IE CCX DTCP Unknown", "wlan.aironet.dtpc_unknown",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_aironet_ie_version,
     {"Aironet IE CCX version", "wlan.aironet.version",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_aironet_ie_data,
     { "Aironet IE data", "wlan.aironet.data",
       FT_BYTES, BASE_NONE, NULL, 0x0,
       NULL, HFILL }},

    {&hf_ieee80211_qbss_version,
     {"QBSS Version", "wlan.qbss.version",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_qbss_scount,
     {"Station Count", "wlan.qbss.scount",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_qbss_cu,
     {"Channel Utilization", "wlan.qbss.cu",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_qbss_adc,
     {"Available Admission Capacity", "wlan.qbss.adc",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_qbss2_cu,
     {"Channel Utilization", "wlan.qbss2.cu",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_qbss2_gl,
     {"G.711 CU Quantum", "wlan.qbss2.glimit",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_qbss2_cal,
     {"Call Admission Limit", "wlan.qbss2.cal",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_qbss2_scount,
     {"Station Count", "wlan.qbss2.scount",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_aironet_ie_qos_reserved,
     {"Aironet IE QoS reserved", "wlan.aironet.qos.reserved",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_aironet_ie_qos_paramset,
     {"Aironet IE QoS paramset", "wlan.aironet.qos.paramset",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_aironet_ie_qos_val,
     {"Aironet IE QoS valueset", "wlan.aironet.qos.val",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_aironet_ie_clientmfp,
     {"Aironet IE Client MFP", "wlan.aironet.clientmfp",
      FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x01,
      NULL, HFILL }},

    /* Vendor Specific : SGDSN */
    {&hf_ieee80211_vs_sgdsn_tag,
     {"Tag", "wlan.vs.sgdsn.tag",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_sgdsn_type,
     {"Type", "wlan.vs.sgdsn.type",
      FT_UINT8, BASE_DEC, VALS(ieee80211_vs_sgdsn_type_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_sgdsn_length,
     {"Length", "wlan.vs.sgdsn.length",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_sgdsn_version,
     {"Version", "wlan.vs.sgdsn.tag.version",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_sgdsn_icaomfrcode,
     {"ICAO Manufacturer Code", "wlan.vs.sgdsn.tag.icaomfrcode",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_sgdsn_manufacturer,
     {"Manufacturer", "wlan.vs.sgdsn.tag.manufacturer",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_sgdsn_model,
     {"Model", "wlan.vs.sgdsn.tag.model",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_sgdsn_serialnumber,
     {"Serial number", "wlan.vs.sgdsn.tag.serialnumber",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_sgdsn_serialnumber_len,
     {"Serial number length", "wlan.vs.sgdsn.tag.serialnumber.len",
      FT_UINT8, BASE_CUSTOM, CF_FUNC(vs_sgdsn_serialnumber_len_custom), 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_sgdsn_gpscoord,
     {"GPS Coord", "wlan.vs.sgdsn.tag.gpscoord",
      FT_INT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_sgdsn_altitude,
     {"Altitude", "wlan.vs.sgdsn.tag.altitude",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_sgdsn_speed,
     {"Speed", "wlan.vs.sgdsn.tag.speed",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_sgdsn_heading,
     {"Heading", "wlan.vs.sgdsn.tag.heading",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    /* Vendor Specific : Nintendo */
    {&hf_ieee80211_vs_nintendo_type,
     {"Type", "wlan.vs.nintendo.type",
      FT_UINT8, BASE_DEC, VALS(ieee80211_vs_nintendo_type_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_nintendo_length,
     {"Length", "wlan.vs.nintendo.length",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_nintendo_servicelist,
     {"Servicelist", "wlan.vs.nintendo.servicelist",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_nintendo_service,
     {"Service", "wlan.vs.nintendo.service",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_nintendo_consoleid,
     {"Console ID", "wlan.vs.nintendo.consoleid",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_nintendo_unknown,
     {"Unknown", "wlan.vs.nintendo.unknown",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    /* Vendor Specific : Aruba Networks */
    {&hf_ieee80211_vs_aruba_subtype,
     {"Subtype", "wlan.vs.aruba.subtype",
      FT_UINT8, BASE_DEC, VALS(ieee80211_vs_aruba_subtype_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_aruba_apname,
     {"AP Name", "wlan.vs.aruba.ap_name",
      FT_STRINGZ, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_aruba_data,
     {"Data", "wlan.vs.aruba.data",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    /* Vendor Specific : Routerboard */
    {&hf_ieee80211_vs_routerboard_unknown,
     {"Unknown", "wlan.vs.routerboard.unknown",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_routerboard_subitem,
     {"Sub IE", "wlan.vs.routerboard.subitem",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_routerboard_subtype,
     {"Subtype", "wlan.vs.routerboard.subtype",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_routerboard_sublength,
     {"Sublength", "wlan.vs.routerboard.sublength",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_routerboard_subdata,
     {"Subdata", "wlan.vs.routerboard.subdata",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_routerboard_subtype1_prefix,
     {"Subtype 1 Prefix", "wlan.vs.routerboard.subtype1_prefix",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_routerboard_subtype1_data,
     {"Subtype 1 Data", "wlan.vs.routerboard.subtype1_data",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    /* Vendor Specific : Meru (Fortinet) */
    {&hf_ieee80211_vs_meru_subitem,
     {"Sub IE", "wlan.vs.meru.unknown",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_meru_subtype,
     {"Subtype", "wlan.vs.meru.subtype",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_meru_sublength,
     {"Sublength", "wlan.vs.meru.sublength",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_meru_subdata,
     {"Subdata", "wlan.vs.meru.subdata",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    /* Vendor Specific : Extreme (Zebra) */
    {&hf_ieee80211_vs_extreme_subtype,
     {"Subtype", "wlan.vs.extreme.subtype",
      FT_UINT8, BASE_DEC, VALS(ieee80211_vs_extreme_subtype_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_extreme_subdata,
     {"Subdata", "wlan.vs.extreme.subdata",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_extreme_unknown,
     {"Unknown", "wlan.vs.extreme.unknown",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_extreme_ap_length,
     {"AP Length", "wlan.vs.extreme.ap_length",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_extreme_ap_name,
     {"AP Name", "wlan.vs.extreme.ap_name",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    /* Vendor Specific : Aerohive */
    {&hf_ieee80211_vs_aerohive_version,
     {"Version", "wlan.vs.aerohive.version",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_aerohive_subtype,
     {"Subtype", "wlan.vs.aerohive.subtype",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_aerohive_hostname_length,
     {"Host Name Length", "wlan.vs.aerohive.hostname_length",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_aerohive_hostname,
     {"Host Name", "wlan.vs.aerohive.hostname",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_aerohive_data,
     {"Data", "wlan.vs.aerohive.data",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    /* Vendor Specific : Mist */
    {&hf_ieee80211_vs_mist_ap_name,
     {"AP Name", "wlan.vs.mist.apname",
       FT_STRING, BASE_NONE, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_vs_mist_data,
     {"Data", "wlan.vs.mist.data",
       FT_BYTES, BASE_NONE, NULL, 0,
       NULL, HFILL }},

    /* Vendor Specific : Ruckus */
    {&hf_ieee80211_vs_ruckus_ap_name,
     {"AP Name", "wlan.vs.ruckus.apname",
       FT_STRING, BASE_NONE, NULL, 0,
       NULL, HFILL }},

    {&hf_ieee80211_vs_ruckus_data,
     {"Data", "wlan.vs.ruckus.data",
       FT_BYTES, BASE_NONE, NULL, 0,
       NULL, HFILL }},

     /* Vendor Specific : Alcatel-Lucent */
     {&hf_ieee80211_vs_alcatel_ap_name,
      {"AP Name", "wlan.vs.alcatel.apname",
        FT_STRING, BASE_NONE, NULL, 0,
        NULL, HFILL }},

     {&hf_ieee80211_vs_alcatel_data,
      {"Data", "wlan.vs.alcatel.data",
        FT_BYTES, BASE_NONE, NULL, 0,
        NULL, HFILL }},

    /* Vendor Specific : Fortinet */
    {&hf_ieee80211_vs_fortinet_subtype,
     {"Subtype", "wlan.vs.fortinet.subtype",
      FT_UINT16, BASE_DEC, VALS(ieee80211_vs_fortinet_subtype_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_fortinet_system_type,
     {"Type", "wlan.vs.fortinet.system.type",
      FT_UINT8, BASE_DEC, VALS(ieee80211_vs_fortinet_system_type_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_fortinet_system_length,
     {"Length", "wlan.vs.fortinet.system.length",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_fortinet_system_apname,
     {"AP Name", "wlan.vs.fortinet.system.ap_name",
      FT_STRINGZ, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_fortinet_system_apmodel,
     {"AP Model", "wlan.vs.fortinet.system.ap_model",
      FT_STRINGZ, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_fortinet_system_apserial,
     {"AP Serial", "wlan.vs.fortinet.system.ap_serial",
      FT_STRINGZ, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_fortinet_data,
     {"Data", "wlan.vs.fortinet.data",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    /* Vendor Specific : Arista Networks */
    {&hf_ieee80211_vs_arista_subtype,
     {"Subtype", "wlan.vs.arista.subtype",
      FT_UINT8, BASE_DEC, VALS(ieee80211_vs_arista_subtype_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_arista_apname,
     {"AP Name", "wlan.vs.arista.ap_name",
      FT_STRINGZ, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_vs_arista_data,
     {"Data", "wlan.vs.arista.data",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    /* Vendor Specific : Wi-SUN */
    {&hf_ieee80211_vs_wisun_type,
     {"Data Type", "wlan.vs.wisun.type",
      FT_UINT8, BASE_DEC, VALS(ieee80211_vs_wisun_type_vals), 0,
      NULL, HFILL }},
    {&hf_ieee80211_vs_wisun_ptkid,
     {"PTK ID", "wlan.vs.wisun.ptkid",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},
    {&hf_ieee80211_vs_wisun_gtkl,
     {"GTK Liveness", "wlan.vs.wisun.gtkl",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},
    {&hf_ieee80211_vs_wisun_gtkl_gtk0,
     {"GTK[0]", "wlan.vs.wisun.gtkl.gtk0",
      FT_UINT8, BASE_HEX, NULL, WISUN_GTKL_GTK0, NULL, HFILL }},
    {&hf_ieee80211_vs_wisun_gtkl_gtk1,
     {"GTK[1]", "wlan.vs.wisun.gtkl.gtk1",
      FT_UINT8, BASE_HEX, NULL, WISUN_GTKL_GTK1, NULL, HFILL }},
    {&hf_ieee80211_vs_wisun_gtkl_gtk2,
     {"GTK[2]", "wlan.vs.wisun.gtkl.gtk2",
      FT_UINT8, BASE_HEX, NULL, WISUN_GTKL_GTK2, NULL, HFILL }},
    {&hf_ieee80211_vs_wisun_gtkl_gtk3,
     {"GTK[3]", "wlan.vs.wisun.gtkl.gtk3",
      FT_UINT8, BASE_HEX, NULL, WISUN_GTKL_GTK3, NULL, HFILL }},
    {&hf_ieee80211_vs_wisun_nr,
     {"Node Role", "wlan.vs.wisun.nr",
      FT_UINT8, BASE_DEC, VALS(ieee80211_vs_wisun_nr_vals), 0,
      NULL, HFILL }},
    {&hf_ieee80211_vs_wisun_lgtkl,
     {"LGTK Liveness", "wlan.vs.wisun.lgtkl",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},
    {&hf_ieee80211_vs_wisun_lgtkl_lgtk0,
     {"LGTK[0]", "wlan.vs.wisun.lgtkl.lgtk0",
      FT_UINT8, BASE_HEX, NULL, WISUN_LGTKL_LGTK0, NULL, HFILL }},
    {&hf_ieee80211_vs_wisun_lgtkl_lgtk1,
     {"LGTK[1]", "wlan.vs.wisun.lgtkl.lgtk1",
      FT_UINT8, BASE_HEX, NULL, WISUN_LGTKL_LGTK1, NULL, HFILL }},
    {&hf_ieee80211_vs_wisun_lgtkl_lgtk2,
     {"LGTK[2]", "wlan.vs.wisun.lgtkl.lgtk2",
      FT_UINT8, BASE_HEX, NULL, WISUN_LGTKL_LGTK2, NULL, HFILL }},
    {&hf_ieee80211_vs_wisun_lgtk_key_id,
     {"Key ID", "wlan.vs.wisun.lgtk.key_id",
      FT_UINT8, BASE_HEX, NULL, 0x03, NULL, HFILL }},
    {&hf_ieee80211_vs_wisun_lgtk_lgtk,
     {"LGTK", "wlan.vs.wisun.lgtk.lgtk",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
    {&hf_ieee80211_vs_wisun_data,
     {"Data", "wlan.vs.wisun.data",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tsinfo,
     {"Traffic Stream (TS) Info", "wlan.ts_info",
      FT_UINT24, BASE_HEX, NULL, 0,
      "Traffic Stream (TS) Info field", HFILL }},

    {&hf_ieee80211_tsinfo_type,
     {"Traffic Type", "wlan.ts_info.type",
      FT_UINT24, BASE_DEC, VALS(tsinfo_type), 0x000001,
      "Traffic Stream (TS) Info Traffic Type", HFILL }},

    {&hf_ieee80211_tsinfo_tsid,
     {"Traffic Stream ID (TSID)", "wlan.ts_info.tsid",
      FT_UINT24, BASE_DEC, NULL, 0x00001E,
      "Traffic Stream ID (TSID) Info TSID", HFILL }},

    {&hf_ieee80211_tsinfo_dir,
     {"Direction", "wlan.ts_info.dir",
      FT_UINT24, BASE_DEC, VALS(tsinfo_direction), 0x000060,
      "Traffic Stream (TS) Info Direction", HFILL }},

    {&hf_ieee80211_tsinfo_access,
     {"Access Policy", "wlan.ts_info.access",
      FT_UINT24, BASE_DEC, VALS(tsinfo_access), 0x000180,
      "Traffic Stream (TS) Info Access Policy", HFILL }},

    {&hf_ieee80211_tsinfo_agg,
     {"Aggregation", "wlan.ts_info.agg",
      FT_UINT24, BASE_DEC, NULL, 0x000200,
      "Traffic Stream (TS) Info Access Policy", HFILL }},

    {&hf_ieee80211_tsinfo_apsd,
     {"Automatic Power-Save Delivery (APSD)", "wlan.ts_info.apsd",
      FT_UINT24, BASE_DEC, NULL, 0x000400,
      "Traffic Stream (TS) Info Automatic Power-Save Delivery (APSD)", HFILL }},

    {&hf_ieee80211_tsinfo_up,
     {"User Priority", "wlan.ts_info.up",
      FT_UINT24, BASE_DEC, VALS(qos_up), 0x003800,
      "Traffic Stream (TS) Info User Priority", HFILL }},

    {&hf_ieee80211_tsinfo_ack,
     {"Ack Policy", "wlan.ts_info.ack",
      FT_UINT24, BASE_DEC, VALS(ack_policy), 0x00C000,
      "Traffic Stream (TS) Info Ack Policy", HFILL }},

    {&hf_ieee80211_tsinfo_sched,
     {"Schedule", "wlan.ts_info.sched",
      FT_UINT24, BASE_DEC, NULL, 0x010000,
      "Traffic Stream (TS) Info Schedule", HFILL }},

    {&hf_ieee80211_tsinfo_rsv,
     {"Reserved", "wlan.ts_info.rsv",
      FT_UINT24, BASE_HEX, NULL, 0xFE0000,
      "Must be Zero", HFILL }},

    {&hf_ieee80211_tspec_nor_msdu,
     {"Normal MSDU Size", "wlan.tspec.nor_msdu",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tspec_max_msdu,
     {"Maximum MSDU Size", "wlan.tspec.max_msdu",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tspec_min_srv,
     {"Minimum Service Interval", "wlan.tspec.min_srv",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tspec_max_srv,
     {"Maximum Service Interval", "wlan.tspec.max_srv",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tspec_inact_int,
     {"Inactivity Interval", "wlan.tspec.inact_int",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tspec_susp_int,
     {"Suspension Interval", "wlan.tspec.susp_int",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tspec_srv_start,
     {"Service Start Time", "wlan.tspec.srv_start",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tspec_min_data,
     {"Minimum Data Rate", "wlan.tspec.min_data",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tspec_mean_data,
     {"Mean Data Rate", "wlan.tspec.mean_data",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tspec_peak_data,
     {"Peak Data Rate", "wlan.tspec.peak_data",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tspec_burst_size,
     {"Burst Size", "wlan.tspec.burst_size",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tspec_delay_bound,
     {"Delay Bound", "wlan.tspec.delay_bound",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tspec_min_phy,
     {"Minimum PHY Rate", "wlan.tspec.min_phy",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tspec_surplus,
     {"Surplus Bandwidth Allowance", "wlan.tspec.surplus",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tspec_medium,
     {"Medium Time", "wlan.tspec.medium",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tspec_dmg,
     {"DMG attributes", "wlan.tspec.dmg",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ts_delay,
     {"Traffic Stream (TS) Delay", "wlan.ts_delay",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tclas_process,
     {"Processing", "wlan.tclas_proc.processing",
      FT_UINT8, BASE_DEC, VALS(ieee80211_tclas_process_flag), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ext_supp_rates,
     {"Extended Supported Rates", "wlan.extended_supported_rates",
      FT_UINT8, BASE_HEX|BASE_EXT_STRING, &ieee80211_supported_rates_vals_ext, 0x0,
      "In Mbit/sec, (B) for Basic Rates", HFILL }},

    {&hf_ieee80211_sched_info,
     {"Schedule Info", "wlan.sched.sched_info",
      FT_UINT16, BASE_HEX, NULL, 0,
      "Schedule Info field", HFILL }},

    {&hf_ieee80211_sched_info_agg,
     {"Schedule Aggregation", "wlan.sched_info.agg",
      FT_UINT16, BASE_DEC, NULL, 0x0001,
      "Traffic Stream (TS) Info Access Policy", HFILL }},

    {&hf_ieee80211_sched_info_tsid,
     {"Schedule Traffic Stream ID (TSID)", "wlan.sched_info.tsid",
      FT_UINT16, BASE_DEC, NULL, 0x001E,
      "Traffic Stream ID (TSID) Info TSID", HFILL }},

    {&hf_ieee80211_sched_info_dir,
     {"Schedule Direction", "wlan.sched_info.dir",
      FT_UINT16, BASE_DEC, VALS(tsinfo_direction), 0x0060,
      "Traffic Stream (TS) Info Direction", HFILL }},

    {&hf_ieee80211_sched_srv_start,
     {"Service Start Time", "wlan.sched.srv_start",
      FT_UINT32, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_sched_srv_int,
     {"Service Interval", "wlan.sched.srv_int",
      FT_UINT32, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_sched_spec_int,
     {"Specification Interval", "wlan.sched.spec_int",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_aruba,
     {"Aruba Type", "wlan.aruba.type",
      FT_UINT16, BASE_DEC|BASE_EXT_STRING, &aruba_mgt_typevals_ext, 0,
      "Aruba Management", HFILL }},

    {&hf_ieee80211_aruba_hb_seq,
     {"Aruba Heartbeat Sequence", "wlan.aruba.heartbeat_sequence",
      FT_UINT64, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_aruba_mtu,
     {"Aruba MTU Size", "wlan.aruba.mtu_size",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    /* Start: HT Control (+HTC) */
    {&hf_ieee80211_htc,
     {"HT Control (+HTC)", "wlan.htc",
      FT_UINT32, BASE_HEX, NULL, 0,
      "High Throughput Control (+HTC)", HFILL }},

    {&hf_ieee80211_htc_vht,
     {"VHT", "wlan.htc.vht",
      FT_BOOLEAN, 32, NULL, HTC_VHT,
      "High Throughput Control HT/VHT flag", HFILL }},

    {&hf_ieee80211_htc_he,
     {"HE", "wlan.htc.he",
      FT_BOOLEAN, 32, NULL, HTC_HE,
      "High Efficiency Control HE flag", HFILL }},

    {&hf_ieee80211_htc_he_ctrl_id,
     {"Control ID", "wlan.htc.he.a_control.ctrl_id",
      FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_a_control_padding,
     {"Padding", "wlan.htc.he.a_control.padding",
      FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_trs_he_tb_ppdu_len,
     {"HE TB PPDU Length", "wlan.htc.he.a_control.umrs.he_tb_ppdu_len",
      FT_UINT32, BASE_DEC, NULL, 0x0000001f, NULL, HFILL }},

    {&hf_ieee80211_he_trs_ru_allocation,
     {"RU Allocation", "wlan.htc.he.a_control.umrs.ru_allocation",
      FT_UINT32, BASE_DEC, NULL, 0x00001fe0, NULL, HFILL }},

    {&hf_ieee80211_he_dl_tx_power,
     {"DL Tx Power", "wlan.htc.he.a_control.umrs.dl_tx_power",
      FT_UINT32, BASE_HEX, NULL, 0x0003e000, NULL, HFILL }},

    {&hf_ieee80211_he_ul_target_rssi,
     {"UL Target RSSI", "wlan.htc.he.a_control.umrs.ul_target_rssi",
      FT_UINT32, BASE_CUSTOM, CF_FUNC(ul_target_rssi_base_custom),
      0x007c0000, NULL, HFILL }},

    {&hf_ieee80211_he_ul_mcs,
     {"UL MCS", "wlan.htc.he.a_control.umrs.ul_mcs",
      FT_UINT32, BASE_HEX, NULL, 0x01800000, NULL, HFILL }},

    {&hf_ieee80211_he_ul_reserved,
     {"reserved", "wlan.htc.he.a_control.umrs.reserved",
      FT_UINT32, BASE_HEX, NULL, 0x02000000, NULL, HFILL }},

    {&hf_ieee80211_he_om_rx_nss,
     {"Rx NSS", "wlan.htc.he.a_control.om.rx_nss",
      FT_UINT32, BASE_DEC, NULL, 0x00000007, NULL, HFILL }},

    {&hf_ieee80211_he_om_channel_width,
     {"Channel Width", "wlan.htc.he.a_control.om.channel_width",
      FT_UINT32, BASE_DEC, NULL, 0x00000018, NULL, HFILL }},

    {&hf_ieee80211_he_om_ul_mu_disable,
     {"UL MU Disable", "wlan.htc.he.a_control.om.ul_mu_disable",
      FT_BOOLEAN, 32, NULL, 0x00000020, NULL, HFILL }},

    {&hf_ieee80211_he_om_tx_nsts,
     {"Tx NSTS", "wlan.htc.he.a_control.om.tx_nsts",
      FT_UINT32, BASE_DEC, NULL, 0x000001c0, NULL, HFILL }},

    {&hf_ieee80211_he_om_er_su_disable,
     {"ER SU Disable", "wlan.htc.he.a_control.om.er_su_disable",
      FT_BOOLEAN, 32, NULL, 0x00000200, NULL, HFILL }},

    {&hf_ieee80211_he_om_dl_mu_mimo_resound,
     {"DL MU-MIMO Resound Recommendation",
      "wlan.htc.he.a_control.om.dl_mu_mimo_resound_recommendation",
      FT_BOOLEAN, 32, NULL, 0x00000400, NULL, HFILL }},

    {&hf_ieee80211_he_om_ul_mu_data_disable,
     {"UL MU Data Disable", "wlan.htc.he.a_control.om.ul_mu_data_disable",
      FT_BOOLEAN, 32, NULL, 0x00000800, NULL, HFILL }},

    {&hf_ieee80211_he_hla_unsolicited_mfb,
     {"Unsolicited MFB", "wlan.htc.he.a_control.hla.unsolicited_mfb",
      FT_BOOLEAN, 32, NULL, 0x00000001, NULL, HFILL }},

    {&hf_ieee80211_he_hla_mrq,
     {"MRQ", "wlan.htc.he.a_control.hla.mrq",
      FT_BOOLEAN, 32, NULL, 0x00000002, NULL, HFILL }},

    {&hf_ieee80211_he_hla_nss,
     {"NSS", "wlan.htc.he.a_control.hla.NSS",
      FT_UINT32, BASE_DEC, NULL, 0x0000001c, NULL, HFILL }},

    {&hf_ieee80211_he_hla_he_mcs,
     {"HE-MCS", "wlan.htc.he.a_control.hla.he_mcs",
      FT_UINT32, BASE_DEC, NULL, 0x000001e0, NULL, HFILL }},

    {&hf_ieee80211_he_hla_dcm,
     {"DCM", "wlan.htc.he.a_control.hla.dcm",
      FT_BOOLEAN, 32, NULL, 0x00000200, NULL, HFILL }},

    {&hf_ieee80211_he_hla_ru,
     {"RU", "wlan.htc.he.a_control.hla.ru",
      FT_UINT32, BASE_DEC, NULL, 0x0003fc00, NULL, HFILL }},

    {&hf_ieee80211_he_hla_bw,
     {"BW", "wlan.htc.he.a_control.hla.bw",
      FT_UINT32, BASE_DEC, NULL, 0x000c0000, NULL, HFILL }},

    {&hf_ieee80211_he_hla_msi_ppdu_type,
     {"MSI/PPDU Type", "wlan.htc.he.a_control.hla.msi_ppdu_type",
      FT_UINT32, BASE_DEC, NULL, 0x00700000, NULL, HFILL }},

    {&hf_ieee80211_he_hla_tx_bf,
     {"Tx BF", "wlan.htc.he.a_control.hla.tx_bf",
      FT_BOOLEAN, 32, TFS(&he_hla_tx_bf_tfs), 0x00800000, NULL, HFILL }},

    {&hf_ieee80211_he_hla_reserved,
     {"Reserved", "wlan.htc.he.a_control.hla.reserved",
      FT_UINT32, BASE_HEX, NULL, 0x03000000, NULL, HFILL }},

    {&hf_ieee80211_he_bsr_aci_bitmap,
     {"ACI Bitmap", "wlan.htc.he.a_control.bsr.aci_bitmap",
      FT_UINT32, BASE_HEX, NULL, 0x0000000f, NULL, HFILL }},

    {&hf_ieee80211_he_bsr_delta_tid,
     {"Delta TID", "wlan.htc.he.a_control.bsr.delta_tid",
      FT_UINT32, BASE_HEX, NULL, 0x00000030, NULL, HFILL }},

    {&hf_ieee80211_he_bsr_aci_high,
     {"ACI High", "wlan.htc.he.a_control.bsr.aci_high",
      FT_UINT32, BASE_HEX, NULL, 0x000000c0, NULL, HFILL }},

    {&hf_ieee80211_he_bsr_scaling_factor,
     {"Scaling Factor", "wlan.htc.he.a_control.bsr.scaling_factor",
      FT_UINT32, BASE_HEX, NULL, 0x00000300, NULL, HFILL }},

    {&hf_ieee80211_he_bsr_queue_size_high,
     {"Queue Size High", "wlan.htc.he.a_control.bsr.queue_size_high",
      FT_UINT32, BASE_HEX, NULL, 0x0003fc00, NULL, HFILL }},

    {&hf_ieee80211_he_bsr_queue_size_all,
     {"Queue Size All", "wlan.htc.he.a_control.bsr.queue_size_all",
      FT_UINT32, BASE_HEX, NULL, 0x03fc0000, NULL, HFILL }},

    {&hf_ieee80211_he_uph_ul_power_headroom,
     {"UL Power Headroom", "wlan.htc.he.a_control.uph.ul_power_headroom",
      FT_UINT32, BASE_DEC, NULL, 0x0000001f, NULL, HFILL }},

    {&hf_ieee80211_he_uph_ul_min_transmit_power_flag,
     {"Minimum Transmit Power Flag", "wlan.htc.he.a_control.uph.min_transmit_power_flag",
      FT_BOOLEAN, 32, NULL, 0x00000020, NULL, HFILL }},

    {&hf_ieee80211_he_uph_reserved,
     {"Reserved", "wlan.htc.he.a_control.uph.reserved",
      FT_UINT32, BASE_HEX, NULL, 0x000000c0, NULL, HFILL }},

    {&hf_ieee80211_he_btc_avail_chan,
     {"Available Channel Bitmap", "wlan.htc.he.a_control.bqr.avail_chan_bitmap",
      FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_btc_reserved,
     {"Reserved", "wlan.htc.he.a_control.bqr.reserved",
      FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_cci_ac_constraint,
     {"AC Constraint", "wlan.htc.he.a_control.cci.ac_constraint",
      FT_BOOLEAN, 32, NULL, 0x00000001, NULL, HFILL }},

    {&hf_ieee80211_he_cci_rdg_more_ppdu,
     {"RDG/More PPDU", "wlan.htc.he.a_control.cci.rdg_more_ppdu",
      FT_BOOLEAN, 32, NULL, 0x00000002, NULL, HFILL }},

    {&hf_ieee80211_he_cci_sr_ppdu_indic,
     {"PSRT PPDU", "wlan.htc.he.a_control.cci.sr_ppdu_indic",
      FT_BOOLEAN, 32, NULL, 0x00000004, NULL, HFILL }},

    {&hf_ieee80211_he_cci_reserved,
     {"Reserved", "wlan.htc.he.a_control.cci.reserved",
      FT_UINT32, BASE_HEX, NULL, 0x000000F8, NULL, HFILL }},

    {&hf_ieee80211_he_eht_om_rx_nss_ext,
     {"Rx NSS Extension", "wlan.htc.he.a_control.eht_om.rx_nss_ext",
      FT_BOOLEAN, 32, NULL, 0x00000001, NULL, HFILL }},

    {&hf_ieee80211_he_eht_om_chan_w_ext,
     {"Channel Width Extension", "wlan.htc.he.a_control.eht_om.chan_w_ext",
      FT_BOOLEAN, 32, NULL, 0x00000002, NULL, HFILL }},

    {&hf_ieee80211_he_eht_om_tx_nsts_ext,
     {"Tx NSTS Extension", "wlan.htc.he.a_control.eht_om.tx_nsts_ext",
      FT_BOOLEAN, 32, NULL, 0x00000004, NULL, HFILL }},

    {&hf_ieee80211_he_eht_om_reserved,
     {"Reserved", "wlan.htc.he.a_control.eht_om.reserved",
      FT_UINT32, BASE_HEX, NULL, 0x00000038, NULL, HFILL }},

    {&hf_ieee80211_he_srs_ppdu_resp_dur,
     {"PPDU Response Duration", "wlan.htc.he.a_control.srs.ppdu_resp_dur",
      FT_UINT32, BASE_DEC, NULL, 0x000000FF, NULL, HFILL }},

    {&hf_ieee80211_he_srs_reserved,
     {"Reserved", "wlan.htc.he.a_control.srs.reserved",
      FT_UINT32, BASE_HEX, NULL, 0x00000300, NULL, HFILL }},

    {&hf_ieee80211_he_aar_assisted_ap_bitmap,
     {"Assisted AP Link ID Bitmap",
      "wlan.htc.he.a_control.aar.assisted_ap_link_id_bitmap",
      FT_UINT32, BASE_HEX, NULL, 0x0000FFFF, NULL, HFILL }},

    {&hf_ieee80211_he_aar_reserved,
     {"Reserved", "wlan.htc.he.a_control.aar.reserved",
      FT_UINT32, BASE_HEX, NULL, 0x000F0000, NULL, HFILL }},

    {&hf_ieee80211_he_a_control_ones,
     {"Padding", "wlan.htc.he.a_control.ones",
      FT_UINT32, BASE_HEX, NULL, 0x03ffffff, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_common_info,
     {"HE Trigger Common Info", "wlan.trigger.he.common_info",
      FT_UINT64, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_type,
     {"Trigger Type", "wlan.trigger.he.trigger_type",
      FT_UINT64, BASE_DEC|BASE_VAL64_STRING, VALS64(trigger_type_vals),
        0x000000000000000F, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ul_length,
     {"UL Length", "wlan.trigger.he.ul_length",
      FT_UINT64, BASE_DEC, NULL, 0x000000000000FFF0, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_more_tf,
     {"More TF", "wlan.trigger.he.more_tf",
      FT_BOOLEAN, 64, NULL, 0x0000000000010000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_cs_required,
     {"CS Required", "wlan.trigger.he.cs_required",
      FT_BOOLEAN, 64, NULL, 0x0000000000020000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ul_bw,
     {"UL BW", "wlan.trigger.he.ul_bw",
      FT_UINT64, BASE_DEC|BASE_VAL64_STRING, VALS64(bw_subfield_vals), 0x00000000000C0000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_gi_and_ltf_type,
     {"GI And LTF Type", "wlan.trigger.he.gi_and_ltf_type",
      FT_UINT64, BASE_DEC|BASE_VAL64_STRING, VALS64(gi_and_ltf_type_subfield_vals), 0x0000000000300000,
        NULL, HFILL }},

    {&hf_ieee80211_he_trigger_mu_mimo_ltf_mode,
     {"MU-MIMO LTF Mode", "wlan.trigger.he.mu_mimo_ltf_mode",
      FT_BOOLEAN, 64, TFS(&mu_mimo_ltf_mode_tfs), 0x0000000000400000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_num_he_ltf_syms_etc,
     {"Number of HE-LTF Symbols and Midamble Periodicity",
        "wlan.trigger.he.num_he_ltf_syms_and_midamble_per",
      FT_UINT64, BASE_HEX, NULL, 0x0000000003800000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ul_stbc,
     {"UL STBC", "wlan.trigger.he.ul_stbc",
      FT_BOOLEAN, 64, NULL, 0x0000000004000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ldpc_extra_sym_seg,
     {"LDPC Extra Symbol Segment", "wlan.trigger.he.ldpc_extra_symbol_segment",
      FT_BOOLEAN, 64, NULL, 0x0000000008000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ap_tx_power,
     {"AP Tx Power", "wlan.trigger.he.ap_tx_power",
      FT_UINT64, BASE_CUSTOM, CF_FUNC(ap_tx_power_custom),
      0x00000003F0000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_pre_fec_padding_factor,
     {"Pre-FEC Padding Factor",
      "wlan.trigger.he.ul_packet_extension.pre_fec_padding_factor",
      FT_UINT64, BASE_DEC|BASE_VAL64_STRING,
      VALS64(pre_fec_padding_factor_vals),
      0x0000000C00000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_pe_disambiguity,
     {"PE Disambiguity",
      "wlan.trigger.he.ul_packet_extension.pe_disambiguity",
      FT_BOOLEAN, 64, TFS(&pe_disambiguity_tfs),
      0x0000001000000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ul_spatial_reuse,
     {"UL Spatial Reuse", "wlan.trigger.he.ul_spatial_reuse",
      FT_UINT64, BASE_HEX, NULL, 0x001FFFE000000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ul_he_sig_a_reserved,
     {"UL HE-SIG-A2 Reserved", "wlan.trigger.he.ul_he_sig_a2_reserved",
      FT_UINT64, BASE_HEX, NULL, 0x7FC0000000000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_doppler,
     {"Doppler", "wlan.trigger.he.doppler",
      FT_BOOLEAN, 64, NULL, 0x0020000000000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_reserved,
     {"Reserved", "wlan.trigger.he.reserved",
      FT_UINT64, BASE_HEX, NULL, 0x8000000000000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_bar_ctrl,
     {"BAR Control", "wlan.trigger.he.common_info.bar_ctrl",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_bar_ctrl_ba_ack_policy,
     {"BA Ack Policy", "wlan.trigger.he.common_info.bar_ctrl.ba_ack_policy",
      FT_BOOLEAN, 16, TFS(&ieee80211_block_ack_control_ack_policy_flag), 0x0001,
       NULL, HFILL }},

    {&hf_ieee80211_he_trigger_bar_ctrl_ba_type,
     {"BA Type", "wlan.trigger.he.common_info.bar_ctrl.ba_type",
      FT_UINT16, BASE_HEX, VALS(block_ack_type_vals), 0x001e, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_bar_ctrl_reserved,
     {"Reserved", "wlan.trigger.he.common_info.bar_ctrl.reserved",
      FT_UINT16, BASE_HEX, NULL, 0x0FE0, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_bar_ctrl_tid_info,
     {"TID_INFO", "wlan.trigger.he.common_info.bar_ctrl.tid_info",
      FT_UINT16, BASE_HEX, NULL, 0xF000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_bar_info,
     {"BAR Information", "wlan.trigger.he.common_info.bar_info",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_bar_info_blk_ack_seq_ctrl,
     {"Block Ack Starting Sequence Control",
      "wlan.trigger.he.common_info.bar_info.blk_ack_starting_seq_ctrl",
      FT_UINT16, BASE_HEX, NULL, 0xffff, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_user_info,
     {"User Info", "wlan.trigger.he.user_info",
      FT_UINT40, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_user_info_padding_start,
     {"Start of Padding", "wlan.trigger.he.user_info.start_of_padding",
      FT_UINT16, BASE_DEC, NULL, 0x0FFF, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_padding,
     {"Padding", "wlan.trigger.he.padding",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_mpdu_mu_spacing,
     {"MPDU MU Spacing Factor", "wlan.trigger.he.mpdu_mu_spacing_factor",
      FT_UINT8, BASE_DEC, NULL, 0x03, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_tid_aggregation_limit,
     {"TID Aggregation Limit", "wlan.trigger.he.tid_aggregation_limit",
      FT_UINT8, BASE_DEC, NULL, 0x1C, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_dependent_reserved1,
     {"Reserved", "wlan.trigger.he.reserved1",
      FT_UINT8, BASE_HEX, NULL, 0x20, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_preferred_ac,
     {"Preferred AC", "wlan.trigger.he.preferred_ac",
      FT_UINT8, BASE_HEX, VALS(preferred_ac_vals), 0xC0, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_dep_basic_user_info,
     {"Basic Trigger Dependent User Info", "wlan.trigger.he.basic_user_info",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_starting_aid,
     {"Starting AID", "wlan.trigger.he.starting_aid",
      FT_UINT40, BASE_HEX, NULL, 0x0000000FFF, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_dependent_reserved2,
     {"Reserved", "wlan.trigger.he.reserved2",
      FT_UINT40, BASE_HEX, NULL, 0x00001FF000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_feedback_type,
     {"Feedback Type", "wlan.trigger.he.feedback_type",
      FT_UINT40, BASE_HEX, NULL, 0x0001E00000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_dependent_reserved3,
     {"Reserved", "wlan.trigger.he.reserved3",
      FT_UINT40, BASE_HEX, NULL, 0x00FE000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_nfrp_target_rssi,
     {"Target RSSI", "wlan.trigger.he.target_rssi",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(target_rssi_base_custom), 0x7F00000000,
       NULL, HFILL }},

    {&hf_ieee80211_he_trigger_multiplexing_flag,
     {"Multiplexing Flag", "wlan.trigger.he.multiplexing_flag",
      FT_UINT40, BASE_HEX, NULL, 0x8000000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_dep_nfrp_user_info,
     {"NFRP Trigger Dependent User Unfo", "wlan.trigger.he.nfrp_user_info",
      FT_UINT40, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_feedback_seg_retrans_bm,
     {"Feedback Segment Retransmission Bitmap", "wlan.trigger.he.feedback_bm",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_aid12,
     {"AID12", "wlan.trigger.he.user_info.aid12",
      FT_UINT40, BASE_HEX, NULL, 0x0000000FFF, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ru_allocation_region,
     {"RU Allocation Region", "wlan.trigger.he.ru_allocation_region",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(he_trigger_ru_allocation_region_custom),
      0x0000001000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ru_allocation,
     {"RU Allocation", "wlan.trigger.he.ru_allocation",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(he_ru_allocation_base_custom),
      0x00000FE000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ul_fec_coding_type,
     {"UL FEC Coding Type", "wlan.trigger.he.ul_fec_coding_type",
      FT_BOOLEAN, 40, TFS(&he_trigger_ul_fec_coding_type_tfs), 0x0000100000,
        NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ul_mcs,
     {"UL MCS", "wlan.trigger.he.ul_mcs",
      FT_UINT40, BASE_HEX, NULL, 0x0001E00000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ul_dcm,
     {"UL DCM", "wlan.trigger.he.ul_dcm",
      FT_BOOLEAN, 40, NULL, 0x0002000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ru_starting_spatial_stream,
     {"Starting Spatial Stream", "wlan.trigger.he.ru_starting_spatial_stream",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(he_trigger_minus_one_custom),
      0x001c000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ru_number_spatial_streams,
     {"Number Of Spatial Streams", "wlan.trigger.he.ru_number_of_spatial_stream",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(he_trigger_minus_one_custom),
      0x00E0000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ru_number_ra_ru,
     {"Number of RA-RU", "wlan.trigger.he.ru_number_of_ra_ru",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(he_trigger_minus_one_custom),
      0x007C000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ru_no_more_ra_ru,
     {"No More RA-RU", "wlan.trigger.he.ru_no_more_ra_ru",
      FT_BOOLEAN, 40, NULL, 0x0080000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ul_target_rssi,
     {"UL Target RSSI", "wlan.trigger.he.ul_target_rssi",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(target_rssi_base_custom), 0x7F00000000,
       NULL, HFILL }},

    {&hf_ieee80211_he_trigger_user_reserved,
     {"Reserved", "wlan.trigger.he.user_reserved",
      FT_UINT40, BASE_HEX, NULL, 0x8000000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ranging_common_info_1,
     {"Ranging Common Info", "wlan.trigger.he.ranging.common_info",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ranging_common_info_2,
     {"Ranging Common Info", "wlan.trigger.he.ranging.common_info",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_common_info,
     {"EHT Trigger Common Info", "wlan.trigger.eht.common_info",
      FT_UINT64, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_type,
     {"Trigger Type", "wlan.trigger.eht.trigger_type",
      FT_UINT64, BASE_DEC|BASE_VAL64_STRING, VALS64(trigger_type_vals),
        0x000000000000000F, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_ul_length,
     {"UL Length", "wlan.trigger.eht.ul_length",
      FT_UINT64, BASE_DEC, NULL, 0x000000000000FFF0, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_more_tf,
     {"More TF", "wlan.trigger.eht.more_tf",
      FT_BOOLEAN, 64, NULL, 0x0000000000010000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_cs_required,
     {"CS Required", "wlan.trigger.eht.cs_required",
      FT_BOOLEAN, 64, NULL, 0x0000000000020000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_ul_bw,
     {"UL BW", "wlan.trigger.eht.ul_bw",
      FT_UINT64, BASE_DEC|BASE_VAL64_STRING, VALS64(bw_subfield_vals),
      0x00000000000C0000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_gi_and_eht_ltf_type,
     {"GI And HE/EHT-LTF Type/Triggered TXOP Sharing Mode",
      "wlan.trigger.eht.gi_and_he_eht_ltf_type_triggered_txop_sharing_mode",
      FT_UINT64, BASE_HEX, NULL, 0x0000000000300000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_reserved2,
     {"Reserved", "wlan.trigger.eht.reserved2",
      FT_UINT64, BASE_HEX, NULL, 0x0000000000400000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_num_he_eht_ltf_syms_etc,
     {"Number of HE/EHT-LTF Symbols",
      "wlan.trigger.eht.num_ltf_eht_ltf_symbols",
      FT_UINT64, BASE_HEX, NULL, 0x0000000003800000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_reserved3,
     {"Reserved", "wlan.trigger.eht.reserved3",
      FT_UINT64, BASE_HEX, NULL, 0x0000000004000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_ldpc_extra_sym_seg,
     {"LDPC Extra Symbol Segment", "wlan.trigger.eht.ldpc_extra_symbol_segment",
      FT_BOOLEAN, 64, NULL, 0x0000000008000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_ap_tx_power,
     {"AP Tx Power", "wlan.trigger.eht.ap_tx_power",
      FT_UINT64, BASE_CUSTOM, CF_FUNC(ap_tx_power_custom),
      0x00000003F0000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_pre_fec_padding_factor,
     {"Pre-FEC Padding Factor",
      "wlan.trigger.eht.ul_packet_extension.pre_fec_padding_factor",
      FT_UINT64, BASE_DEC|BASE_VAL64_STRING,
      VALS64(pre_fec_padding_factor_vals),
      0x0000000c00000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_pe_disambiguity,
     {"PE Disambiguity",
      "wlan.trigger.eht.ul_packet_extension.pe_disambiguity",
      FT_BOOLEAN, 64, TFS(&pe_disambiguity_tfs),
      0x0000001000000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_ul_spatial_reuse,
     {"Spatial Reuse", "wlan.trigger.eht.spatial_reuse",
      FT_UINT64, BASE_HEX, NULL, 0x001FFFE000000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_reserved4,
     {"Reserved", "wlan.trigger.eht.reserved4",
      FT_UINT64, BASE_HEX, NULL, 0x0020000000000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_he_eht_p160,
     {"HE/EHT P160", "wlan.trigger.eht.he_eht_p160",
      FT_UINT64, BASE_HEX, NULL, 0x0040000000000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_special_user_info_flag,
     {"Special User Info Field Flag",
      "wlan.trigger.eht.special_user_info_flag",
      FT_UINT64, BASE_HEX, NULL, 0x0080000000000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_eht_reserved,
     {"EHT Reserved", "wlan.trigger.eht.eht_reserved",
      FT_UINT64, BASE_HEX, NULL, 0x7f00000000000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_reserved,
     {"Reserved", "wlan.trigger.eht.reserved",
      FT_UINT64, BASE_HEX, NULL, 0x8000000000000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_user_info,
     {"EHT User Info", "wlan.trigger.eht.user_info",
      FT_UINT40, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_aid12,
     {"AID12", "wlan.trigger.eht.user_info.aid12",
      FT_UINT40, BASE_DEC, NULL, 0x0000000FFF, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_ru_allocation_region,
     {"RU Allocation Region", "wlan.trigger.eht.user_info.ru_allocation_region",
      FT_UINT40, BASE_HEX, NULL, 0x0000001000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_ru_allocation,
     {"RU Allocation", "wlan.trigger.eht.user_info.ru_allocation",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(eht_ru_allocation_base_custom), 0x00000FE000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_ul_fec_coding_type,
     {"UL FEC Coding Type", "wlan.trigger.eht.user_info.ul_fec_coding_type",
      FT_UINT40, BASE_HEX, NULL, 0x0000100000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_ul_eht_mcs,
     {"UL EHT MCS", "wlan.trigger.eht.user_info.ul_eht_mcs",
      FT_UINT40, BASE_HEX, NULL, 0x0001E00000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_user_info_reserved,
     {"Reserved", "wlan.trigger.eht.user_info.reserved",
      FT_UINT40, BASE_HEX, NULL, 0x0002000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_ru_starting_spatial_stream,
     {"Starting Spatial Stream",
      "wlan.trigger.eht.user_info.ru_starting_spatial_stream",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(he_trigger_minus_one_custom),
      0x003C000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_ru_number_spatial_streams,
     {"Number Of Spatial Streams",
      "wlan.trigger.eht.user_info.ru_number_spatial_streams",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(he_trigger_minus_one_custom),
      0x00C0000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_ul_target_recv_power,
     {"UL Target Receive Power",
      "wlan.trigger.eht.user_info.ul_target_receive_power",
      FT_UINT40, BASE_HEX, NULL, 0x7F00000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_ps160,
     {"PS160", "wlan.trigger.eht.user_info.ps160",
      FT_UINT40, BASE_HEX, NULL, 0x8000000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_special_user_info,
     {"Special User Info",
      "wlan.trigger.eht.special_user_info",
      FT_UINT40, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_phy_version_identifier,
     {"Phy Version Identifier",
      "wlan.trigger.eht.user_info.phy_version_identifier",
      FT_UINT40, BASE_HEX, NULL, 0x0000007000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_ul_bw_extenstion,
     {"UL BW Extension", "wlan.trigger.eht.user_info.ul_bw_extension",
      FT_UINT40, BASE_HEX, NULL, 0x0000018000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_eht_spatial_reuse_1,
     {"EHT Spatial Reuse 1", "wlan.trigger.eht.user_info.eht_spatial_reuse_1",
      FT_UINT40, BASE_HEX, NULL, 0x00001E0000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_eht_spatial_reuse_2,
     {"EHT Spatial Reuse 2", "wlan.trigger.eht.user_info.eht_spatial_reuse_2",
      FT_UINT40, BASE_HEX, NULL, 0x0001E00000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_disregard_u_sig_1,
     {"Disregard In U-SIG-1",
      "wlan.trigger.eht.user_info.disregard_u_sig_1",
      FT_UINT40, BASE_HEX, NULL, 0x007E000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_validate_u_sig_2,
     {"Validate In U-SIG-2",
      "wlan.trigger.eht.user_info.validate_u_sig_2",
      FT_UINT40, BASE_HEX, NULL, 0x0080000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_disregard_u_sig_2_4lsb,
     {"four LSBs of Disregard In U-SIG-2",
      "wlan.trigger.eht.user_info.disregard_u_sig_2_4lsb",
      FT_UINT40, BASE_HEX, NULL, 0x0F00000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_disregard_u_sig_2_msb,
     {"MSB of Disregard In U-SIG-2",
      "wlan.trigger.eht.user_info.disregard_u_sig_2_msb",
      FT_UINT40, BASE_HEX, NULL, 0x1000000000, NULL, HFILL }},

    {&hf_ieee80211_eht_trigger_special_reserved,
     {"Reserved", "wlan.trigger.eht.user_info.special_reserved",
      FT_UINT40, BASE_HEX, NULL, 0xE000000000, NULL, HFILL }},

    {&hf_ieee80211_ranging_trigger_subtype1,
     {"Ranging Trigger Subtype",
      "wlan.trigger.he.ranging.ranging_trigger_subtype",
      FT_UINT8, BASE_RANGE_STRING|BASE_HEX, RVALS(ranging_trigger_subtype_vals),
      0x0f, NULL, HFILL }},

    {&hf_ieee80211_ranging_trigger_reserved1,
     {"Reserved", "wlan.trigger.he.ranging.reserved",
      FT_UINT8, BASE_HEX, NULL, 0x10, NULL, HFILL }},

    {&hf_ieee80211_ranging_trigger_token,
     {"Token", "wlan.trigger.he.ranging.token",
      FT_UINT8, BASE_HEX, NULL, 0xe0, NULL, HFILL }},

    {&hf_ieee80211_ranging_trigger_subtype2,
     {"Ranging Trigger Subtype",
      "wlan.trigger.he.ranging.ranging_trigger_subtype",
      FT_UINT16, BASE_RANGE_STRING|BASE_HEX,
      RVALS(ranging_trigger_subtype_vals), 0x000f, NULL, HFILL }},

    {&hf_ieee80211_ranging_trigger_reserved2,
     {"Reserved", "wlan.trigger.he.ranging.reserved2",
      FT_UINT16, BASE_HEX, NULL, 0x03f0, NULL, HFILL }},

    {&hf_ieee80211_ranging_trigger_sounding_dialog_token,
     {"Sounding Dialog Token Number",
      "wlan.trigger.he.ranging.sounding_dialog_token",
      FT_UINT16, BASE_HEX, NULL, 0xfc00, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ranging_trigger_poll_rpt,
     {"Ranging Trigger Poll/Rpt", "wlan.trigger.he.ranging.poll_rpt",
      FT_UINT40, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_ranging_pol_rpt_aid12_rsid12,
     {"AID12/RSID12", "wlan.trigger.he.ranging.poll_rpt.aid12_rsid12",
      FT_UINT40, BASE_DEC, NULL, 0x0000000fff, NULL, HFILL }},

    {&hf_ieee80211_ranging_pol_rpt_ru_alloc_region,
     {"RU Allocation Region", "wlan.trigger.he.ranging.poll_rpt.ru_allocation_region",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(he_trigger_ru_allocation_region_custom),
      0x0000001000, NULL, HFILL }},

    {&hf_ieee80211_ranging_pol_rpt_ru_alloc,
     {"RU Allocation", "wlan.trigger.he.ranging.poll_rpt.ru_allocation",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(he_ru_allocation_base_custom), 0x00000fe000, NULL, HFILL }},

    {&hf_ieee80211_ranging_pol_rpt_ul_fec_coding_type,
     {"UL FEC Coding Type",
      "wlan.trigger.he.ranging.poll_rpt.ul_fec_coding_type",
      FT_BOOLEAN, 40, TFS(&he_trigger_ul_fec_coding_type_tfs), 0x0000100000, NULL, HFILL }},

    {&hf_ieee80211_ranging_pol_rpt_ulmcs,
     {"UL MCS", "wlan.trigger.he.ranging.poll_rpt.ul_mcs",
      FT_UINT40, BASE_HEX, NULL, 0x0001e00000, NULL, HFILL }},

    {&hf_ieee80211_ranging_pol_rpt_uldcm,
     {"UL DCM", "wlan.trigger.he.ranging.poll_rpt.ul_dcm",
      FT_UINT40, BASE_HEX, NULL, 0x0002000000, NULL, HFILL }},

    {&hf_ieee80211_ranging_pol_rpt_starting_spatial_stream,
     {"Starting Spatial Stream",
      "wlan.trigger.he.ranging.poll_rpt.starting_spatial_stream",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(he_trigger_minus_one_custom),
      0x001c000000, NULL, HFILL }},

    {&hf_ieee80211_ranging_pol_rpt_number_spatial_streams,
     {"Number Of Spatial Streams",
      "wlan.trigger.he.ranging.poll_rpt.number_spatial_streams",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(he_trigger_minus_one_custom),
      0x00e0000000, NULL, HFILL }},

    {&hf_ieee80211_ranging_pol_rpt_ul_target_rssi,
     {"UL Target RSSI", "wlan.trigger.he.ranging.poll_rpt.ul_target_rssi",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(target_rssi_base_custom), 0x7f00000000, NULL, HFILL }},

    {&hf_ieee80211_ranging_pol_rpt_reserved,
     {"Reserved", "wlan.trigger.he.ranging.poll_rpt.reserved",
      FT_UINT40, BASE_HEX, NULL, 0x8000000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ranging_trigger_sounding,
     {"Ranging Trigger Sounding", "wlan.trigger.he.ranging.sounding",
      FT_UINT40, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_ranging_sounding_aid12_rsid12,
     {"AID12/RSID12", "wlan.trigger.he.ranging.sounding.aid12_rsid12",
      FT_UINT40, BASE_DEC, NULL, 0x0000000fff, NULL, HFILL }},

    {&hf_ieee80211_ranging_sounding_reserved1,
     {"Reserved", "wlan.trigger.he.ranging.sounding.reserved1",
      FT_UINT40, BASE_HEX, NULL, 0x00001ff000, NULL, HFILL }},

    {&hf_ieee80211_ranging_sounding_i2r_rep,
     {"I2R Rep", "wlan.trigger.he.ranging.sounding.i2r_rep",
      FT_UINT40, BASE_DEC, NULL, 0x0000e00000, NULL, HFILL }},

    {&hf_ieee80211_ranging_sounding_reserved2,
     {"Reserved", "wlan.trigger.he.ranging.sounding.reserved2",
      FT_UINT40, BASE_HEX, NULL, 0x0003000000, NULL, HFILL }},

    {&hf_ieee80211_ranging_sounding_starting_spatial_stream,
     {"Starting Spatial Stream",
      "wlan.trigger.he.ranging.sounding.starting_spatial_stream",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(he_trigger_minus_one_custom),
      0x001c000000, NULL, HFILL }},

    {&hf_ieee80211_ranging_sounding_number_spatial_streams,
     {"Number of Spatial Streams",
      "wlan.trigger.he.ranging.sounding.number_spatial_streams",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(he_trigger_minus_one_custom),
      0x00e0000000, NULL, HFILL }},

    {&hf_ieee80211_ranging_sounding_ul_target_rssi,
     {"UL Target RSSI", "wlan.trigger.he.ranging.sounding.ul_target_rssi",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(target_rssi_base_custom), 0x7f00000000, NULL, HFILL }},

    {&hf_ieee80211_ranging_sounding_reserved3,
     {"Reserved", "wlan.trigger.he.ranging.sounding.reserved3",
      FT_UINT40, BASE_HEX, NULL, 0x8000000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ranging_trigger_sec_sound,
     {"Secured Sounding", "wlan.trigger.he.ranging.secured_sounding",
      FT_UINT40, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_ranging_sec_sound_aid12_rsid12,
     {"AID12/RSID12", "wlan.trigger.he.ranging.secured_sounding.aid12_rsid12",
      FT_UINT40, BASE_DEC, NULL, 0x0000000fff, NULL, HFILL }},

    {&hf_ieee80211_ranging_sec_sound_reserved1,
     {"Reserved", "wlan.trigger.he.ranging.secured_sounding.reserved1",
      FT_UINT40, BASE_HEX, NULL, 0x00001ff000, NULL, HFILL }},

    {&hf_ieee80211_ranging_sec_sound_i2r_rep,
     {"I2R Rep", "wlan.trigger.he.ranging.secured_sounding.i2r_rep",
      FT_UINT40, BASE_HEX, NULL, 0x0000e00000, NULL, HFILL }},

    {&hf_ieee80211_ranging_sec_sound_reserved2,
     {"Reserved", "wlan.trigger.he.ranging.secured_sounding.reserved2",
      FT_UINT40, BASE_HEX, NULL, 0x0003000000, NULL, HFILL }},

    {&hf_ieee80211_ranging_sec_sound_starting_spatial_stream,
     {"Starting Spatial Stream",
      "wlan.trigger.he.ranging.secured_sounding.starting_spatial_stream",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(he_trigger_minus_one_custom),
      0x001c000000, NULL, HFILL }},

    {&hf_ieee80211_ranging_sec_sound_number_spatial_streams,
     {"Number of Spatial Streams",
      "wlan.trigger.he.ranging.secured_sounding.number_spatial_streams",
      FT_UINT40, BASE_CUSTOM, CF_FUNC(he_trigger_minus_one_custom),
      0x00e0000000, NULL, HFILL }},

    {&hf_ieee80211_ranging_sec_sound_ul_target_rssi,
     {"UL Target RSSI",
      "wlan.trigger.he.ranging.secured_sounding.ul_target_rssi",
      FT_UINT40, BASE_HEX, NULL, 0x7f00000000, NULL, HFILL }},

    {&hf_ieee80211_ranging_sec_sound_reserved3,
     {"Reserved", "wlan.trigger.he.ranging.secured_sounding.reserved3",
      FT_UINT40, BASE_HEX, NULL, 0x8000000000, NULL, HFILL }},

    {&hf_ieee80211_he_trigger_ranging_user_info_sac,
     {"SAC", "wlan.trigger.he.ranging.user_info.sac",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_qtp_control,
     {"Control", "wlan.ext_tag.quiet_time_period.control",
      FT_UINT8, BASE_RANGE_STRING | BASE_HEX, RVALS(quiet_time_period_control_rvals), 0,
      "Type of Quiet Time Period Element", HFILL } },

    {&hf_ieee80211_he_qtp_setup_quiet_period_duration,
     {"Quiet Period Duration", "wlan.ext_tag.quiet_time_period.setup.duration",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Quiet Period Duration in units of 32us", HFILL } },

    {&hf_ieee80211_he_qtp_setup_srv_specific_identif,
     {"Service Specific Identifier", "wlan.ext_tag.quiet_time_period.setup.srv_specific_identif",
      FT_UINT16, BASE_HEX, NULL, 0,
      "Service Specific peer-to-peer operation", HFILL } },

    {&hf_ieee80211_he_qtp_request_dialog_token,
     {"Dialog Token", "wlan.ext_tag.quiet_time_period.request.dialog_token",
      FT_UINT16, BASE_DEC, NULL, 0,
      "Quiet Time Periods Response suptype to which request subtype corresponds",
      HFILL } },

    {&hf_ieee80211_he_qtp_request_quiet_period_offset,
     {"Quiet Period Offset", "wlan.ext_tag.quiet_time_period.request.offset",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Offset of the first quiet period from the TBTT in TUs", HFILL } },

    {&hf_ieee80211_he_qtp_request_quiet_period_duration,
     {"Quiet Period Duration", "wlan.ext_tag.quiet_time_period.request.duration",
      FT_UINT16, BASE_DEC, NULL, 0,
      "Quiet Period Duration in units of 32us", HFILL } },

    {&hf_ieee80211_he_qtp_request_quiet_period_interval,
     {"Quiet Period Interval", "wlan.ext_tag.quiet_time_period.request.interval",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Interval between the start of two consecutive quite time periods, in TUs",
      HFILL } },

    {&hf_ieee80211_he_qtp_request_repetition_count,
     {"Repetition Count", "wlan.ext_tag.quiet_time_period.request.repetition_count",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Number of requested quiet time periods", HFILL } },

    {&hf_ieee80211_he_qtp_request_srv_specific_identif,
     {"Service Specific Identifier", "wlan.ext_tag.quiet_time_period.request.srv_specific_identif",
      FT_UINT16, BASE_HEX, NULL, 0,
      "Specified peer-to-peer operation for which participating HE STAs might transmit frames during the quiet time period", HFILL } },

    {&hf_ieee80211_he_qtp_response_dialog_token,
     {"Dialog Token", "wlan.ext_tag.quiet_time_period.response.dialog_token",
      FT_UINT16, BASE_DEC, NULL, 0,
      "The quiet time period request subtype to which this response corresponds",
      HFILL } },

    {&hf_ieee80211_he_qtp_response_status_code,
     {"Status Code", "wlan.ext_tag.quiet_time_period.response.status_code",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Status of the requested operation", HFILL } },

    {&hf_ieee80211_he_qtp_response_quiet_period_offset,
     {"Quiet Period Offset", "wlan.ext_tag.quiet_time_period.response.offset",
       FT_UINT8, BASE_DEC, NULL, 0,
      "Offset of the start of the first quiet time period", HFILL } },

    {&hf_ieee80211_he_qtp_response_quiet_period_duration,
     {"Quiet Period Duration", "wlan.ext_tag.quiet_time_period.response.duration",
      FT_UINT16, BASE_DEC, NULL, 0,
      "Quiet Period Duration in units of 32us", HFILL } },

    {&hf_ieee80211_he_qtp_response_quiet_period_interval,
     {"Quiet Period Interval", "wlan.ext_tag.quiet_time_period.response.interval",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Interval between the start of two consecutive quiet time periods", HFILL } },

    {&hf_ieee80211_he_qtp_response_repetition_count,
     {"Repetition Count", "wlan.ext_tag.quiet_time_period.response.repetition_count",
      FT_UINT8, BASE_DEC, NULL, 0,
      "Number of requested quiet time periods", HFILL } },

    {&hf_ieee80211_he_qtp_response_srv_specific_identif,
     {"Service Specific Identifier", "wlan.ext_tag.quiet_time_period.response.srv_specific_identif",
      FT_UINT16, BASE_HEX, NULL, 0,
      "Identifier of a peer-to-peer operation for which participating HE STAs might transmit frames",
      HFILL } },

    {&hf_ieee80211_he_ndp_annc_sta,
     {"STA Info", "wlan.he_ndp.sta_info",
      FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_ndp_annc_aid11,
     {"AID11", "wlan.he_ndp.sta_info.aid11",
      FT_UINT32, BASE_HEX, NULL, 0x000007FF, NULL, HFILL }},

    {&hf_ieee80211_he_ndp_annc_ru_start,
     {"RU Start Index", "wlan.he_ndp.sta_info.ru_start",
      FT_UINT32, BASE_HEX, NULL, 0x0003F800,
      "26-tone RU start index of the target STA", HFILL }},

    {&hf_ieee80211_he_ndp_annc_ru_end,
     {"RU End Index", "wlan.he_ndp.sta_info.ru_end",
      FT_UINT32, BASE_HEX, NULL, 0x01FC0000,
      "26-tone RU end index  of the target STA", HFILL }},

    {&hf_ieee80211_he_ndp_annc_feedback_type_and_ng,
     {"Feedback Type and Ng", "wlan.he_ndp.sta_info.feedback_type_and_ng",
      FT_UINT32, BASE_HEX, NULL, 0x06000000, NULL, HFILL }},

    {&hf_ieee80211_he_ndp_annc_disambiguation,
     {"Disambiguation", "wlan.he_ndp.sta_info.disambiguation",
      FT_UINT32, BASE_HEX, NULL, 0x08000000, NULL, HFILL }},

    {&hf_ieee80211_he_ndp_annc_codebook_size,
     {"Codebook Size", "wlan.he_ndp.sta_info.codebook_size",
      FT_UINT32, BASE_HEX, NULL, 0x10000000, NULL, HFILL }},

    {&hf_ieee80211_he_ndp_annc_nc,
     {"Nc", "wlan.he_ndp.sta_info.nc",
      FT_UINT32, BASE_HEX, NULL, 0xE0000000, NULL, HFILL }},

    {&hf_ieee80211_he_ndp_annc_disallowed_bitmap,
     {"Disallowed Subchannel Bitmap",
      "wlan.he_ndp.sta_info.disallowed_subchannel_bitmap",
      FT_UINT32, BASE_HEX, NULL, 0x0007f800, NULL, HFILL }},

    {&hf_ieee80211_he_ndp_annc_reserved1,
     {"Reserved", "wlan.he_ndp.sta_info.reserved1",
      FT_UINT32, BASE_HEX, NULL, 0x07f80000, NULL, HFILL }},

    {&hf_ieee80211_he_ndp_annc_reserved2,
     {"Reserved", "wlan.he_ndp.sta_info.reserved2",
      FT_UINT32, BASE_HEX, NULL, 0xf0000000, NULL, HFILL }},

    {&hf_ieee80211_htc_ht_lac,
     {"Link Adaptation Control (LAC)", "wlan.htc.lac",
      FT_UINT32, BASE_HEX, NULL, 0x0000FFFE,
      "High Throughput Control Link Adaptation Control (LAC)", HFILL }},

    {&hf_ieee80211_htc_lac_trq,
     {"Training Request (TRQ)", "wlan.htc.lac.trq",
      FT_BOOLEAN, 16, TFS(&htc_lac_trq_flag), 0x0002,
      "High Throughput Control Link Adaptation Control Training Request (TRQ)", HFILL }},

    {&hf_ieee80211_htc_lac_mai_aseli,
     {"Antenna Selection Indication (ASELI)", "wlan.htc.lac.mai.aseli",
      FT_UINT16, BASE_HEX, NULL, 0x003C,
      "High Throughput Control Link Adaptation Control MAI Antenna Selection Indication", HFILL }},

    {&hf_ieee80211_htc_lac_mai_mrq,
     {"MCS Request (MRQ)", "wlan.htc.lac.mai.mrq",
      FT_BOOLEAN, 16, TFS(&htc_lac_mai_mrq_flag), 0x0004,
      "High Throughput Control Link Adaptation Control MAI MCS Request", HFILL }},

    {&hf_ieee80211_htc_lac_mai_msi,
     {"MCS Request Sequence Identifier (MSI)", "wlan.htc.lac.mai.msi",
      FT_UINT16, BASE_HEX, NULL, 0x0038,
      "High Throughput Control Link Adaptation Control MAI MCS Request Sequence Identifier", HFILL }},

    {&hf_ieee80211_htc_lac_mai_reserved,
     {"Reserved", "wlan.htc.lac.mai.reserved",
      FT_UINT16, BASE_HEX, NULL, 0x0038,
      "High Throughput Control Link Adaptation Control MAI Reserved", HFILL }},

    {&hf_ieee80211_htc_lac_mfsi,
     {"MCS Feedback Sequence Identifier (MFSI)", "wlan.htc.lac.mfsi",
      FT_UINT16, BASE_DEC, NULL, 0x01C0,
      "High Throughput Control Link Adaptation Control MCS Feedback Sequence Identifier (MSI)", HFILL }},

    {&hf_ieee80211_htc_lac_asel_command,
     {"Antenna Selection (ASEL) Command", "wlan.htc.lac.asel.command",
      FT_UINT16, BASE_HEX, VALS(ieee80211_htc_lac_asel_command_flags), 0x0E00,
      "High Throughput Control Link Adaptation Control Antenna Selection (ASEL) Command", HFILL }},

    {&hf_ieee80211_htc_lac_asel_data,
     {"Antenna Selection (ASEL) Data", "wlan.htc.lac.asel.data",
      FT_UINT16, BASE_HEX, NULL, 0xF000,
      "High Throughput Control Link Adaptation Control Antenna Selection (ASEL) Data", HFILL }},

    {&hf_ieee80211_htc_lac_mfb,
     {"MCS Feedback (MFB)", "wlan.htc.lac.mfb",
      FT_UINT16, BASE_HEX, NULL, 0xFE00,
      "High Throughput Control Link Adaptation Control MCS Feedback", HFILL }},

    {&hf_ieee80211_htc_cal_pos,
     {"Calibration Position", "wlan.htc.cal.pos",
      FT_UINT32, BASE_DEC, VALS(ieee80211_htc_cal_pos_flags), 0x00030000,
      "High Throughput Control Calibration Position", HFILL }},

    {&hf_ieee80211_htc_cal_seq,
     {"Calibration Sequence Identifier", "wlan.htc.cal.seq",
      FT_UINT32, BASE_DEC, NULL, 0x000C0000,
      "High Throughput Control Calibration Sequence Identifier", HFILL }},

    {&hf_ieee80211_htc_reserved1,
     {"Reserved", "wlan.htc.reserved1",
      FT_UINT32, BASE_HEX, NULL, 0x00300000,
      "High Throughput Control Reserved", HFILL }},

    {&hf_ieee80211_htc_csi_steering,
     {"CSI/Steering", "wlan.htc.csi_steering",
      FT_UINT32, BASE_DEC, VALS(ieee80211_htc_csi_steering_flags), 0x00C00000,
      "High Throughput Control CSI/Steering", HFILL }},

    {&hf_ieee80211_htc_ndp_announcement,
     {"NDP Announcement", "wlan.htc.ndp_announcement",
      FT_BOOLEAN, 32, TFS(&ieee80211_htc_ndp_announcement_flag), 0x01000000,
      "High Throughput Control NDP Announcement", HFILL }},

    {&hf_ieee80211_htc_reserved2,
     {"Reserved", "wlan.htc.reserved2",
      FT_UINT32, BASE_HEX, NULL, 0x3E000000,
      "High Throughput Control Reserved", HFILL }},

    {&hf_ieee80211_htc_mrq,
     {"MRQ", "wlan.htc.mrq",
      FT_BOOLEAN, 32, NULL, HTC_MRQ,
      "VHT-MCS feedback request", HFILL }},

    {&hf_ieee80211_htc_msi,
     {"MSI", "wlan.htc.msi",
      FT_UINT32, BASE_DEC, NULL, 0x00000038,
      "MRQ sequence number", HFILL }},

    {&hf_ieee80211_htc_msi_stbc_reserved,
     {"Reserved", "wlan.htc.msi_stbc_reserved",
      FT_UINT32, BASE_HEX, NULL, 0x00000038,
      NULL, HFILL }},

    {&hf_ieee80211_htc_compressed_msi,
     {"Compressed MSI", "wlan.htc.compressed_msi",
      FT_UINT32, BASE_DEC, NULL, 0x00000018,
      NULL, HFILL }},

    {&hf_ieee80211_htc_ppdu_stbc_encoded,
     {"PPDU was STBC encoded", "wlan.htc.ppdu_stbc_encoded",
      FT_BOOLEAN, 32, NULL, 0x00000020,
      NULL, HFILL }},

    {&hf_ieee80211_htc_mfsi,
     {"MFSI", "wlan.htc.mfsi",
      FT_BOOLEAN, 32, NULL, 0x000001C0,
      "MFB sequence identifier", HFILL }},

    {&hf_ieee80211_htc_gid_l,
     {"GID-L", "wlan.htc.gid_l",
      FT_BOOLEAN, 32, NULL, 0x000001C0,
      "LSBs of group ID", HFILL }},

    {&hf_ieee80211_htc_mfb,
     {"MFB", "wlan.htc.mfb",
      FT_UINT32, BASE_HEX, NULL, 0x00FFFE00,
      "Recommended MFB", HFILL }},

    {&hf_ieee80211_htc_num_sts,
     {"NUM_STS", "wlan.htc.num_sts",
      FT_UINT32, BASE_DEC, NULL, 0x00000E00,
      "Recommended NUM_STS", HFILL }},

    {&hf_ieee80211_htc_vht_mcs,
     {"VHT-MCS", "wlan.htc.vht_mcs",
      FT_UINT32, BASE_DEC, NULL, 0x0000F000,
      "Recommended VHT-MCS", HFILL }},

    {&hf_ieee80211_htc_bw,
     {"BW", "wlan.htc.bw",
      FT_UINT32, BASE_DEC, VALS(ieee80211_htc_bw_recommended_vht_mcs_vals), 0x00030000,
      "Bandwidth for recommended VHT-MCS", HFILL }},

    {&hf_ieee80211_htc_snr,
     {"SNR", "wlan.htc.snr",
      FT_INT32, BASE_DEC, NULL, 0x00FC0000,
      "Average SNR + 22", HFILL }},

    {&hf_ieee80211_htc_reserved3,
     {"Reserved", "wlan.htc.reserved3",
      FT_UINT32, BASE_HEX, NULL, 0x1F000000,
      NULL, HFILL }},

    {&hf_ieee80211_htc_gid_h,
     {"GID-H", "wlan.htc.gid_h",
      FT_UINT32, BASE_DEC, NULL, 0x07000000,
      NULL, HFILL }},

    {&hf_ieee80211_htc_coding_type,
     {"Coding type", "wlan.htc.coding_type",
      FT_UINT32, BASE_DEC, VALS(ieee80211_htc_coding_type_vals), 0x08000000,
      NULL, HFILL }},

    {&hf_ieee80211_htc_fb_tx_type,
     {"FB Tx type", "wlan.htc.fb_tx_type",
      FT_UINT32, BASE_DEC, VALS(ieee80211_htc_fb_tx_type_vals), 0x10000000,
      NULL, HFILL }},

    {&hf_ieee80211_htc_unsolicited_mfb,
     {"Unsolicited MFB", "wlan.htc.unsolicited_mfb",
      FT_BOOLEAN, 32, NULL, HTC_UNSOLICITED_MFB,
      "High Throughput Control Unsolicited MFB", HFILL }},

    {&hf_ieee80211_htc_ac_constraint,
     {"AC Constraint", "wlan.htc.ac_constraint",
      FT_BOOLEAN, 32, NULL, 0x40000000,
      "High Throughput Control AC Constraint", HFILL }},

    {&hf_ieee80211_htc_rdg_more_ppdu,
     {"RDG/More PPDU", "wlan.htc.rdg_more_ppdu",
      FT_BOOLEAN, 32, NULL, 0x80000000,
      "High Throughput Control RDG/More PPDU", HFILL }},
    /* End: HT Control (+HTC) */

    /* MDIE */
    {&hf_ieee80211_tag_mobility_domain_mdid,
     {"Mobility Domain Identifier", "wlan.mobility_domain.mdid",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_mobility_domain_ft_capab,
     {"FT Capability and Policy", "wlan.mobility_domain.ft_capab",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_mobility_domain_ft_capab_ft_over_ds,
     {"Fast BSS Transition over DS",
      "wlan.mobility_domain.ft_capab.ft_over_ds",
      FT_UINT8, BASE_HEX, NULL, 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_mobility_domain_ft_capab_resource_req,
     {"Resource Request Protocol Capability",
      "wlan.mobility_domain.ft_capab.resource_req",
      FT_UINT8, BASE_HEX, NULL, 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_mobility_domain_ft_capab_reserved,
     {"Reserved",
      "wlan.mobility_domain.ft_capab.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xfc,
      NULL, HFILL }},

    /* FTIE */
    {&hf_ieee80211_tag_ft_mic_control,
     {"MIC Control", "wlan.ft.mic_control",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_mic_control_rsnxe_used,
     {"RSNXE Used", "wlan.ft.mic_control.rsnxe_used",
      FT_BOOLEAN, 16, TFS(&tfs_used_notused), 0x0001, NULL, HFILL }},

    {&hf_ieee80211_tag_ft_mic_control_mic_length,
     {"MIC Length", "wlan.ft.mic_control.mic_length",
      FT_UINT16, BASE_DEC, NULL, 0x000e, NULL, HFILL }},

    {&hf_ieee80211_tag_ft_mic_control_reserved,
     {"Reserved", "wlan.ft.mic_control.reserved",
      FT_UINT16, BASE_HEX, NULL, 0x00f0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_mic_control_element_count,
     {"Element Count", "wlan.ft.mic_control.element_count",
      FT_UINT16, BASE_DEC, NULL, 0xff00,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_mic,
     {"MIC", "wlan.ft.mic",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_anonce,
     {"ANonce", "wlan.ft.anonce",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_snonce,
     {"SNonce", "wlan.ft.snonce",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_id,
     {"Subelement ID", "wlan.ft.subelem.id",
      FT_UINT8, BASE_DEC, VALS(ft_subelem_id_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_len,
     {"Length", "wlan.ft.subelem.len",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_data,
     {"Data", "wlan.ft.subelem.data",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_r1kh_id,
     {"PMK-R1 key holder identifier (R1KH-ID)", "wlan.ft.subelem.r1kh_id",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_gtk_key_info,
     {"Key Info", "wlan.ft.subelem.gtk.key_info",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_gtk_key_id,
     {"Key ID", "wlan.ft.subelem.gtk.key_id",
      FT_UINT16, BASE_DEC, NULL, 0x0003,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_gtk_key_length,
     {"Key Length", "wlan.ft.subelem.gtk.key_length",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_gtk_rsc,
     {"RSC", "wlan.ft.subelem.gtk.rsc",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_gtk_key,
     {"GTK", "wlan.ft.subelem.gtk.key",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_gtk_key_encrypted,
     {"GTK (encrypted)", "wlan.ft.subelem.gtk.key_encrypted",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_r0kh_id,
     {"PMK-R0 key holder identifier (R0KH-ID)", "wlan.ft.subelem.r0kh_id",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_igtk_key_id,
     {"Key ID", "wlan.ft.subelem.igtk.key_id",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_igtk_ipn,
     {"IPN", "wlan.ft.subelem.igtk.ipn",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_igtk_key_length,
     {"Key Length", "wlan.ft.subelem.igtk.key_length",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_igtk_key,
     {"Wrapped Key (IGTK)", "wlan.ft.subelem.igtk.key",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_oci_op_class,
     {"Operating Class", "wlan.ft.subelem.oci.operating_class",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_oci_prim_chan_num,
     {"Primary Channel Number", "wlan.ft.subelem.oci.primary_channel_number",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_oci_freq_seg_1,
     {"Frequency Segment 1 Channel Number",
      "wlan.ft.subelem.oci.frequency_segment_1_channel_number",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_oci_oct_op_class,
     {"OCT Operating Class", "wlan.ft.subelem.oci.oct_operating_class",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_oci_oct_prim_chan_num,
     {"OCT Primary Channel Number",
      "wlan.ft.subelem.oci.oct_primary_channel_number",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_oci_oct_freq_seg_1,
     {"OCT Frequency Segment 1 Channel Number",
      "wlan.ft.subelem.oci.oct_frequency_segment_1_channel_number",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_bigtk_key_id,
     {"Key ID", "wlan.ft.subelem.bigtk.key_id",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_bigtk_bipn,
     {"BIPN", "wlan.ft.subelem.bigtk.bipn",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_bigtk_key_length,
     {"Key Length", "wlan.ft.subelem.bigtk.key_length",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_bigtk_key,
     {"Wrapped Key (BIGTK)", "wlan.ft.subelem.bigtk.key",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_gtk_key_info,
     {"Key Info", "wlan.ft.subelem.mlo_gtk.key_info",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_gtk_key_id,
     {"Key ID", "wlan.ft.subelem.mlo_gtk.key_id",
      FT_UINT16, BASE_DEC, NULL, 0x0003,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_gtk_link_id_info,
     {"Link ID Info", "wlan.ft.subelem.mlo_gtk.link_id_info",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_gtk_link_id,
     {"Link ID", "wlan.ft.subelem.mlo_gtk.link_id",
      FT_UINT8, BASE_DEC, NULL, 0x0f,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_gtk_key_length,
     {"Key Length", "wlan.ft.subelem.mlo_gtk.key_length",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_gtk_rsc,
     {"RSC", "wlan.ft.subelem.mlo_gtk.rsc",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_gtk_key,
     {"Wrapped Key (MLO GTK)", "wlan.ft.subelem.mlo_gtk.key",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_igtk_key_id,
     {"Key ID", "wlan.ft.subelem.mlo_igtk.key_id",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_igtk_ipn,
     {"IPN", "wlan.ft.subelem.mlo_igtk.ipn",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_igtk_link_id_info,
     {"Link ID Info", "wlan.ft.subelem.mlo_igtk.link_id_info",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_igtk_link_id,
     {"Link ID", "wlan.ft.subelem.mlo_igtk.link_id",
      FT_UINT8, BASE_DEC, NULL, 0x0f,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_igtk_key_length,
     {"Key Length", "wlan.ft.subelem.mlo_igtk.key_length",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_igtk_key,
     {"Wrapped Key (MLO IGTK)", "wlan.ft.subelem.mlo_igtk.key",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_bigtk_key_id,
     {"Key ID", "wlan.ft.subelem.mlo_bigtk.key_id",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_bigtk_bipn,
     {"BIPN", "wlan.ft.subelem.mlo_bigtk.bipn",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_bigtk_link_id,
     {"Link ID", "wlan.ft.subelem.mlo_bigtk.link_id",
      FT_UINT8, BASE_DEC, NULL, 0x0f,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_bigtk_link_id_info,
     {"Link ID Info", "wlan.ft.subelem.mlo_bigtk.link_id_info",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_bigtk_key_length,
     {"Key Length", "wlan.ft.subelem.mlo_bigtk.key_length",
      FT_UINT8, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_ft_subelem_mlo_bigtk_key,
     {"Wrapped Key (MLO BIGTK)", "wlan.ft.subelem.mlo_bigtk.key",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    /* RIC Data IE: 802.11-2012: 8.4.2.52 */
    {&hf_ieee80211_tag_ric_data_id,
     {"Resource Handshake Identifier", "wlan.ric_data.id",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_ric_data_desc_cnt,
     {"Resource Descriptor Count", "wlan.ric_data.desc_cnt",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_ric_data_status_code,
     {"Status Code", "wlan.ric_data.status_code",
      FT_UINT16, BASE_HEX|BASE_EXT_STRING, &ieee80211_status_code_ext, 0,
      "Status of requested Resource", HFILL }},

    /* OBSS IE: 802.11-2012: 8.4.2.61 */
    {&hf_ieee80211_tag_obss_spd,
     {"Scan Passive Dwell", "wlan.obss.spd",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_obss_sad,
     {"Scan Active Dwell", "wlan.obss.sad",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_obss_cwtsi,
     {"Channel Width Trigger Scan Interval", "wlan.obss.cwtsi",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_obss_sptpc,
     {"Scan Passive Total Per Channel", "wlan.obss.sptpc",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_obss_satpc,
     {"Scan Active Total Per Channel", "wlan.obss.satpc",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_obss_wctdf,
     {"Width Channel Transition Delay Factor", "wlan.obss.wctdf",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_obss_sat,
     {"Scan Activity Threshold", "wlan.obss.sat",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    /* Group Data Cypher Suite: 802.11-2012: 8.4.2.25.1 */
    {&hf_ieee80211_group_data_cipher_suite_oui,
     {"Group Data Cypher Suite OUI", "wlan.osen.gdcs.oui",
      FT_UINT24, BASE_OUI, NULL, 0, NULL, HFILL }},

    /* TODO: List the suite names ... */
    {&hf_ieee80211_group_data_cipher_suite_type,
     {"Group Data Cypher Suite type", "wlan.osen.gdcs.type",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_osen_pcs_count,
     {"OSEN Pairwise Cipher Suite Count", "wlan.osen.pwcs.count",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_osen_pairwise_cipher_suite_oui,
     {"OSEN Pairwise Cypher Suite OUI", "wlan.osen.pwcs.oui",
      FT_UINT24, BASE_OUI, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_osen_pairwise_cipher_suite_type,
     {"OSEN Pairwise Cypher Suite type", "wlan.osen.pwcs.type",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_osen_akm_count,
     {"OSEN AKM Cipher Suite Count", "wlan.osen.akms.count",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_osen_akm_cipher_suite_oui,
     {"OSEN AKM Cipher Suite OUI", "wlan.osen.akms.oui",
      FT_UINT24, BASE_OUI, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_osen_akm_cipher_suite_type,
     {"OSEN AKM Cipher Suite Type", "wlan.osen.akms.type",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_osen_rsn_cap_preauth,
     {"RSN Pre-Auth capabilities", "wlan.osen.rsn.capabilities.preauth",
      FT_BOOLEAN, 16, TFS(&rsn_preauth_flags), 0x0001, NULL, HFILL }},

    {&hf_ieee80211_osen_rsn_cap_no_pairwise,
     {"RSN No Pairwise capabilities", "wlan.osen.rsn.capabilities.no_pairwise",
      FT_BOOLEAN, 16, TFS(&rsn_no_pairwise_flags), 0x0002, NULL, HFILL }},

    {&hf_ieee80211_osen_rsn_cap_ptksa_replay_counter,
     {"RSN PTKSA Replay Counter capabilities",
                "wlan.osen.rsn.capabilities.ptksa_replay_counter",
      FT_UINT16, BASE_HEX, VALS(rsn_cap_replay_counter), 0x000C, NULL, HFILL }},

    {&hf_ieee80211_osen_rsn_cap_gtksa_replay_counter,
     {"RSN GTKSA Replay Counter capabilities",
                "wlan.osen.rsn.capabilities.gtksa_replay_counter",
      FT_UINT16, BASE_HEX, VALS(rsn_cap_replay_counter), 0x0030, NULL, HFILL }},

    {&hf_ieee80211_osen_group_management_cipher_suite_oui,
     {"OSEN Group Management Cipher Suite OUI", "wlan.osen.gmcs.oui",
      FT_UINT24, BASE_OUI, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_osen_group_management_cipher_suite_type,
     {"OSEN Group Management Cipher Suite Type", "wlan.osen.gmcs.type",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_osen_rsn_cap_mfpr,
     {"Management Frame Protection Required", "wlan.osen.rsn.capabilities.mfpr",
      FT_BOOLEAN, 16, TFS(&tfs_required_not_required), 0x0040, NULL, HFILL }},

    {&hf_ieee80211_osen_rsn_cap_mfpc,
     {"Management Frame Protection Capable", "wlan.osen.rsn.capabilities.mfpc",
      FT_BOOLEAN, 16, TFS(&tfs_capable_not_capable), 0x0080, NULL, HFILL }},

    {&hf_ieee80211_osen_rsn_cap_jmr,
     {"Joint Multi-band RSNA", "wlan.osen.rsn.capabilities.jmr",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0100, NULL, HFILL }},

    {&hf_ieee80211_osen_rsn_cap_peerkey,
     {"PeerKey Enabled", "wlan.osen.rsn.capabilities.peerkey",
      FT_BOOLEAN, 16, TFS(&tfs_enabled_disabled), 0x0200, NULL, HFILL }},

    {&hf_ieee80211_osen_rsn_cap_flags,
     {"RSN Capability Flags", "wlan.osen.rsn.capabilities.flags",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_osen_rsn_spp_a_msdu_capable,
     {"SPP A-MSDU Capable", "wlan.osen.rsn.capabilities.spp_a_msdu_cap",
      FT_BOOLEAN, 16, TFS(&tfs_capable_not_capable), 0x0400, NULL, HFILL }},

    {&hf_ieee80211_osen_rsn_spp_a_msdu_required,
     {"SPP A-MSDU Required", "wlan.osen.rsn.capabilities.spp_a_msdu_req",
      FT_BOOLEAN, 16, TFS(&tfs_required_not_required), 0x0800, NULL, HFILL }},

    {&hf_ieee80211_osen_rsn_pbac,
     {"Protected Block Ack Agreement Capable", "wlan.osen.rsn.capabilities.pbac",
      FT_BOOLEAN, 16, TFS(&tfs_capable_not_capable), 0x1000, NULL, HFILL }},

    {&hf_ieee80211_osen_extended_key_id_iaf,
     {"Extended Key ID for Individually Addressed Frames",
      "wlan.osn.rsn.extended_key_id_iaf",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x2000, NULL, HFILL }},

    {&hf_ieee80211_osen_reserved,
     {"Reserved", "wlan.osen.rsn.capabilities.reserved",
      FT_UINT16, BASE_HEX, NULL, 0xC000, NULL, HFILL }},

    {&hf_ieee80211_osen_pmkid_count,
     {"OSEN PMKID Count", "wlan.osen.pmkid.count",
      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_osen_pmkid,
     {"OSEN PKMID", "wlan.osen.pmkid.bytes",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    /* RIC Descriptor IE: 802.11-2012: 8.4.2.53 */
    {&hf_ieee80211_tag_ric_desc_rsrc_type,
     {"Resource Type", "wlan.ric_desc.rsrc_type",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_ric_desc_var_params,
     {"Variable Params", "wlan.ric_desc.var_params",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    /* MMIE */
    {&hf_ieee80211_tag_mmie_keyid,
     {"KeyID", "wlan.mmie.keyid",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_mmie_ipn,
     {"IPN", "wlan.mmie.ipn",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_mmie_mic,
     {"MIC", "wlan.mmie.mic",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    /* Non Transmitted BSSID Capability */
    {&hf_ieee80211_tag_no_bssid_capability_dmg_bss_control,
     {"DMG BSS Control", "wlan.no_bssid_capability.dmg_bss_control",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_no_bssid_capability_dmg_bss_control_type,
     {"Type", "wlan.no_bssid_capability.dmg_bss_control.type",
      FT_UINT8, BASE_DEC, NULL, 0x03, NULL, HFILL }},

    {&hf_ieee80211_tag_no_bssid_capability_dmg_bss_control_reserved,
     {"Reserved", "wlan.no_bssid_capability.dmg_bss_control.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xFC, NULL, HFILL }},

    /* Multiple BSSID Index */
    {&hf_ieee80211_tag_multiple_bssid_index_bssid_index,
     {"BSSID Index", "wlan.multiple_bssid_index.bssid_index",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_multiple_bssid_index_dtim_period,
     {"DTIM Period", "wlan.multiple_bssid_index.dtim_period",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_multiple_bssid_index_dtim_count,
     {"DTIM Count", "wlan.multiple_bssid_index.dtim_count",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    /* WAPI Parameter Set*/
    {&hf_ieee80211_tag_wapi_param_set_version,
     {"Version", "wlan.wapi.version",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_wapi_param_set_akm_suite_count,
     {"AKM Suite Count", "wlan.wapi.akm_suite.count",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_wapi_param_set_akm_suite_oui,
     {"AKM Suite OUI", "wlan.wapi.akm_suite.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_wapi_param_set_akm_suite_type,
     {"AKM Suite Type", "wlan.wapi.akm_suite.type",
      FT_UINT8, BASE_DEC, VALS(ieee80211_wapi_suite_type) , 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_wapi_param_set_ucast_cipher_suite_count,
     {"Unicast Cipher Suite Count", "wlan.wapi.unicast_cipher.suite.count",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_wapi_param_set_ucast_cipher_suite_oui,
     {"Unicast Cipher Suite OUI", "wlan.wapi.unicast_cipher.suite.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_wapi_param_set_ucast_cipher_suite_type,
     {"Unicast Cipher Suite Type", "wlan.wapi.unicast_cipher.suite.type",
      FT_UINT8, BASE_DEC, VALS(ieee80211_wapi_cipher_type) , 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_wapi_param_set_mcast_cipher_suite_oui,
     {"Multicast Cipher Suite OUI", "wlan.wapi.multicast_cipher.suite.oui",
      FT_UINT24, BASE_OUI, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_wapi_param_set_mcast_cipher_suite_type,
     {"Multicast Cipher Suite Type", "wlan.wapi.multicast_cipher.suite.type",
      FT_UINT8, BASE_DEC, VALS(ieee80211_wapi_cipher_type) , 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_wapi_param_set_capab,
     {"WAPI Capability Info", "wlan.wapi.capab",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_wapi_param_set_capab_preauth,
     {"Supports Preauthentication?", "wlan.wapi.capab.preauth",
      FT_BOOLEAN, 16 , NULL, 0x0001,
      NULL, HFILL }},

    {&hf_ieee80211_tag_wapi_param_set_capab_rsvd,
     {"Reserved", "wlan.wapi.capab.rsvd",
      FT_UINT16, BASE_DEC , NULL, 0xFFFE,
      NULL, HFILL }},

    {&hf_ieee80211_tag_wapi_param_set_bkid_count,
     {"No of BKID's", "wlan.wapi.bkid.count",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_wapi_param_set_bkid_list,
     {"BKID", "wlan.wapi.bkid",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    /* BSS Max Idle Period */
    {&hf_ieee80211_tag_bss_max_idle_period,
     {"Max Idle Period (1000 TUs)", "wlan.bss_max_idle.period",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_bss_max_idle_options,
     {"Idle Options", "wlan.bss_max_idle.options",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_tag_bss_max_idle_options_protected,
     {"Protected Keep-Alive Required",
      "wlan.bss_max_idle.options.protected",
      FT_UINT8, BASE_DEC, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_tag_bss_idle_options_reserved,
     {"Reserved", "wlan.bss_max_idle.options.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xFE, NULL, HFILL }},

    /* TFS Request */
    {&hf_ieee80211_tag_tfs_request_id,
     {"TFS ID", "wlan.tfs_request.id",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_tfs_request_ac_delete_after_match,
     {"TFS Action Code - Delete after match",
      "wlan.tfs_request.action_code.delete_after_match",
      FT_UINT8, BASE_DEC, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_tag_tfs_request_ac_notify,
     {"TFS Action Code - Notify",
      "wlan.tfs_request.action_code.notify",
      FT_UINT8, BASE_DEC, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_tag_tfs_request_subelem_id,
     {"Subelement ID", "wlan.tfs_request.subelem.id",
      FT_UINT8, BASE_DEC, VALS(tfs_request_subelem_ids), 0,
      "TFS Request Subelement ID", HFILL }},

    {&hf_ieee80211_tag_tfs_request_subelem_len,
     {"Length", "wlan.tfs_request.subelem.len",
      FT_UINT8, BASE_DEC, NULL, 0,
      "TFS Request Subelement Length", HFILL }},

    {&hf_ieee80211_tag_tfs_request_subelem,
     {"Subelement Data", "wlan.tfs_request.subelem",
      FT_BYTES, BASE_NONE, NULL, 0,
      "TFS Request Subelement Data", HFILL }},

    /* TFS Response */
    {&hf_ieee80211_tag_tfs_response_subelem_id,
     {"Subelement ID", "wlan.tfs_response.subelem.id",
      FT_UINT8, BASE_DEC, VALS(tfs_response_subelem_ids), 0,
      "TFS Response Subelement ID", HFILL }},

    {&hf_ieee80211_tag_tfs_response_subelem_len,
     {"Length", "wlan.tfs_response.subelem.len",
      FT_UINT8, BASE_DEC, NULL, 0,
      "TFS Response Subelement Length", HFILL }},

    {&hf_ieee80211_tag_tfs_response_subelem,
     {"Subelement Data", "wlan.tfs_response.subelem",
      FT_BYTES, BASE_NONE, NULL, 0,
      "TFS Response Subelement Data", HFILL }},

    {&hf_ieee80211_tag_tfs_response_status,
     {"TFS Response Status", "wlan.tfs_response.status",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_tfs_response_id,
     {"TFS ID", "wlan.tfs_response.tfs_id",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    /* WNM-Sleep Mode */
    {&hf_ieee80211_tag_wnm_sleep_mode_action_type,
     {"Action Type", "wlan.wnm_sleep_mode.action_type",
      FT_UINT8, BASE_DEC, VALS(wnm_sleep_mode_action_types), 0,
      "WNM-Sleep Mode Action Type", HFILL }},

    {&hf_ieee80211_tag_wnm_sleep_mode_response_status,
     {"WNM-Sleep Mode Response Status",
      "wlan.wnm_sleep_mode.response_status",
      FT_UINT8, BASE_DEC, VALS(wnm_sleep_mode_response_status_vals), 0, NULL,
      HFILL }},

    {&hf_ieee80211_tag_wnm_sleep_mode_interval,
     {"WNM-Sleep Interval", "wlan.wnm_sleep_mode.interval",
      FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_wnm_sub_elt_id,
     {"Subelement ID", "wlan.wnm_subelt.id",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_wnm_sub_elt_len,
     {"Subelement len", "wlan.wnm_subelt.len",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    /* Time Advertisement */
    {&hf_ieee80211_tag_time_adv_timing_capab,
     {"Timing capabilities", "wlan.time_adv.timing_capab",
      FT_UINT8, BASE_DEC, VALS(time_adv_timing_capab_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_time_adv_time_value,
     {"Time Value", "wlan.time_adv.time_value",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_time_adv_time_value_year,
     {"Time Value: Year", "wlan.time_adv.time_value.year",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_time_adv_time_value_month,
     {"Time Value: Month", "wlan.time_adv.time_value.month",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_time_adv_time_value_day,
     {"Time Value: Day", "wlan.time_adv.time_value.day",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_time_adv_time_value_hours,
     {"Time Value: Hours", "wlan.time_adv.time_value.hours",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_time_adv_time_value_minutes,
     {"Time Value: Minutes", "wlan.time_adv.time_value.minutes",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_time_adv_time_value_seconds,
     {"Time Value: Seconds", "wlan.time_adv.time_value.seconds",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_time_adv_time_value_milliseconds,
     {"Time Value: Milliseconds", "wlan.time_adv.time_value.milliseconds",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_time_adv_time_value_reserved,
     {"Time Value: Reserved", "wlan.time_adv.time_value.reserved",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_time_adv_time_error,
     {"Time Error", "wlan.time_adv.time_error",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_time_adv_time_update_counter,
     {"Time Update Counter", "wlan.time_adv.time_update_counter",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    /* Time Zone */
    {&hf_ieee80211_tag_time_zone,
     {"Time Zone", "wlan.time_zone",
      FT_STRING, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    /* Interworking */
    {&hf_ieee80211_tag_interworking_access_network_type,
     {"Access Network Type", "wlan.interworking.access_network_type",
      FT_UINT8, BASE_DEC, VALS(access_network_type_vals), 0x0f,
      NULL, HFILL }},

    {&hf_ieee80211_tag_interworking_internet,
     {"Internet", "wlan.interworking.internet",
      FT_UINT8, BASE_DEC, NULL, 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_tag_interworking_asra,
     {"ASRA", "wlan.interworking.asra",
      FT_UINT8, BASE_DEC, NULL, 0x20,
      "Additional Step Required for Access", HFILL }},

    {&hf_ieee80211_tag_interworking_esr,
     {"ESR", "wlan.interworking.esr",
      FT_UINT8, BASE_DEC, NULL, 0x40,
      "Emergency services reachable", HFILL }},

    {&hf_ieee80211_tag_interworking_uesa,
     {"UESA", "wlan.interworking.uesa",
      FT_UINT8, BASE_DEC, NULL, 0x80,
      "Unauthenticated emergency service accessible", HFILL }},

    {&hf_ieee80211_tag_interworking_hessid,
     {"HESSID", "wlan.interworking.hessid",
      FT_ETHER, BASE_NONE, NULL, 0,
      "Homogeneous ESS identifier", HFILL }},

    /* QoS Map Set element */
    {&hf_ieee80211_tag_qos_map_set_dscp_exc,
     {"DSCP Exception", "wlan.qos_map_set.dscp_exception",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_qos_map_set_dscp_exc_val,
     {"DSCP Value", "wlan.qos_map_set.dscp_value",
      FT_UINT8, BASE_DEC, NULL, 0,
      "DSCP Exception - DSCP Value", HFILL }},

    {&hf_ieee80211_tag_qos_map_set_dscp_exc_up,
     {"User Priority", "wlan.qos_map_set.up",
      FT_UINT8, BASE_DEC, NULL, 0,
      "DSCP Exception - User Priority", HFILL }},

    {&hf_ieee80211_tag_qos_map_set_range,
     {"DSCP Range description", "wlan.qos_map_set.range",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_qos_map_set_low,
     {"DSCP Low Value", "wlan.qos_map_set.dscp_low_value",
      FT_UINT8, BASE_DEC, NULL, 0,
      "DSCP Range description - DSCP Low Value", HFILL }},

    {&hf_ieee80211_tag_qos_map_set_high,
     {"DSCP High Value", "wlan.qos_map_set.dscp_high_value",
      FT_UINT8, BASE_DEC, NULL, 0,
      "DSCP Range description - DSCP High Value", HFILL }},

    /* Advertisement Protocol */
    {&hf_ieee80211_tag_adv_proto_resp_len_limit,
     {"Query Response Length Limit", "wlan.adv_proto.resp_len_limit",
      FT_UINT8, BASE_DEC, NULL, 0x7f,
      NULL, HFILL }},

    {&hf_ieee80211_tag_adv_proto_pame_bi,
     {"PAME-BI", "wlan.adv_proto.pame_bi",
      FT_UINT8, BASE_DEC, NULL, 0x80,
      "Pre-Association Message Xchange BSSID Independent (PAME-BI)", HFILL }},

    {&hf_ieee80211_tag_adv_proto_id,
     {"Advertisement Protocol ID", "wlan.adv_proto.id",
      FT_UINT8, BASE_DEC, VALS(adv_proto_id_vals), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_adv_vs_len,
     {"Advertisement Protocol Vendor Specific length", "wlan.adv_proto.vs_len",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL}},
#if 0
    {&hf_ieee80211_tag_adv_proto_vs_info,
     {"Advertisement Protocol Vendor Specific info", "wlan.adv_proto.vs_info",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},
#endif

    /* Roaming Consortium */
    {&hf_ieee80211_tag_roaming_consortium_num_anqp_oi,
     {"Number of ANQP OIs", "wlan.roaming_consortium.num_anqp_oi",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_roaming_consortium_oi1_len,
     {"OI #1 Length", "wlan.roaming_consortium.oi1_len",
      FT_UINT8, BASE_DEC, NULL, 0x0f,
      NULL, HFILL }},

    {&hf_ieee80211_tag_roaming_consortium_oi2_len,
     {"OI #2 Length", "wlan.roaming_consortium.oi2_len",
      FT_UINT8, BASE_DEC, NULL, 0xf0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_roaming_consortium_oi1,
     {"OI #1", "wlan.roaming_consortium.oi1",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_roaming_consortium_oi2,
     {"OI #2", "wlan.roaming_consortium.oi2",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_roaming_consortium_oi3,
     {"OI #3", "wlan.roaming_consortium.oi3",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    /* Timeout Interval */
    {&hf_ieee80211_tag_timeout_int_type,
     {"Timeout Interval Type", "wlan.timeout_int.type",
      FT_UINT8, BASE_DEC, VALS(timeout_int_types), 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_timeout_int_value,
     {"Timeout Interval Value", "wlan.timeout_int.value",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    /* Link Identifier */
    {&hf_ieee80211_tag_link_id_bssid,
     {"BSSID", "wlan.link_id.bssid",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_link_id_init_sta,
     {"TDLS initiator STA Address", "wlan.link_id.init_sta",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_link_id_resp_sta,
     {"TDLS responder STA Address", "wlan.link_id.resp_sta",
      FT_ETHER, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    /* Wakeup Schedule */
    {&hf_ieee80211_tag_wakeup_schedule_offset,
     {"Offset", "wlan.wakeup_schedule.offset",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_wakeup_schedule_interval,
     {"Interval", "wlan.wakeup_schedule.interval",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_wakeup_schedule_awake_window_slots,
     {"Awake Window Slots", "wlan.wakeup_schedule.awake_window_slots",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_wakeup_schedule_max_awake_dur,
     {"Maximum Awake Window Duration", "wlan.wakeup_schedule.max_awake_dur",
      FT_UINT32, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_wakeup_schedule_idle_count,
     {"Idle Count", "wlan.wakeup_schedule.idle_count",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    /* Channel Switch Timing */
    {&hf_ieee80211_tag_channel_switch_timing_switch_time,
     {"Switch Time", "wlan.channel_switch_timing.switch_time",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_channel_switch_timing_switch_timeout,
     {"Switch Timeout", "wlan.channel_switch_timing.switch_timeout",
      FT_UINT16, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    /* PTI Control */
    {&hf_ieee80211_tag_pti_control_tid,
     {"TID", "wlan.pti_control.tid",
      FT_UINT8, BASE_DEC, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_pti_control_sequence_control,
     {"Sequence Control", "wlan.pti_control.sequence_control",
      FT_UINT16, BASE_HEX, NULL, 0,
      NULL, HFILL }},

    /* PU Buffer Status */
    {&hf_ieee80211_tag_pu_buffer_status_ac_bk,
     {"AC_BK traffic available", "wlan.pu_buffer_status.ac_bk",
      FT_UINT8, BASE_DEC, NULL, 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_tag_pu_buffer_status_ac_be,
     {"AC_BE traffic available", "wlan.pu_buffer_status.ac_be",
      FT_UINT8, BASE_DEC, NULL, 0x02,
      NULL, HFILL }},

    {&hf_ieee80211_tag_pu_buffer_status_ac_vi,
     {"AC_VI traffic available", "wlan.pu_buffer_status.ac_vi",
      FT_UINT8, BASE_DEC, NULL, 0x04,
      NULL, HFILL }},

    {&hf_ieee80211_tag_pu_buffer_status_ac_vo,
     {"AC_VO traffic available", "wlan.pu_buffer_status.ac_vo",
      FT_UINT8, BASE_DEC, NULL, 0x08,
      NULL, HFILL }},

    /* 60g ie  */
    {&hf_ieee80211_wfa_60g_attr,
     {"Attribute", "wlan.60g.attr",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_60g_attr_id,
     {"Attribute ID", "wlan.60g.attr.id",
      FT_UINT8, BASE_DEC, VALS(ieee80211_wfa_60g_attr_ids), 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_60g_attr_len,
     {"Attribute Length", "wlan.60g.attr.length",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_60g_attr_cap_sta_mac_addr,
     {"STA Address", "wlan.60g.attr.60g_cap.sta_mac_addr",
      FT_ETHER, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_60g_attr_cap_recv_amsdu_frames,
     {"Receive Capability AMSDU", "wlan.60g.attr.60g_cap.recv_amsdu",
      FT_UINT8, BASE_DEC, NULL, 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_wfa_60g_attr_cap_reserved,
     {"Reserved", "wlan.60g.attr.60g_cap.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xfe,
      NULL, HFILL }},

    {&hf_ieee80211_mysterious_extra_stuff,
     {"Mysterious extra OLPC/Ruckus/Atheros/Vector/??? stuff", "wlan.mysterious_extra_stuff",
      FT_NONE, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_mscs_descriptor_type,
     {"Request Type", "wlan.ext_tag.mscs_descriptor.request_type",
      FT_UINT8, BASE_DEC|BASE_RANGE_STRING, RVALS(scs_request_type_rvals),
      0x0, NULL, HFILL }},

    {&hf_ieee80211_mscs_user_prio_control_reserved,
     {"Reserved", "wlan.ext_tag.mscs_descriptor.reserved1",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_user_prio_bitmap,
     {"User Priority Bitmap",
       "wlan.ext_tag.mscs_descriptor.user_prio_control.upbm",
       FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_user_prio_bitmap_bit0,
     {"User Priority 0",
       "wlan.ext_tag.mscs_descriptor.user_prio_control.user_prio_0",
       FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x01, NULL, HFILL }},

    {&hf_ieee80211_user_prio_bitmap_bit1,
     {"User Priority 1",
       "wlan.ext_tag.mscs_descriptor.user_prio_control.user_prio_1",
       FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x02, NULL, HFILL }},

    {&hf_ieee80211_user_prio_bitmap_bit2,
     {"User Priority 2",
       "wlan.ext_tag.mscs_descriptor.user_prio_control.user_prio_2",
       FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x04, NULL, HFILL }},

    {&hf_ieee80211_user_prio_bitmap_bit3,
     {"User Priority 3",
       "wlan.ext_tag.mscs_descriptor.user_prio_control.user_prio_3",
       FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x08, NULL, HFILL }},

    {&hf_ieee80211_user_prio_bitmap_bit4,
     {"User Priority 4",
       "wlan.ext_tag.mscs_descriptor.user_prio_control.user_prio_4",
       FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x10, NULL, HFILL }},

    {&hf_ieee80211_user_prio_bitmap_bit5,
     {"User Priority 5",
       "wlan.ext_tag.mscs_descriptor.user_prio_control.user_prio_5",
       FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x20, NULL, HFILL }},

    {&hf_ieee80211_user_prio_bitmap_bit6,
     {"User Priority 6",
       "wlan.ext_tag.mscs_descriptor.user_prio_control.user_prio_6",
       FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x40, NULL, HFILL }},

    {&hf_ieee80211_user_prio_bitmap_bit7,
     {"User Priority 7",
       "wlan.ext_tag.mscs_descriptor.user_prio_control.user_prio_7",
       FT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x80, NULL, HFILL }},

    {&hf_ieee80211_user_prio_limit,
     {"User Priority Limit",
      "wlan.ext_tag.mscs_descriptor.user_prio_control.user_prio_limit",
      FT_UINT8, BASE_DEC, NULL, 0x07, NULL, HFILL }},

    {&hf_ieee80211_user_prio_reserved,
     {"Reserved", "wlan.ext_tag.mscs_descriptor.user_prio_control.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xF8, NULL, HFILL }},

    {&hf_ieee80211_stream_timeout_reserved,
     {"Reserved", "wlan.ext_tag.mscs_descriptor.reserved2",
      FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_stream_timeout,
     {"Stream Timeout", "wlan.ext_tag.mscs_descriptor.stream_timeout",
      FT_UINT32, BASE_DEC|BASE_UNIT_STRING, UNS(&units_tu_tus), 0x0, NULL, HFILL }},

    {&hf_ieee80211_mscs_subelement_id,
     {"MSCS Subelement ID", "wlan.ext_tag.mscs_descriptor.subelement_id",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_mscs_subelement_len,
     {"MSCS Subelement Length", "wlan.ext_tag.mscs_descriptor.subelement_len",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_mscs_subelement_data,
     {"MSCS Subelement Data", "wlan.ext_tag.mscs_descriptor.subelement_data",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_intra_access_prio,
     {"Intra-Access Priority", "wlan.tag.scs_intra_access_prio",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_intra_access_prio_user_prio,
     {"User Priority", "wlan.tag.scs_intra_access_prio.user_prio",
      FT_UINT8, BASE_DEC, NULL, 0x07, NULL, HFILL }},

    {&hf_ieee80211_intra_access_prio_alt_queue,
     {"Alternate Queue", "wlan.tag.scs_intra_access_prio.alt_queue",
      FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},

    {&hf_ieee80211_intra_access_prio_drop_elig,
     {"Drop Eligibility", "wlan.tag.scs_intra_access_prio.drop_elig",
      FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},

    {&hf_ieee80211_intra_access_prio_reserved,
     {"Reserved", "wlan.tag.scs_intra_access_prio.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xE0, NULL, HFILL }},

    {&hf_ieee80211_scs_descriptor_scsid,
     {"SCSID", "wlan.tag.scs_descriptor.scsid",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_scs_descriptor_type,
     {"Request Type", "wlan.tag.scs_descriptor.request_type",
      FT_UINT8, BASE_DEC|BASE_RANGE_STRING, RVALS(scs_request_type_rvals),
      0x0, NULL, HFILL }},

    {&hf_ieee80211_estimated_service_params,
     {"Estimated Service Parameters", "wlan.ext_tag.estimated_service_params",
      FT_UINT24, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_esp_access_category,
     {"Access Category", "wlan.ext_tag.estimated_service_params.access_category",
      FT_UINT24, BASE_DEC, VALS(esp_access_category_vals), 0x000003,
       NULL, HFILL }},

    {&hf_ieee80211_esp_reserved,
     {"Reserved", "wlan.ext_tag.estimated_service_params.reserved",
      FT_UINT24, BASE_HEX, NULL, 0x000004, NULL, HFILL }},

    {&hf_ieee80211_esp_data_format,
     {"Data Format", "wlan.ext_tag.estimated_service_params.data_format",
      FT_UINT24, BASE_DEC, VALS(esp_data_format_vals), 0x000018,
       NULL, HFILL }},

    {&hf_ieee80211_esp_ba_windows_size,
     {"BA Window Size", "wlan.ext_tag.estimated_service_params.ba_window_size",
      FT_UINT24, BASE_DEC, VALS(esp_ba_window_size_vals), 0x0000E0,
       NULL, HFILL }},

    {&hf_ieee80211_esp_est_air_time_frac,
     {"Estimated Air Time Fraction", "wlan.ext_tag.estimated_service_params.air_time_frac",
      FT_UINT24, BASE_DEC, NULL, 0x00FF00, NULL, HFILL }},

    {&hf_ieee80211_esp_data_ppdu_duration_target,
     {"Data PPDU Duration Target", "wlan.ext_tag.estimated_service_params.data_ppdu_dur_target",
      FT_UINT24, BASE_DEC, NULL, 0xFF0000, NULL, HFILL }},

    {&hf_ieee80211_fcg_new_channel_number,
     {"New Channel Number", "wlan.ext_tag.future_channel_guidance.new_chan_num",
      FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_fcg_extra_info,
     {"Extra bytes", "wlan.ext_tag.future_channel_guidance.extra_bytes",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_sae_password_identifier,
     {"Password Identifier", "wlan.ext_tag.sae.password_identifier",
      FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_sae_anti_clogging_token,
     {"Anti-Clogging Token", "wlan.ext_tag.sae.anti_clogging_token",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_tag_fils_indication_info_nr_pk,
     {"Number of Public Key Identifiers", "wlan.fils_indication.info.nr_pk",
      FT_UINT16, BASE_DEC, NULL, GENMASK(2,0), NULL, HFILL }},

    {&hf_ieee80211_tag_fils_indication_info_nr_realm,
     {"Number of Realm Identifiers", "wlan.fils_indication.info.nr_realm",
      FT_UINT16, BASE_DEC, NULL, GENMASK(5,3), NULL, HFILL }},

    {&hf_ieee80211_tag_fils_indication_info_ip_config,
     {"FILS IP Address Configuration", "wlan.fils_indication.info.ip_config",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), GENMASK(6,6), NULL, HFILL }},

    {&hf_ieee80211_tag_fils_indication_info_cache_id_included,
     {"Cache Identifier", "wlan.fils_indication.info.cache_id_included",
      FT_BOOLEAN, 16, TFS(&tfs_included_not_included), GENMASK(7,7), NULL, HFILL }},

    {&hf_ieee80211_tag_fils_indication_info_hessid_included,
     {"HESSID", "wlan.fils_indication.info.hessid_included",
      FT_BOOLEAN, 16, TFS(&tfs_included_not_included), GENMASK(8,8), NULL, HFILL }},

    {&hf_ieee80211_tag_fils_indication_info_ska_without_pfs,
     {"FILS Shared Key Authentication without PFS", "wlan.fils_indication.info.ska_without_pfs",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), GENMASK(9,9), NULL, HFILL }},

    {&hf_ieee80211_tag_fils_indication_info_ska_with_pfs,
     {"FILS Shared Key Authentication with PFS", "wlan.fils_indication.info.ska_with_pfs",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), GENMASK(10,10), NULL, HFILL }},

    {&hf_ieee80211_tag_fils_indication_info_pka,
     {"FILS Public Key Authentication", "wlan.fils_indication.info.pka",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), GENMASK(11,11), NULL, HFILL }},

    {&hf_ieee80211_tag_fils_indication_info_reserved,
     {"Reserved", "wlan.fils_indication.info.reserved",
      FT_UINT16, BASE_HEX, NULL, GENMASK(15,12), NULL, HFILL }},

    {&hf_ieee80211_tag_fils_indication_cache_identifier,
     {"Cache Identifier", "wlan.fils_indication.cache_identifier",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_fils_indication_hessid,
     {"HESSID", "wlan.fils_indication.hessid",
      FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_fils_indication_realm_list,
     {"Realm Identifiers", "wlan.fils_indication.realms",
      FT_NONE, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_fils_indication_realm_identifier,
     {"Realm Identifier", "wlan.fils_indication.realms.identifier",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_fils_indication_public_key_list,
     {"Public Keys", "wlan.fils_indication.public_keys",
      FT_NONE, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_fils_indication_public_key_type,
     {"Key Type", "wlan.fils_indication.public_keys.key_type",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_fils_indication_public_key_length,
     {"Length", "wlan.fils_indication.public_keys.length",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_fils_indication_public_key_indicator,
     {"Public Key Indicator", "wlan.fils_indication.public_keys.indicator",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_qos_mgmt_attribute_id,
     {"Attribute ID", "wlan.qos_mgmt.ie.attribute_id",
      FT_UINT8, BASE_DEC|BASE_RANGE_STRING, RVALS(qos_mgmt_attributes), 0,
      NULL, HFILL }},

    {&hf_ieee80211_qos_mgmt_attribute_len,
     {"Length", "wlan.qos_mgmt.ie.length",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_qos_mgmt_start_port_range,
     {"Start Port", "wlan.qos_mgmt.ie.start_port",
      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_qos_mgmt_end_port_range,
     {"End Port", "wlan.qos_mgmt.ie.end_port",
      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_qos_mgmt_dscp_pol_id,
     {"Policy ID", "wlan.qos_mgmt.ie.dscp_policy.policy_id",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_qos_mgmt_dscp_pol_req_type,
     {"Request Type", "wlan.qos_mgmt.ie.dscp_policy.request_type",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_qos_mgmt_dscp_pol_dscp,
     {"DSCP", "wlan.qos_mgmt.ie.dscp_policy.dscp",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_qos_mgmt_domain_name,
     {"Domain Name", "wlan.qos_mgmt.ie.domain_name",
      FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_qos_mgmt_unknown_attr,
     {"Unknown attribute", "wlan.qos_mgmt.ie.unknown_attribute",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_ext_tag,
     {"Ext Tag", "wlan.ext_tag",
      FT_NONE, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_ext_tag_number,
     {"Ext Tag Number", "wlan.ext_tag.number",
      FT_UINT8, BASE_DEC|BASE_EXT_STRING, &tag_num_vals_eid_ext_ext, 0,
      "Element ID", HFILL }},

    {&hf_ieee80211_ext_tag_length,
     {"Ext Tag length", "wlan.ext_tag.length",
      FT_UINT32, BASE_DEC, NULL, 0,
      "Length of tag", HFILL }},

    {&hf_ieee80211_ext_tag_data,
     {"Ext Tag Data", "wlan.ext_tag.data",
      FT_BYTES, BASE_NONE, NULL, 0,
      NULL, HFILL }},

    {&hf_ieee80211_fils_req_params_parameter_control_bitmap,
     {"Parameter Control Bitmap", "wlan.ext_tag.fils.req_params.parameter_control_bitmap",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_fils_req_params_fils_criteria_present,
     {"FILS Criteria Present", "wlan.ext_tag.fils.req_params.fils_criteria_present",
      FT_BOOLEAN, 8, NULL, FILS_REQ_PARAMS_FILS_CRITERIA,
      NULL, HFILL }},

    {&hf_ieee80211_fils_req_params_max_delay_limit_present,
     {"Max Delay Limit Present", "wlan.ext_tag.fils.req_params.max_delay_limit_present",
      FT_BOOLEAN, 8, NULL, FILS_REQ_PARAMS_MAX_DELAY_LIMIT,
      NULL, HFILL }},

    {&hf_ieee80211_fils_req_params_minimum_data_rate_present,
     {"Minimum Data Rate Present", "wlan.ext_tag.fils.req_params.minimum_data_rate_present",
      FT_BOOLEAN, 8, NULL, FILS_REQ_PARAMS_MINIMUM_DATA_RATE,
      NULL, HFILL }},

    {&hf_ieee80211_fils_req_params_rcpi_limit_present,
     {"RCPI Limit Present", "wlan.ext_tag.fils.req_params.rcpi_limit_present",
      FT_BOOLEAN, 8, NULL, FILS_REQ_PARAMS_RCPI_LIMIT,
      NULL, HFILL }},

    {&hf_ieee80211_fils_req_params_oui_response_criteria_present,
     {"OUI Response Criteria Present", "wlan.ext_tag.fils.req_params.oui_response_criteria_present",
      FT_BOOLEAN, 8, NULL, FILS_REQ_PARAMS_OUI_RESPONSE_CRITERIA,
      NULL, HFILL }},

    {&hf_ieee80211_fils_req_params_reserved,
     {"Reserved", "wlan.ext_tag.fils.req_params.reserved",
      FT_UINT8, BASE_HEX, NULL, FILS_REQ_PARAMS_RESERVED,
      NULL, HFILL }},

    {&hf_ieee80211_fils_req_params_max_channel_time,
     {"Max Channel Time", "wlan.ext_tag.fils.req_params.max_channel_time",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_fils_req_params_fils_criteria,
     {"FILS Criteria", "wlan.ext_tag.fils.req_params.fils_criteria",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_fils_req_params_fils_criteria_bss_delay,
     {"BSS Delay", "wlan.ext_tag.fils.req_params.fils_criteria.bss_delay",
      FT_BOOLEAN, 8, NULL, FILS_REQ_PARAMS_FILS_CRITERIA_BSS_DELAY,
      NULL, HFILL }},

    {&hf_ieee80211_fils_req_params_fils_criteria_phy_support,
     {"PHY Support", "wlan.ext_tag.fils.req_params.fils_criteria.phy_support",
      FT_BOOLEAN, 8, NULL, FILS_REQ_PARAMS_FILS_CRITERIA_PHY_SUPPORT,
      NULL, HFILL }},

    {&hf_ieee80211_fils_req_params_fils_criteria_reserved,
     {"Reserved", "wlan.ext_tag.fils.req_params.fils_criteria.reserved",
      FT_UINT8, BASE_HEX, NULL, FILS_REQ_PARAMS_FILS_CRITERIA_RESERVED,
      NULL, HFILL }},

    {&hf_ieee80211_fils_req_params_max_delay_limit,
     {"Max Delay Limit", "wlan.ext_tag.fils.req_params.max_delay_limit",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_fils_req_params_minimum_data_rate,
     {"Minimum Data Rate", "wlan.ext_tag.fils.req_params.minimum_data_rate",
      FT_UINT24, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_fils_req_params_rcpi_limit,
     {"RCPI Limit", "wlan.ext_tag.fils.req_params.rcpi_limit",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_fils_req_params_oui_response_criteria,
     {"OUI Response Criteria", "wlan.ext_tag.fils.req_params.oui_response_criteria",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_fils_session,
     {"FILS Session", "wlan.ext_tag.fils.session",
      FT_BYTES, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_fils_encrypted_data,
     {"FILS Encrypted Data", "wlan.ext_tag.fils.encrypted_data",
      FT_BYTES, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_fils_nonce,
     {"FILS Nonce", "wlan.ext_tag.fils.nonce",
      FT_BYTES, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_he_mac_capabilities,
     {"HE MAC Capabilities Information", "wlan.ext_tag.he_mac_caps",
      FT_UINT48, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_htc_he_support,
     {"+HTC HE Support", "wlan.ext_tag.he_mac_cap.htc_he_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000000000001,
      NULL, HFILL }},

    {&hf_ieee80211_he_twt_requester_support,
     {"TWT Requester Support", "wlan.ext_tag.he_mac_cap.twt_req_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000000000002,
      NULL, HFILL }},

    {&hf_ieee80211_he_twt_responder_support,
     {"TWT Responder Support", "wlan.ext_tag.he_mac_cap.twt_rsp_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000000000004,
      NULL, HFILL }},

    {&hf_ieee80211_he_dynamic_fragmentation_support,
     {"Dynamic Fragmentation Support", "wlan.ext_tag.he_mac_cap.dynamic_fragmentation_support",
      FT_UINT48, BASE_DEC|BASE_VAL64_STRING,
      VALS64(he_dynamic_fragmentation_support_vals), 0x000000000018,
      NULL, HFILL }},

    {&hf_ieee80211_he_max_number_fragmented_msdus,
     {"Maximum Number of Fragmented MSDUs", "wlan.ext_tag.he_mac_cap.max_frag_msdus",
      FT_UINT48, BASE_CUSTOM, CF_FUNC(max_frag_msdus_base_custom), 0x0000000000E0,
      NULL, HFILL }},

    {&hf_ieee80211_he_min_fragment_size,
     {"Minimum Fragment Size", "wlan.ext_tag.he_mac_cap.min_frag_size",
      FT_UINT48, BASE_DEC|BASE_VAL64_STRING,
      VALS64(he_minimum_fragmentation_size_vals), 0x000000000300,
      NULL, HFILL }},

    {&hf_ieee80211_he_trigger_frame_mac_padding_dur,
     {"Trigger Frame MAC Padding Duration", "wlan.ext_tag.he_mac_cap.trig_frm_mac_padding_dur",
      FT_UINT48, BASE_DEC|BASE_VAL64_STRING, VALS64(he_trigger_mac_padding_dur_vals), 0x000000000C00, NULL, HFILL }},

    {&hf_ieee80211_he_multi_tid_aggregation_rx_support,
     {"Multi-TID Aggregation Rx Support", "wlan.ext_tag.he_mac_cap.multi_tid_agg_rx_support",
      FT_UINT48, BASE_DEC, NULL, 0x000000007000, NULL, HFILL }},

    {&hf_ieee80211_he_he_link_adaptation_support,
     {"HE Link Adaptation Support", "wlan.ext_tag.he_mac_cap.he_link_adaptation_support",
      FT_UINT48, BASE_DEC|BASE_VAL64_STRING,
      VALS64(he_link_adaptation_support_vals), 0x000000018000,
      NULL, HFILL }},

    {&hf_ieee80211_he_all_ack_support,
     {"All Ack Support", "wlan.ext_tag.he_mac_cap.all_ack_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000000020000,
      NULL, HFILL }},

    {&hf_ieee80211_he_trs_support,
     {"TRS Support", "wlan.ext_tag.he_mac_cap.trs_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000000040000,
      NULL, HFILL }},

    {&hf_ieee80211_he_bsr_support,
     {"BSR Support", "wlan.ext_tag.he_mac_cap.bsr_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000000080000,
      NULL, HFILL }},

    {&hf_ieee80211_he_broadcast_twt_support,
     {"Broadcast TWT Support", "wlan.ext_tag.he_mac_cap.broadcast_twt_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000000100000,
      NULL, HFILL }},

    {&hf_ieee80211_he_32_bit_ba_bitmap_support,
     {"32-bit BA Bitmap Support", "wlan.ext_tag.he_mac_cap.32_bit_ba_bitmap_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000000200000,
      NULL, HFILL }},

    {&hf_ieee80211_he_mu_cascading_support,
     {"MU Cascading Support", "wlan.ext_tag.he_mac_cap.mu_cascading_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000000400000,
      NULL, HFILL }},

    {&hf_ieee80211_he_ack_enabled_aggregation_support,
     {"Ack-Enabled Aggregation Support", "wlan.ext_tag.he_mac_cap.ack_enabled_agg_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000000800000,
      NULL, HFILL }},

    {&hf_ieee80211_he_reserved_b24,
     {"Reserved", "wlan.ext_tag.he_mac_cap.reserved_b24",
      FT_UINT48, BASE_HEX, NULL, 0x000001000000,
      NULL, HFILL }},

    {&hf_ieee80211_he_om_control_support,
     {"OM Control Support", "wlan.ext_tag.he_mac_cap.om_control_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000002000000,
      NULL, HFILL }},

    {&hf_ieee80211_he_ofdma_ra_support,
     {"OFDMA RA Support", "wlan.ext_tag.he_mac_cap.ofdma_ra_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000004000000,
      NULL, HFILL }},

    {&hf_ieee80211_he_max_a_mpdu_length_exponent_ext,
     {"Maximum A-MPDU Length Exponent Extension",
      "wlan.ext_tag.he_mac_cap.max_a_mpdu_len_exp_ext",
      FT_UINT48, BASE_DEC, NULL, 0x000018000000, NULL, HFILL }},

    {&hf_ieee80211_he_a_msdu_fragmentation_support,
     {"A-MSDU Fragmentation Support", "wlan.ext_tag.he_mac_cap.a_msdu_frag_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000020000000,
      NULL, HFILL }},

    {&hf_ieee80211_he_flexible_twt_schedule_support,
     {"Flexible TWT Schedule Support", "wlan.ext_tag.he_mac_cap.flexible_twt_sched_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000040000000,
      NULL, HFILL }},

    {&hf_ieee80211_he_rx_control_frame_to_multibss,
     {"Rx Control Frame to MultiBSS", "wlan.ext_tag.he_mac_cap.rx_ctl_frm_multibss",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000080000000,
      NULL, HFILL }},

    {&hf_ieee80211_he_bsrp_bqrp_a_mpdu_aggregation,
     {"BSRP BQRP A-MPDU Aggregation", "wlan.ext_tag.he_mac_cap.bsrp_bqrp_a_mpdu_agg",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000100000000,
      NULL, HFILL }},

    {&hf_ieee80211_he_qtp_support,
     {"QTP Support", "wlan.ext_tag.he_mac_cap.qtp_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000200000000,
      NULL, HFILL }},

    {&hf_ieee80211_he_bqr_support,
     {"BQR Support", "wlan.ext_tag.he_mac_cap.bqr_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000400000000,
      NULL, HFILL }},

    {&hf_ieee80211_he_psr_responder,
     {"PSR Responder", "wlan.ext_tag.he_mac_cap.psr_responder",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x000800000000,
      NULL, HFILL }},

    {&hf_ieee80211_he_ndp_feedback_report_support,
     {"NDP Feedback Report Support", "wlan.ext_tag.he_mac_cap.ndp_feedback_report_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x001000000000,
      NULL, HFILL }},

    {&hf_ieee80211_he_ops_support,
     {"OPS Support", "wlan.ext_tag.he_mac_cap.ops_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x002000000000,
      NULL, HFILL }},

    {&hf_ieee80211_he_a_msdu_in_a_mpdu_support,
     {"A-MSDU Not Under BA in Ack-Enabled A-MPDU Support", "wlan.ext_tag.he_mac_cap.a_msdu_in_a_mpdu_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported), 0x004000000000,
      NULL, HFILL }},

    {&hf_ieee80211_he_multi_tid_aggregation_tx_support,
     {"Multi-TID Aggregation Tx Support", "wlan.ext_tag.he_mac_cap.multi_tid_agg_tx_support",
       FT_UINT48, BASE_DEC, NULL, 0x038000000000, NULL, HFILL }},

    {&hf_ieee80211_he_subchannel_selective_trans_support,
     {"HE Subchannel Selective Transmission Support", "wlan.ext_tag.he_mac_cap.subchannel_selective_xmit_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported),
      0x040000000000, NULL, HFILL }},

    {&hf_ieee80211_he_2_996_tone_ru_support,
     {"UL 2x996-tone RU Support", "wlan.ext_tag.he_mac_cap.ul_2_996_tone_ru_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported),
      0x080000000000, NULL, HFILL }},

    {&hf_ieee80211_he_om_control_ul_mu_data_disable_rx_support,
     {"OM Control UL MU Data Disable RX Support", "wlan.ext_tag.he_mac_cap.om_cntl_ul_mu_data_disable_rx_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported),
      0x100000000000, NULL, HFILL }},

    {&hf_ieee80211_he_dynamic_sm_power_save,
     {"HE Dynamic SM Power Save", "wlan.ext_tag.he_mac_cap.dynamic_sm_power_save",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported),
      0x200000000000, NULL, HFILL }},

    {&hf_ieee80211_he_punctured_sounding_support,
     {"Punctured Sounding Support", "wlan.ext_tag.he_mac_cap.punctured_sounding_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported),
      0x400000000000, NULL, HFILL }},

    {&hf_ieee80211_he_ht_and_vht_trigger_frame_rx_support,
     {"HT And VHT Trigger Frame RX Support", "wlan.ext_tag.he_mac_cap.ht_and_vht_trigger_frame_rx_support",
      FT_BOOLEAN, 48, TFS(&tfs_supported_not_supported),
      0x800000000000, NULL, HFILL }},

    {&hf_ieee80211_he_reserved_bits_5_7,
     {"Reserved", "wlan.ext_tag.he_mac_cap.reserved_bits_5_7",
      FT_UINT48, BASE_HEX, NULL, 0x0000000000E0, NULL, HFILL }},

    {&hf_ieee80211_he_reserved_bits_8_9,
     {"Reserved", "wlan.ext_tag.he_mac_cap.reserved_bits_8_9",
      FT_UINT48, BASE_HEX, NULL, 0x000000000300, NULL, HFILL }},

    {&hf_ieee80211_he_reserved_bits_15_16,
     {"Reserved", "wlan.ext_tag.he_mac_cap.reserved_bits_15_16",
      FT_UINT48, BASE_HEX, NULL, 0x000000018000, NULL, HFILL }},

    {&hf_ieee80211_he_reserved_bit_18,
     {"Reserved", "wlan.ext_tag.he_mac_cap.reserved_bit_18",
      FT_UINT48, BASE_HEX, NULL, 0x000000040000, NULL, HFILL }},

    {&hf_ieee80211_he_reserved_bit_19,
     {"Reserved", "wlan.ext_tag.he_mac_cap.reserved_bit_19",
      FT_UINT48, BASE_HEX, NULL, 0x000000080000, NULL, HFILL }},

    {&hf_ieee80211_he_reserved_bit_25,
     {"Reserved", "wlan.ext_tag.he_mac_cap.reserved_bit_25",
      FT_UINT48, BASE_HEX, NULL, 0x000002000000, NULL, HFILL }},

    {&hf_ieee80211_he_reserved_bit_29,
       {"Reserved", "wlan.ext_tag.he_mac_cap.reserved_bit_29",
        FT_UINT48, BASE_HEX, NULL, 0x000020000000, NULL, HFILL }},

    {&hf_ieee80211_he_reserved_bit_34,
       {"Reserved", "wlan.ext_tag.he_mac_cap.reserved_bit_34",
        FT_UINT48, BASE_HEX, NULL, 0x000400000000, NULL, HFILL }},

    {&hf_ieee80211_he_phy_reserved_b0,
     {"Reserved", "wlan.ext_tag.he_phy_cap.reserved_b0",
      FT_UINT8, BASE_HEX, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_reserved_b0,
     {"Reserved", "wlan.ext_tag.he_phy_cap.fbyte.reserved_b0",
      FT_UINT8, BASE_HEX, NULL, 0x01,
      NULL, HFILL }},

    {&hf_ieee80211_he_phy_chan_width_set,
     {"Channel Width Set", "wlan.ext_tag.he_phy_cap.fbytes",
      FT_UINT8, BASE_HEX, NULL, 0xFE, NULL, HFILL }},

    {&hf_ieee80211_he_40mhz_channel_2_4ghz,
     {"40 MHz in 2.4 GHz band", "wlan.ext_tag.he_phy_cap.chan_width_set.40mhz_in_2_4ghz",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x02, NULL, HFILL }},

    {&hf_ieee80211_he_40_and_80_mhz_5ghz,
     {"40 & 80 MHz in the 5 GHz and 6 GHz bands", "wlan.ext_tag.he_phy_cap.chan_width_set.40_80_in_5ghz",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x04, NULL, HFILL }},

    {&hf_ieee80211_he_160_mhz_5ghz,
     {"160 MHz in the 5 GHz and 6 GHz bands", "wlan.ext_tag.he_phy_cap.chan_width_set.160_in_5ghz",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x08, NULL, HFILL }},

    {&hf_ieee80211_he_160_80_plus_80_mhz_5ghz,
     {"160/80+80 MHz in the 5 GHz and 6 GHz bands", "wlan.ext_tag.he_phy_cap.chan_width_set.160_80_80_in_5ghz",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x10, NULL, HFILL }},

    {&hf_ieee80211_he_242_tone_rus_in_2_4ghz,
     {"242 tone RUs in the 2.4 GHz band", "wlan.ext_tag.he_phy_cap.chan_width_set.242_tone_in_2_4ghz",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x20, NULL, HFILL }},

    {&hf_ieee80211_he_242_tone_rus_in_5ghz,
     {"242 tone RUs in the 5 GHz and 6 GHz bands", "wlan.ext_tag.he_phy_cap.chan_width_set.242_tone_in_5ghz",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x40, NULL, HFILL }},

    {&hf_ieee80211_he_chan_width_reserved,
     {"Reserved", "wlan.ext_tag.he_phy_cap.chan_width_set.reserved",
      FT_UINT8, BASE_HEX, NULL, 0x80, NULL, HFILL }},

    {&hf_ieee80211_he_phy_b8_to_b23,
     {"Bits 8 to 23", "wlan.ext_tag.he_phy_cap.bits_8_to_23",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_5ghz_b0_reserved,
     {"Reserved", "wlan.ext_tag.he_phy_cap.chan_width.set.5GHz_b0_reserved",
      FT_UINT8, BASE_HEX, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_he_5ghz_b4_reserved,
     {"Reserved", "wlan.ext_tag.he_phy_cap.chan_width.set.5GHz_b4_reserved",
      FT_UINT8, BASE_HEX, NULL, 0x20, NULL, HFILL }},

    {&hf_ieee80211_he_24ghz_b1_reserved,
     {"Reserved", "wlan.ext_tag.he_phy_cap.chan_width.set.24GHz_b1_reserved",
      FT_UINT8, BASE_HEX, NULL, 0x04, NULL, HFILL }},

    {&hf_ieee80211_he_24ghz_b2_reserved,
     {"Reserved", "wlan.ext_tag.he_phy_cap.chan_width.set.24GHz_b2_reserved",
      FT_UINT8, BASE_HEX, NULL, 0x08, NULL, HFILL }},

    {&hf_ieee80211_he_24ghz_b3_reserved,
     {"Reserved", "wlan.ext_tag.he_phy_cap.chan_width.set.24GHz_b3_reserved",
      FT_UINT8, BASE_HEX, NULL, 0x10, NULL, HFILL }},

    {&hf_ieee80211_he_24ghz_b5_reserved,
     {"Reserved", "wlan.ext_tag.he_phy_cap.chan_width.set.24GHz_b5_reserved",
      FT_UINT8, BASE_HEX, NULL, 0x40, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_punctured_preamble_rx,
     {"Punctured Preamble Rx", "wlan.ext_tag.he_phy_cap.punc_preamble_rx",
      FT_UINT16, BASE_HEX, NULL, 0x000F, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_device_class,
     {"Device Class", "wlan.ext_tag.he_phy_cap.device_class",
      FT_UINT16, BASE_HEX, VALS(he_phy_device_class_vals), 0x0010, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_ldpc_coding_in_payload,
     {"LDPC Coding In Payload", "wlan.ext_tag.he_phy_cap.ldpc_coding_in_payload",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0020, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_he_su_ppdu_1x_he_ltf_08us,
     {"HE SU PPDU With 1x HE-LTF And 0.8us GI",
      "wlan.ext_tag.he_phy_cap.he_su_ppdu_with_1x_he_ltf_08us",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0040, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_midamble_tx_rx_max_nsts,
     {"Midamble Tx/Rx Max NSTS", "wlan.ext_tag.he_phy_cap.midamble_tx_rx_max_nsts",
      FT_UINT16, BASE_HEX, VALS(he_phy_midamble_tx_rx_max_nsts_vals), 0x0180, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_ndp_with_4x_he_ltf_32us,
     {"NDP With 4x HE-LTF and 3.2us GI",
      "wlan.ext_tag.he_phy_cap.ndp_with_4x_he_ltf_4x_3.2us",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0200, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_stbc_tx_lt_80mhz,
     {"STBC Tx <= 80 MHz", "wlan.ext_tag.he_phy_cap.stbc_tx_lt_80mhz",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0400, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_stbc_rx_lt_80mhz,
     {"STBC Rx <= 80 MHz", "wlan.ext_tag.he_phy_cap.stbc_rx_lt_80mhz",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0800, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_doppler_tx,
     {"Doppler Tx", "wlan.ext_tag.he_phy_cap.doppler_tx",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x1000, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_doppler_rx,
     {"Doppler Rx", "wlan.ext_tag.he_phy_cap.doppler_rx",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x2000, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_full_bw_ul_mu_mimo,
     {"Full Bandwidth UL MU-MIMO", "wlan.ext_tag.he_phy_cap.full_bw_ul_mu_mimo",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x4000, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_partial_bw_ul_mu_mimo,
     {"Partial Bandwidth UL MU-MIMO", "wlan.ext_tag.he_phy_cap.partial_bw_ul_mu_mimo",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x8000, NULL, HFILL }},

    {&hf_ieee80211_he_phy_b24_to_b39,
     {"Bits 24 to 39", "wlan.ext_tag.he_phy_cap.bits_24_to_39",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_dcm_max_constellation_tx,
     {"DCM Max Constellation Tx", "wlan.ext_tag.he_phy_cap.dcm_max_const_tx",
      FT_UINT16, BASE_HEX, VALS(he_phy_dcm_max_constellation_vals), 0x0003, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_dcm_max_nss_tx,
     {"DCM Max NSS Tx", "wlan.ext_tag.he_phy_cap.dcm_max_nss_tx",
      FT_UINT16, BASE_HEX, VALS(he_phy_dcm_max_nss_vals), 0x0004, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_dcm_max_constellation_rx,
     {"DCM Max Constellation Rx", "wlan.ext_tag.he_phy_cap.dcm_max_const_rx",
      FT_UINT16, BASE_HEX, VALS(he_phy_dcm_max_constellation_vals), 0x0018, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_dcm_max_nss_rx,
     {"DCM Max NSS Rx", "wlan.ext_tag.he_phy_cap.dcm_max_nss_rx",
      FT_UINT16, BASE_HEX, VALS(he_phy_dcm_max_nss_vals), 0x0020, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_rx_partial_bw_su_20mhz_he_mu_ppdu,
     {"Rx Partial BW SU In 20 MHz HE MU PPDU", "wlan.ext_tag.he_phy_cap.rx_partial_bw_su_20mhz_he_mu_ppdu",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0040, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_su_beamformer,
     {"SU Beamformer", "wlan.ext_tag.he_phy_cap.su_beamformer",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0080, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_su_beamformee,
     {"SU Beamformee", "wlan.ext_tag.he_phy_cap.su_beamformee",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0100, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_mu_beamformer,
     {"MU Beamformer", "wlan.ext_tag.he_phy_cap.mu_beamformer",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0200, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_beamformee_sts_lte_80mhz,
     {"Beamformee STS <= 80 MHz", "wlan.ext_tag.he_phy_cap.beamformee_sts_lte_80mhz",
      FT_UINT16, BASE_HEX, NULL, 0x1C00, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_beamformee_sts_gt_80mhz,
     {"Beamformee STS > 80 MHz", "wlan.ext_tag.he_phy_cap.beamformee_sts_gt_80mhz",
      FT_UINT16, BASE_HEX, NULL, 0xE000, NULL, HFILL }},

    {&hf_ieee80211_he_phy_b40_to_b55,
     {"Bits 40 to 55", "wlan.ext_tag.he_phy_cap.bits_40_to_55",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_number_of_sounding_dims_lte_80,
     {"Number Of Sounding Dimensions <= 80 MHz", "wlan.ext_tag.he_phy_cap.no_sounding_dims_lte_80",
      FT_UINT16, BASE_DEC, NULL, 0x0007, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_number_of_sounding_dims_gt_80,
     {"Number Of Sounding Dimensions > 80 MHz", "wlan.ext_tag.he_phy_cap.no_sounding_dims_gt_80",
      FT_UINT16, BASE_DEC, NULL, 0x0038, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_ng_eq_16_su_fb,
     {"Ng = 16 SU Feedback", "wlan.ext_tag.he_phy_cap.ng_eq_16_su_fb",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0040, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_ng_eq_16_mu_fb,
     {"Ng = 16 MU Feedback", "wlan.ext_tag.he_phy_cap.ng_eq_16_mu_fb",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0080, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_codebook_size_eq_4_2_fb,
     {"Codebook Size SU Feedback", "wlan.ext_tag.he_phy_cap.codebook_size_su_fb",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0100, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_codebook_size_eq_7_5_fb,
     {"Codebook Size MU Feedback", "wlan.ext_tag.he_phy_cap.codebook_size_mu_fb",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0200, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_triggered_su_beamforming_fb,
     {"Triggered SU Beamforming Feedback", "wlan.ext_tag.he_phy_cap.trig_su_bf_fb",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0400, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_triggered_mu_beamforming_fb,
     {"Triggered MU Beamforming Feedback", "wlan.ext_tag.he_phy_cap.trig_mu_bf_fb",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0800, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_triggered_cqi_fb,
     {"Triggered CQI Feedback", "wlan.ext_tag.he_phy_cap.trig_cqi_fb",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x1000, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_partial_bw_extended_range,
     {"Partial Bandwidth Extended Range", "wlan.ext_tag.he_phy_cap.partial_bw_er",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x2000, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_partial_bw_dl_mu_mimo,
     {"Partial Bandwidth DL MU-MIMO", "wlan.ext_tag.he_phy_cap.partial_bw_dl_mu_mimo",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x4000, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_ppe_threshold_present,
     {"PPE Thresholds Present", "wlan.ext_tag.he_phy_cap.ppe_thres_present",
      FT_BOOLEAN, 16, NULL, 0x8000, NULL, HFILL }},

    {&hf_ieee80211_he_phy_b56_to_b71,
     {"Bits 56 to 71", "wlan.ext_tag.he_phy_cap.bits_56_to_71",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_psr_based_sr_support,
     {"PSR-based SR Support", "wlan.ext_tag.he_phy_cap.psr_based_sr_sup",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0001, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_power_boost_factor_ar_support,
     {"Power Boost Factor ar Support", "wlan.ext_tag.he_phy_cap.pwr_bst_factor_ar_sup",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0002, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_he_su_ppdu_etc_gi,
     {"HE SU PPDU And HE MU PPDU With 4x HE-LTF And 0.8us GI", "wlan.ext_tag.he_phy_cap.he_su_ppdu_etc_gi",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0004, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_max_nc,
     {"Max Nc", "wlan.ext_tag.he_phy_cap.max_nc",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0038, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_stbc_tx_gt_80_mhz,
     {"STBC Tx > 80 MHz", "wlan.ext_tag.he_phy_cap.stbc_tx_gt_80_mhz",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0040, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_stbc_rx_gt_80_mhz,
     {"STBC Rx > 80 MHz", "wlan.ext_tag.he_phy_cap.stbc_rx_gt_80_mhz",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0080, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_he_er_su_ppdu_4xxx_gi,
     {"HE ER SU PPDU With 4x HE-LTF And 0.8us GI", "wlan.ext_tag.he_phy_cap.he_er_su_ppdu_4xxx_gi",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0100, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_20mhz_in_40mhz_24ghz_band,
     {"20 MHz In 40 MHz HE PPDU In 2.4 GHz Band", "wlan.ext_tag.he_phy_cap.20_mhz_in_40_in_2_4ghz",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0200, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_20mhz_in_160_80p80_ppdu,
     {"20 MHz In 160/80+80 MHz HE PPDU", "wlan.ext_tag.he_phy_cap.20_mhz_in_160_80p80_ppdu",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0400, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_80mgz_in_160_80p80_ppdu,
     {"80 MHz In 160/80+80 MHz HE PPDU", "wlan.ext_tag.he_phy_cap.80_mhz_in_160_80p80_ppdu",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0800, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_he_er_su_ppdu_1xxx_gi,
     {"HE ER SU PPDU With 1x HE-LTF And 0.8us GI", "wlan.ext_tag.he_phy_cap.he_er_su_ppdu_1xxx_gi",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x1000, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_midamble_tx_rx_2x_xxx_ltf,
     {"Midamble Tx/Rx 2x And 1x HE-LTF", "wlan.ext_tag.he_phy_cap.midamble_tx_rx_2x_1x_he_ltf",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x2000, NULL, HFILL }},

    {&hf_ieee80211_he_phy_b72_to_b87,
     {"Bits 72 to 87", "wlan.ext_tag.he_phy_cap.bits_72_to_87",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_dcm_max_ru,
     {"DCM Max RU", "wlan.ext_tag.he_phy_cap.dcm_max_ru",
      FT_UINT16, BASE_HEX, VALS(he_phy_dcm_max_ru_vals), 0xC000, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_longer_than_16_he_sigb_ofdm_symbol_support,
     {"Longer Than 16 HE SIG-B OFDM Symbols Support", "wlan.ext_tag.he_phy_cap.longer_than_16_he_sigb_ofdm_sym_support",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0001, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_non_triggered_cqi_feedback,
     {"Non-Triggered CQI Feedback", "wlan.ext_tag.he_phy_cap.non_triggered_feedback",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0002, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_tx_1024_qam_242_tone_ru_support,
     {"Tx 1024-QAM Support < 242-tone RU Support", "wlan.ext_tag.he_phy_cap.tx_1024_qam_support_lt_242_tone_ru",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0004, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_rx_1024_qam_242_tone_ru_support,
     {"Rx 1024-QAM Support < 242-tone RU Support", "wlan.ext_tag.he_phy_cap.rx_1024_qam_support_lt_242_tone_ru",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0008, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_rx_full_bw_su_using_he_muppdu_w_compressed_sigb,
     {"Rx Full BW SU Using HE MU PPDU With Compressed HE-SIG-B", "wlan.ext_tag.he_phy_cap.rx_full_bw_su_using_he_mu_ppdu_with_compressed_sigb",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0010, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_rx_full_bw_su_using_he_muppdu_w_non_compressed_sigb,
     {"Rx Full BW SU Using HE MU PPDU With Non-Compressed HE-SIG-B", "wlan.ext_tag.he_phy_cap.rx_full_bw_su_using_he_mu_ppdu_with_non_compressed_sigb",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0020, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_nominal_packet_padding,
     {"Nominal Packet Padding", "wlan.ext_tag.he_phy_cap.nominal_packet_padding",
      FT_UINT16, BASE_DEC, VALS(he_phy_nominal_packet_padding_vals), 0x00C0, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_he_mu_ppdu_ru_rx_max,
     {"HE MU PPDU With More Than One RU Rx Max N_HE-LTF", "wlan.ext_tag.he_phy_cap.he_mu_ppdu_ru_rx_max",
      FT_UINT16, BASE_DEC, NULL, 0x0100, NULL, HFILL }},

    {&hf_ieee80211_he_phy_cap_b81_b87_reserved,
     {"Reserved", "wlan.ext_tag.he_phy_cap.reserved_b81_b87",
      FT_UINT16, BASE_HEX, NULL, 0xFE00, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80_rx_1_ss,
     {"Max HE-MCS for 1 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80_rx_1_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0003, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80_rx_2_ss,
     {"Max HE-MCS for 2 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80_rx_2_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x000C, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80_rx_3_ss,
     {"Max HE-MCS for 3 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80_rx_3_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0030, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80_rx_4_ss,
     {"Max HE-MCS for 4 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80_rx_4_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x00C0, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80_rx_5_ss,
     {"Max HE-MCS for 5 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80_rx_5_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0300, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80_rx_6_ss,
     {"Max HE-MCS for 6 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80_rx_6_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0C00, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80_rx_7_ss,
     {"Max HE-MCS for 7 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80_rx_7_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x3000, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80_rx_8_ss,
     {"Max HE-MCS for 8 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80_rx_8_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0xC000, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80_tx_1_ss,
     {"Max HE-MCS for 1 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80_tx_1_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0003, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80_tx_2_ss,
     {"Max HE-MCS for 2 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80_tx_2_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x000C, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80_tx_3_ss,
     {"Max HE-MCS for 3 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80_tx_3_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0030, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80_tx_4_ss,
     {"Max HE-MCS for 4 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80_tx_4_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x00C0, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80_tx_5_ss,
     {"Max HE-MCS for 5 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80_tx_5_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0300, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80_tx_6_ss,
     {"Max HE-MCS for 6 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80_tx_6_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0C00, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80_tx_7_ss,
     {"Max HE-MCS for 7 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80_tx_7_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x3000, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80_tx_8_ss,
     {"Max HE-MCS for 8 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80_tx_8_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0xC000, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_1_ss,
     {"Max HE-MCS for 1 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80p80_rx_1_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0003, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_2_ss,
     {"Max HE-MCS for 2 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80p80_rx_2_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x000C, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_3_ss,
     {"Max HE-MCS for 3 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80p80_rx_3_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0030, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_4_ss,
     {"Max HE-MCS for 4 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80p80_rx_4_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x00C0, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_5_ss,
     {"Max HE-MCS for 5 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80p80_rx_5_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0300, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_6_ss,
     {"Max HE-MCS for 6 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80p80_rx_6_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0C00, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_7_ss,
     {"Max HE-MCS for 7 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80p80_rx_7_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x3000, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80p80_rx_8_ss,
     {"Max HE-MCS for 8 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80p80_rx_8_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0xC000, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_1_ss,
     {"Max HE-MCS for 1 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80p80_tx_1_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0003, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_2_ss,
     {"Max HE-MCS for 2 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80p80_tx_2_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x000C, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_3_ss,
     {"Max HE-MCS for 3 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80p80_tx_3_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0030, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_4_ss,
     {"Max HE-MCS for 4 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80p80_tx_4_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x00C0, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_5_ss,
     {"Max HE-MCS for 5 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80p80_tx_5_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0300, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_6_ss,
     {"Max HE-MCS for 6 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80p80_tx_6_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0C00, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_7_ss,
     {"Max HE-MCS for 7 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80p80_tx_7_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x3000, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_80p80_tx_8_ss,
     {"Max HE-MCS for 8 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_80p80_tx_8_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0xC000, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_160_rx_1_ss,
     {"Max HE-MCS for 1 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_160_rx_1_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0003, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_160_rx_2_ss,
     {"Max HE-MCS for 2 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_160_rx_2_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x000C, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_160_rx_3_ss,
     {"Max HE-MCS for 3 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_160_rx_3_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0030, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_160_rx_4_ss,
     {"Max HE-MCS for 4 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_160_rx_4_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x00C0, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_160_rx_5_ss,
     {"Max HE-MCS for 5 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_160_rx_5_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0300, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_160_rx_6_ss,
     {"Max HE-MCS for 6 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_160_rx_6_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0C00, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_160_rx_7_ss,
     {"Max HE-MCS for 7 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_160_rx_7_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x3000, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_160_rx_8_ss,
     {"Max HE-MCS for 8 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_160_rx_8_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0xC000, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_160_tx_1_ss,
     {"Max HE-MCS for 1 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_160_tx_1_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0003, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_160_tx_2_ss,
     {"Max HE-MCS for 2 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_160_tx_2_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x000C, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_160_tx_3_ss,
     {"Max HE-MCS for 3 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_160_tx_3_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0030, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_160_tx_4_ss,
     {"Max HE-MCS for 4 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_160_tx_4_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x00C0, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_160_tx_5_ss,
     {"Max HE-MCS for 5 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_160_tx_5_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0300, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_160_tx_6_ss,
     {"Max HE-MCS for 6 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_160_tx_6_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x0C00, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_160_tx_7_ss,
     {"Max HE-MCS for 7 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_160_tx_7_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0x3000, NULL, HFILL }},

    {&hf_ieee80211_he_mcs_max_he_mcs_160_tx_8_ss,
     {"Max HE-MCS for 8 SS", "wlan.ext_tag.he_mcs_map.max_he_mcs_160_tx_8_ss",
      FT_UINT16, BASE_HEX, VALS(he_mcs_map_vals), 0xC000, NULL, HFILL }},

    {&hf_ieee80211_he_rx_he_mcs_map_lte_80,
     {"Rx HE-MCS Map <= 80 MHz", "wlan.ext_tag.he_mcs_map.rx_he_mcs_map_lte_80",
     FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_tx_he_mcs_map_lte_80,
     {"Tx HE-MCS Map <= 80 MHz", "wlan.ext_tag.he_mcs_map.tx_he_mcs_map_lte_80",
     FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_rx_he_mcs_map_160,
     {"Rx HE-MCS Map 160 MHz", "wlan.ext_tag.he_mcs_map.rx_he_mcs_map_160",
     FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_tx_he_mcs_map_160,
     {"Tx HE-MCS Map 160 MHz", "wlan.ext_tag.he_mcs_map.tx_he_mcs_map_160",
     FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_rx_he_mcs_map_80_80,
     {"Rx HE-MCS Map 80+80 MHz", "wlan.ext_tag.he_mcs_map.rx_he_mcs_map_80_80",
     FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_tx_he_mcs_map_80_80,
     {"Tx HE-MCS Map 80+80 MHz", "wlan.ext_tag.he_mcs_map.tx_he_mcs_map_80_80",
     FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_ppe_thresholds_nss,
     {"NSS", "wlan.ext_tag.he_ppe_thresholds.nss",
      FT_UINT8, BASE_DEC, NULL, 0x07, NULL, HFILL }},

    {&hf_ieee80211_he_ppe_thresholds_ru_index_bitmask,
     {"RU Index Bitmask", "wlan.ext_tag.he_ppe_thresholds.ru_index_bitmask",
      FT_UINT8, BASE_HEX, NULL, 0x78, NULL, HFILL }},

    {&hf_ieee80211_he_ppe_ppet16,
     {"PPET16","wlan.ext_tag.he_ppe_thresholds.ppet16",
      FT_UINT8, BASE_HEX, VALS(constellation_vals), 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_ppe_ppet8,
     {"PPET8","wlan.ext_tag.he_ppe_thresholds.ppet8",
      FT_UINT8, BASE_HEX, VALS(constellation_vals), 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_operation_parameter,
     {"HE Operation Parameters", "wlan.ext_tag.he_operation.params",
      FT_UINT24, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_operation_default_pe_duration,
     {"Default PE Duration", "wlan.ext_tag.he_operation.default_pe_duration",
      FT_UINT24, BASE_DEC, NULL, 0x000007, NULL, HFILL }},

    {&hf_ieee80211_he_operation_twt_required,
     {"TWT Required", "wlan.ext_tag.he_operation.twt_required",
      FT_BOOLEAN, 24, TFS(&tfs_required_not_required), 0x000008, NULL, HFILL }},

    {&hf_ieee80211_he_operation_txop_duration_rts_threshold,
     {"TXOP Duration RTS Threshold", "wlan.ext_tag.he_operation.txop_duration_rts_thresh",
      FT_UINT24, BASE_DEC, NULL, 0x003FF0, NULL, HFILL }},

    {&hf_ieee80211_he_operation_vht_operation_information_present,
     {"VHT Operation Information Present", "wlan.ext_tag.he_operation.vht_op_info_present",
      FT_BOOLEAN, 24, NULL, 0x004000, NULL, HFILL }},

    {&hf_ieee80211_he_operation_co_hosted_bss,
     {"Co-Hosted BSS", "wlan.ext_tag.he_operation.co_hosted_bss",
      FT_BOOLEAN, 24, NULL, 0x008000, NULL, HFILL }},

    {&hf_ieee80211_he_operation_er_su_disable,
     {"ER SU Disable", "wlan.ext_tag.he_operation.er_su_disable",
      FT_BOOLEAN, 24, NULL, 0x010000, NULL, HFILL }},

    {&hf_ieee80211_he_operation_6ghz_operation_information_present,
     {"6 GHz Operation Information Present", "wlan.ext_tag.he_operation.6ghz_operation_information_present",
      FT_BOOLEAN, 24, NULL, 0x020000, NULL, HFILL }},

    {&hf_ieee80211_he_operation_reserved_b16_b23,
     {"Reserved", "wlan.ext_tag.he_operation.reserved_b16_b32",
      FT_UINT24, BASE_HEX, NULL, 0xFC0000, NULL, HFILL }},

    {&hf_ieee80211_he_bss_color_information,
     {"BSS Color Information", "wlan.ext_tag.bss_color_information",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_bss_color_info_bss_color,
     {"BSS Color", "wlan.ext_tag.bss_color_information.bss_color",
      FT_UINT8, BASE_HEX, NULL, 0x3F, NULL, HFILL }},

    {&hf_ieee80211_he_bss_color_partial_bss_color,
     {"Partial BSS Color", "wlan.ext_tag.bss_color_information.partial_bss_color",
      FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},

    {&hf_ieee80211_he_bss_color_bss_color_disabled,
     {"BSS Color Disabled", "wlan.ext_tag.bss_color_information.bss_color_disabled",
      FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},

    {&hf_ieee80211_he_operation_basic_mcs,
     {"Basic HE-MCS and NSS Set", "wlan.ext_tag.he_operation.basic_he_mcs_and_nss",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_oper_max_he_mcs_for_1_ss,
     {"Max HE-MCS for 1 SS", "wlan.ext_tag.he_operation.max_he_mcs_for_1_ss",
      FT_UINT16, BASE_DEC, VALS(he_mcs_map_vals), 0x0003, NULL, HFILL }},

    {&hf_ieee80211_he_oper_max_he_mcs_for_2_ss,
     {"Max HE-MCS for 2 SS", "wlan.ext_tag.he_operation.max_he_mcs_for_2_ss",
      FT_UINT16, BASE_DEC, VALS(he_mcs_map_vals), 0x000C, NULL, HFILL }},

    {&hf_ieee80211_he_oper_max_he_mcs_for_3_ss,
     {"Max HE-MCS for 3 SS", "wlan.ext_tag.he_operation.max_he_mcs_for_3_ss",
      FT_UINT16, BASE_DEC, VALS(he_mcs_map_vals), 0x0030, NULL, HFILL }},

    {&hf_ieee80211_he_oper_max_he_mcs_for_4_ss,
     {"Max HE-MCS for 4 SS", "wlan.ext_tag.he_operation.max_he_mcs_for_4_ss",
      FT_UINT16, BASE_DEC, VALS(he_mcs_map_vals), 0x00C0, NULL, HFILL }},

    {&hf_ieee80211_he_oper_max_he_mcs_for_5_ss,
     {"Max HE-MCS for 5 SS", "wlan.ext_tag.he_operation.max_he_mcs_for_5_ss",
      FT_UINT16, BASE_DEC, VALS(he_mcs_map_vals), 0x0300, NULL, HFILL }},

    {&hf_ieee80211_he_oper_max_he_mcs_for_6_ss,
     {"Max HE-MCS for 6 SS", "wlan.ext_tag.he_operation.max_he_mcs_for_6_ss",
      FT_UINT16, BASE_DEC, VALS(he_mcs_map_vals), 0x0C00, NULL, HFILL }},

    {&hf_ieee80211_he_oper_max_he_mcs_for_7_ss,
     {"Max HE-MCS for 7 SS", "wlan.ext_tag.he_operation.max_he_mcs_for_7_ss",
      FT_UINT16, BASE_DEC, VALS(he_mcs_map_vals), 0x3000, NULL, HFILL }},

    {&hf_ieee80211_he_oper_max_he_mcs_for_8_ss,
     {"Max HE-MCS for 8 SS", "wlan.ext_tag.he_operation.max_he_mcs_for_8_ss",
      FT_UINT16, BASE_DEC, VALS(he_mcs_map_vals), 0xC000, NULL, HFILL }},

    {&hf_ieee80211_he_operation_channel_width,
     {"Channel Width", "wlan.ext_tag.he_operation.vht_op_info.channel_width",
      FT_UINT8, BASE_DEC, VALS(channel_width_vals), 0, NULL, HFILL }},

    {&hf_ieee80211_he_operation_channel_center_freq_0,
     {"Channel Center Frequency Segment 0", "wlan.ext_tag.he_operation.vht_op_info.chan_center_freq_seg_0",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_operation_channel_center_freq_1,
     {"Channel Center Frequency Segment 1", "wlan.ext_tag.he_operation.vht_op_info.chan_center_freq_seg_1",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_operation_max_co_hosted_bssid_indicator,
     {"Max Co-Hosted BSSID Indicator", "wlan.ext_tag.he_operation.max_co_hosted_bssid_indicator",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_operation_6ghz_primary_channel,
     {"Primary Channel", "wlan.ext_tag.he_operation.6ghz.primary_channel",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_operation_6ghz_control,
     {"Control", "wlan.ext_tag.he_operation.6ghz.control",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_operation_6ghz_control_channel_width,
     {"Channel Width", "wlan.ext_tag.he_operation.6ghz.control.channel_width",
      FT_UINT8, BASE_DEC, VALS(operating_mode_field_channel_width), 0x03, NULL, HFILL }},

    {&hf_ieee80211_he_operation_6ghz_control_duplicate_beacon,
     {"Duplicate Beacon", "wlan.ext_tag.he_operation.6ghz.control.duplicate_beacon",
      FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},

    {&hf_ieee80211_he_operation_6ghz_control_regulatory_info,
     {"Regulatory Info", "wlan.ext_tag.he_operation.6ghz.control.regulatory_info",
      FT_UINT8, BASE_DEC, NULL, 0x38, NULL, HFILL }},

    {&hf_ieee80211_he_operation_6ghz_control_reserved,
     {"Reserved", "wlan.ext_tag.he_operation.6ghz.control.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xC0, NULL, HFILL }},

    {&hf_ieee80211_he_operation_6ghz_channel_center_freq_0,
     {"Channel Center Frequency Segment 0", "wlan.ext_tag.he_operation.6ghz.chan_center_freq_seg_0",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_operation_6ghz_channel_center_freq_1,
     {"Channel Center Frequency Segment 1", "wlan.ext_tag.he_operation.6ghz.chan_center_freq_seg_1",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_operation_6ghz_minimum_rate,
     {"Minimum Rate", "wlan.ext_tag.he_operation.6ghz.minimum_rate",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_muac_aci_aifsn,
     {"AIC/AIFSN","wlan.ext_tag.mu_edca_parameter_set.aic_aifsn",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_muac_aifsn,
     {"AIFSN", "wlan.ext_tag.mu_edca_parameter_set.aifsn",
      FT_UINT8, BASE_DEC, NULL, 0x0F,
      NULL, HFILL }},

    {&hf_ieee80211_he_muac_acm,
     {"Admission Control Mandatory", "wlan.ext_tag.mu_edca_parameter_set.acm",
      FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x10,
      NULL, HFILL }},

    {&hf_ieee80211_he_muac_aci,
     {"ACI", "wlan.ext_tag.mu_edca_parameter_set.aci",
      FT_UINT8, BASE_DEC, VALS(ieee80211_wfa_ie_wme_acs_vals), 0x60,
      NULL, HFILL }},

    {&hf_ieee80211_he_muac_reserved,
     {"Reserved", "wlan.ext_tag.mu_edca_parameter_set.reserved",
      FT_UINT8, BASE_DEC, NULL, 0x80,
      "Must be Zero", HFILL }},

    {&hf_ieee80211_he_mu_edca_timer,
     {"MU EDCA Timer","wlan.ext_tag.mu_edca_parameter_set.mu_edca_timer",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_muac_ecwmin_ecwmax,
     {"ECWmin/ECWmax","wlan.ext_tag.mu_edca_parameter_set.ecwmin_ecwmax",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_spatial_reuse_sr_control,
     {"SR Control", "wlan.ext_tag.spatial_reuse.sr_control",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_srp_disallowed,
     {"SRP Disallowed", "wlan.ext_tag.spatial_reuse.sr_control.srp_dis",
      FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_he_non_srg_obss_pd_sr_disallowed,
     {"NON-SRG OBSS PD SR Disallowed", "wlan.ext_tag.spatial_reuse.sr_control.non_srg_obss_pd_sr_dis",
      FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_he_non_srg_offset_present,
     {"Non-SRG Offset Present", "wlan.ext_tag.spatial_reuse.sr_control.non_srg_ofs_present",
      FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},

    {&hf_ieee80211_he_srg_information_present,
     {"SRG Information Present", "wlan.ext_tag.spatial_reuse.sr_control.srg_info_present",
     FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},

    {&hf_ieee80211_he_hesiga_spatial_reuse_value15_allowed,
     {"HESIGA Spatial Reuse value 15 allowed", "wlan.ext_tag.spatial_reuse.sr_control.hesiga_val_15_allowed",
      FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},

    {&hf_ieee80211_he_sr_control_reserved,
     {"Reserved", "wlan.ext_tag.spatial_reuse.sr_control.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xE0, NULL, HFILL }},

    {&hf_ieee80211_he_spatial_non_srg_obss_pd_max_offset,
     {"Non-SRG OBSS PD Max Offset", "wlan.ext_tag.spatial_reuse.non_srg_obss_pd_max_offset",
      FT_INT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_spatial_srg_obss_pd_min_offset,
     {"SRG OBSS PD Min Offset", "wlan.ext_tag.spatial_reuse.srg_obss_pd_min_offset",
      FT_INT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_spatial_srg_obss_pd_max_offset,
     {"SRG OBSS PD Max Offset", "wlan.ext_tag.spatial_reuse.srg_obss_pd_max_offset",
      FT_INT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_spatial_srg_bss_color_bitmap,
     {"SRG BSS Color Bitmap", "wlan.ext_tag.spatial_reuse.srg_bss_color_bitmap",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_spatial_srg_partial_bssid_bitmap,
     {"SRG Partial BSSID Bitmap", "wlan.ext_tag.spatial_reuse.srg_partial_bssid_bitmap",
      FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_resource_request_buffer_thresh,
     {"Resource Request Buffer Threshold Exponent", "wlan.ext_tag.ndp_feedback.res_req_buf_thresh_exp",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_bss_color_change_new_color_info,
     {"New BSS Color Info", "wlan.ext_tag.bss_color_change.new_color_info",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_new_bss_color_info_color,
     {"New BSS Color", "wlan.ext_tag.bss_color_change.new_bss_color",
      FT_UINT8, BASE_HEX, NULL, 0x3F, NULL, HFILL }},

    {&hf_ieee80211_he_new_bss_color_info_reserved,
     {"Reserved", "wlan.ext_tag.bss_color_change.new_color_reserved",
      FT_UINT8, BASE_HEX, NULL, 0xC0, NULL, HFILL }},

    {&hf_ieee80211_he_bss_color_change_switch_countdown,
     {"BSS Color Switch Countdown", "wlan.ext_tag.bss_color_change.color_switch_countdown",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_ess_report_planned_ess,
     {"Planned ESS", "wlan.ext_tag.ess_report.ess_info.planned_ess",
      FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_he_ess_report_edge_of_ess,
     {"Edge of ESS", "wlan.ext_tag.ess_report.ess_info.edge_of_ess",
      FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_he_ess_report_info_field,
     {"ESS Information field", "wlan.ext_tag.ess_report.ess_info.field",
     FT_UINT8, BASE_HEX, NULL, 0x03, NULL, HFILL }},

    {&hf_ieee80211_he_ess_report_recommend_transition_thresh,
     {"Recommended BSS Transition Threshold", "wlan.ext_tag.ess_report.ess_info.thresh",
     FT_INT8, BASE_DEC, NULL, 0xFC, NULL, HFILL }},

    {&hf_ieee80211_he_ops_duration,
     {"OPS Duration", "wlan.ext_tag.ops.ops_duration",
      FT_UINT8, BASE_DEC|BASE_UNIT_STRING, UNS(&units_ms), 0x0, NULL, HFILL }},

    {&hf_ieee80211_he_uora_field,
     {"UL OFDMA-based Random Access Parameter SET", "wlan.ext_tag.uora_parameter_set.field",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_he_uora_eocwmin,
     {"EOCWmin", "wlan.ext_tag.uora_parameter_set.eocwmin",
      FT_UINT8, BASE_DEC, NULL, 0x07, NULL, HFILL }},

    {&hf_ieee80211_he_uora_owcwmax,
     {"EOCWmax", "wlan.ext_tag.uora_parameter_set.eocwmax",
      FT_UINT8, BASE_DEC, NULL, 0x38, NULL, HFILL }},

    {&hf_ieee80211_he_uora_reserved,
     {"Reserved", "wlan.ext_tag.uora_parameter_set.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xC0, NULL, HFILL }},

    {&hf_ieee80211_max_channel_switch_time,
     {"Max Channel Switch Time",
      "wlan.ext_tag.max_channel_switch_time.switch_time",
      FT_UINT24, BASE_DEC|BASE_UNIT_STRING, UNS(&units_tu_tus), 0x0, NULL, HFILL }},

    {&hf_ieee80211_oci_operating_class,
     {"Operating Class", "wlan.ext_tag.oci.operating_class",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_oci_primary_channel_number,
     {"Primary Channel Number", "wlan.ext_tag.oci.primary_channel_number",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_oci_frequency_segment_1,
     {"Frequency Segment 1 Channel Number",
      "wlan.ext_tag.oci.frequency_segment_1_channel_number",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_oci_oct_operating_class,
     {"OCT Operating Class", "wlan.ext_tag.oci.oct_operating_class",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_oci_oct_primary_channel_number,
     {"OCT Primary Channel Number",
      "wlan.ext_tag.oci.oct_primary_channel_number",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_oci_oct_frequency_segment_1,
     {"OCT Frequency Segment 1 Channel Number",
      "wlan.ext_tag.oci.oct_frequency_segment_1_channel_number",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_multiple_bssid_configuration_bssid_count,
     {"BSSID Count", "wlan.ext_tag.multiple_bssid_configuration.bssid_count",
     FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_non_inheritance_element_id_list_length,
     {"Length", "wlan.ext_tag.non_inheritance.element_id_list.length",
     FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_non_inheritance_element_id_list_element_id,
     {"Element ID", "wlan.ext_tag.non_inheritance.element_id_list.element_id",
     FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_non_inheritance_element_id_ext_list_length,
     {"Length", "wlan.ext_tag.non_inheritance.element_id_ext_list.length",
     FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_non_inheritance_element_id_ext_list_element_id_ext,
     {"Element ID Extension", "wlan.ext_tag.non_inheritance.element_id_ext_list.element_id_ext",
     FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_multiple_bssid_configuration_full_set_rx_periodicity,
     {"Full Set Rx Periodicity", "wlan.ext_tag.multiple_bssid_configuration.full_set_rx_periodicity",
     FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_known_bssid_bitmap,
     {"Bitmap", "wlan.ext_tag.known_bssid.bitmap",
     FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_short_ssid,
     {"Short SSID", "wlan.ext_tag.short_ssid",
     FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_rejected_groups_group,
     {"Rejected Finite Cyclic Group", "wlan.ext_tag.rejected_groups.group",
      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_ff_s1g_action,
      {"S1G Action", "wlan.s1g.action",
       FT_UINT8, BASE_DEC, VALS(s1g_action_vals), 0, NULL, HFILL }},

    {&hf_ieee80211_ff_prot_s1g_action,
      {"Protected S1G Action", "wlan.s1g.prot_action",
       FT_UINT8, BASE_DEC, VALS(prot_s1g_action_vals), 0, NULL, HFILL }},

    {&hf_ieee80211_ff_s1g_timestamp,
     {"Timestamp", "wlan.s1g.timestamp",
      FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_ff_s1g_change_sequence,
     {"Change Sequence", "wlan.s1g.change_sequence",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_ff_s1g_next_tbtt,
     {"Next TBTT", "wlan.s1g.next_tbtt",
      FT_UINT24, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_ff_s1g_compressed_ssid,
     {"Compressed SSID", "wlan.s1g.compressed_ssid",
      FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_ff_s1g_access_network_options,
     {"Access Network Options", "wlan.s1g.access_network_options",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_s1g_sync_control,
     {"Sync Control", "wlan.s1g.sync_control",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_sync_control_uplink_sync_request,
     {"Uplink Sync Request", "wlan.s1g.sync_control.uplink_sync_request",
      FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_s1g_sync_control_time_slot_protection_request,
     {"Time Slot Protection request",
      "wlan.s1g.sync_control.time_slot_protection_request",
      FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_s1g_sync_control_reserved,
     {"Reserved", "wlan.s1g.sync_control.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xFC, NULL, HFILL }},

    {&hf_ieee80211_s1g_sector_id_index,
     {"Sector ID Index", "wlan.s1g.sector_id_index",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_sector_id_preferred_sector_id,
     {"Preferred Sector ID", "wlan.s1g.sector_id_index.preferred_sector_id",
      FT_UINT16, BASE_DEC, NULL, 0x0007, NULL, HFILL }},

    {&hf_ieee80211_s1g_sector_id_snr,
     {"SNR", "wlan.s1g.sector_id_index.snr",
      FT_UINT16, BASE_CUSTOM, CF_FUNC(s1g_sector_id_index_snr_custom),
      0x00F8, NULL, HFILL }},

    {&hf_ieee80211_s1g_sector_id_receive_sector_bitmap,
     {"Receive Sector Bitmap", "wlan.s1g.sector_id_index.receive_sector_bitmap",
      FT_UINT16, BASE_HEX, NULL, 0xFF00, NULL, HFILL }},

    {&hf_ieee80211_s1g_twt_information_control,
     {"TWT Information Control", "wlan.s1g.twt_information.control",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_twt_next_twt_32,
     {"Next TWT", "wlan.s1g.twt_information.next_twt32",
      FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_twt_next_twt_48,
     {"Next TWT", "wlan.s1g.twt_information.next_twt48",
      FT_UINT48, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_twt_next_twt_64,
     {"Next TWT", "wlan.s1g.twt_information.next_twt64",
      FT_UINT64, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_twt_flow_identifier,
     {"TWT Flow Identifier",
      "wlan.s1g.twt_information.control.twt_flow_identifier",
      FT_UINT8, BASE_DEC, NULL, 0x07, NULL, HFILL }},

    {&hf_ieee80211_s1g_twt_response_required,
     {"Response Requested",
      "wlan.s1g.twt_information.control.response_requested",
     FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},

    {&hf_ieee80211_s1g_twt_next_twt_request,
     {"Next TWT Request", "wlan.s1g.twt_information.control.next_twt_request",
      FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},

    {&hf_ieee80211_s1g_twt_next_twt_subfield_size,
     {"Next TWT Subfield Size",
      "wlan.s1g.twt_information.control.next_twt_subfield_size",
      FT_UINT8, BASE_HEX, NULL, 0x60, NULL, HFILL }},

    {&hf_ieee80211_s1g_twt_reserved,
     {"Reserved", "wlan.s1g.twt_information.control.reserved",
      FT_UINT8, BASE_HEX, NULL, 0x80, NULL, HFILL }},

    {&hf_ieee80211_s1g_update_edca_info,
     {"Update EDCA Info", "wlan.s1g.edca_param_set.update_edca_info",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_s1g_update_edca_override,
     {"Override", "wlan.s1g.edca_param_set.update_edca_info.override",
      FT_BOOLEAN, 8, NULL, 0x01,
      "Overrides the previously stored EDCAL parameters", HFILL }},

    {&hf_ieee80211_s1g_update_edca_ps_poll_aci,
     {"PS-Poll ACI", "wlan.s1g.edca_param_set.update_edca_info.pd_poll_aci",
      FT_UINT8, BASE_HEX, NULL, 0x06, NULL, HFILL }},

    {&hf_ieee80211_s1g_update_edca_raw_aci,
     {"RAW ACI", "wlan.s1g.edca_param_set.update_edca_info.raw_aci",
      FT_UINT8, BASE_HEX, NULL, 0x18, NULL, HFILL }},

    {&hf_ieee80211_s1g_update_edca_sta_type,
     {"STA Type", "wlan.s1g.edca_param_set.update_edca_info.sta_type",
      FT_UINT8, BASE_HEX, VALS(sta_field_type_vals), 0x60, NULL, HFILL }},

    {&hf_ieee80211_s1g_update_edca_reserved,
     {"Reserved", "wlan.s1g.edca_param_set.update_edca_info.reserved",
     FT_UINT8, BASE_HEX, NULL, 0x80, NULL, HFILL }},

    {&hf_ieee80211_twt_bcast_flow,
      {"TWT Flow", "wlan.twt.bcast_flow",
       FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_twt_individual_flow,
      {"TWT Flow", "wlan.twt.individual_flow",
       FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_twt_individual_flow_id,
      {"Individual TWT Flow Id", "wlan.twt.individual_flow_id",
       FT_UINT8, BASE_DEC, NULL, 0x7, NULL, HFILL }},

    {&hf_ieee80211_twt_individual_reserved,
     {"Reserved", "wlan.twt.individual_reserved",
      FT_UINT8, BASE_HEX, NULL, 0x18, NULL, HFILL }},

    {&hf_ieee80211_twt_bcast_id,
      {"Broadcast TWT Id", "wlan.twt.bcast_flow_id",
       FT_UINT8, BASE_DEC, NULL, 0x1f, NULL, HFILL }},

    {&hf_ieee80211_twt_neg_type,
      {"TWT Negotiation type", "wlan.twt.neg_type",
       FT_UINT8, BASE_DEC, VALS(twt_neg_type_vals), 0x60,
       NULL, HFILL }},

    {&hf_ieee80211_twt_neg_type2_reserved1,
     {"Reserved", "wlan.twt.flow_id_reserved1",
      FT_UINT8, BASE_HEX, NULL, 0x1f, NULL, HFILL }},

    {&hf_ieee80211_twt_neg_type2_reserved2,
     {"Reserved", "wlan.twt.flow_id_reserved2",
      FT_UINT8, BASE_HEX, NULL, 0x80, NULL, HFILL }},

    {&hf_ieee80211_twt_bcast_teardown_all,
     {"TWT Flow", "wlan.twt.bcast_flow",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_twt_bcast_twt_id_reserved,
     {"Reserved", "wlan.twt.bcast_flow.twt_id_reserved",
      FT_UINT8, BASE_HEX, NULL, 0x1F, NULL, HFILL }},

    {&hf_ieee80211_twt_bcast_neg_type_reserved,
     {"Reserved", "wlan.twt.bcast_flow.negotiation_type_reserved",
      FT_UINT8, BASE_HEX, NULL, 0x60, NULL, HFILL }},

    {&hf_ieee80211_twt_bcast_teardown_all_twt,
     {"Teardown All TWT", "wlan.twt.bcast_flow.teardown_all_twt",
      FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_control_field,
      {"Control Field", "wlan.twt.control_field",
       FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_ndp_paging_indicator,
     {"NDP Paging Indicator", "wlan.twt.ndp_paging_indicator",
      FT_BOOLEAN, 8, TFS(&tfs_present_not_present), 0x1, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_responder_pm_mode,
     {"Responder PM Mode", "wlan.twt.resp_pm",
      FT_BOOLEAN, 8, TFS(&twt_responder_pm_mode_tfs), 0x2, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_neg_type,
      {"Negotiation type", "wlan.twt.neg_type",
       FT_UINT8, BASE_DEC, VALS(twt_neg_type_vals), 0xc, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_info_frame_disabled,
     {"TWT Information Frame Disabled", "wlan.twt.info_frame_disabled",
      FT_BOOLEAN, 8, TFS(&twt_info_frame_disabled_tfs), 0x10, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_wake_duration_unit,
     {"Wake Duration Unit", "wlan.twt.wake_duration_unit",
      FT_BOOLEAN, 8, TFS(&twt_wake_duration_unit_tfs), 0x20, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_link_id_bitmap_present,
     {"Link ID Bitmap Present", "wlan.twt.link_id_bitmap_present",
      FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_aligned_twt,
      {"Aligned TWT", "wlan.twt.aligned_twt",
       FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_req_type_field,
      {"Request Type", "wlan.twt.request_type",
       FT_UINT16, BASE_HEX, NULL, 0, NULL,  HFILL }},

    {&hf_ieee80211_tag_twt_req_type_req,
      {"Requester", "wlan.twt.requester",
       FT_BOOLEAN, 16, TFS(&twt_requester_tfs), 0x0001, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_req_type_setup_cmd,
      {"Setup Command", "wlan.twt.setup_cmd",
       FT_UINT16, BASE_DEC, VALS(twt_setup_cmd), 0x000e, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_req_type_trigger,
      {"Trigger", "wlan.twt.trigger",
       FT_BOOLEAN, 16, TFS(&twt_trigger), 0x0010, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_req_type_implicit,
      {"Implicit", "wlan.twt.implicit",
       FT_BOOLEAN, 16, TFS(&twt_implicit), 0x0020, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_req_type_flow_type,
      {"Flow type", "wlan.twt.flow_type",
       FT_BOOLEAN, 16, TFS(&twt_flow_type), 0x0040, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_req_type_flow_id,
      {"Flow ID", "wlan.twt.flow_id",
       FT_UINT16, BASE_DEC, NULL, 0x0380, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_req_type_wake_int_exp,
      {"Wake Interval Exponent", "wlan.twt.wake_interval_exp",
       FT_UINT16, BASE_DEC, NULL, 0x7c00, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_req_type_prot,
      {"Protection", "wlan.twt.prot",
       FT_BOOLEAN, 16, NULL, 0x8000, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_req_type_last_bcst_parm_set,
      {"Last Broadcast Parameter Set",
       "wlan.twt.last_broadcast_parameter_set",
       FT_BOOLEAN, 16, NULL, 0x0020, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_req_type_bcst_twt_recom,
      {"Broadcast TWT Recommendation", "wlan.twt.broadcast_twt_recommendation",
       FT_UINT16, BASE_DEC, NULL, 0x0380, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_req_type_aligned,
      {"Aligned", "wlan.twt.aligned",
       FT_UINT16, BASE_HEX, NULL, 0x8000, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_ndp_paging_field,
     {"NDP Paging", "wlan.twt.ndp_paging",
      FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_ndp_paging_p_id,
     {"P-ID", "wlan.twt.ndp_paging.p_id",
      FT_UINT32, BASE_HEX, NULL, 0x000001FF, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_ndp_max_ndp_paging_period,
     {"Max NDP Paging Period", "wlan.twt.ndp_paging.max_ndp_paging_period",
      FT_UINT32, BASE_DEC, NULL, 0x0001FE00, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_ndp_partial_tsf_offset,
     {"Partial TSF Offset", "wlan.twt.ndp_paging.partial_tsf_offset",
      FT_UINT32, BASE_DEC, NULL, 0x001E0000, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_ndp_action,
     {"Action", "wlan.twt.ndp_paging.action",
      FT_UINT32, BASE_DEC, VALS(twt_ndp_action_vals),
      0x00E00000, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_ndp_min_sleep_duration,
     {"Min Sleep Duration", "wlan.twt.ndp_paging.min_sleep_duration",
      FT_UINT32, BASE_DEC, NULL, 0x3C000000, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_ndp_reserved,
     {"Reserved", "wlan.twt.ndp_paging.reserved",
      FT_UINT32, BASE_HEX, NULL, 0xC0000000, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_link_id_bitmap,
     {"Link ID Bitmap", "wlan.twt.link_id_bitmap",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_aligned_twt_link_bitmap,
     {"Aligned TWT Link Bitmap", "wlan.twt.aligned_twt_link_bitmap",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_broadcast_info,
     {"Broadcast TWT Info", "wlan.twt.broadcast_twt_info",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_bcast_info_persistence,
     {"Broadcast TWT Persistence",
      "wlan.twt.bcast_twt_info.broadcast_twt_persistence",
      FT_UINT16, BASE_HEX, NULL, 0xFF00, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_bcast_info_id,
     {"Broadcast TWT ID", "wlan.twt.bcast_twt_info.broadcast_twt_id",
      FT_UINT16, BASE_HEX, NULL, 0x00F8, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_bcast_info_rtwt_sche_info,
     {"Restricted TWT Schedule Info", "wlan.twt.bcast_twt_info.rtwt_schedule_info",
      FT_UINT16, BASE_HEX, NULL, 0x0006, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_bcast_info_rtwt_traffic_present,
     {"Restricted TWT Traffic Info Present", "wlan.twt.bcast_twt_info.rtwt_traffic_info_present",
      FT_BOOLEAN, 16, NULL, 0x0001, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_traffic_info_control,
      {"Traffic Info Control", "wlan.twt.traffic_info.control",
       FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_traffic_info_dl_bitmap_valid,
      {"DL TID Bitmap Valid", "wlan.twt.traffic_info.dl_tid_bitmap_valid",
       FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_traffic_info_ul_bitmap_valid,
      {"UL TID Bitmap Valid", "wlan.twt.traffic_info.ul_tid_bitmap_valid",
       FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_traffic_info_reserved,
      {"Reserved", "wlan.twt.traffic_info.reserved",
       FT_UINT8, BASE_HEX, NULL, 0xFC, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_traffic_info_rtwt_dl_bitmap,
      {"Restricted TWT DL TID Bitmap", "wlan.twt.traffic_info.dl_tid_bitmap",
       FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_traffic_info_rtwt_ul_bitmap,
      {"Restricted TWT UL TID Bitmap", "wlan.twt.traffic_info.ul_tid_bitmap",
       FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_target_wake_time,
      {"Target Wake Time", "wlan.twt.target_wake_time",
       FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_target_wake_time_short,
      {"Target Wake Time", "wlan.twt.target_wake_time",
       FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_nom_min_twt_wake_dur,
      {"Nominal Minimum TWT Wake duration", "wlan.twt.nom_min_twt_wake_duration",
       FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_wake_interval_mantissa,
      {"TWT Wake Interval Mantissa", "wlan.twt.wake_interval_mantissa",
       FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_twt_channel,
      {"TWT Channel", "wlan.twt.channel",
       FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_tag_rsnx,
      {"RSNX", "wlan.rsnx",
       FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_transition_disable_bitmap,
      {"Transition Disable Bitmap", "wlan.transition_disable_bitmap",
       FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_transition_disable_wpa3_personal,
      {"WPA3-Personal", "wlan.transition_disable.wpa3_personal",
       FT_BOOLEAN, 8, NULL, GENMASK(0, 0), NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_transition_disable_sae_pk,
      {"SAE-PK", "wlan.transition_disable.sae_pk",
       FT_BOOLEAN, 8, NULL, GENMASK(1, 1), NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_transition_disable_wpa3_enterprise,
      {"WPA3-Enterprise", "wlan.transition_disable.wpa3_enterprise",
       FT_BOOLEAN, 8, NULL, GENMASK(2, 2), NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_transition_disable_enhanced_open,
      {"Wi-Fi Enhanced Open", "wlan.transition_disable.enhanced_open",
       FT_BOOLEAN, 8, NULL, GENMASK(3, 3), NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_transition_disable_reserved_b4thru7,
      {"Reserved", "wlan.transition_disable.reserved.b4thru7",
       FT_UINT8, BASE_HEX, NULL, GENMASK(7, 4), NULL, HFILL }},

    {&hf_ieee80211_wfa_ie_transition_disable_reserved,
      {"Reserved", "wlan.transition_disable.reserved",
       FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_tag_rsnx_length,
      {"RSNX Length", "wlan.rsnx.length",
       FT_UINT8, BASE_DEC, NULL, 0x0F, NULL, HFILL }},

    {&hf_ieee80211_tag_rsnx_protected_twt_operations_support,
      {"Protected TWT Operations Support", "wlan.rsnx.protected_twt_operations_support",
       FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},

    {&hf_ieee80211_tag_rsnx_sae_hash_to_element,
      {"SAE Hash to element", "wlan.rsnx.sae_hash_to_element",
       FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},

    {&hf_ieee80211_tag_rsnx_sae_pk,
      {"SAE-PK", "wlan.rsnx.sae_pk",
       FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},

    {&hf_ieee80211_tag_rsnx_protected_wur_frame_support,
      {"Protected WUR Frame Support", "wlan.rsnx.protected_wur_frame_support",
       FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},

    {&hf_ieee80211_tag_rsnx_secure_ltf_support,
      {"Secure LTF Support", "wlan.rsnx.secure_ltf_support",
       FT_BOOLEAN, 8, NULL, GENMASK(0, 0), NULL, HFILL }},

    {&hf_ieee80211_tag_rsnx_secure_rtt_supported,
      {"Secure RTT Supported", "wlan.rsnx.secure_rtt_supported",
       FT_BOOLEAN, 8, NULL, GENMASK(1, 1), NULL, HFILL }},

    {&hf_ieee80211_tag_rsnx_urnm_mfpr_x20,
      {"URNM-MFPR-X20", "wlan.rsnx.urnm_mfpr_x20",
       FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},

    {&hf_ieee80211_tag_rsnx_protected_announce_support,
      {"Protected Announce Support", "wlan.rsnx.protected_announce_support",
       FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},

    {&hf_ieee80211_tag_rsnx_pbac,
      {"PBAC", "wlan.rsnx.pbac",
       FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},

    {&hf_ieee80211_tag_rsnx_extended_s1g_action_protection,
      {"Extended S1G Action Protection", "wlan.rsnx.extended_s1g_action_protection",
       FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},

    {&hf_ieee80211_tag_rsnx_spp_amsdu_capable,
      {"SPP AMSDU Capable", "wlan.rsnx.spp_amsdu_capable",
       FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},

    {&hf_ieee80211_tag_rsnx_urnm_mfpr,
      {"URNM-MFPR", "wlan.rsnx.urnm_mfpr",
       FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},

    {&hf_ieee80211_tag_rsnx_reserved,
      {"Reserved", "wlan.rsnx.reserved",
       FT_UINT8, BASE_HEX, NULL, 0x00, NULL, HFILL }},

    {&hf_ieee80211_owe_dh_parameter_group,
     {"Group", "wlan.ext_tag.owe_dh_parameter.group",
      FT_UINT32, BASE_DEC, VALS(owe_dh_parameter_group_vals), 0x0, NULL, HFILL }},

    {&hf_ieee80211_owe_dh_parameter_public_key,
     {"Public Key", "wlan.ext_tag.owe_dh_parameter.public_key",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_tag_pasn_parameters_control,
     {"Control", "wlan.etag.pasn_params.control",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_tag_pasn_params_comeback_info_present,
     {"Comeback Info Present", "wlan.etag.pasn_params.comeback_info_present",
      FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_tag_pasn_params_group_and_key_present,
     {"Group and Key Present", "wlan.etag.pasn_params.group_and_key_present",
      FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_tag_pasn_parameters_reserved,
     {"Reserved", "wlan.etag.pasn_parameters.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xFC, NULL, HFILL }},

    {&hf_ieee80211_tag_pasn_parameters_wrapped_fmt,
      {"Wrapped Data Format", "wlan.etag.pasn_parameters.wrapped_data_format",
       FT_UINT8, BASE_HEX|BASE_RANGE_STRING, RVALS(wrapped_data_fmt_rvals),
       0x0, NULL, HFILL }},

    {&hf_ieee80211_tag_pasn_comeback_after,
     {"Comeback After", "wlan.etag.pasn_parameters.comeback_after",
      FT_UINT16, BASE_DEC|BASE_UNIT_STRING, UNS(&units_tu_tus), 0x0, NULL, HFILL }},

    {&hf_ieee80211_tag_pasn_cookie_length,
     {"Cookie length", "wlan.etag.pasn_parameters.cookie_length",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_tag_pasn_cookie,
     {"Cookie", "wlan.etag.pasn_parameters.cookie",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_tag_pasn_finite_cyclic_group_id,
     {"Finite Cyclic Group ID",
      "wlan.etag.pasn_parameters.finite_cyclic_group_id",
      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_tag_pasn_ephemeral_public_key_len,
     {"Ephemeral Public Key Length",
      "wlan.etag.pasn_parameters.ephemeral_public_key_len",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_tag_pasn_ephemeral_public_key,
      {"Ephemeral Public Key",
       "wlan.etag.pasn_parameters.ephemeral_public_key",
       FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_pasn_auth1_frame_len,
     {"Auth Frame 1 Length", "wlan.pasn_wrapped_data.auth_frame_1_len",
      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_pasn_auth2_frame_len,
     {"Auth Frame 2 Length", "wlan.pasn_wrapped_data.auth_frame_2_len",
      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_eml_control_field,
     {"EML Control Field", "wlan.eht.eml_control",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_eml_control_emlsr_mode,
     {"EMLSR Mode", "wlan.eht.eml_control.emlsr_mode",
      FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_eht_eml_control_emlmr_mode,
     {"EMLMR Mode", "wlan.eht.eml_control.emlmr_mode",
      FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_eht_eml_control_emlsr_para_update_control,
     {"EMLSR Parameter Update Control", "wlan.eht.eml_control.emlsr_para_update_control",
      FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},

    {&hf_ieee80211_eht_eml_control_device_coexist_activities,
     {"In-Device Coexistence Activities",
      "wlan.eht.eml_control.in_device_coexist_activities",
      FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},

    {&hf_ieee80211_eht_eml_control_reserved,
     {"Reserved", "wlan.eht.eml_control.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xf0, NULL, HFILL }},

    {&hf_ieee80211_eht_eml_control_link_bitmap,
     {"Link Bitmap", "wlan.eht.eml_control.link_bitmap",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_eml_control_link_enable_id,
     {"Enable Link ID",
       "wlan.eht.eml_control.link_map.enable_id",
       FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_eml_control_mcs_map_count,
     {"MCS Map Count Control", "wlan.eht.eml_control.mcs_map_count",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_eht_eml_control_mcs_map_count_bw,
     {"MCS Map Count Control BW", "wlan.eht.eml_control.mcs_map_count.bw",
      FT_UINT8, BASE_HEX, VALS(eht_eml_control_mcs_map_count_bw), 0x03, NULL, HFILL }},

    {&hf_ieee80211_eht_eml_control_mcs_map_count_reserved,
     {"Reserved", "wlan.eht.eml_control.mcs_map_count.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xfc, NULL, HFILL }},

    {&hf_ieee80211_eht_emlsr_para_update,
     {"EMLSR Parameter Update", "wlan.eht.emlsr_parameter_update",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_eht_emlsr_para_update_padding_delay,
     {"EMLSR Padding Delay", "wlan.eht.emlsr_parameter_update.padding_delay",
      FT_UINT8, BASE_HEX, NULL, 0x07, NULL, HFILL }},

    {&hf_ieee80211_eht_emlsr_para_update_tran_delay,
     {"EMLSR Transition Delay", "wlan.eht.emlsr_parameter_update.transition_delay",
      FT_UINT8, BASE_HEX, NULL, 0x38, NULL, HFILL }},

    {&hf_ieee80211_eht_emlsr_para_update_reserved,
     {"Reserved", "wlan.eht.emlsr_parameter_update.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xc0, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control,
     {"Multi-Link Control", "wlan.eht.multi_link.control",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control_type,
     {"Type", "wlan.eht.multi_link.control.type",
      FT_UINT16, BASE_DEC, VALS(multi_link_type_vals), 0x0007, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control_reserved,
     {"Reserved", "wlan.eht.multi_link.control.reserved",
      FT_UINT16, BASE_HEX, NULL, 0x0008, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control_link_id_present,
     {"Link ID Info Present",
      "wlan.eht.multi_link.control.basic.link_id_info_present",
      FT_BOOLEAN, 16, NULL, 0x0010, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control_bss_parms_ch_count,
     {"BSS Parameters Change Count Present",
      "wlan.eht.multi_link.control.basic.bss_parameters_change_count_present",
      FT_BOOLEAN, 16, NULL, 0x0020, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control_medium_sync_delay,
     {"Medium Synchronization Delay Info Present",
      "wlan.eht.multi_link.control.basic.medium_sync_delayinfo_present",
      FT_BOOLEAN, 16, NULL, 0x0040, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control_eml_capa,
     {"EML Capabilities Present",
      "wlan.eht.multi_link.control.basic.eml_capabilities_present",
      FT_BOOLEAN, 16, NULL, 0x0080, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control_mld_capa,
     {"MDL Capabilities Present",
      "wlan.eht.multi_link.control.basic.mld_capabilities_present",
      FT_BOOLEAN, 16, NULL, 0x0100, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control_basic_mld_id_present,
     {"AP MLD ID Present",
      "wlan.eht.multi_link.control.basic.mld_id_present",
      FT_BOOLEAN, 16, NULL, 0x0200, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control_ext_mld_capa,
     {"Extended MLD Capabilities and Operations Present",
      "wlan.eht.multi_link.control.basic.ext_mld_capabilities_present",
      FT_BOOLEAN, 16, NULL, 0x0400, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control_bitmap_reserved,
     {"Reserved", "wlan.eht.multi_link.control.basic.reserved",
      FT_UINT16, BASE_HEX, NULL, 0xF800, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control_probe_mld_id_present,
     {"AP MLD ID Present",
      "wlan.eht.multi_link.control.probe.mld_id_present",
      FT_BOOLEAN, 16, NULL, 0x0010, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control_probe_reserved,
     {"Reserved", "wlan.eht.multi_link.control.probe.reserved",
      FT_UINT16, BASE_HEX, NULL, 0xFFE0, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control_tdls_reserved,
     {"Reserved", "wlan.eht.multi_link.control.tdls.reserved",
      FT_UINT16, BASE_HEX, NULL, 0xFFF0, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control_prio_access_reserved,
     {"Reserved", "wlan.eht.multi_link.control.prio_access.reserved",
      FT_UINT16, BASE_HEX, NULL, 0xFFF0, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control_reconfig_mld_mac,
     {"MLD MAC Address Present",
      "wlan.eht.multi_link.control.reconfig.mld_mac_addr_present",
      FT_BOOLEAN, 16, NULL, 0x0010, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control_reconfig_eml_capa,
     {"EML Capabilities Present",
      "wlan.eht.multi_link.control.reconfig.eml_capabilities_present",
      FT_BOOLEAN, 16, NULL, 0x0020, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control_reconfig_mld_capa_oper,
     {"MLD Capabilities And Operations Present",
      "wlan.eht.multi_link.control.reconfig.mld_capabilities_present",
      FT_BOOLEAN, 16, NULL, 0x0040, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_control_reconfig_reserved,
     {"Reserved",
      "wlan.eht.multi_link.control.reconfig.reserved",
      FT_UINT16, BASE_HEX, NULL, 0xFF80, NULL, HFILL }},

    {&hf_ieee80211_eht_common_field_length,
     {"Common Info Length", "wlan.eht.multi_link.common_info.length",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_common_field_mld_mac,
     {"MLD MAC Address", "wlan.eht.multi_link.common_info.mld_mac_address",
      FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_common_field_link_id_field,
     {"Link ID subfield", "wlan.eht.multi_link.common_info.link_id_subfield",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_link_id,
     {"Link ID", "wlan.eht.multi_link.common_info.link_id_subfield.link_id",
      FT_UINT8, BASE_HEX, NULL, 0x0F, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_link_id_reserved,
     {"Reserved", "wlan.eht.multi_link.common_info.link_id_subfield.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xF0, NULL, HFILL }},

    {&hf_ieee80211_eht_common_field_bss_param_change_count,
     {"BSS Parameters Change Count",
      "wlan.eht.multi_link.common_info.bss_parameters_change_count",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_common_field_medium_sync_field,
     {"Medium Sync Field", "wlan.eht.multi_link.common_info.medium_sync_field",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_medium_sync_duration,
     {"Medium Synchronization Duration",
      "wlan.eht.multi_link.common_info.medium_sync.sync_duration",
      FT_UINT16, BASE_DEC, NULL, 0x00FF, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_medium_sync_threshold,
     {"Medium Synchronization OFDM ED Threshold",
      "wlan.eht.multi_link.common_info.medium_sync.ofdm_ed_threshold",
      FT_UINT16, BASE_DEC, NULL, 0x0F00, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_medium_sync_max_txops,
     {"Medium Synchronization Maximum Number of TXOPs",
      "wlan.eht.multi_link.common_info.medium_sync.max_number_of_txops",
      FT_UINT16, BASE_DEC, NULL, 0xF000, NULL, HFILL }},

    {&hf_ieee80211_eht_common_field_eml_capabilities,
     {"EML Capabilities", "wlan.eht.multi_link.common_info.eml_capabilities",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_eml_capa_emlsr_support,
     {"EMLSR Support",
      "wlan.eht.multi_link.common_info.eml_capabilities.emlsr_support",
      FT_BOOLEAN, 16, NULL, 0x0001, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_eml_capa_emlsr_padding_delay,
     {"EMLSR Padding Delay",
      "wlan.eht.multi_link.common_info.eml_capabilities.emlsr_padding_delay",
      FT_UINT16, BASE_DEC, NULL, 0x000E, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_eml_capa_emlsr_transition_delay,
     {"EMLSR Transition Delay",
      "wlan.eht.multi_link.common_info.eml_capabilities.emlsr_transition_delay",
      FT_UINT16, BASE_DEC, NULL, 0x0070, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_eml_capa_emlmr_support,
     {"EMLMR Support",
      "wlan.eht.multi_link.common_info.eml_capabilities.emlmr_support",
      FT_BOOLEAN, 16, NULL, 0x0080, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_eml_capa_emlmr_delay,
     {"EMLMR Delay",
      "wlan.eht.multi_link.common_info.eml_capabilities.emlmr_delay",
      FT_UINT16, BASE_DEC, NULL, 0x0700, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_eml_capa_transition_timeout,
     {"Transition Timeout",
      "wlan.eht.multi_link.common_info.eml_capabilities.transition_timeout",
      FT_UINT16, BASE_DEC, NULL, 0x7800, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_eml_capa_reserved,
     {"Reserved",
      "wlan.eht.multi_link.common_info.eml_capabilities.capa_reserved",
      FT_UINT16, BASE_HEX, NULL, 0x8000, NULL, HFILL }},

    {&hf_ieee80211_eht_common_field_mld_capabilities,
     {"MLD Capabilities", "wlan.eht.multi_link.common_info.mld_capabilities",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_mld_max_simul_links,
     {"Maximum Number of Simultaneous Links",
      "wlan.eht.multi_link.common_info.mld_capabilities.max_simultaneous_links",
      FT_UINT16, BASE_DEC, NULL, 0x000F, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_mld_srs_support,
     {"SRS Support",
      "wlan.eht.multi_link.common_info.mld_capabilities.srs_support",
      FT_BOOLEAN, 16, NULL, 0x0010, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_mld_tid_to_link_map_neg,
     {"TID-To-Link Mapping Negotiation Support",
      "wlan.eht.multi_link.common_info.mld_capabilities.tid_to_link_neg_sup",
      FT_UINT16, BASE_DEC, NULL, 0x0060, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_mld_freq_sep_for_str,
     {"Frequency Separation For STR/AP MLD Type Indication",
      "wlan.eht.multi_link.common_info.mld_capabilities.freq_sep_for_str",
      FT_UINT16, BASE_DEC, NULL, 0x0F80, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_mld_aar_support,
     {"AAR Support",
      "wlan.eht.multi_link.common_info.mld_capabilities.aar_support",
      FT_BOOLEAN, 16, NULL, 0x1000, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_mld_link_reconf_op_support,
     {"Link Reconfiguration Operation Support",
      "wlan.eht.multi_link.common_info.mld_capabilities.link_reconfig_op_support",
      FT_BOOLEAN, 16, NULL, 0x2000, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_mld_aligned_twt_support,
     {"Aligned TWT Support",
      "wlan.eht.multi_link.common_info.mld_capabilities.aligned_twt_support",
      FT_BOOLEAN, 16, NULL, 0x4000, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_mld_reserved,
     {"Reserved", "wlan.eht.multi_link.common_info.mld_capabilities.reserved",
      FT_UINT16, BASE_HEX, NULL, 0x8000, NULL, HFILL }},

    {&hf_ieee80211_eht_common_field_ap_mld_mac,
     {"AP MLD MAC Address",
      "wlan.eht.multi_link.common_info.ap_mld_mac_address",
      FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_common_field_mld_id,
     {"AP MLD ID", "wlan.eht.multi_link.common_info.mld_id",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_common_field_ext_mld_capabilities,
     {"Extended MLD Capabilities and Operations",
      "wlan.eht.multi_link.common_info.ext_mld_capabilities",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_ext_mld_op_update_support,
     {"Operation Parameter Update Support",
      "wlan.eht.multi_link.common_info.ext_mld_capabilities.op_param_update_support",
      FT_BOOLEAN, 16, NULL, 0x0001, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_ext_mld_max_simul_links,
     {"Recommended Max Simultaneous Links",
      "wlan.eht.multi_link.common_info.ext_mld_capabilities.max_simultaneous_links",
      FT_UINT16, BASE_DEC, NULL, 0x001E, NULL, HFILL }},

    {&hf_ieee80211_eht_common_info_ext_mld_reserved,
     {"Reserved", "wlan.eht.multi_link.common_info.ext_mld_capabilities.reserved",
      FT_UINT16, BASE_HEX, NULL, 0xFFE0, NULL, HFILL }},

    {&hf_ieee80211_eht_profile_sta_control,
     {"STA Control", "wlan.eht.multi_link.sta_profile.sta_control",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_subelt_tag,
     {"Subelement ID", "wlan.eht.multi_link.sta_profile.subelt_id",
      FT_UINT8, BASE_HEX | BASE_RANGE_STRING, RVALS(multi_link_sub_elt_string),
      0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_subelt_len,
     {"Subelement Length", "wlan.eht.multi_link.sta_profile.subelt_len",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_type_0_link_count,
     {"Basic STA Profile Count", "wlan.eht.multi_link.type_0.sta_profile_count",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_type_1_link_count,
     {"Probe Request STA Profile Count", "wlan.eht.multi_link.type_1.sta_profile_count",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_type_2_link_count,
     {"Reconfiguration STA Profile Count", "wlan.eht.multi_link.type_2.sta_profile_count",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_type_3_link_count,
     {"TDLS STA Profile Count", "wlan.eht.multi_link.type_3.sta_profile_count",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_type_4_link_count,
     {"Priority Access STA Profile Count", "wlan.eht.multi_link.type_4.sta_profile_count",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_link_id_list,
     {"STA Profiles LinkIds", "wlan.eht.multi_link.sta_profile_id_list",
      FT_STRINGZ, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_profile_link_id,
     {"Link ID", "wlan.eht.multi_link.sta_profile.sta_control.link_id",
      FT_UINT16, BASE_HEX, NULL, STA_CTRL_LINK_ID, NULL, HFILL }},

    {&hf_ieee80211_eht_profile_complete_profile,
     {"Complete Profile",
      "wlan.eht.multi_link.sta_profile.sta_control.complete_profile",
      FT_BOOLEAN, 16, NULL, STA_CTRL_COMPLETE_PROFILE, NULL, HFILL }},

    {&hf_ieee80211_eht_profile_mac_address_present,
     {"MAC Address Present",
      "wlan.eht.multi_link.sta_profile.sta_control.mac_address_present",
      FT_BOOLEAN, 16, NULL, STA_CTRL_MAC_ADDR_PRESENT, NULL, HFILL }},

    {&hf_ieee80211_eht_profile_beacon_interval_present,
     {"Beacon Interval Present",
      "wlan.eht.multi_link.sta_profile.sta_control.beacon_interval_present",
      FT_BOOLEAN, 16, NULL, STA_CTRL_BEACON_INT_PRESENT, NULL, HFILL }},

    {&hf_ieee80211_eht_profile_tsf_offset_present,
     {"TSF Offset Present",
      "wlan.eht.multi_link.sta_profile.sta_control.tsf_offset_present",
      FT_BOOLEAN, 16, NULL, STA_CTRL_TSF_OFFSET_PRESENT, NULL, HFILL }},

    {&hf_ieee80211_eht_profile_dtim_info_present,
     {"DTIM Info Present",
      "wlan.eht.multi_link.sta_profile.sta_control.dtim_info_present",
      FT_BOOLEAN, 16, NULL, STA_CTRL_DTIM_INFO_PRESENT, NULL, HFILL }},

    {&hf_ieee80211_eht_profile_nstr_link_pair_present,
     {"NSTR Link Pair Present",
      "wlan.eht.multi_link.sta_profile.sta_control.nstr_link_pair_present",
      FT_BOOLEAN, 16, NULL, STA_CTRL_NSTR_LINK_PAIR_PRESENT, NULL, HFILL }},

    {&hf_ieee80211_eht_profile_nstr_bitmap_size,
     {"NSTR Bitmap Size",
      "wlan.eht.multi_link.sta_profile.sta_control.nstr_bitmap_size",
      FT_UINT16, BASE_DEC, NULL, STA_CTRL_NSTR_BITMAP_SIZE, NULL, HFILL }},

    {&hf_ieee80211_eht_profile_bss_params_change_count_present,
     {"BSS Parameters Change Count Present",
      "wlan.eht.multi_link.sta_profile.sta_control.bss_params_change_count_present",
      FT_BOOLEAN, 16, NULL, STA_CTRL_BSS_PARAMS_CHANGE_CNT_PRESENT, NULL, HFILL }},

    {&hf_ieee80211_eht_profile_reserved,
     {"Reserved", "wlan.eht.multi_link.sta_profile.sta_control.reserved",
      FT_UINT16, BASE_HEX, NULL, STA_CTRL_RESERVED, NULL, HFILL }},

    {&hf_ieee80211_eht_profile_probe_reserved,
     {"Reserved", "wlan.eht.multi_link.sta_profile.sta_control.probe_reserved",
      FT_UINT16, BASE_HEX, NULL, 0xFFE0, NULL, HFILL }},

    {&hf_ieee80211_eht_profile_removal_timer_present,
     {"AP Removal Timer Present",
      "wlan.eht.multi_link.sta_profile.sta_control.ap_removal_timer_present",
      FT_BOOLEAN, 16, NULL, 0x0040, NULL, HFILL }},

    {&hf_ieee80211_eht_profile_reconfig_operation_type,
     {"Reconfiguration Operation Type",
      "wlan.eht.multi_link.sta_profile.sta_control.reconfig_operation_type",
      FT_UINT16, BASE_DEC|BASE_RANGE_STRING, RVALS(eht_reconfig_op_type_rvals),
      0x0780, NULL, HFILL }},

    {&hf_ieee80211_eht_profile_operation_para_present,
     {"Operation Parameters Present",
      "wlan.eht.multi_link.sta_profile.sta_control.operation_parameters_present",
      FT_BOOLEAN, 16, NULL, 0x0800, NULL, HFILL }},

    {&hf_ieee80211_eht_profile_reconfig_nstr_bitmap_size,
     {"NSTR Bitmap Size",
      "wlan.eht.multi_link.sta_profile.sta_control.reconfig_nstr_bitmap_size",
      FT_UINT16, BASE_DEC, NULL, 0x1000, NULL, HFILL }},

    {&hf_ieee80211_eht_profile_reconfig_reserved,
     {"Reserved", "wlan.eht.multi_link.sta_profile.sta_control.reconfig_reserved",
      FT_UINT16, BASE_HEX, NULL, 0xE000, NULL, HFILL }},

    {&hf_ieee80211_eht_profile_prio_acc_reserved,
     {"Reserved",
      "wlan.eht.multi_link.sta_profile.sta_control.priority_access_reserved",
      FT_UINT16, BASE_HEX, NULL, 0xFFF0, NULL, HFILL }},

    {&hf_ieee80211_eht_sta_profile_info_len,
     {"STA Info Length",
      "wlan.eht.multi_link.sta_profile.sta_info.len",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_sta_profile_info_mac,
     {"STA MAC Address",
      "wlan.eht.multi_link.sta_profile.sta_info.sta_mac_addr",
      FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_sta_profile_info_beacon,
     {"Beacon Interval",
      "wlan.eht.multi_link.sta_profile.sta_info.beacon_interval",
      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_sta_profile_info_tsf_offset,
     {"TSF Offset",
      "wlan.eht.multi_link.sta_profile.sta_info.tsf_offset",
      FT_INT64, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_sta_profile_info_dtim_count,
     {"DTIM Count",
      "wlan.eht.multi_link.sta_profile.sta_info.dtim_count",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_sta_profile_info_dtim_period,
     {"DTIM Period",
      "wlan.eht.multi_link.sta_profile.sta_info.dtim_period",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_sta_profile_info_bitmap,
     {"NSTR Indication Bitmap",
      "wlan.eht.multi_link.sta_profile.sta_info.nstr_bitmap",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_sta_profile_bss_params_change_count,
     {"BSS Parameters Change Count",
      "wlan.eht.multi_link.sta_profile.sta_info.bss_params_change_count",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_sta_profile_removal_timer,
     {"AP Removal Timer",
      "wlan.eht.multi_link.sta_profile.sta_info.ap_removal_timer",
      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_sta_profile_presence_indi,
     {"Presence Indication",
      "wlan.eht.multi_link.sta_profile.sta_info.presence_indication",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_sta_profile_presence_indi_max_mpdu_length_present,
     {"Maximum MPDU Length Present",
      "wlan.eht.multi_link.sta_profile.sta_info.presence_indication.max_mpdu_length_present",
      FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_eht_sta_profile_presence_indi_max_amsdu_length_present,
     {"Maximum A-MSDU Length Present",
      "wlan.eht.multi_link.sta_profile.sta_info.presence_indication.max_amsdu_length_present",
      FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_eht_sta_profile_presence_indi_reserved,
     {"Reserved",
      "wlan.eht.multi_link.sta_profile.sta_info.presence_indication.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xfc, NULL, HFILL }},

    {&hf_ieee80211_eht_sta_profile_operation_para_info,
     {"Operation Parameter Info",
      "wlan.eht.multi_link.sta_profile.sta_info.operation_parameter_info",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_sta_profile_operation_para_info_max_mpdu_length,
     {"Maximum MPDU Length",
      "wlan.eht.multi_link.sta_profile.sta_info.operation_parameter_info.max_mpdu_length",
      FT_UINT16, BASE_HEX, VALS(vht_max_mpdu_length_flag), 0x0003,
      "In Octets unit", HFILL }},

    {&hf_ieee80211_eht_sta_profile_operation_para_info_amsdu_length,
     {"A-MSDU length",
      "wlan.eht.multi_link.sta_profile.sta_info.operation_parameter_info.amsdu_length",
      FT_BOOLEAN, 16, TFS(&ht_max_amsdu_flag), 0x0004,
      NULL, HFILL }},

    {&hf_ieee80211_eht_sta_profile_operation_para_info_pad,
     {"Pad", "wlan.eht.multi_link.sta_profile.sta_info.operation_parameter_info.pad",
      FT_UINT16, BASE_HEX, NULL, 0xFFF8,
      NULL, HFILL }},

    {&hf_ieee80211_eht_operation_parameters,
     {"EHT Operation Parameters",
      "wlan.eht.eht_operation_parameters",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_basic_eht_mcs_nss_set,
     {"Basic EHT-MCS And Nss Set",
      "wlan.eht.basic_eht_mcs_and_nss_set",
      FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_operation_control_chan_width,
     {"Channel Width",
      "wlan.eht.eht_operation_information.control.channel_width",
      FT_UINT8, BASE_DEC, VALS(eht_operation_control_chan_wid_vals),
      0x7, NULL, HFILL }},

    {&hf_ieee80211_eht_operation_control_reserved,
     {"Reserved", "wlan.eht.eht_operation_information.control.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xF8, NULL, HFILL }},

    {&hf_ieee80211_eht_operation_info_present,
     {"EHT Operation Information Present",
      "wlan.eht.eht_operation_parameters.eht_operation_information_present",
      FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_eht_operation_subchannel_bitmap_present,
     {"Disabled Subchannel Bitmap Present",
      "wlan.eht.eht_operation_parameters.disabled_subchannel_bitmap_present",
      FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_eht_operation_default_pe_duration,
     {"EHT Default PE Duration",
      "wlan.eht.eht_operation_parameters.eht_default_pe_duration",
      FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},

    {&hf_ieee80211_eht_operation_group_addressed_bu_indication_limit,
     {"Group Addressed BU Indication Limit",
      "wlan.eht.eht_operation_parameters.group_addressed_bu_indication_limit",
      FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},

    {&hf_ieee80211_eht_operation_group_addressed_bu_indication_exp,
     {"Group Addressed BU Indication Exponent",
      "wlan.eht.eht_operation_parameters.group_addressed_bu_indication_exponent",
      FT_UINT8, BASE_DEC, NULL, 0x30, NULL, HFILL }},

    {&hf_ieee80211_eht_operation_reserved,
     {"Reserved",  "wlan.eht.eht_operation_parameters.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xC0, NULL, HFILL }},

    {&hf_ieee80211_eht_operation_control,
     {"Control", "wlan.eht.eht_operation_information.control",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_operation_ccfs0,
     {"CCFS0", "wlan.eht.eht_operation_information.ccfs0",
      FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_operation_ccfs1,
     {"CCFS1", "wlan.eht.eht_operation_information.ccfs1",
      FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_operation_disabled_bitmap,
     {"Disabled Subchannel Bitmap",
      "wlan.eht.eht_operation_information.disabled_subchannel_bitmap",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_mac_capabilities,
     {"EHT MAC Capabilities Information", "wlan.eht.mac_capabilities_info",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_mac_capa_epcs_prio_access_support,
     {"EPCS Priority Access Support",
      "wlan.eht.mac_capabilities.epcs_priority_access_support",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0001, NULL, HFILL }},

    {&hf_ieee80211_eht_mac_capa_eht_om_control_support,
     {"EHT OM Control Support",
      "wlan.eht.mac_capabilities.eht_om_control_support",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0002, NULL, HFILL }},

    {&hf_ieee80211_eht_mac_capa_trig_txop_sharing_mode_1_support,
     {"Triggered TXOP Sharing Mode 1 Support",
      "wlan.eht.mac_capabilities.triggered_txop_sharing_mode_1_support",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0004, NULL, HFILL }},

    {&hf_ieee80211_eht_mac_capa_trig_txop_sharing_mode_2_support,
     {"Triggered TXOP Sharing Mode 2 Support",
      "wlan.eht.mac_capabilities.triggered_txop_sharing_mode_2_support",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0008, NULL, HFILL }},

    {&hf_ieee80211_eht_mac_capa_restricted_twt_support,
     {"Restricted TWT Support",
      "wlan.eht.mac_capabilities.restricted_twt_support",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0010, NULL, HFILL }},

    {&hf_ieee80211_eht_mac_capa_scs_traffic_description_support,
     {"SCS Traffic Description Support",
      "wlan.eht.mac_capabilities.scs_traffic_description_support",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0020, NULL, HFILL }},

    {&hf_ieee80211_eht_mac_capa_maximum_mpdu_length,
     {"Maximum MPDU Length",
      "wlan.eht.mac_capabilities.maximum_mpdu_length",
      FT_UINT16, BASE_HEX, VALS(vht_max_mpdu_length_flag), 0x00c0, NULL, HFILL }},

    {&hf_ieee80211_eht_mac_capa_maximum_ampdu_length_exp_ext,
     {"Maximum A-MPDU Length Exponent Extension",
      "wlan.eht.mac_capabilities.maximum_a_mpdu_length_exponent_extension",
      FT_UINT16, BASE_DEC, NULL, 0x0100, NULL, HFILL }},

    {&hf_ieee80211_eht_mac_capa_eht_trs_support,
     {"EHT TRS Support",
      "wlan.eht.mac_capabilities.eht_trs_support",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0200, NULL, HFILL }},

    {&hf_ieee80211_eht_mac_capa_txop_return_support_txop_sha_mode,
     {"TXOP Return Support In TXOP Sharing Mode 2",
      "wlan.eht.mac_capabilities.txop_return_support_in_txop_sharing_mode_2",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0400, NULL, HFILL }},

    {&hf_ieee80211_eht_mac_capa_two_bqrs_support,
     {"Two BQRs Support",
      "wlan.eht.mac_capabilities.two_bqrs_support",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0800, NULL, HFILL }},

    {&hf_ieee80211_eht_mac_capa_eht_link_adaptation_support,
     {"EHT Link Adaptation Support",
      "wlan.eht.mac_capabilities.eht_link_adaptation_support",
      FT_UINT16, BASE_DEC, VALS(eht_link_adaptation_vals), 0x3000, NULL, HFILL }},

    {&hf_ieee80211_eht_mac_capa_reserved,
     {"Reserved",
      "wlan.eht.mac_capabilities.reserved",
      FT_UINT16, BASE_HEX, NULL, 0xc000, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_0_15,
     {"EHT PHY Bits 0-15", "wlan.eht.phy_capabilities.bits_0_15",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_0_15_reserved,
     {"Reserved", "wlan.eht.phy_capabilities.bits_0_15.reserved",
      FT_UINT16, BASE_HEX, NULL, 0x0001, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_0_15_320_mhz_in_6ghz,
     {"Support For 320 MHz in 6 GHz",
      "wlan.eht.phy_capabilities.bits_0_15.support_for_320mhz_in_6ghz",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0002, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_0_15_242_tone_ru_bw_wider_20mhz,
     {"Support for 242-tone RU in BW Wider than 20 MHz",
      "wlan.eht.phy_capabilities.bits_0_15.support_for_242_tone_ru_in_bw_wider_20mhz",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0004, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_0_15_ndp_and_3_2_us_gi,
     {"NDP With 4x EHT-LTF And 3.2 us GI",
      "wlan.eht.phy_capabilities.bits_0_15.ndp_with_4x_eht_ltf_and_3_2_us_gi",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0008, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_0_15_partial_bw_ul_mu_mimo,
     {"Partial Bandwidth UL MU-MIMO",
      "wlan.eht.phy_capabilities.bits_0_15.partial_bandwidth_ul_mu_mimo",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0010, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_0_15_su_beamformer,
     {"SU Beamformer", "wlan.eht.phy_capabilities.bits_0_15.su_beamformer",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0020, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_0_15_su_beamformee,
     {"SU Beamformee", "wlan.eht.phy_capabilities.bits_0_15.su_beamformee",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0040, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_0_15_su_beamformee_le_80mhz,
     {"Beamformee SS (<= 80 MHz)",
      "wlan.eht.phy_capabilities.bits_0_15.beamformee_ss_le_80mhz",
      FT_UINT16, BASE_HEX, NULL, 0x0380, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_0_15_su_beamformee_eq_160mhz,
     {"Beamformee SS (= 160 MHz)",
      "wlan.eht.phy_capabilities.bits_0_15.beamformee_ss_eq_160mhz",
      FT_UINT16, BASE_HEX, NULL, 0x1c00, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_0_15_su_beamformee_eq_320mhz,
     {"Beamformee SS (= 320 MHz)",
      "wlan.eht.phy_capabilities.bits_0_15.beamformee_ss_eq_320_mhz",
      FT_UINT16, BASE_HEX, NULL, 0xe000, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_16_31,
     {"EHT PHY Bits 16-31", "wlan.eht.phy_capabilities.bits_16_31",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_16_31_num_sounding_dims_lt_80mhz,
     {"Number Of Sounding Dimensions (<= 80 MHz)",
      "wlan.eht.phy_capabilities.bits_16_31.number_of_sounding_dims_le_80_mhz",
      FT_UINT16, BASE_HEX, NULL, 0x0007, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_16_31_num_sounding_dims_eq_160mhz,
     {"Number Of Sounding Dimensions (= 160 MHz)",
      "wlan.eht.phy_capabilities.bits_16_31.number_of_sounding_dims_eq_160_mhz",
      FT_UINT16, BASE_HEX, NULL, 0x0038, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_16_31_num_sounding_dims_eq_320mhz,
     {"Number Of Sounding Dimensions (= 320 MHz)",
      "wlan.eht.phy_capabilities.bits_16_31.number_of_sounding_dims_eq_320_mhz",
      FT_UINT16, BASE_HEX, NULL, 0x01c0, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_16_31_num_ng_eq_16_su_feedback,
     {"Ng = 16 SU Feedback",
      "wlan.eht.phy_capabilities.bits_16_31.ng_eq_16_su_fbck",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0200, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_16_31_num_ng_eq_16_mu_feedback,
     {"Ng = 16 MU Feedback",
      "wlan.eht.phy_capabilities.bits_16_31.ng_eq_16_mu_fbck",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0400, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_16_31_codebook_size_4_2_su_fbck,
     {"Codebook Size = (4,2) SU Feedback",
      "wlan.eht.phy_capabilities.bits_16_31.codebook_size_eq_4_2_su_fbck",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x0800, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_16_31_codebook_size_7_5_mu_fbck,
     {"Codebook Size = (7,5) MU Feedback",
      "wlan.eht.phy_capabilities.bits_16_31.codebook_size_eq_7_5_mu_fbck",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x1000, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_16_31_triggered_su_beemform_fbck,
     {"Triggered SU Beamforming Feedback",
      "wlan.eht.phy_capabilities.bits_16_31.triggered_su_beamforming_fbck",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x2000, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_16_31_triggered_mu_beemform_p_bw_fbck,
     {"Triggered MU Beamforming Partial BW Feedback",
      "wlan.eht.phy_capabilities.bits_16_31.triggered_mu_beamforming_partial_fbck",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x4000, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_16_31_triggered_cqi_feedback,
     {"Triggered CQI Feedback",
      "wlan.eht.phy_capabilities.bits_16_31.triggered_cqi_fbck",
      FT_BOOLEAN, 16, TFS(&tfs_supported_not_supported), 0x8000, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_32_39,
     {"EHT PHY Bits 32-39", "wlan.eht.phy_capabilities.bits_32_39",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_32_39_partial_bw_dl_mu_mimo,
     {"Partial Bandwidth DL MU-MIMO",
      "wlan.eht.phy_capabilities.bits_32_39.partial_bw_dl_mu_mimo",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_32_39_eht_psr_based_sr_support,
     {"EHT PSR-Based SR support",
      "wlan.eht.phy_capabilities.bits_32_39.eht_psr_based_sr_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x02, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_32_39_power_boost_factor_support,
     {"Power Boost Factor Support",
      "wlan.eht.phy_capabilities.bits_32_39.power_boost_factor_support",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x04, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_32_39_eht_mu_ppdu_w_4x_eht_ltf_08_gi,
     {"EHT MU PPDU With 4x EHT-LTF and 0.8 us GI",
      "wlan.eht.phy_capabilities.bits_32_39.eht_mu_ppdu_w_4x_eht_ltf_08_us_gi",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x08, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_32_39_max_nc,
     {"Max Nc", "wlan.eht.phy_capabilities.bits_32_39.max_nc",
      FT_UINT8, BASE_DEC, NULL, 0xf0, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_40_63,
     {"EHT PHY Bits 40-63", "wlan.eht.phy_capabilities.bits_40_63",
      FT_UINT24, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_40_63_non_triggered_cqi_fbck,
     {"Non-Triggered CQI Feedback",
      "wlan.eht.phy_capabilities.bits_40_63.non_triggered_cqi_fbck",
      FT_BOOLEAN, 24, TFS(&tfs_supported_not_supported),
      0x000001, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_40_63_tx_1024_4096_qam_lt_242_ru_support,
     {"Tx 1024-QAM & 4096-QAM < 242-tone RU Support",
      "wlan.eht.phy_capabilities.bits_40_63.tx_1024_4096_qam_lt_242_ru_support",
      FT_BOOLEAN, 24, TFS(&tfs_supported_not_supported),
      0x000002, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_40_63_rx_1024_4096_qam_lt_242_ru_support,
     {"Rx 1024-QAM & 4096-QAM < 242-tone-RU Support",
      "wlan.eht.phy_capabilities.bits_40_63.rx_1024_4096_qam_lt_242_ru_support",
      FT_BOOLEAN, 24, TFS(&tfs_supported_not_supported),
      0x000004, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_40_63_ppe_thresholds_present,
     {"PPE Thresholds Present",
      "wlan.eht.phy_capabilities.bits_40_63.ppe_thresholds_present",
      FT_BOOLEAN, 24, TFS(&tfs_present_not_present),
      0x000008, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_40_63_common_nominal_packet_padding,
     {"Common Nominal Packet Padding",
      "wlan.eht.phy_capabilities.bits_40_63.common_nominal_packet_padding",
      FT_UINT24, BASE_DEC, NULL, 0x000030, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_40_63_max_num_supported_eht_ltfs,
     {"Maximum Number Of Supported EHT-LTFs",
      "wlan.eht.phy_capabilities.bits_40_63.max_num_supported_eht_ltfs",
      FT_UINT24, BASE_DEC, NULL, 0x0007c0, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_40_63_support_of_mcx_15,
     {"Support Of MCS 15",
      "wlan.eht.phy_capabilities.bits_40_63.support_of_mcs_15",
      FT_UINT24, BASE_DEC, NULL, 0x007800, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_40_63_support_of_eht_dup_in_6_ghz,
     {"Support Of EHT DUP (MCS 14) in 6 GHz",
      "wlan.eht.phy_capabilities.bits_40_63.support_eht_dup_6_ghz",
      FT_BOOLEAN, 24, TFS(&tfs_supported_not_supported),
      0x008000, NULL, HFILL }},
    {&hf_ieee80211_eht_phy_bits_40_63_support_20_mhz_sta_ndp_wide_bw,
     {"Support For 20 MHz Operating STA Receiving NDP With Wider BW",
      "wlan.eht.phy_capabilities.bits_40_63.support_20_mhz_sta_recv_ndp_wider_bw",
      FT_BOOLEAN, 24, TFS(&tfs_supported_not_supported),
      0x010000, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_40_63_non_ofdma_ul_mu_bw_le_80_mhz,
     {"Non-OFDMA UL MU-MIMO (BW <= 80 MHz)",
      "wlan.eht.phy_capabilities.bits_40_63.non_ofdma_ul_mu_mimo_bw_lt_80_mhz",
      FT_BOOLEAN, 24, TFS(&tfs_supported_not_supported),
      0x020000, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_40_63_non_ofdma_ul_mu_bw_eq_160_mhz,
     {"Non-OFDMA UL MU-MIMO (BW = 160 MHz)",
      "wlan.eht.phy_capabilities.bits_40_63.non_ofdma_ul_mu_mimo_bw_eq_160_mhz",
      FT_BOOLEAN, 24, TFS(&tfs_supported_not_supported),
      0x040000, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_40_63_non_ofdma_ul_mu_bw_eq_320_mhz,
     {"Non-OFDMA UL MU-MIMO (BW = 320 MHz)",
      "wlan.eht.phy_capabilities.bits_40_63.non_ofdma_ul_mu_mimo_bw_eq_320_mhz",
      FT_BOOLEAN, 24, TFS(&tfs_supported_not_supported),
      0x080000, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_40_63_mu_beamformer_bw_le_80_mhz,
     {"MU Beamformer (BW <= 80 MHz)",
      "wlan.eht.phy_capabilities.bits_40_63.mu_beamformer_bw_le_80_mhz",
      FT_BOOLEAN, 24, TFS(&tfs_supported_not_supported),
      0x100000, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_40_63_mu_beamformer_bw_eq_160_mhz,
     {"MU Beamformer (BW = 160 MHz)",
      "wlan.eht.phy_capabilities.bits_40_63.mu_beamformer_bw_eq_160_mhz",
      FT_BOOLEAN, 24, TFS(&tfs_supported_not_supported),
      0x200000, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_40_63_mu_beamformer_bw_eq_320_mhz,
     {"MU Beamformer (BW = 320 MHz)",
      "wlan.eht.phy_capabilities.bits_40_63.mu_beamformer_bw_eq_320_mhz",
      FT_BOOLEAN, 24, TFS(&tfs_supported_not_supported),
      0x400000, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_40_63_tb_sounding_feedback_rate_limit,
     {"TB Sounding Feedback Rate Limit",
      "wlan.eht.phy_capabilities.bits_40_63.tb_sounding_fbck_rate_limit",
      FT_BOOLEAN, 24, TFS(&tfs_supported_not_supported),
      0x800000, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_64_71,
     {"EHT PHY Bits 64-71", "wlan.eht.phy_capabilities.bits_64_71",
      FT_UINT24, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_64_71_rx_1024_qam_wid_bw_dl_ofdma_sup,
     {"Rx 1024-QAM In Wider Bandwidth DL OFDMA Support",
      "wlan.eht.phy_capabilities.bits_64_71.rx_1024_qam_in_wider_bw_dl_ofdma",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported),
      0x01, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_64_71_rx_4096_qam_wid_bw_dl_ofdma_sup,
     {"Rx 4096-QAM In Wider Bandwidth DL OFDMA SUpport",
      "wlan.eht.phy_capabilities.bits_64_71.rx_4096_qam_in_wider_bw_dl_ofdma",
      FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported),
      0x02, NULL, HFILL }},

    {&hf_ieee80211_eht_phy_bits_64_71_reserved,
     {"Reserved", "wlan.eht.phy_capabilities.bits_64_71.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xFC, NULL, HFILL }},

    {&hf_ieee80211_eht_mcs_and_nss_non_ap,
     {"EHT-MCS Map (20 MHz-Only Non-AP STA)",
      "wlan.eht.supported_eht_mcs_bss_set.20_mhz_only_non_sta",
       FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_rx_max_nss_20mhz_0_7,
     {"RX Max NSS That Supports EHt-MCS 0-7",
      "wlan.eht.supported_eht_mcs_bss_non_sta.rx_max_nss_supports_eht_mcs_0_7",
      FT_UINT32, BASE_HEX, NULL, 0x0000000F, NULL, HFILL }},

    {&hf_ieee80211_eht_tx_max_nss_20mhz_0_7,
     {"TX Max NSS That Supports EHt-MCS 0-7",
      "wlan.eht.supported_eht_mcs_bss_non_sta.tx_max_nss_supports_eht_mcs_0_7",
      FT_UINT32, BASE_HEX, NULL, 0x000000F0, NULL, HFILL }},

    {&hf_ieee80211_eht_rx_max_nss_20mhz_8_9,
     {"RX Max NSS That Supports EHt-MCS 8-9",
      "wlan.eht.supported_eht_mcs_bss_non_sta.rx_max_nss_supports_eht_mcs_8_9",
      FT_UINT32, BASE_HEX, NULL, 0x00000F00, NULL, HFILL }},

    {&hf_ieee80211_eht_tx_max_nss_20mhz_8_9,
     {"TX Max NSS That Supports EHt-MCS 8-9",
      "wlan.eht.supported_eht_mcs_bss_non_sta.tx_max_nss_supports_eht_mcs_8_9",
      FT_UINT32, BASE_HEX, NULL, 0x0000F000, NULL, HFILL }},

    {&hf_ieee80211_eht_rx_max_nss_20mhz_10_11,
     {"RX Max NSS That Supports EHt-MCS 10-11",
      "wlan.eht.supported_eht_mcs_bss_non_sta.rx_max_nss_supports_eht_mcs_10_11",
      FT_UINT32, BASE_HEX, NULL, 0x000F0000, NULL, HFILL }},

    {&hf_ieee80211_eht_tx_max_nss_20mhz_10_11,
     {"TX Max NSS That Supports EHt-MCS 10-11",
      "wlan.eht.supported_eht_mcs_bss_non_sta.tx_max_nss_supports_eht_mcs_10_11",
      FT_UINT32, BASE_HEX, NULL, 0x00F00000, NULL, HFILL }},

    {&hf_ieee80211_eht_rx_max_nss_20mhz_12_13,
     {"RX Max NSS That Supports EHt-MCS 12-13",
      "wlan.eht.supported_eht_mcs_bss_non_sta.rx_max_nss_supports_eht_mcs_12_13",
      FT_UINT32, BASE_HEX, NULL, 0x0F000000, NULL, HFILL }},

    {&hf_ieee80211_eht_tx_max_nss_20mhz_12_13,
     {"TX Max NSS That Supports EHt-MCS 12-13",
      "wlan.eht.supported_eht_mcs_bss_non_sta.tx_max_nss_supports_eht_mcs_12_13",
      FT_UINT32, BASE_HEX, NULL, 0xF0000000, NULL, HFILL }},

    {&hf_ieee80211_eht_mcs_and_nss_le_80mhz,
     {"EHT-MCS Map (BW <= 80MHz)",
      "wlan.eht.supported_eht_mcs_bss_set.eht_mcs_map_bw_le_80_mhz",
      FT_UINT24, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_le_80_rx_max_nss_0_9,
     {"Rx Max Nss That Supports EHT-MCS 0-9",
      "wlan.eht.supported_eht_mcs_bss_set.le_80.rx_max_nss_supports_eht_mcs_0_9",
      FT_UINT24, BASE_DEC, NULL, 0x00000F, NULL, HFILL }},

    {&hf_ieee80211_eht_le_80_tx_max_nss_0_9,
     {"Tx Max Nss That Supports EHT-MCS 0-9",
      "wlan.eht.supported_eht_mcs_bss_set.le_80.tx_max_nss_supports_eht_mcs_0_9",
      FT_UINT24, BASE_DEC, NULL, 0x0000F0, NULL, HFILL }},

    {&hf_ieee80211_eht_le_80_rx_max_nss_10_11,
     {"Rx Max Nss That Supports EHT-MCS 10-11",
      "wlan.eht.supported_eht_mcs_bss_set.le_80.rx_max_nss_supports_eht_mcs_10_11",
      FT_UINT24, BASE_DEC, NULL, 0x000F00, NULL, HFILL }},

    {&hf_ieee80211_eht_le_80_tx_max_nss_10_11,
     {"Tx Max Nss That Supports EHT-MCS 10-11",
      "wlan.eht.supported_eht_mcs_bss_set.le_80.tx_max_nss_supports_eht_mcs_10_11",
      FT_UINT24, BASE_DEC, NULL, 0x00F000, NULL, HFILL }},

    {&hf_ieee80211_eht_le_80_rx_max_nss_12_13,
     {"Rx Max Nss That Supports EHT-MCS 12-13",
      "wlan.eht.supported_eht_mcs_bss_set.le_80.rx_max_nss_supports_eht_mcs_12_13",
      FT_UINT24, BASE_DEC, NULL, 0x0F0000, NULL, HFILL }},

    {&hf_ieee80211_eht_le_80_tx_max_nss_12_13,
     {"Tx Max Nss That Supports EHT-MCS 12-13",
      "wlan.eht.supported_eht_mcs_bss_set.le_80.tx_max_nss_supports_eht_mcs_12_13",
      FT_UINT24, BASE_DEC, NULL, 0xF00000, NULL, HFILL }},

    {&hf_ieee80211_eht_mcs_and_nss_eq_160mhz,
     {"EHT-MCS Map (BW = 160MHz)",
      "wlan.eht.supported_eht_mcs_bss_set.eht_mcs_map_bw_eq_160_mhz",
      FT_UINT24, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_160_rx_max_nss_0_9,
     {"Rx Max Nss That Supports EHT-MCS 0-9",
      "wlan.eht.supported_eht_mcs_bss_set.160.rx_max_nss_supports_eht_mcs_0_9",
      FT_UINT24, BASE_DEC, NULL, 0x00000F, NULL, HFILL }},

    {&hf_ieee80211_eht_160_tx_max_nss_0_9,
     {"Tx Max Nss That Supports EHT-MCS 0-9",
      "wlan.eht.supported_eht_mcs_bss_set.160.tx_max_nss_supports_eht_mcs_0_9",
      FT_UINT24, BASE_DEC, NULL, 0x0000F0, NULL, HFILL }},

    {&hf_ieee80211_eht_160_rx_max_nss_10_11,
     {"Rx Max Nss That Supports EHT-MCS 10-11",
      "wlan.eht.supported_eht_mcs_bss_set.160.rx_max_nss_supports_eht_mcs_10_11",
      FT_UINT24, BASE_DEC, NULL, 0x000F00, NULL, HFILL }},

    {&hf_ieee80211_eht_160_tx_max_nss_10_11,
     {"Tx Max Nss That Supports EHT-MCS 10-11",
      "wlan.eht.supported_eht_mcs_bss_set.160.tx_max_nss_supports_eht_mcs_10_11",
      FT_UINT24, BASE_DEC, NULL, 0x00F000, NULL, HFILL }},

    {&hf_ieee80211_eht_160_rx_max_nss_12_13,
     {"Rx Max Nss That Supports EHT-MCS 12-13",
      "wlan.eht.supported_eht_mcs_bss_set.160.rx_max_nss_supports_eht_mcs_12_13",
      FT_UINT24, BASE_DEC, NULL, 0x0F0000, NULL, HFILL }},

    {&hf_ieee80211_eht_160_tx_max_nss_12_13,
     {"Tx Max Nss That Supports EHT-MCS 12-13",
      "wlan.eht.supported_eht_mcs_bss_set.160.tx_max_nss_supports_eht_mcs_12_13",
      FT_UINT24, BASE_DEC, NULL, 0xF00000, NULL, HFILL }},

    {&hf_ieee80211_eht_mcs_and_nss_eq_320mhz,
     {"EHT-MCS Map (BW = 320MHz)",
      "wlan.eht.supported_eht_mcs_bss_set.eht_mcs_map_bw_eq_320_mhz",
      FT_UINT24, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_320_rx_max_nss_0_9,
     {"Rx Max Nss That Supports EHT-MCS 0-9",
      "wlan.eht.supported_eht_mcs_bss_set.320.rx_max_nss_supports_eht_mcs_0_9",
      FT_UINT24, BASE_DEC, NULL, 0x00000F, NULL, HFILL }},

    {&hf_ieee80211_eht_320_tx_max_nss_0_9,
     {"Tx Max Nss That Supports EHT-MCS 0-9",
      "wlan.eht.supported_eht_mcs_bss_set.320.tx_max_nss_supports_eht_mcs_0_9",
      FT_UINT24, BASE_DEC, NULL, 0x0000F0, NULL, HFILL }},

    {&hf_ieee80211_eht_320_rx_max_nss_10_11,
     {"Rx Max Nss That Supports EHT-MCS 10-11",
      "wlan.eht.supported_eht_mcs_bss_set.320.rx_max_nss_supports_eht_mcs_10_11",
      FT_UINT24, BASE_DEC, NULL, 0x000F00, NULL, HFILL }},

    {&hf_ieee80211_eht_320_tx_max_nss_10_11,
     {"Tx Max Nss That Supports EHT-MCS 10-11",
      "wlan.eht.supported_eht_mcs_bss_set.320.tx_max_nss_supports_eht_mcs_10_11",
      FT_UINT24, BASE_DEC, NULL, 0x00F000, NULL, HFILL }},

    {&hf_ieee80211_eht_320_rx_max_nss_12_13,
     {"Rx Max Nss That Supports EHT-MCS 12-13",
      "wlan.eht.supported_eht_mcs_bss_set.320.rx_max_nss_supports_eht_mcs_12_13",
      FT_UINT24, BASE_DEC, NULL, 0x0F0000, NULL, HFILL }},

    {&hf_ieee80211_eht_320_tx_max_nss_12_13,
     {"Tx Max Nss That Supports EHT-MCS 12-13",
      "wlan.eht.supported_eht_mcs_bss_set.320.tx_max_nss_supports_eht_mcs_12_13",
      FT_UINT24, BASE_DEC, NULL, 0xF00000, NULL, HFILL }},

    {&hf_ieee80211_eht_supported_mcs_nss_bytes,
     {"Supported EHT-MCS and NSS Set bytes",
      "wlan.eht.supported_eht_mcs_nss_set.bytes",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_ppe_thresholds,
     {"EHT PPE Thresholds", "wlan.eht.ppe_thresholds",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_ttl_mapping_control,
     {"TID-To-Link Mapping Control",
      "wlan.eht.tid_to_link_mapping.control",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_ttl_mapping_direction,
     {"Direction", "wlan.eht.tid_to_link_mapping.control.direction",
      FT_UINT8, BASE_HEX, VALS(tid_to_link_mapping_dirn_vals), 0x03,
      NULL, HFILL }},

    {&hf_ieee80211_eht_ttl_default_link_mapping,
     {"Default Link Mapping",
      "wlan.eht.tid_to_link_mapping.control.default_link_mapping",
      FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},

    {&hf_ieee80211_eht_ttl_mapping_switch_time_pres,
     {"Mapping Switch Time Present",
      "wlan.eht.tid_to_link_mapping.control.mapping_switch_time",
      FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},

    {&hf_ieee80211_eht_ttl_expected_dura_pres,
     {"Expected Duration Present",
      "wlan.eht.tid_to_link_mapping.control.expected_duration",
      FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},

    {&hf_ieee80211_eht_ttl_link_mapping_size,
     {"Link Mapping Size",
      "wlan.eht.tid_to_link_mapping.control.link_mapping_size",
      FT_UINT8, BASE_DEC, VALS(ttl_link_mapping_size_vals), 0x20, NULL, HFILL }},

    {&hf_ieee80211_eht_ttl_mapping_reserved,
     {"Reserved", "wlan.eht.tid_to_link_mapping.control.reserved",
      FT_UINT8, BASE_HEX, NULL, 0xC0, NULL, HFILL }},

    {&hf_ieee80211_eht_ttl_mapping_presence,
     {"Link Mapping Presence Indicator",
      "wlan.eht.tid_to_link_mapping.control.link_mapping_presence_indicator",
      FT_UINT8, BASE_HEX, NULL, 0x00, NULL, HFILL }},

    {&hf_ieee80211_eht_ttl_mapping_switch_time,
     {"Mapping Switch Time", "wlan.eht.tid_to_link_mapping.switch_time",
      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_ttl_mapping_expected_duration,
     {"Expected Duration", "wlan.eht.tid_to_link_mapping.expected_duration",
      FT_UINT24, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_ttl_mapping_tid_0_link_mapping,
     {"Link Mapping Of TID 0", "wlan.eht.tid_to_link_mapping.tid_0.link_mapping",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_ttl_mapping_tid_1_link_mapping,
     {"Link Mapping Of TID 1", "wlan.eht.tid_to_link_mapping.tid_1.link_mapping",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_ttl_mapping_tid_2_link_mapping,
     {"Link Mapping Of TID 2", "wlan.eht.tid_to_link_mapping.tid_2.link_mapping",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_ttl_mapping_tid_3_link_mapping,
     {"Link Mapping Of TID 3", "wlan.eht.tid_to_link_mapping.tid_3.link_mapping",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_ttl_mapping_tid_4_link_mapping,
     {"Link Mapping Of TID 4", "wlan.eht.tid_to_link_mapping.tid_4.link_mapping",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_ttl_mapping_tid_5_link_mapping,
     {"Link Mapping Of TID 5", "wlan.eht.tid_to_link_mapping.tid_5.link_mapping",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_ttl_mapping_tid_6_link_mapping,
     {"Link Mapping Of TID 6", "wlan.eht.tid_to_link_mapping.tid_6.link_mapping",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_ttl_mapping_tid_7_link_mapping,
     {"Link Mapping Of TID 7", "wlan.eht.tid_to_link_mapping.tid_7.link_mapping",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_traffic_control,
     {"Multi-Link Traffic Control",
      "wlan.eht.multi_link_traffic.traffic_control",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_tc_bitmap_size,
     {"Bitmap Size", "wlan.eht.multi_link_traffic.traffic_control.bitmap_size",
      FT_UINT16, BASE_CUSTOM, CF_FUNC(extra_one_base_custom), 0x000F, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_tc_aid_offset,
     {"AID Offset", "wlan.eht.multi_link_traffic.traffic_control.aid_offset",
      FT_UINT16, BASE_DEC, NULL, 0x7FF0, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_tc_reserved,
     {"Reserved", "wlan.eht.multi_link_traffic.traffic_control.reserved",
      FT_UINT16, BASE_HEX, NULL, 0x8000, NULL, HFILL }},

    {&hf_ieee80211_eht_multi_link_traffic_indication,
     {"Traffic Indication List",
      "wlan.eht.multi_link_traffic.traffic_indication_list",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_dirn,
     {"Direction", "wlan.eht.qos_characteristics.control.direction",
      FT_UINT32, BASE_HEX, VALS(qos_chars_dirn_vals),
      0x00000003, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_tid,
     {"TID", "wlan.eht.qos_characteristics.control.tid",
      FT_UINT32, BASE_HEX, NULL, 0x0000003C, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_user_prio,
     {"User Priority", "wlan.eht.qos_characteristics.control.user_priority",
      FT_UINT32, BASE_HEX, NULL, 0x000001C0, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_bitmap,
     {"Presence Bitmap of Additional Parameters",
      "wlan.eht.qos_characteristics.control.presence_bitmap",
      FT_UINT32, BASE_HEX, NULL, 0x01FFFE00, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_linkid,
     {"LinkID", "wlan.eht.qos_characteristics.control.linkid",
      FT_UINT32, BASE_HEX, NULL, 0x1E000000, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_resrvd,
     {"Reserved", "wlan.eht.qos_characteristics.control.reserved",
      FT_UINT32, BASE_HEX, NULL, 0xE0000000, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_min_svc_interval,
     {"Minimum Service Interval",
      "wlan.eht.qos_characteristics.minimum_service_interval",
      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_max_svc_interval,
     {"Maximum Service Interval",
      "wlan.eht.qos_characteristics.maximum_service_interval",
      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_min_data_rate,
     {"Minimum Data Rate",
      "wlan.eht.qos_characteristics.minimal_data_rate",
      FT_UINT24, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_delay_bound,
     {"Delay Bound",
      "wlan.eht.qos_characteristics.delay_bound",
      FT_UINT24, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_max_msdu_size,
     {"Maximum MSDU Size", "wlan.eht.qos_characteristics.max_msdu_size",
      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_service_start_time,
     {"Service Start Time", "wlan.eht.qos_characteristics.service_start_time",
      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_service_start_time_linkid,
     {"Service Start Time LinkID", "wlan.eht.qos_characteristics.service_start_time_linkid",
      FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_mean_data_rate,
     {"Mean Data Rate", "wlan.eht.qos_characteristics.mean_data_rate",
      FT_UINT24, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_burst_size,
     {"Burst Size", "wlan.eht.qos_characteristics.burst_size",
      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_msdu_lifetime,
     {"MSDU Lifetime", "wlan.eht.qos_characteristics.msdu_lifetime",
      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_msdu_delivery_ratio,
     {"MSDU Delivery Ratio", "wlan.eht.qos_characteristics.msdu_delivery_ratio",
      FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_msdu_count_exponent,
     {"MSDU Count Exponent", "wlan.eht.qos_characteristics.msdu_count_exponent",
      FT_UINT8, BASE_DEC, NULL, 0xf0, NULL, HFILL }},

    {&hf_ieee80211_eht_qos_chars_medium_time,
     {"Medium Time", "wlan.eht.qos_characteristics.medium_time",
      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_link_id_bitmap,
     {"Link ID Bitmap", "wlan.eht.link_id_bitmap",
      FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_eht_aid_bitmap_length,
     {"Partial AID Bitmap Length", "wlan.eht.aid_bitmap.length",
      FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_eht_aid_bitmap_control,
     {"Bitmap Control", "wlan.eht.aid_bitmap.control",
      FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_eht_aid_bitmap_control_offset,
     {"Bitmap Offset", "wlan.eht.aid_bitmap.control.offset",
      FT_UINT8, BASE_HEX, NULL, 0xfe, NULL, HFILL }},

    {&hf_ieee80211_eht_aid_bitmap_control_reserved,
     {"Reserved", "wlan.eht.aid_bitmap.control.reserved",
      FT_UINT8, BASE_HEX, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_eht_aid_bitmap_partial_aid_bitmap,
     {"Partial AID Bitmap", "wlan.eht.aid_bitmap.partial_aid_bitmap",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_aid_bitmap_aid,
     {"Association ID", "wlan.eht.aid_bitmap.aid",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_bw_indi_param,
     {"Bandwidth Indication Parameters", "wlan.eht.bw_indication_params",
      FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_bw_indi_param_reserved,
     {"Reserved", "wlan.eht.bw_indication_params.reserved",
      FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},

    {&hf_ieee80211_eht_bw_indi_param_disabled_subchan_bitmap,
     {"Disabled Subchannel Bitmap Present", "wlan.eht.bw_indication_params.disabled_subchan_bitamp",
      FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},

    {&hf_ieee80211_eht_bw_indi_param_reserved1,
     {"Reserved", "wlan.eht.bw_indication_params.reserved1",
      FT_UINT8, BASE_HEX, NULL, 0xfc, NULL, HFILL }},

    {&hf_ieee80211_eht_bw_indi_diabled_bitmap,
     {"Disabled Subchannel Bitmap",
      "wlan.eht.bw_indication.disabled_subchannel_bitmap",
      FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_mimo_ctrl_field,
     {"EHT MIMO Control", "wlan.eht.mimo.control",
      FT_UINT40, BASE_HEX, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_mimo_ctrl_nc_index,
     {"Nc Index", "wlan.eht.mimo.control.nc_index",
      FT_UINT40, BASE_DEC, NULL, 0x000000000F, NULL, HFILL }},

    {&hf_ieee80211_eht_mimo_ctrl_nr_index,
     {"Nr Index", "wlan.eht.mimo.control.nr_index",
      FT_UINT40, BASE_DEC, NULL, 0x00000000F0, NULL, HFILL }},

    {&hf_ieee80211_eht_mimo_ctrl_bw,
     {"BW", "wlan.eht.mimo.control.bw",
      FT_UINT40, BASE_DEC|BASE_VAL64_STRING, VALS64(eht_mimo_bw_vals),
      0x0000000700, NULL, HFILL }},

    {&hf_ieee80211_eht_mimo_ctrl_grouping,
     {"Grouping", "wlan.eht.mimo.control.grouping",
      FT_UINT40, BASE_DEC|BASE_VAL64_STRING, VALS64(eht_mimo_grouping_vals),
      0x0000000800, NULL, HFILL }},

    {&hf_ieee80211_eht_mimo_ctrl_feedback_type,
     {"Feedback Type", "wlan.eht.mimo.control.feedback_type",
      FT_UINT40, BASE_DEC|BASE_VAL64_STRING, VALS64(eht_feedback_type_vals),
      0x0000003000, NULL, HFILL }},

    {&hf_ieee80211_eht_mimo_ctrl_reserved1,
     {"Reserved", "wlan.eht.mimo.control.reserved1",
      FT_UINT40, BASE_HEX, NULL, 0x000001C000, NULL, HFILL }},

    {&hf_ieee80211_eht_mimo_ctrl_remaining_feedback_segments,
     {"Remaining Feedback Segments",
      "wlan.eht.mimo.control.remaining_feedback_segments",
      FT_UINT40, BASE_DEC, NULL, 0x00000E0000, NULL, HFILL }},

    {&hf_ieee80211_eht_mimo_ctrl_first_feedback_segment,
     {"First Feedback Segment", "wlan.eht.mimo.control.first_feedback_segment",
      FT_UINT40, BASE_DEC, NULL, 0x0000100000, NULL, HFILL }},

    {&hf_ieee80211_eht_mimo_ctrl_partial_bw_info,
     {"Partial BW Info", "wlan.eht.mimo.control.partial_bw_info",
      FT_UINT40, BASE_HEX, NULL, 0x003FE00000, NULL, HFILL }},

    {&hf_ieee80211_eht_mimo_ctrl_sounding_dialog_token_number,
     {"Sounding Dialog Token Number",
      "wlan.eht.mimo.control.sounding_dialog_token_number",
      FT_UINT40, BASE_DEC, NULL, 0x0FC0000000, NULL, HFILL }},

    {&hf_ieee80211_eht_mimo_ctrl_codebook_info,
     {"Codebook Information", "wlan.eht.mimo.control.codebook_info",
      FT_UINT40, BASE_DEC, NULL, 0x1000000000, NULL, HFILL }},

    {&hf_ieee80211_eht_mimo_ctrl_reserved2,
     {"Reserved", "wlan.eht.mimo.control.reserved2",
      FT_UINT40, BASE_HEX, NULL, 0xE000000000, NULL, HFILL }},

    {&hf_ieee80211_eht_compressed_beamforming_report_snr,
     {"AgvSNR", "wlan.eht.mimo.beamforming_report.avgsnr",
      FT_INT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},

    {&hf_ieee80211_eht_compressed_beamform_scidx,
     {"SCIDX", "wlan.eht.mimo.beamforming_report.scidx",
      FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

    {&hf_ieee80211_eht_mu_exclusive_beamforming_report_delta_snr,
     {"Delta SNR", "wlan.eht.mu.exclusive_beamforming_report.delta_snr",
      FT_INT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},
  };

  static hf_register_info aggregate_fields[] = {
    {&hf_ieee80211_amsdu_subframe,
     {"A-MSDU Subframe", "wlan_aggregate.a_msdu.subframe",
      FT_NONE, BASE_NONE, NULL, 0x0,
      "Aggregate MAC Service Data Unit (MSDU) Subframe", HFILL }},

    {&hf_ieee80211_amsdu_length,
     {"A-MSDU Length", "wlan_aggregate.a_msdu.length",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_ieee80211_amsdu_padding,
     {"A-MSDU Padding", "wlan_aggregate.a_msdu.padding",
      FT_BYTES, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},
  };

  static uat_field_t wep_uat_flds[] = {

      UAT_FLD_VS(uat_wep_key_records, key, "Key type", wep_type_vals,
                        "Decryption key type used"),
      UAT_FLD_CSTRING(uat_wep_key_records, string, "Key",
                        "wep:<wep hexadecimal key>\n"
                        "wpa-pwd:<passphrase>[:<ssid>]\n"
                        "wpa-psk:<wpa hexadecimal key>\n"
                        "tk:<hexadecimal key>\n"
                        "msk:<hexadecimal key>\n"),
      UAT_END_FIELDS
    };

  static int *tree_array[] = {
    &ett_80211,
    &ett_proto_flags,
    &ett_cap_tree,
    &ett_fc_tree,
    &ett_cntrl_wrapper_fc,
    &ett_cntrl_wrapper_payload,
    &ett_fragments,
    &ett_fragment,
    &ett_block_ack,
    &ett_block_ack_tid,
    &ett_block_ack_request_control,
    &ett_block_ack_bitmap,
    &ett_block_ack_request_multi_sta_aid_tid,
    &ett_multi_sta_block_ack,
    &ett_ath_cap_tree,
    &ett_extreme_mesh_services_tree,
    &ett_addr,

    &ett_80211_mgt,
    &ett_fixed_parameters,
    &ett_tagged_parameters,
    &ett_tag_bmapctl_tree,
    &ett_s1g_pvb_tree,
    &ett_s1g_pvb_eb_tree,
    &ett_s1g_pvb_block_control_byte,
    &ett_s1g_pvb_block_bitmap_tree,
    &ett_s1g_pvb_subblock_tree,
    &ett_s1g_pvb_olb_tree,
    &ett_s1g_pvb_ade_control,
    &ett_s1g_pvb_ade_tree,
    &ett_s1g_pvb_olb_subblock,
    &ett_tag_country_fnm_tree,
    &ett_tag_country_rcc_tree,
    &ett_qos_parameters,
    &ett_qos_ps_buf_state,
    &ett_wep_parameters,
    &ett_msh_control,
    &ett_hwmp_targ_flags_tree,
    &ett_mesh_chswitch_flag_tree,
    &ett_mesh_config_cap_tree,
    &ett_mesh_formation_info_tree,
    &ett_bcn_timing_rctrl_tree,
    &ett_bcn_timing_info_tree,
    &ett_gann_flags_tree,
    &ett_pxu_proxy_info_tree,
    &ett_pxu_proxy_info_flags_tree,

    &ett_rsn_gcs_tree,
    &ett_rsn_pcs_tree,
    &ett_rsn_sub_pcs_tree,
    &ett_rsn_akms_tree,
    &ett_rsn_sub_akms_tree,
    &ett_rsn_cap_tree,
    &ett_rsn_pmkid_tree,
    &ett_rsn_gmcs_tree,

    &ett_kde_mlo_link_info,

    &ett_wpa_mcs_tree,
    &ett_wpa_ucs_tree,
    &ett_wpa_sub_ucs_tree,
    &ett_wpa_akms_tree,
    &ett_wpa_sub_akms_tree,
    &ett_wme_ac,
    &ett_wme_aci_aifsn,
    &ett_wme_ecw,
    &ett_wme_qos_info,

    &ett_update_edca_info,

    &ett_ht_cap_tree,
    &ett_ampduparam_tree,
    &ett_mcsset_tree,
    &ett_mcsbit_tree,
    &ett_htex_cap_tree,
    &ett_txbf_tree,
    &ett_antsel_tree,
    &ett_hta_cap_tree,
    &ett_hta_cap1_tree,
    &ett_hta_cap2_tree,

    &ett_s1g_ndp,
    &ett_s1g_ndp_ack,
    &ett_s1g_ndp_cts,
    &ett_s1g_ndp_cf_end,
    &ett_s1g_ndp_ps_poll,
    &ett_s1g_ndp_ps_poll_ack,
    &ett_s1g_ndp_block_ack,
    &ett_s1g_ndp_beamforming_report_poll,
    &ett_s1g_ndp_paging,
    &ett_s1g_ndp_probe,
    &ett_pv1_sid,
    &ett_pv1_sid_field,
    &ett_pv1_seq_control,
    &ett_ieee80211_s1g_capabilities_info,
    &ett_ieee80211_s1g_capabilities,
    &ett_s1g_cap_byte1,
    &ett_s1g_cap_byte2,
    &ett_s1g_cap_byte3,
    &ett_s1g_cap_byte4,
    &ett_s1g_cap_byte5,
    &ett_s1g_cap_byte6,
    &ett_s1g_cap_byte7,
    &ett_s1g_cap_byte8,
    &ett_s1g_cap_byte9,
    &ett_s1g_cap_byte10,
    &ett_ieee80211_s1g_sup_mcs_and_nss_set,
    &ett_s1g_mcs_and_mcs_set,
    &ett_s1g_operation_info,
    &ett_s1g_channel_width,
    &ett_s1g_subchannel_selective_transmission,
    &ett_s1g_raw_assignment,
    &ett_s1g_raw_assn_tree,
    &ett_s1g_raw_control,
    &ett_s1g_raw_slot_def,
    &ett_s1g_raw_group_subfield,
    &ett_s1g_raw_channel_indication,
    &ett_s1g_page_slice_control,
    &ett_s1g_aid_request_mode,
    &ett_s1g_aid_characteristic,
    &ett_s1g_sector_operation,
    &ett_tack_info,
    &ett_ieee80211_s1g_auth_control,
    &ett_s1g_relay_control,
    &ett_s1g_relay_function,
    &ett_ieee80211_s1g_addr_list,
    &ett_ieee80211_s1g_reach_addr,
    &ett_s1g_relay_discovery_control,
    &ett_ieee80211_s1g_aid_entry,
    &ett_s1g_probe_resp_subfield_0,
    &ett_s1g_header_comp_control,
    &ett_pv1_mgmt_action,
    &ett_pv1_mgmt_action_no_ack,
    &ett_pv1_cntl_stack,
    &ett_pv1_cntl_bat,

    &ett_htc_tree,
    &ett_htc_he_a_control,
    &ett_mfb_subtree,
    &ett_lac_subtree,
    &ett_ieee80211_a_control_padding,
    &ett_ieee80211_a_control_ones,
    &ett_ieee80211_triggered_response_schedule,
    &ett_ieee80211_control_om,
    &ett_ieee80211_hla_control,
    &ett_ieee80211_buffer_status_report,
    &ett_ieee80211_control_uph,
    &ett_ieee80211_buffer_control_bqr,
    &ett_ieee80211_control_cci,
    &ett_ieee80211_control_eht_om,
    &ett_ieee80211_control_srs,
    &ett_ieee80211_control_aar,

    &ett_vht_cap_tree,
    &ett_vht_mcsset_tree,
    &ett_vht_rx_mcsbit_tree,
    &ett_vht_tx_mcsbit_tree,
    &ett_vht_basic_mcsbit_tree,
    &ett_vht_op_tree,
    &ett_vht_tpe_info_tree,
    &ett_tpe_psd,

    &ett_vht_ranging_annc,

    &ett_ff_he_action,
    &ett_ff_protected_he_action,
    &ett_ff_protected_eht_action,
    &ett_ff_he_mimo_control,
    &ett_ff_he_mimo_beamforming_report_snr,
    &ett_ff_he_mimo_feedback_matrices,

    &ett_ff_vhtmimo_cntrl,
    &ett_ff_vhtmimo_beamforming_report,
    &ett_ff_vhtmimo_beamforming_report_snr,
    &ett_ff_vhtmimo_beamforming_angle,
    &ett_ff_vhtmimo_beamforming_report_feedback_matrices,
    &ett_ff_vhtmu_exclusive_beamforming_report_matrices,

    &ett_vht_grpidmgmt,
    &ett_vht_msa,
    &ett_vht_upa,

    &ett_ht_info_delimiter1_tree,
    &ett_ht_info_delimiter2_tree,
    &ett_ht_info_delimiter3_tree,

    &ett_ff_ftm_param_delim1,
    &ett_ff_ftm_param_delim2,
    &ett_ff_ftm_param_delim3,
    &ett_ff_ftm_tod_err1,
    &ett_ff_ftm_toa_err1,
    &ett_tag_ranging,
    &ett_tag_ranging_ntb,

    &ett_ranging_subelement_tree,

    &ett_tag_direct_meas_results,

    &ett_rsta_avail_header,
    &ett_rsta_avail_tree,
    &ett_rsta_avail_subfield,

    &ett_pasn_parameters,
    &ett_pasn_comeback_tree,
    &ett_pasn_auth_frame,

    /* 802.11be tree */
    &ett_eht_multi_link_control,
    &ett_eht_multi_link_common_info,
    &ett_eht_multi_link_common_info_link_id,
    &ett_eht_multi_link_common_info_medium_sync,
    &ett_eht_multi_link_common_info_eml_capa,
    &ett_eht_multi_link_common_info_mld_capa,
    &ett_eht_multi_link_common_info_ext_mld_capa,
    &ett_eht_multi_link_per_sta,
    &ett_eht_multi_link_subelt,
    &ett_eht_multi_link_sta_control,
    &ett_eht_multi_link_per_sta_info,
    &ett_eht_multi_link_sta_dtim,
    &ett_eht_multi_link_reconf_oper_param,
    &ett_eht_multi_link_reconfig_presence_indi,
    &ett_eht_multi_link_reconfig_operation_para_info,
    &ett_eht_operation_params,
    &ett_eht_operation_control,
    &ett_eht_mac_capa,
    &ett_eht_phy_capa,
    &ett_eht_phy_bits_0_15,
    &ett_eht_phy_bits_16_31,
    &ett_eht_phy_bits_32_39,
    &ett_eht_phy_bits_40_63,
    &ett_eht_phy_bits_64_71,
    &ett_eht_phy_mcs_nss,
    &ett_eht_phy_mcs_nss_set,
    &ett_eht_ttl_mapping,
    &ett_eht_ttl_mapping_link_mapping,
    &ett_eht_eht_multi_link_tc,
    &ett_eht_qos_characteristics,
    &ett_eht_aid_bmapctl_tree,
    &ett_eht_bw_indication_param,
    &ett_eht_eml_control,
    &ett_eht_eml_control_link_map,
    &ett_eht_eml_control_mcs_map_count,
    &ett_eht_emlsr_para_update,
    &ett_eht_mimo_ctrl,
    &ett_eht_beamforming_rpt_ru_index,
    &ett_eht_beamforming_feedback_tree,
    &ett_ff_eht_mimo_beamforming_report_snr,
    &ett_ff_eht_mimo_mu_exclusive_report,
    &ett_eht_mu_exclusive_beamforming_rpt_ru_index,

    &ett_tag_measure_request_mode_tree,
    &ett_tag_measure_request_type_tree,
    &ett_tag_measure_request_sub_element_tree,
    &ett_tag_measure_report_mode_tree,
    &ett_tag_measure_report_type_tree,
    &ett_tag_measure_report_basic_map_tree,
    &ett_tag_measure_report_rpi_tree,
    &ett_tag_measure_report_frame_tree,
    &ett_tag_measure_report_sub_element_tree,
    &ett_tag_measure_reported_frame_tree,
    &ett_tag_measure_reported_frame_frag_id_tree,
    &ett_tag_measure_reported_lci_z_tree,
    &ett_tag_measure_reported_lci_urp_tree,
    &ett_tag_bss_bitmask_tree,
    &ett_tag_dfs_map_tree,
    &ett_tag_dfs_map_flags_tree,
    &ett_tag_erp_info_tree,
    &ett_tag_ex_cap1,
    &ett_tag_ex_cap2,
    &ett_tag_ex_cap3,
    &ett_tag_ex_cap4,
    &ett_tag_ex_cap5,
    &ett_tag_ex_cap6,
    &ett_tag_ex_cap7,
    &ett_tag_ex_cap8,
    &ett_tag_ex_cap89,
    &ett_tag_ex_cap10,
    &ett_tag_ex_cap11,
    &ett_tag_ex_cap12,
    &ett_tag_ex_cap13,

    &ett_tag_rm_cap1,
    &ett_tag_rm_cap2,
    &ett_tag_rm_cap3,
    &ett_tag_rm_cap4,
    &ett_tag_rm_cap5,

    &ett_tag_rsnx_octet1,
    &ett_tag_rsnx_octet2,

    &ett_tag_multiple_bssid_subelem_tree,

    &ett_tag_20_40_bc,

    &ett_tag_intolerant_tree,

    &ett_tag_tclas_mask_tree,

    &ett_tag_supported_channels,

    &ett_tag_neighbor_report_bssid_info_tree,
    &ett_tag_neighbor_report_bssid_info_capability_tree,
    &ett_tag_neighbor_report_subelement_tree,
    &ett_tag_neighbor_report_sub_tag_tree,

    &ett_tag_wapi_param_set_akm_tree,
    &ett_tag_wapi_param_set_ucast_tree,
    &ett_tag_wapi_param_set_mcast_tree,
    &ett_tag_wapi_param_set_preauth_tree,

    &ett_max_idle_period_options,

    &ett_tag_time_adv_tree,

    &ett_tag_he_6ghz_cap_inf_tree,

    &ett_ff_ba_param_tree,
    &ett_ff_ba_ssc_tree,
    &ett_ff_delba_param_tree,
    &ett_ff_qos_info,
    &ett_ff_psmp_param_set,
    &ett_ff_mimo_cntrl,
    &ett_ff_ant_sel,
    &ett_mimo_report,
    &ett_ff_sm_pwr_save,
    &ett_ff_chan_switch_announce,
    &ett_ff_ht_info,
    &ett_ff_psmp_sta_info,

    &ett_tpc,

    &ett_msdu_aggregation_parent_tree,
    &ett_msdu_aggregation_subframe_tree,

    &ett_80211_mgt_ie,
    &ett_tsinfo_tree,
    &ett_sched_tree,

    &ett_fcs,

    &ett_hs20_osu_providers_list,
    &ett_hs20_osu_provider_tree,
    &ett_hs20_friendly_names_list,
    &ett_hs20_friendly_name_tree,
    &ett_hs20_osu_provider_method_list,
    &ett_osu_icons_avail_list,
    &ett_hs20_osu_icon_tree,
    &ett_hs20_osu_service_desc_list,
    &ett_hs20_osu_service_desc_tree,
    &ett_hs20_venue_url,
    &ett_hs20_advice_of_charge,
    &ett_hs20_aoc_plan,

    &ett_hs20_ofn_tree,

    &ett_adv_proto,
    &ett_adv_proto_tuple,
    &ett_gas_query,
    &ett_gas_anqp,
    &ett_nai_realm,
    &ett_nai_realm_eap,
    &ett_tag_ric_data_desc_ie,
    &ett_anqp_vendor_capab,

    &ett_osen_group_data_cipher_suite,
    &ett_osen_pairwise_cipher_suites,
    &ett_osen_pairwise_cipher_suite,
    &ett_osen_akm_cipher_suites,
    &ett_osen_akm_cipher_suite,
    &ett_osen_rsn_cap_tree,
    &ett_osen_pmkid_list,
    &ett_osen_pmkid_tree,
    &ett_osen_group_management_cipher_suite,

    &ett_hs20_cc_proto_port_tuple,

    &ett_tag_no_bssid_capability_dmg_bss_control_tree,
    &ett_ssid_list,

    &ett_sgdsn,
    &ett_nintendo,

    &ett_routerboard,

    &ett_meru,

    &ett_wisun_gtkl,
    &ett_wisun_lgtkl,

    &ett_qos_map_set_exception,
    &ett_qos_map_set_range,

    &ett_wnm_notif_subelt,

    &ett_tag_mobility_domain_ft_capab_tree,

    &ett_tag_ft_mic_control_tree,
    &ett_tag_ft_subelem_tree,

    /* 802.11ad trees */
    &ett_dynamic_alloc_tree,
    &ett_ssw_tree,
    &ett_bf_tree,
    &ett_sswf_tree,
    &ett_brp_tree,
    &ett_blm_tree,
    &ett_bic_tree,
    &ett_dmg_params_tree,
    &ett_cc_tree,
    &ett_rcsi_tree,
    &ett_80211_ext,
    &ett_allocation_tree,
    &ett_sta_info,

    &ett_ieee80211_esp,
    &ett_ieee80211_wfa_60g_attr,
    &ett_ieee80211_wfa_transition_disable_tree,
    &ett_gas_resp_fragment,
    &ett_gas_resp_fragments,

    &ett_mbo_oce_attr,
    &ett_mbo_ap_cap,
    &ett_oce_cap,
    &ett_oce_metrics_cap,

    /* 802.11 ah trees */
    &ett_s1g_sync_control_tree,
    &ett_s1g_twt_information_control,
    &ett_s1g_sector_id_index,
    &ett_twt_tear_down_tree,
    &ett_twt_control_field_tree,
    &ett_twt_req_type_tree,
    &ett_twt_ndp_paging_field_tree,
    &ett_twt_broadcast_info_tree,
    &ett_twt_traffic_info_tree,
    &ett_twt_traffic_info_control_tree,

    /* 802.11ax trees */
    &ett_he_mac_capabilities,
    &ett_he_phy_capabilities,
    &ett_he_phy_cap_first_byte,
    &ett_he_phy_cap_chan_width_set,
    &ett_he_phy_cap_b8_to_b23,
    &ett_he_phy_cap_b24_to_b39,
    &ett_he_phy_cap_b40_to_b55,
    &ett_he_phy_cap_b56_to_b71,
    &ett_he_phy_cap_b72_to_b87,
    &ett_he_mcs_and_nss_set,
    &ett_he_rx_tx_he_mcs_map_lte_80,
    &ett_he_rx_mcs_map_lte_80,
    &ett_he_tx_mcs_map_lte_80,
    &ett_he_rx_tx_he_mcs_map_160,
    &ett_he_rx_mcs_map_160,
    &ett_he_tx_mcs_map_160,
    &ett_he_rx_tx_he_mcs_map_80_80,
    &ett_he_rx_mcs_map_80_80,
    &ett_he_tx_mcs_map_80_80,
    &ett_he_ppe_threshold,
    &ett_he_ppe_nss,
    &ett_he_ppe_ru_alloc,
    &ett_he_operation_params,
    &ett_he_bss_color_information,
    &ett_he_oper_basic_mcs,
    &ett_he_operation_vht_op_info,
    &ett_he_operation_6ghz,
    &ett_he_operation_6ghz_control,
    &ett_he_mu_edca_param,
    &ett_he_uora_tree,
    &ett_he_aic_aifsn,
    &ett_he_spatial_reuse_control,
    &ett_he_ess_report_info_field,
    &ett_he_bss_new_color_info,
    &ett_he_trigger_common_info,
    &ett_he_trigger_ranging,
    &ett_he_trigger_ranging_poll,
    &ett_he_trigger_packet_extension,
    &ett_he_trigger_base_common_info,
    &ett_he_trigger_bar_ctrl,
    &ett_he_trigger_bar_info,
    &ett_he_trigger_user_info,
    &ett_he_trigger_base_user_info,
    &ett_he_trigger_dep_basic_user_info,
    &ett_he_trigger_dep_nfrp_user_info,
    &ett_ndp_annc,
    &ett_ndp_vht_annc_sta_list,
    &ett_ndp_vht_annc_sta_info_tree,
    &ett_ndp_he_annc_sta_list,
    &ett_ndp_he_annc_sta_item,
    &ett_ndp_he_annc_sta_info,
    &ett_ndp_eht_annc_sta_list,
    &ett_ndp_eht_annc_sta_info,
    &ett_ndp_ranging_annc_sta_list,
    &ett_ndp_ranging_annc_sta_info,
    &ett_non_inheritance_element_id_list,
    &ett_non_inheritance_element_id_ext_list,
    &ett_mscs_user_prio,
    &ett_ieee80211_user_prio_bitmap,
    &ett_ieee80211_intra_access_prio,

    &ett_ieee80211_3gpp_plmn,

    /* 802.11ai trees */
    &ett_fils_indication_realm_list,
    &ett_fils_indication_public_key_list,

    &ett_neighbor_ap_info,
    &ett_tbtt_infos,
    &ett_rnr_bss_params_tree,
    &ett_rnr_mld_params_tree,

    &ett_qos_mgmt_dscp_policy_capabilities,
    &ett_qos_mgmt_pol_capa,
    &ett_qos_mgmt_attributes,
    &ett_qos_mgmt_dscp_policy,
    &ett_qos_mgmt_tclas,
    &ett_qos_mgmt_domain_name,
    &ett_qos_mgmt_unknown_attribute,
    &ett_dscp_policy_status_list,
    &ett_pol_rqst_cont_tree,
    &ett_pol_resp_cont_tree,

    &ett_ff_fils_discovery_frame_control,
    &ett_ff_fils_discovery_capability,

    &ett_ff_fils_req_params,
    &ett_ff_fils_req_params_fils_criteria,
  };

  static ei_register_info ei[] = {
    { &ei_ieee80211_bad_length,
      { "ieee80211.bad_length", PI_MALFORMED, PI_ERROR,
        "Wrong length indicated", EXPFILL }},

    { &ei_ieee80211_inv_val,
      { "ieee80211.invalid_value", PI_MALFORMED, PI_WARN,
        "Invalid value", EXPFILL }},

    { &ei_ieee80211_tag_number,
      { "wlan.tag.number.unexpected_ie", PI_MALFORMED, PI_ERROR,
        "Unexpected Information Element ID", EXPFILL }},

    { &ei_ieee80211_tag_length,
      { "wlan.tag.length.bad", PI_MALFORMED, PI_ERROR,
        "Bad tag length", EXPFILL }},

    { &ei_ieee80211_extra_data,
      { "ieee80211.extra_data", PI_MALFORMED, PI_WARN,
        "Unexpected extra data in the end", EXPFILL }},

    { &ei_ieee80211_ff_anqp_capability,
      { "wlan.fixed.anqp.capability.invalid", PI_MALFORMED, PI_ERROR,
        "Invalid vendor-specific ANQP capability", EXPFILL }},

    { &ei_ieee80211_ff_anqp_venue_length,
      { "wlan.fixed.anqp.venue.length.invalid", PI_MALFORMED, PI_ERROR,
        "Invalid Venue Name Duple length", EXPFILL }},

    { &ei_ieee80211_ff_anqp_roaming_consortium_oi_len,
      { "wlan.fixed.anqp.roaming_consortium.oi_len.invalid", PI_MALFORMED, PI_ERROR,
        "Invalid Roaming Consortium OI", EXPFILL }},

    { &ei_ieee80211_ff_anqp_nai_field_len,
      { "wlan.fixed.anqp.nai_realm_list.field_len.invalid", PI_MALFORMED, PI_ERROR,
        "Invalid NAI Realm List", EXPFILL }},

    { &ei_ieee80211_ff_anqp_nai_realm_eap_len,
      { "wlan.fixed.anqp_nai_realm_list.eap_method_len.invalid", PI_MALFORMED, PI_ERROR,
        "Invalid EAP Method subfield", EXPFILL }},

    { &ei_hs20_anqp_ofn_length,
      { "wlan.hs20.anqp.ofn.length.invalid", PI_MALFORMED, PI_ERROR,
        "Invalid Operator Friendly Name Duple length", EXPFILL }},

    { &ei_hs20_anqp_nai_hrq_length,
      { "wlan.hs20.anqp.nai_hrq.length.invalid", PI_MALFORMED, PI_ERROR,
        "Invalid NAI Home Realm Query length", EXPFILL }},

    { &ei_ieee80211_ff_anqp_info_length,
      { "wlan.fixed.anqp.info_length.invalid", PI_MALFORMED, PI_ERROR,
        "Invalid ANQP Info length", EXPFILL }},

    { &ei_ieee80211_not_enough_room_for_anqp_header,
      { "wlan.fixed.query_length_invalid", PI_MALFORMED, PI_ERROR,
        "Not enough room for ANQP header", EXPFILL }},

    { &ei_ieee80211_ff_query_request_length,
      { "wlan.fixed.query_request_length.invalid", PI_MALFORMED, PI_ERROR,
        "Invalid Query Request Length", EXPFILL }},

    { &ei_ieee80211_ff_query_response_length,
      { "wlan.fixed.query_response_length.invalid", PI_MALFORMED, PI_ERROR,
        "Invalid Query Response Length", EXPFILL }},

    { &ei_ieee80211_tag_wnm_sleep_mode_no_key_data,
      { "wlan.wnm_sleep_mode.no_key_data", PI_MALFORMED, PI_ERROR,
        "WNM-Sleep Mode Response is not long enough to include Key Data", EXPFILL }},

    { &ei_ieee80211_tdls_setup_response_malformed,
      { "wlan.tdls_setup_response_malformed", PI_MALFORMED, PI_ERROR,
        "TDLS Setup Response (success) does not include mandatory fields", EXPFILL }},

    { &ei_ieee80211_tdls_setup_confirm_malformed,
      { "wlan.tdls_setup_confirm_malformed", PI_MALFORMED, PI_ERROR,
        "TDLS Setup Confirm (success) does not include mandatory fields", EXPFILL }},

    { &ei_ieee80211_wfa_ie_wme_qos_info_bad_ftype,
      { "wlan.wfa.ie.wme.qos_info.bad_ftype", PI_UNDECODED, PI_WARN,
        "Could not deduce direction to decode correctly", EXPFILL }},

    { &ei_ieee80211_qos_info_bad_ftype,
      { "wlan.qos_info.bad_ftype", PI_UNDECODED, PI_WARN,
        "Could not deduce direction to decode correctly", EXPFILL }},

    { &ei_ieee80211_qos_bad_aifsn,
      { "wlan.qos_info.bad_aifsn", PI_MALFORMED, PI_WARN,
        "Invalid AIFSN", EXPFILL }},

    { &ei_ieee80211_rsn_pcs_count,
      { "wlan.rsn.pcs.count.invalid", PI_MALFORMED, PI_ERROR,
        "Pairwise Cipher Suite Count too large", EXPFILL }},

    { &ei_ieee80211_rsn_pmkid_count,
      { "wlan.rsn.akms.count.invalid", PI_MALFORMED, PI_ERROR,
        "Auth Key Management (AKM) Suite Count too large", EXPFILL }},

    { &ei_ieee80211_pmkid_count_too_large,
      { "wlan.rsn.pmkid.count.invalid", PI_MALFORMED, PI_ERROR,
        "PMKID Count too large", EXPFILL }},

    { &ei_ieee80211_vht_tpe_pwr_info_count,
      { "wlan.vht.tpe.pwr_info.count.invalid", PI_MALFORMED, PI_ERROR,
        "Max Tx Pwr Count is Incorrect, should be 0-7", EXPFILL }},

    { &ei_ieee80211_missing_data,
      { "ieee80211.missing_data", PI_MALFORMED, PI_WARN,
        "No Request subelements in TFS Request", EXPFILL }},

    { &ei_ieee80211_fc_retry,
      { "wlan.fc.retry.expert", PI_SEQUENCE, PI_NOTE,
        "Retransmission (retry)", EXPFILL }},

    { &ei_ieee80211_tag_measure_request_unknown,
      { "wlan.measure.req.unknown.expert", PI_UNDECODED, PI_WARN,
        "Undecoded Measurement Request type (or subtype), Contact Wireshark developers if you want this supported", EXPFILL }},

    { &ei_ieee80211_tag_measure_request_beacon_unknown,
      { "wlan.measure.req.beacon.unknown.expert", PI_UNDECODED, PI_WARN,
        "Unknown Data (not interpreted)", EXPFILL }},

    { &ei_ieee80211_tag_measure_report_unknown,
      { "wlan.measure.rep.unknown.expert", PI_UNDECODED, PI_WARN,
        "Undecoded Measurement Report type (or subtype), Contact Wireshark developers if you want this supported", EXPFILL }},

    { &ei_ieee80211_tag_measure_report_beacon_unknown,
      { "wlan.measure.rep.beacon.unknown.expert", PI_UNDECODED, PI_WARN,
        "Unknown Data (not interpreted)", EXPFILL }},

    { &ei_ieee80211_tag_measure_report_lci_unknown,
      { "wlan.measure.rep.lci.unknown.expert", PI_UNDECODED, PI_WARN,
        "Unknown Data (not interpreted)", EXPFILL }},

    { &ei_ieee80211_tag_data,
      { "wlan.tag.data.undecoded", PI_UNDECODED, PI_NOTE,
        "Dissector for 802.11 IE Tag code not implemented, Contact Wireshark developers if you want this supported", EXPFILL }},

    { &ei_ieee80211_dmg_subtype,
      { "wlan.dmg_subtype.bad", PI_MALFORMED, PI_ERROR,
        "Bad DMG type/subtype", EXPFILL }},

    { &ei_ieee80211_wfa_60g_attr_len_invalid,
      { "wlan.60g.attr.length.invalid", PI_MALFORMED, PI_ERROR,
        "Attribute length invalid", EXPFILL }},

    { &ei_ieee80211_vht_action,
      { "wlan.vht.action.undecoded", PI_UNDECODED, PI_NOTE,
        "All subtype of VHT Action is not yet supported by Wireshark", EXPFILL }},

    { &ei_ieee80211_mesh_peering_unexpected,
      { "wlan.peering.unexpected", PI_MALFORMED, PI_ERROR,
        "Unexpected Self-protected action", EXPFILL }},

    { &ei_ieee80211_wfa_60g_unknown_attribute,
      { "wlan.attr.unknown", PI_MALFORMED, PI_ERROR,
        "Attribute unknown", EXPFILL }},

    { &ei_ieee80211_fcs,
      { "wlan.fcs.bad_checksum", PI_MALFORMED, PI_ERROR,
        "Bad checksum", EXPFILL }},

    { &ei_ieee80211_mismatched_akm_suite,
      { "wlan.rsn.akms.mismatched", PI_PROTOCOL, PI_ERROR,
        "Mismatched AKMS", EXPFILL }},

    { &ei_ieee80211_vs_routerboard_unexpected_len,
      { "wlan.vs.routerboard.unexpected_len", PI_PROTOCOL, PI_WARN,
        "Unexpected IE Length", EXPFILL }},

    { &ei_ieee80211_vs_sgdsn_serialnumber_invalid_len_val,
      { "wlan.vs.sgdsn.tag.serialnumber.invalid_len_val", PI_PROTOCOL, PI_ERROR,
        "Invalid serial number length value", EXPFILL }},

    { &ei_ieee80211_vs_sgdsn_serialnumber_unexpected_len_val,
      { "wlan.vs.sgdsn.tag.serialnumber.unexpected_len_val", PI_PROTOCOL, PI_WARN,
        "Unexpected serial number length", EXPFILL }},

    { &ei_ieee80211_twt_tear_down_bad_neg_type,
      { "wlan.twt.tear_down_bad_neg_type", PI_PROTOCOL, PI_ERROR,
        "Bad Negotiation type for S1G TWT Flow field in TWT teardown", EXPFILL }},

    { &ei_ieee80211_twt_setup_bad_command,
      { "wlan.twt.setup_bad_command", PI_PROTOCOL, PI_ERROR,
        "This TWT Setup Command is not allowed, check the TWT Request field", EXPFILL }},

    { &ei_ieee80211_twt_bcast_info_no_term,
      { "wlan.twt.incorrect_length", PI_PROTOCOL, PI_ERROR,
        "Incorrect length or missing Last Broadcast Parameter Set field", EXPFILL }},

    { &ei_ieee80211_invalid_control_word,
      { "wlan.htc.he.a_control.invalid", PI_PROTOCOL, PI_ERROR,
        "Invalid control word", EXPFILL }},

    { &ei_ieee80211_invalid_control_id,
      { "wlan.htc.he.a_control.ctrl_id.invalid", PI_PROTOCOL, PI_ERROR,
        "Invalid control word", EXPFILL }},

    { &ei_ieee80211_invalid_control_length,
      { "wlan.htc.he.a_control.ctrl_length.invalid", PI_PROTOCOL, PI_ERROR,
        "Incorrect Control Information Length", EXPFILL }},

    { &ei_ieee80211_htc_in_dmg_packet,
      { "wlan.htc_in_dmg_packet", PI_PROTOCOL, PI_ERROR,
        "DMG frame has the +HTC/Order bit set", EXPFILL }},

    { &ei_ieee80211_eht_invalid_subelement,
      { "wlan.eht.invalid_subelement", PI_PROTOCOL, PI_ERROR,
         "Incorrect EHT Sub-element length", EXPFILL }},

    { &ei_ieee80211_eht_invalid_action,
      { "wlan.eht.invalid_action", PI_PROTOCOL, PI_ERROR,
         "Invalid EHT Action field value", EXPFILL }},

    { &ei_ieee80211_eht_invalid_multi_link,
      { "wlan.eht.invalid_multi_link", PI_PROTOCOL, PI_ERROR,
         "Invalid EHT Multi-Link element", EXPFILL }},

     {&ei_ieee80211_eht_invalid_nc_nr,
       { "wlan.eht.invalid_nc_nr", PI_PROTOCOL, PI_WARN,
         "Invalid NR or NC in EHT MIMO Control", EXPFILL }},
  };

  expert_module_t *expert_ieee80211;

  module_t *wlan_module;

  memset(&wlan_stats, 0, sizeof wlan_stats);

  proto_aggregate = proto_register_protocol("IEEE 802.11 wireless LAN aggregate frame",
      "IEEE 802.11 Aggregate Data", "wlan_aggregate");
  proto_register_field_array(proto_aggregate, aggregate_fields, array_length(aggregate_fields));

  proto_wlan = proto_register_protocol("IEEE 802.11 wireless LAN", "IEEE 802.11", "wlan");

  heur_subdissector_list = register_heur_dissector_list_with_description("wlan_data", "IEEE 802.11 WLAN v0 data", proto_wlan);

  /* Created to remove Decode As confusion */
  proto_centrino = proto_register_protocol("IEEE 802.11 wireless LAN (Centrino)", "IEEE 802.11 (Centrino)", "wlan_centrino");
  proto_register_field_array(proto_wlan, hf, array_length(hf));
  centrino_handle = register_dissector("wlan_centrino",  dissect_ieee80211_centrino, proto_centrino );

  proto_wlan_ext = proto_register_protocol("IEEE 802.11 wireless LAN extension frame",
      "IEEE 802.11 EXT", "wlan_ext");

  proto_register_subtree_array(tree_array, array_length(tree_array));

  expert_ieee80211 = expert_register_protocol(proto_wlan);
  expert_register_field_array(expert_ieee80211, ei, array_length(ei));

  /*
   * Create the hash table we will use for holding STA properties that
   * track newer protocol varients like S1G, DMG, etc. Use the existing
   * retransmit hash and equal functions.
   */
  sta_prop_hash = wmem_map_new_autoreset(wmem_epan_scope(), wmem_file_scope(),
                                         sta_prop_hash_fn, sta_prop_equal_fn);

  ieee80211_handle = register_dissector("wlan", dissect_ieee80211,                    proto_wlan);
  register_dissector("wlan_withfcs",            dissect_ieee80211_withfcs,            proto_wlan);
  wlan_withoutfcs_handle = register_dissector("wlan_withoutfcs", dissect_ieee80211_withoutfcs, proto_wlan);
  register_dissector("wlan_bsfc",               dissect_ieee80211_bsfc,               proto_wlan);
  register_dissector("wlan_noqos",              dissect_ieee80211_noqos,              proto_wlan);

  register_capture_dissector("ieee80211", capture_ieee80211, proto_wlan);
  register_capture_dissector("ieee80211_datapad", capture_ieee80211_datapad, proto_wlan);

  reassembly_table_register(&wlan_reassembly_table,
                        &addresses_reassembly_table_functions);
  register_init_routine(wlan_retransmit_init);
  reassembly_table_register(&gas_reassembly_table,
                        &addresses_reassembly_table_functions);

  wlan_tap = register_tap("wlan");
  register_conversation_table(proto_wlan, true, wlan_conversation_packet, wlan_endpoint_packet);

  wlan_address_type = address_type_dissector_register("AT_ETHER_WLAN", "WLAN Address", ether_to_str, ether_str_len, NULL, wlan_col_filter_str,
                                                            ether_len, ether_name_resolution_str, ether_name_resolution_len);
  wlan_bssid_address_type = address_type_dissector_register("AT_ETHER_BSSID", "WLAN BSSID Address", ether_to_str, ether_str_len, NULL, wlan_bssid_col_filter_str,
                                                            ether_len, ether_name_resolution_str, ether_name_resolution_len);
  set_address(&bssid_broadcast, wlan_bssid_address_type, 6, bssid_broadcast_data);

  wlan_ra_ta_address_type = address_type_dissector_register("AT_ETHER_RA_TA", "WLAN RA/TA Address", ether_to_str, ether_str_len, NULL, wlan_ra_ta_col_filter_str,
                                                            ether_len, ether_name_resolution_str, ether_name_resolution_len);

  wlan_aid_address_type = address_type_dissector_register("AT_WLAN_AID", "WLAN Association ID", wlan_aid_to_str, wlan_aid_str_len, NULL, wlan_aid_col_filter_str, NULL, NULL, NULL);

  tagged_field_table = register_dissector_table("wlan.tag.number", "IEEE 802.11 Fields", proto_wlan, FT_UINT8, BASE_DEC);
  vendor_specific_action_table = register_dissector_table("wlan.action.vendor_specific", "IEEE802.11 Vendor Specific Action", proto_wlan, FT_UINT24, BASE_HEX);
  wifi_alliance_action_subtype_table = register_dissector_table("wlan.action.wifi_alliance.subtype", "Wi-Fi Alliance Action Subtype", proto_wlan, FT_UINT8, BASE_HEX);
  vendor_specific_anqp_info_table = register_dissector_table("wlan.anqp.vendor_specific", "IEEE802.11 ANQP information Vendor Specific", proto_wlan, FT_UINT24, BASE_HEX);
  wifi_alliance_anqp_info_table = register_dissector_table("wlan.anqp.wifi_alliance.subtype", "Wi-Fi Alliance ANQP Subtype", proto_wlan, FT_UINT8, BASE_HEX);
  wifi_alliance_ie_table = register_dissector_table("wlan.ie.wifi_alliance.subtype", "Wi-Fi Alliance IE Subtype", proto_wlan, FT_UINT8, BASE_HEX);
  wifi_alliance_public_action_table = register_dissector_table("wlan.pa.wifi_alliance.subtype", "Wi-Fi Alliance PA Subtype", proto_wlan, FT_UINT8, BASE_HEX);

  /* Register configuration options */
  wlan_module = prefs_register_protocol(proto_wlan, init_wepkeys);
  prefs_register_bool_preference(wlan_module, "defragment",
    "Reassemble fragmented 802.11 datagrams",
    "Whether fragmented 802.11 datagrams should be reassembled",
     &wlan_defragment);

  prefs_register_bool_preference(wlan_module, "ignore_draft_ht",
    "Ignore vendor-specific HT elements",
    "Don't dissect 802.11n draft HT elements (which might contain duplicate information).",
    &wlan_ignore_draft_ht);

  prefs_register_bool_preference(wlan_module, "retransmitted",
    "Call subdissector for retransmitted 802.11 frames",
    "Whether retransmitted 802.11 frames should be subdissected",
    &wlan_subdissector);

  prefs_register_bool_preference(wlan_module, "check_fcs",
    "Assume packets have FCS",
    "Some 802.11 cards include the FCS at the end of a packet, others do not.",
    &wlan_check_fcs);

  prefs_register_bool_preference(wlan_module, "check_checksum",
    "Validate the FCS checksum if possible",
    "Whether to validate the FCS checksum or not.",
    &wlan_check_checksum);

  prefs_register_enum_preference(wlan_module, "ignore_wep",
    "Ignore the Protection bit",
    "Some 802.11 cards leave the Protection bit set even though the packet is decrypted, "
    "and some also leave the IV (initialization vector).",
    &wlan_ignore_prot, wlan_ignore_prot_options, true);

  prefs_register_bool_preference(wlan_module, "wpa_key_mic_len_enable",
    "Enable WPA Key MIC Length override",
    "Whether to enable MIC Length override or not.",
    &wlan_key_mic_len_enable);

  prefs_register_uint_preference(wlan_module, "wpa_key_mic_len",
    "WPA Key MIC Length override",
    "Some Key MIC lengths are greater than 16 bytes, so set the length you require",
    10, &wlan_key_mic_len);

  prefs_register_bool_preference(wlan_module, "treat_as_s1g",
    "Treat as S1G", "Treat all WiFi packets as S1G",
    &treat_as_s1g);

  prefs_register_obsolete_preference(wlan_module, "wep_keys");

  prefs_register_bool_preference(wlan_module, "enable_decryption",
    "Enable decryption", "Enable WEP and WPA/WPA2 decryption",
    &enable_decryption);

  wep_uat = uat_new("WEP and WPA Decryption Keys",
            sizeof(uat_wep_key_record_t), /* record size */
            "80211_keys",                 /* filename */
            true,                         /* from_profile */
            &uat_wep_key_records,         /* data_ptr */
            &num_wepkeys_uat,             /* numitems_ptr */
            UAT_AFFECTS_DISSECTION,       /* affects dissection of packets, but not set of named fields */
            "Ch80211Keys",                /* help */
            uat_wep_key_record_copy_cb,   /* copy callback */
            uat_wep_key_record_update_cb, /* update callback */
            uat_wep_key_record_free_cb,   /* free callback */
            init_wepkeys,                 /* post update callback - update the WEP/WPA keys */
            NULL,                         /* reset callback */
            wep_uat_flds);                /* UAT field definitions */

  prefs_register_uat_preference(wlan_module,
                                "wep_key_table",
                                "Decryption keys",
                                "WEP and pre-shared WPA keys\n"
                                "Key examples: 01:02:03:04:05 (40/64-bit WEP),\n"
                                "010203040506070809101111213 (104/128-bit WEP),\n"
                                "MyPassword[:MyAP] (WPA + plaintext password [+ SSID]),\n"
                                "0102030405...6061626364 (WPA + 256-bit key)."
                                "Invalid keys will be ignored.",
                                wep_uat);
}

void
proto_register_wlan_rsna_eapol(void)
{

  static hf_register_info hf[] = {
    {&hf_wlan_rsna_eapol_wpa_keydes_msgnr,
     {"Message number", "wlan_rsna_eapol.keydes.msgnr",
      FT_UINT8, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_keyinfo,
     {"Key Information", "wlan_rsna_eapol.keydes.key_info",
      FT_UINT16, BASE_HEX, NULL, 0x0,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_keyinfo_keydes_version,
     {"Key Descriptor Version", "wlan_rsna_eapol.keydes.key_info.keydes_version",
      FT_UINT16, BASE_DEC, VALS(keydes_version_vals), KEY_INFO_KEYDES_VERSION_MASK,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_keyinfo_key_type,
     {"Key Type", "wlan_rsna_eapol.keydes.key_info.key_type",
      FT_BOOLEAN, 16, TFS(&keyinfo_key_type_tfs), KEY_INFO_KEY_TYPE_MASK,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_keyinfo_key_index,
     {"Key Index", "wlan_rsna_eapol.keydes.key_info.key_index",
      FT_UINT16, BASE_DEC, NULL, KEY_INFO_KEY_INDEX_MASK,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_keyinfo_install,
     {"Install", "wlan_rsna_eapol.keydes.key_info.install",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), KEY_INFO_INSTALL_MASK,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_keyinfo_key_ack,
     {"Key ACK", "wlan_rsna_eapol.keydes.key_info.key_ack",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), KEY_INFO_KEY_ACK_MASK,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_keyinfo_key_mic,
     {"Key MIC", "wlan_rsna_eapol.keydes.key_info.key_mic",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), KEY_INFO_KEY_MIC_MASK,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_keyinfo_secure,
     {"Secure", "wlan_rsna_eapol.keydes.key_info.secure",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), KEY_INFO_SECURE_MASK,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_keyinfo_error,
     {"Error", "wlan_rsna_eapol.keydes.key_info.error",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), KEY_INFO_ERROR_MASK,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_keyinfo_request,
     {"Request", "wlan_rsna_eapol.keydes.key_info.request",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), KEY_INFO_REQUEST_MASK,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_keyinfo_encrypted_key_data,
     {"Encrypted Key Data", "wlan_rsna_eapol.keydes.key_info.encrypted_key_data",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), KEY_INFO_ENCRYPTED_KEY_DATA_MASK,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_keyinfo_smk_message,
     {"SMK Message", "wlan_rsna_eapol.keydes.key_info.smk_message",
      FT_BOOLEAN, 16, TFS(&tfs_set_notset), KEY_INFO_SMK_MESSAGE_MASK,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_keydes_key_len,
     {"Key Length", "eapol.keydes.key_len",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_keydes_replay_counter,
     {"Replay Counter", "eapol.keydes.replay_counter",
      FT_UINT64, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_keydes_key_iv,
     {"Key IV", "eapol.keydes.key_iv",
      FT_BYTES, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_nonce,
     {"WPA Key Nonce", "wlan_rsna_eapol.keydes.nonce",
      FT_BYTES, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_rsc,
     {"WPA Key RSC", "wlan_rsna_eapol.keydes.rsc",
      FT_BYTES, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_id,
     {"WPA Key ID", "wlan_rsna_eapol.keydes.id",
      FT_BYTES, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_mic,
     {"WPA Key MIC", "wlan_rsna_eapol.keydes.mic",
      FT_BYTES, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_data_len,
     {"WPA Key Data Length", "wlan_rsna_eapol.keydes.data_len",
      FT_UINT16, BASE_DEC, NULL, 0x0,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_data,
     {"WPA Key Data", "wlan_rsna_eapol.keydes.data",
      FT_BYTES, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_keydes_padding,
     {"WPA Key Data Padding", "wlan_rsna_eapol.keydes.padding",
      FT_BYTES, BASE_NONE, NULL, 0x0,
      NULL, HFILL }},

    {&hf_wlan_rsna_eapol_wpa_extraneous,
     {"WPA EAPOL Extraneous Data", "wlan_rsna_eapol.extraneous",
      FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
  };

  static int *tree_array[] = {
    &ett_keyinfo,
    &ett_wlan_rsna_eapol_keydes_data,
  };

  proto_wlan_rsna_eapol = proto_register_protocol("IEEE 802.11 RSNA EAPOL key",
      "802.11 RSNA EAPOL", "wlan_rsna_eapol");
  proto_register_field_array(proto_wlan_rsna_eapol, hf, array_length(hf));

  proto_register_subtree_array(tree_array, array_length(tree_array));
}

void
proto_reg_handoff_ieee80211(void)
{
  dissector_handle_t data_encap_handle;
  dissector_handle_t wlan_rsna_eapol_wpa_key_handle, wlan_rsna_eapol_rsn_key_handle;
  capture_dissector_handle_t ieee80211_cap_handle;

  dissector_add_for_decode_as_with_preference("udp.port", ieee80211_handle);
  /*
   * Get handles for the 802.2 (LPD) LLC, EPD LLC, IPX and Ethernet
   * dissectors.
   */
  llc_handle            = find_dissector_add_dependency("llc", proto_wlan);
  epd_llc_handle        = find_dissector_add_dependency("epd_llc", proto_wlan);
  ipx_handle            = find_dissector_add_dependency("ipx", proto_wlan);
  eth_withoutfcs_handle = find_dissector_add_dependency("eth_withoutfcs", proto_wlan);

  /*
   * Get the Ethertype dissector table.
   */
  ethertype_subdissector_table = find_dissector_table("ethertype");

  llc_cap_handle = find_capture_dissector("llc");
  ipx_cap_handle = find_capture_dissector("ipx");

  dissector_add_uint("wtap_encap", WTAP_ENCAP_IEEE_802_11, ieee80211_handle);

  dissector_add_uint("ethertype", ETHERTYPE_CENTRINO_PROMISC, centrino_handle);

  ieee80211_cap_handle = find_capture_dissector("ieee80211");
  capture_dissector_add_uint("wtap_encap", WTAP_ENCAP_IEEE_802_11, ieee80211_cap_handle);
  capture_dissector_add_uint("wtap_encap", WTAP_ENCAP_IEEE_802_11_WITH_RADIO, ieee80211_cap_handle);
  capture_dissector_add_uint("ppi", 105 /* DLT_DLT_IEEE802_11 */, ieee80211_cap_handle);

  /* Register handoff to Aruba GRE */
  dissector_add_uint("gre.proto", GRE_ARUBA_8200, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_8210, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_8220, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_8230, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_8240, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_8250, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_8260, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_8270, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_8280, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_8290, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_82A0, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_82B0, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_82C0, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_82D0, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_82E0, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_82F0, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_8300, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_8310, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_8320, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_8330, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_8340, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_8350, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_8360, wlan_withoutfcs_handle);
  dissector_add_uint("gre.proto", GRE_ARUBA_8370, wlan_withoutfcs_handle);

  data_encap_handle = create_dissector_handle(dissect_data_encap, proto_wlan);
  dissector_add_uint("ethertype", ETHERTYPE_IEEE80211_DATA_ENCAP,
                data_encap_handle);

  /*
   * EAPOL key descriptor types.
   */
  wlan_rsna_eapol_wpa_key_handle = create_dissector_handle(dissect_wlan_rsna_eapol_wpa_or_rsn_key,
                                                               proto_wlan_rsna_eapol);
  dissector_add_uint("eapol.keydes.type", EAPOL_WPA_KEY, wlan_rsna_eapol_wpa_key_handle);
  wlan_rsna_eapol_rsn_key_handle = create_dissector_handle(dissect_wlan_rsna_eapol_wpa_or_rsn_key,
                                                               proto_wlan_rsna_eapol);
  dissector_add_uint("eapol.keydes.type", EAPOL_RSN_KEY, wlan_rsna_eapol_rsn_key_handle);

  dissector_add_uint("sflow_245.header_protocol", SFLOW_5_HEADER_80211_MAC, wlan_withoutfcs_handle);

  /* Tagged fields */
  /* XXX - for now, do it without pinos so the protocol is -1 */
  dissector_add_uint("wlan.tag.number", TAG_SSID, create_dissector_handle(ieee80211_tag_ssid, -1));
  dissector_add_uint("wlan.tag.number", TAG_SUPP_RATES, create_dissector_handle(ieee80211_tag_supp_rates, -1));
  dissector_add_uint("wlan.tag.number", TAG_FH_PARAMETER, create_dissector_handle(ieee80211_tag_fh_parameter, -1));
  dissector_add_uint("wlan.tag.number", TAG_DS_PARAMETER, create_dissector_handle(ieee80211_tag_ds_parameter, -1));
  dissector_add_uint("wlan.tag.number", TAG_CF_PARAMETER, create_dissector_handle(ieee80211_tag_cf_parameter, -1));
  dissector_add_uint("wlan.tag.number", TAG_TIM, create_dissector_handle(ieee80211_tag_tim, -1));
  dissector_add_uint("wlan.tag.number", TAG_IBSS_PARAMETER, create_dissector_handle(ieee80211_tag_ibss_parameter, -1));
  dissector_add_uint("wlan.tag.number", TAG_COUNTRY_INFO, create_dissector_handle(ieee80211_tag_country_info, -1));
  dissector_add_uint("wlan.tag.number", TAG_FH_HOPPING_PARAMETER, create_dissector_handle(ieee80211_tag_fh_hopping_parameter, -1));
  dissector_add_uint("wlan.tag.number", TAG_FH_HOPPING_TABLE, create_dissector_handle(ieee80211_tag_fh_hopping_table, -1));
  dissector_add_uint("wlan.tag.number", TAG_REQUEST, create_dissector_handle(ieee80211_tag_request, -1));
  dissector_add_uint("wlan.tag.number", TAG_QBSS_LOAD, create_dissector_handle(ieee80211_tag_qbss_load, -1));
  dissector_add_uint("wlan.tag.number", TAG_EDCA_PARAM_SET, create_dissector_handle(ieee80211_tag_edca_param_set, -1));
  dissector_add_uint("wlan.tag.number", TAG_TSPEC, create_dissector_handle(ieee80211_tag_tspec, -1));
  dissector_add_uint("wlan.tag.number", TAG_TCLAS, create_dissector_handle(ieee80211_tag_tclas, -1));
  dissector_add_uint("wlan.tag.number", TAG_SCHEDULE, create_dissector_handle(ieee80211_tag_schedule, -1));
  dissector_add_uint("wlan.tag.number", TAG_CHALLENGE_TEXT, create_dissector_handle(ieee80211_tag_challenge_text, -1));
  dissector_add_uint("wlan.tag.number", TAG_POWER_CONSTRAINT, create_dissector_handle(ieee80211_tag_power_constraint, -1));
  dissector_add_uint("wlan.tag.number", TAG_POWER_CAPABILITY, create_dissector_handle(ieee80211_tag_power_capability, -1));
  dissector_add_uint("wlan.tag.number", TAG_TPC_REQUEST, create_dissector_handle(ieee80211_tag_tpc_request, -1));
  dissector_add_uint("wlan.tag.number", TAG_TPC_REPORT, create_dissector_handle(ieee80211_tag_tpc_report, -1));
  dissector_add_uint("wlan.tag.number", TAG_SUPPORTED_CHANNELS, create_dissector_handle(ieee80211_tag_supported_channels, -1));
  dissector_add_uint("wlan.tag.number", TAG_CHANNEL_SWITCH_ANN, create_dissector_handle(ieee80211_tag_switch_ann, -1));
  dissector_add_uint("wlan.tag.number", TAG_MEASURE_REQ, create_dissector_handle(ieee80211_tag_measure_req, -1));
  dissector_add_uint("wlan.tag.number", TAG_MEASURE_REP, create_dissector_handle(ieee80211_tag_measure_rep, -1));
  dissector_add_uint("wlan.tag.number", TAG_QUIET, create_dissector_handle(ieee80211_tag_quiet, -1));
  dissector_add_uint("wlan.tag.number", TAG_IBSS_DFS, create_dissector_handle(ieee80211_tag_ibss_dfs, -1));
  dissector_add_uint("wlan.tag.number", TAG_ERP_INFO, create_dissector_handle(ieee80211_tag_erp_info, -1));
  dissector_add_uint("wlan.tag.number", TAG_ERP_INFO_OLD, create_dissector_handle(ieee80211_tag_erp_info, -1));
  dissector_add_uint("wlan.tag.number", TAG_TS_DELAY, create_dissector_handle(ieee80211_tag_ts_delay, -1));
  dissector_add_uint("wlan.tag.number", TAG_TCLAS_PROCESS, create_dissector_handle(ieee80211_tag_tclas_process, -1));
  dissector_add_uint("wlan.tag.number", TAG_QOS_CAPABILITY, create_dissector_handle(ieee80211_tag_qos_capability, -1));
  dissector_add_uint("wlan.tag.number", TAG_RSN_IE, create_dissector_handle(ieee80211_tag_rsn_ie, -1));
  dissector_add_uint("wlan.tag.number", TAG_EXT_SUPP_RATES, create_dissector_handle(ieee80211_tag_ext_supp_rates, -1));
  dissector_add_uint("wlan.tag.number", TAG_EXTENDED_CAPABILITIES, create_dissector_handle(dissect_extended_capabilities_ie, -1));
  dissector_add_uint("wlan.tag.number", TAG_CISCO_CCX1_CKIP, create_dissector_handle(ieee80211_tag_cisco_ccx1_ckip, -1));
  dissector_add_uint("wlan.tag.number", TAG_VHT_CAPABILITY, create_dissector_handle(dissect_vht_capability_ie, -1));
  dissector_add_uint("wlan.tag.number", TAG_VHT_OPERATION, create_dissector_handle(dissect_vht_operation_ie, -1));
  dissector_add_uint("wlan.tag.number", TAG_EXT_BSS_LOAD, create_dissector_handle(dissect_ext_bss_load, -1));
  dissector_add_uint("wlan.tag.number", TAG_WIDE_BW_CHANNEL_SWITCH, create_dissector_handle(dissect_wide_bw_channel_switch, -1));
  dissector_add_uint("wlan.tag.number", TAG_TX_PWR_ENVELOPE, create_dissector_handle(dissect_vht_tx_pwr_envelope, -1));
  dissector_add_uint("wlan.tag.number", TAG_CHANNEL_SWITCH_WRAPPER, create_dissector_handle(dissect_channel_switch_wrapper, -1));
  dissector_add_uint("wlan.tag.number", TAG_OPERATING_MODE_NOTIFICATION, create_dissector_handle(dissect_operating_mode_notification, -1));
  dissector_add_uint("wlan.tag.number", TAG_REDUCED_NEIGHBOR_REPORT, create_dissector_handle(dissect_reduced_neighbor_report, -1));
  dissector_add_uint("wlan.tag.number", TAG_FINE_TIME_MEASUREMENT_PARAM, create_dissector_handle(dissect_ftm_params, -1));
  dissector_add_uint("wlan.tag.number", TAG_S1G_CAPABILITIES, create_dissector_handle(dissect_s1g_capabilities, -1));
  dissector_add_uint("wlan.tag.number", TAG_SUBCHANNEL_SELECTIVE_TRANSMISSION, create_dissector_handle(dissect_subchannel_selective_transmission, -1));
  dissector_add_uint("wlan.tag.number", TAG_S1G_OPEN_LOOP_LINK_MARGIN_INDEX, create_dissector_handle(dissect_s1g_open_loop_link_margin_index, -1));
  dissector_add_uint("wlan.tag.number", TAG_RPS, create_dissector_handle(dissect_rps, -1));
  dissector_add_uint("wlan.tag.number", TAG_PAGE_SLICE, create_dissector_handle(dissect_page_slice, -1));
  dissector_add_uint("wlan.tag.number", TAG_AID_REQUEST, create_dissector_handle(dissect_aid_request, -1));
  dissector_add_uint("wlan.tag.number", TAG_AID_RESPONSE, create_dissector_handle(dissect_aid_response, -1));
  dissector_add_uint("wlan.tag.number", TAG_S1G_SECTOR_OPERATION, create_dissector_handle(dissect_s1g_sector_operation, -1));
  dissector_add_uint("wlan.tag.number", TAG_S1G_BEACON_COMPATIBILITY, create_dissector_handle(dissect_s1g_beacon_compatibility, -1));
  dissector_add_uint("wlan.tag.number", TAG_SHORT_BEACON_INTERVAL, create_dissector_handle(dissect_s1g_short_beacon_interval, -1));
  dissector_add_uint("wlan.tag.number", TAG_CHANGE_SEQUENCE, create_dissector_handle(dissect_s1g_change_sequence, -1));
  /* 7.3.2.26 Vendor Specific information element (221) */
  dissector_add_uint("wlan.tag.number", TAG_VENDOR_SPECIFIC_IE, create_dissector_handle(ieee80211_tag_vendor_specific_ie, -1));
  dissector_add_uint("wlan.tag.number", TAG_AUTHENTICATION_CONTROL, create_dissector_handle(dissect_authentication_control, -1));
  dissector_add_uint("wlan.tag.number", TAG_TSF_TIMER_ACCURACY, create_dissector_handle(dissect_tsf_timer_accuracy, -1));
  dissector_add_uint("wlan.tag.number", TAG_S1G_RELAY, create_dissector_handle(dissect_s1g_relay, -1));
  dissector_add_uint("wlan.tag.number", TAG_REACHABLE_ADDRESS, create_dissector_handle(dissect_reachable_address, -1));
  dissector_add_uint("wlan.tag.number", TAG_S1G_RELAY_DISCOVERY, create_dissector_handle(dissect_s1g_relay_discovery, -1));
  dissector_add_uint("wlan.tag.number", TAG_S1G_RELAY_ACTIVATION, create_dissector_handle(dissect_s1g_relay_activation, -1));
  dissector_add_uint("wlan.tag.number", TAG_AID_ANNOUNCEMENT, create_dissector_handle(dissect_aid_announcement, -1));
  dissector_add_uint("wlan.tag.number", TAG_PV1_PROBE_RESPONSE_OPTION, create_dissector_handle(dissect_pv1_probe_response_option, -1));
  dissector_add_uint("wlan.tag.number", TAG_EL_OPERATION, create_dissector_handle(dissect_el_operation, -1));
  dissector_add_uint("wlan.tag.number", TAG_SECTORIZED_GROUP_ID_LIST, create_dissector_handle(dissect_sectorized_group_id_list, -1));
  dissector_add_uint("wlan.tag.number", TAG_S1G_OPERATION, create_dissector_handle(dissect_s1g_operation, -1));
  dissector_add_uint("wlan.tag.number", TAG_HEADER_COMPRESSION, create_dissector_handle(dissect_header_compression, -1));
  dissector_add_uint("wlan.tag.number", TAG_SST_OPERATION, create_dissector_handle(dissect_sst_operation, -1));
  dissector_add_uint("wlan.tag.number", TAG_MAD, create_dissector_handle(dissect_max_away_duration, -1));
  /* This Cisco proprietary IE seems to mimic 221 */
  dissector_add_uint("wlan.tag.number", TAG_CISCO_VENDOR_SPECIFIC, create_dissector_handle(ieee80211_tag_vendor_specific_ie, -1));
  dissector_add_uint("wlan.tag.number", TAG_SYMBOL_PROPRIETARY, create_dissector_handle(ieee80211_tag_symbol_proprietary_ie, -1));
  dissector_add_uint("wlan.tag.number", TAG_MOBILITY_DOMAIN, create_dissector_handle(dissect_mobility_domain, -1));
  dissector_add_uint("wlan.tag.number", TAG_FAST_BSS_TRANSITION, create_dissector_handle(dissect_fast_bss_transition, -1));
  dissector_add_uint("wlan.tag.number", TAG_MMIE, create_dissector_handle(dissect_mmie, -1));
  dissector_add_uint("wlan.tag.number", TAG_NO_BSSID_CAPABILITY, create_dissector_handle(dissect_no_bssid_capability, -1));
  dissector_add_uint("wlan.tag.number", TAG_SSID_LIST, create_dissector_handle(dissect_ssid_list, -1));
  dissector_add_uint("wlan.tag.number", TAG_MULTIPLE_BSSID_INDEX, create_dissector_handle(dissect_multiple_bssid_index, -1));
  dissector_add_uint("wlan.tag.number", TAG_TIME_ZONE, create_dissector_handle(dissect_time_zone, -1));
  dissector_add_uint("wlan.tag.number", TAG_TIMEOUT_INTERVAL, create_dissector_handle(dissect_timeout_interval, -1));
  dissector_add_uint("wlan.tag.number", TAG_RIC_DATA, create_dissector_handle(dissect_ric_data, -1));
  dissector_add_uint("wlan.tag.number", TAG_LINK_IDENTIFIER, create_dissector_handle(dissect_link_identifier, -1));
  dissector_add_uint("wlan.tag.number", TAG_WAKEUP_SCHEDULE, create_dissector_handle(dissect_wakeup_schedule, -1));
  dissector_add_uint("wlan.tag.number", TAG_CHANNEL_SWITCH_TIMING, create_dissector_handle(dissect_channel_switch_timing, -1));
  dissector_add_uint("wlan.tag.number", TAG_PTI_CONTROL, create_dissector_handle(dissect_pti_control, -1));
  dissector_add_uint("wlan.tag.number", TAG_PU_BUFFER_STATUS, create_dissector_handle(dissect_pu_buffer_status, -1));
  dissector_add_uint("wlan.tag.number", TAG_HT_CAPABILITY, create_dissector_handle(dissect_ht_capability_ie, -1));
  dissector_add_uint("wlan.tag.number", TAG_HT_INFO, create_dissector_handle(dissect_ht_info_ie_1_1, -1));
  dissector_add_uint("wlan.tag.number", TAG_SECONDARY_CHANNEL_OFFSET, create_dissector_handle(dissect_secondary_channel_offset_ie, -1));
  dissector_add_uint("wlan.tag.number", TAG_RCPI, create_dissector_handle(dissect_rcpi_ie, -1));
  dissector_add_uint("wlan.tag.number", TAG_BSS_AVG_ACCESS_DELAY, create_dissector_handle(dissect_bss_avg_access_delay_ie, -1));
  dissector_add_uint("wlan.tag.number", TAG_ANTENNA, create_dissector_handle(dissect_antenna_ie, -1));
  dissector_add_uint("wlan.tag.number", TAG_RSNI, create_dissector_handle(dissect_rsni_ie, -1));
  dissector_add_uint("wlan.tag.number", TAG_MEASURE_PILOT_TRANS, create_dissector_handle(dissect_measurement_pilot_trans_ie, -1));
  dissector_add_uint("wlan.tag.number", TAG_BSS_AVB_ADM_CAPACITY, create_dissector_handle(dissect_bss_available_admission_capacity_ie, -1));
  dissector_add_uint("wlan.tag.number", TAG_IE_68_CONFLICT, create_dissector_handle(ieee80211_tag_ie_68_conflict, -1));
  dissector_add_uint("wlan.tag.number", TAG_BSS_MAX_IDLE_PERIOD, create_dissector_handle(dissect_bss_max_idle_period, -1));
  dissector_add_uint("wlan.tag.number", TAG_TFS_REQUEST, create_dissector_handle(dissect_tfs_request, -1));
  dissector_add_uint("wlan.tag.number", TAG_TFS_RESPONSE, create_dissector_handle(dissect_tfs_response, -1));
  dissector_add_uint("wlan.tag.number", TAG_WNM_SLEEP_MODE, create_dissector_handle(dissect_wnm_sleep_mode, -1));
  dissector_add_uint("wlan.tag.number", TAG_TIME_ADV, create_dissector_handle(dissect_time_adv, -1));
  dissector_add_uint("wlan.tag.number", TAG_RM_ENABLED_CAPABILITY, create_dissector_handle(dissect_rm_enabled_capabilities_ie, -1));
  dissector_add_uint("wlan.tag.number", TAG_MULTIPLE_BSSID, create_dissector_handle(dissect_multiple_bssid_ie, -1));
  dissector_add_uint("wlan.tag.number", TAG_20_40_BSS_CO_EX, create_dissector_handle(dissect_20_40_bss_coexistence, -1));
  dissector_add_uint("wlan.tag.number", TAG_20_40_BSS_INTOL_CH_REP, create_dissector_handle(dissect_20_40_bss_intolerant, -1));
  dissector_add_uint("wlan.tag.number", TAG_OVERLAP_BSS_SCAN_PAR, create_dissector_handle(dissect_overlap_bss_scan_par, -1));
  dissector_add_uint("wlan.tag.number", TAG_RIC_DESCRIPTOR, create_dissector_handle(dissect_ric_descriptor, -1));
  dissector_add_uint("wlan.tag.number", TAG_MESH_PEERING_MGMT, create_dissector_handle(ieee80211_tag_mesh_peering_mgmt, -1));
  dissector_add_uint("wlan.tag.number", TAG_MESH_CONFIGURATION, create_dissector_handle(ieee80211_tag_mesh_configuration, -1));
  dissector_add_uint("wlan.tag.number", TAG_MESH_ID, create_dissector_handle(ieee80211_tag_mesh_id, -1));
  dissector_add_uint("wlan.tag.number", TAG_BEACON_TIMING, create_dissector_handle(ieee80211_tag_beacon_timing, -1));
  dissector_add_uint("wlan.tag.number", TAG_GANN, create_dissector_handle(ieee80211_tag_gann, -1));
  dissector_add_uint("wlan.tag.number", TAG_MESH_PREQ, create_dissector_handle(ieee80211_tag_mesh_preq, -1));
  dissector_add_uint("wlan.tag.number", TAG_MESH_PREP, create_dissector_handle(ieee80211_tag_mesh_prep, -1));
  dissector_add_uint("wlan.tag.number", TAG_MESH_PERR, create_dissector_handle(ieee80211_tag_mesh_perr, -1));
  dissector_add_uint("wlan.tag.number", TAG_PXU, create_dissector_handle(ieee80211_tag_pxu, -1));
  dissector_add_uint("wlan.tag.number", TAG_PXUC, create_dissector_handle(ieee80211_tag_pxuc, -1));
  dissector_add_uint("wlan.tag.number", TAG_MIC, create_dissector_handle(ieee80211_tag_mic, -1));
  dissector_add_uint("wlan.tag.number", TAG_RANN, create_dissector_handle(ieee80211_tag_rann, -1));
  dissector_add_uint("wlan.tag.number", TAG_MESH_CHANNEL_SWITCH, create_dissector_handle(ieee80211_tag_mesh_channel_switch, -1));
  dissector_add_uint("wlan.tag.number", TAG_INTERWORKING, create_dissector_handle(dissect_interworking, -1));
  dissector_add_uint("wlan.tag.number", TAG_ADVERTISEMENT_PROTOCOL, create_dissector_handle(dissect_advertisement_protocol, -1));
  dissector_add_uint("wlan.tag.number", TAG_QOS_MAP_SET, create_dissector_handle(dissect_qos_map_set, -1));
  dissector_add_uint("wlan.tag.number", TAG_ROAMING_CONSORTIUM, create_dissector_handle(dissect_roaming_consortium, -1));
  dissector_add_uint("wlan.tag.number", TAG_AP_CHANNEL_REPORT, create_dissector_handle(dissect_ap_channel_report, -1));
  dissector_add_uint("wlan.tag.number", TAG_NEIGHBOR_REPORT, create_dissector_handle(dissect_neighbor_report, -1));
  dissector_add_uint("wlan.tag.number", TAG_MESH_AWAKE_WINDOW, create_dissector_handle(ieee80211_tag_mesh_awake_window, -1));
  dissector_add_uint("wlan.tag.number", TAG_EXTENDED_CHANNEL_SWITCH_ANNOUNCEMENT, create_dissector_handle(ieee80211_tag_channel_switch_announcement, -1));
  dissector_add_uint("wlan.tag.number", TAG_SUPPORTED_OPERATING_CLASSES, create_dissector_handle(ieee80211_tag_supported_operating_classes, -1));
  dissector_add_uint("wlan.tag.number", TAG_RELAY_CAPABILITIES, create_dissector_handle(add_tag_relay_capabilities, -1));
  dissector_add_uint("wlan.tag.number", TAG_DMG_BSS_PARAMETER_CHANGE, create_dissector_handle(ieee80211_tag_bss_parameter_change, -1));
  dissector_add_uint("wlan.tag.number", TAG_DMG_CAPABILITIES, create_dissector_handle(ieee80211_tag_dmg_capabilities, -1));
  dissector_add_uint("wlan.tag.number", TAG_DMG_OPERATION, create_dissector_handle(ieee80211_tag_dmg_operation, -1));
  dissector_add_uint("wlan.tag.number", TAG_ANTENNA_SECTOR_ID, create_dissector_handle(ieee80211_tag_antenna_section_id, -1));
  dissector_add_uint("wlan.tag.number", TAG_EXTENDED_SCHEDULE, create_dissector_handle(ieee80211_tag_extended_schedule, -1));
  dissector_add_uint("wlan.tag.number", TAG_STA_AVAILABILITY, create_dissector_handle(ieee80211_tag_sta_availability, -1));
  dissector_add_uint("wlan.tag.number", TAG_NEXT_DMG_ATI, create_dissector_handle(ieee80211_tag_next_dmg_ati, -1));
  dissector_add_uint("wlan.tag.number", TAG_NEXTPCP_LIST, create_dissector_handle(ieee80211_tag_nextpcp_list, -1));
  dissector_add_uint("wlan.tag.number", TAG_PCP_HANDOVER, create_dissector_handle(ieee80211_tag_pcp_handover, -1));
  dissector_add_uint("wlan.tag.number", TAG_BEAMLINK_MAINTENANCE, create_dissector_handle(ieee80211_tag_beamlink_maintenance, -1));
  dissector_add_uint("wlan.tag.number", TAG_QUIET_PERIOD_RES, create_dissector_handle(ieee80211_tag_quiet_period_res, -1));
  dissector_add_uint("wlan.tag.number", TAG_INTRA_ACCESS_CAT_PRIO, create_dissector_handle(ieee80211_tag_intra_access_cat_prio, -1));
  dissector_add_uint("wlan.tag.number", TAG_SCS_DESCRIPTOR, create_dissector_handle(ieee80211_tag_scs_descriptor, -1));
  dissector_add_uint("wlan.tag.number", TAG_RELAY_TRANSFER_PARAM, create_dissector_handle(ieee80211_tag_relay_transfer_param, -1));
  dissector_add_uint("wlan.tag.number", TAG_DMG_BEAM_REFINEMENT, create_dissector_handle(ieee80211_tag_dmg_beam_refinement, -1));
  dissector_add_uint("wlan.tag.number", TAG_WAKEUP_SCHEDULE_AD, create_dissector_handle(ieee80211_tag_wakeup_schedule_ad, -1));
  dissector_add_uint("wlan.tag.number", TAG_DMG_TSPEC, create_dissector_handle(ieee80211_tag_dmg_tspec, -1));
  dissector_add_uint("wlan.tag.number", TAG_CHANNEL_MEASURMENT_FB, create_dissector_handle(ieee80211_tag_channel_measurement_fb, -1));
  dissector_add_uint("wlan.tag.number", TAG_AWAKE_WINDOW, create_dissector_handle(ieee80211_tag_awake_window, -1));
  dissector_add_uint("wlan.tag.number", TAG_ADDBA_EXT, create_dissector_handle(ieee80211_tag_addba_ext, -1));
  dissector_add_uint("wlan.tag.number", TAG_MULTI_BAND, create_dissector_handle(ieee80211_tag_multi_band, -1));
  dissector_add_uint("wlan.tag.number", TAG_DMG_LINK_MARGIN, create_dissector_handle(ieee80211_tag_dmg_link_margin, -1));
  dissector_add_uint("wlan.tag.number", TAG_DMG_LINK_ADAPTION_ACK, create_dissector_handle(ieee80211_tag_dmg_link_adaption_ack, -1));
  dissector_add_uint("wlan.tag.number", TAG_FILS_INDICATION, create_dissector_handle(ieee80211_tag_fils_indication, -1));
  dissector_add_uint("wlan.tag.number", TAG_SWITCHING_STREAM, create_dissector_handle(ieee80211_tag_switching_stream, -1));
  dissector_add_uint("wlan.tag.number", TAG_ELEMENT_ID_EXTENSION, create_dissector_handle(ieee80211_tag_element_id_extension, -1));
  dissector_add_uint("wlan.tag.number", TAG_TWT, create_dissector_handle(ieee80211_tag_twt, -1));
  dissector_add_uint("wlan.tag.number", TAG_RSNX, create_dissector_handle(ieee80211_tag_rsnx, -1));

  /* Vendor specific actions */
  dissector_add_uint("wlan.action.vendor_specific", OUI_MARVELL, create_dissector_handle(dissect_vendor_action_marvell, -1));
  dissector_add_uint("wlan.action.vendor_specific", OUI_WFA, create_dissector_handle(dissect_vendor_action_wifi_alliance, -1));

  /* Protected action WFA ... */
  dissector_add_uint("wlan.action.wifi_alliance.subtype", WFA_SUBTYPE_ACTION_QOS_MGMT, create_dissector_handle(dissect_vendor_action_wfa_qos_mgmt, -1));

  dissector_add_uint("wlan.anqp.vendor_specific", OUI_WFA, create_dissector_handle(dissect_vendor_wifi_alliance_anqp, -1));
  dissector_add_uint("wlan.anqp.wifi_alliance.subtype", WFA_ANQP_SUBTYPE_HS20, create_dissector_handle(dissect_hs20_anqp, -1));
  dissector_add_uint("wlan.anqp.wifi_alliance.subtype", WFA_ANQP_SUBTYPE_MBO, create_dissector_handle(dissect_mbo_anqp, -1));
  dissector_add_uint("wlan.ie.wifi_alliance.subtype", WFA_SUBTYPE_SUBSCRIPTION_REMEDIATION, create_dissector_handle(dissect_hs20_subscription_remediation, -1));
  dissector_add_uint("wlan.ie.wifi_alliance.subtype", WFA_SUBTYPE_DEAUTHENTICATION_IMMINENT, create_dissector_handle(dissect_hs20_deauthentication_imminent, -1));
  dissector_add_uint("wlan.ie.wifi_alliance.subtype", WFA_SUBTYPE_HS20_INDICATION, create_dissector_handle(dissect_hs20_indication, -1));
  dissector_add_uint("wlan.ie.wifi_alliance.subtype", WFA_SUBTYPE_OSEN, create_dissector_handle(dissect_hs20_osen, -1));
  dissector_add_uint("wlan.ie.wifi_alliance.subtype", WFA_SUBTYPE_OWE_TRANSITION_MODE, create_dissector_handle(dissect_owe_transition_mode, -1));
  dissector_add_uint("wlan.ie.wifi_alliance.subtype", WFA_SUBTYPE_TRANSITION_DISABLE_KDE, create_dissector_handle(dissect_transition_disable_kde, -1));
  dissector_add_uint("wlan.ie.wifi_alliance.subtype", WFA_SUBTYPE_WIFI_60G, create_dissector_handle(dissect_wfa_60g_ie, -1));
  dissector_add_uint("wlan.ie.wifi_alliance.subtype", WFA_SUBTYPE_MBO_OCE, create_dissector_handle(dissect_mbo_oce, -1));
  dissector_add_uint("wlan.ie.wifi_alliance.subtype", WFA_WNM_SUBTYPE_NON_PREF_CHAN_REPORT, create_dissector_handle(dissect_wfa_wnm_non_pref_chan, -1));
  dissector_add_uint("wlan.ie.wifi_alliance.subtype", WFA_WNM_SUBTYPE_CELL_DATA_CAPABILITIES, create_dissector_handle(dissect_wfa_wnm_cell_cap, -1));
  dissector_add_uint("wlan.ie.wifi_alliance.subtype", WFA_SUBTYPE_QOS_MGMT, create_dissector_handle(dissect_qos_mgmt, -1));
}

/*
 * Editor modelines
 *
 * Local Variables:
 * c-basic-offset: 2
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set shiftwidth=2 tabstop=8 expandtab:
 * :indentSize=2:tabSize=8:noTabs=true:
 */
